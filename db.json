{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/nexmoe/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/author.png","path":"image/author.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/1NF-1.png","path":"image/article/1NF-1.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/1NF-2.png","path":"image/article/1NF-2.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20190216114129109.png","path":"image/article/20190216114129109.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20191108105314115.png","path":"image/article/20191108105314115.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200602172212687.png","path":"image/article/20200602172212687.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200602175224360.png","path":"image/article/20200602175224360.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2020062316474822.png","path":"image/article/2020062316474822.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164809990.png","path":"image/article/20200623164809990.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164833872.png","path":"image/article/20200623164833872.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164845962.png","path":"image/article/20200623164845962.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164901861.png","path":"image/article/20200623164901861.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164853569.png","path":"image/article/20200623164853569.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164920502.png","path":"image/article/20200623164920502.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2020062316493391.png","path":"image/article/2020062316493391.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623164958936.png","path":"image/article/20200623164958936.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623165030775.png","path":"image/article/20200623165030775.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623165014965.png","path":"image/article/20200623165014965.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623165129955.png","path":"image/article/20200623165129955.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200623165404113.png","path":"image/article/20200623165404113.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180016435.png","path":"image/article/20200628180016435.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180025728.png","path":"image/article/20200628180025728.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180055895.png","path":"image/article/20200628180055895.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180035980.png","path":"image/article/20200628180035980.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2020121722082798.png","path":"image/article/2020121722082798.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180128654.png","path":"image/article/20200628180128654.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20200628180116257.png","path":"image/article/20200628180116257.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426183040.png","path":"image/article/20210426183040.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426163943.png","path":"image/article/20210426163943.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426183748.png","path":"image/article/20210426183748.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426184103.png","path":"image/article/20210426184103.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426184359.png","path":"image/article/20210426184359.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210426184621.png","path":"image/article/20210426184621.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210427182334.png","path":"image/article/20210427182334.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210427183235.png","path":"image/article/20210427183235.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210427182427.png","path":"image/article/20210427182427.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428131402.png","path":"image/article/20210428131402.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428131746.png","path":"image/article/20210428131746.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428133849.png","path":"image/article/20210428133849.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428132115.png","path":"image/article/20210428132115.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428133859.png","path":"image/article/20210428133859.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428135406.png","path":"image/article/20210428135406.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428162308.png","path":"image/article/20210428162308.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428162631.png","path":"image/article/20210428162631.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428162806.png","path":"image/article/20210428162806.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428170220.png","path":"image/article/20210428170220.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428170647.png","path":"image/article/20210428170647.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428171331.png","path":"image/article/20210428171331.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428171043.png","path":"image/article/20210428171043.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428172011.png","path":"image/article/20210428172011.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428201314.png","path":"image/article/20210428201314.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210428230921.png","path":"image/article/20210428230921.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210430181656.png","path":"image/article/20210430181656.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210430200702.png","path":"image/article/20210430200702.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/20210511152803.png","path":"image/article/20210511152803.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2NF-2.png","path":"image/article/2NF-2.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2NF-1.png","path":"image/article/2NF-1.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/2NF-3.png","path":"image/article/2NF-3.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/3NF-2.png","path":"image/article/3NF-2.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/3NF-1.png","path":"image/article/3NF-1.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/3NF-3.png","path":"image/article/3NF-3.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/courgette.log","path":"image/article/courgette.log","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20200227090842247.png","path":"image/article/image-20200227090842247.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20200227093004793.png","path":"image/article/image-20200227093004793.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20200227092939646.png","path":"image/article/image-20200227092939646.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210407105452970.png","path":"image/article/image-20210407105452970.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210411183018803.png","path":"image/article/image-20210411183018803.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210411183039107.png","path":"image/article/image-20210411183039107.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414143319605.png","path":"image/article/image-20210414143319605.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414150356108.png","path":"image/article/image-20210414150356108.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414150428147.png","path":"image/article/image-20210414150428147.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414153626283.png","path":"image/article/image-20210414153626283.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414170751285.png","path":"image/article/image-20210414170751285.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414173909852.png","path":"image/article/image-20210414173909852.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414173959254.png","path":"image/article/image-20210414173959254.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414184512856.png","path":"image/article/image-20210414184512856.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414201800584.png","path":"image/article/image-20210414201800584.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/image-20210414201814306.png","path":"image/article/image-20210414201814306.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/shaxiang1.png","path":"image/article/shaxiang1.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/5c3aec85a4343.jpg","path":"image/cover/5c3aec85a4343.jpg","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/shaxiang2.png","path":"image/article/shaxiang2.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/IMG_0488(20210213-001329).JPG","path":"image/cover/IMG_0488(20210213-001329).JPG","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/MKTO-Classic.jpg","path":"image/cover/MKTO-Classic.jpg","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/article/shaxiang3.png","path":"image/article/shaxiang3.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/JAVA.png","path":"image/cover/JAVA.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/MyBatis.png","path":"image/cover/MyBatis.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/cover-20210415151105.jpg","path":"image/cover/cover-20210415151105.jpg","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/Spring.png","path":"image/cover/Spring.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/leetcode.png","path":"image/cover/leetcode.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/mysql.png","path":"image/cover/mysql.png","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/gitee.svg","path":"lib/iconfont/gitee.svg","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/image/cover/fw658.gif","path":"image/cover/fw658.gif","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.eot","path":"lib/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.svg","path":"lib/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/css/mdui.css","path":"lib/mdui_043tiny/css/mdui.css","modified":0,"renderable":1},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/js/mdui.js","path":"lib/mdui_043tiny/js/mdui.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/nexmoe/source/image/article/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619265893852},{"_id":"themes/nexmoe/.gitignore","hash":"3cc8fa8c3fe29546b38050deb8f7d5cfb5fb601f","modified":1618335901704},{"_id":"themes/nexmoe/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1618335901704},{"_id":"themes/nexmoe/_config.yml","hash":"7dd5d995a0a692e8c7745c32137ada43c9d962d7","modified":1649604899180},{"_id":"themes/nexmoe/languages/default.yml","hash":"4ddc26fd072b08f7b740e723ed6481d58ce4fa54","modified":1649346984041},{"_id":"themes/nexmoe/languages/en.yml","hash":"83430833744a430b49adec9298473ad2d32066e1","modified":1618335901714},{"_id":"themes/nexmoe/languages/ja.yml","hash":"9e133c840b2ec1b8da8a042b6e0bb814e33ee094","modified":1618335901714},{"_id":"themes/nexmoe/languages/zh-CN.yml","hash":"08782500dd6492ee6e4ab4b46b45b7739951e0a7","modified":1618501733096},{"_id":"themes/nexmoe/languages/zh-HK.yml","hash":"ce19cbbeb610e27645b3109414bf546c70629442","modified":1618335901714},{"_id":"themes/nexmoe/languages/zh-TW.yml","hash":"ce19cbbeb610e27645b3109414bf546c70629442","modified":1618335901714},{"_id":"themes/nexmoe/README.md","hash":"7928876665baf3eba21bb514e8f0ef36f4883440","modified":1618335901704},{"_id":"themes/nexmoe/package.json","hash":"5c454cb05e8795113c2d8055e15e806625371387","modified":1618501733124},{"_id":"themes/nexmoe/layout/archives.ejs","hash":"b36b2cb80fbf2bf1de6b9e6328911dec852fb77e","modified":1618417110000},{"_id":"themes/nexmoe/layout/py.ejs","hash":"7d877186e87fa9a9eb1175e980c18407a6955f61","modified":1618335901764},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/bug_report_en.md","hash":"557484415c610222b16b58df470c2a768782c4fc","modified":1618335901704},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/feature_request_en.md","hash":"803f6736473a122ed78867e64681defcd2edd954","modified":1618335901704},{"_id":"themes/nexmoe/layout/index.ejs","hash":"e301b314a76c540383d8be755bf370710c0a5058","modified":1649357628265},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"d6c77dbb2a3d638d748280fb37dd29375aebe98c","modified":1618335901704},{"_id":"themes/nexmoe/.github/workflows/codeql-analysis.yml","hash":"a3566121c1e8cb3ca64a386c3c520b169f2af81c","modified":1618335901704},{"_id":"themes/nexmoe/layout/layout.ejs","hash":"3344bd6ee06c890dadfc4298973274f152a6c617","modified":1649358350761},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"843abf5e1d7b06cb1feddd75f7025150d46a91c2","modified":1618335901704},{"_id":"themes/nexmoe/.github/workflows/npm-publish.yml","hash":"64765ae1ecf8583019762fccba55df667cb2e65a","modified":1618335901704},{"_id":"themes/nexmoe/layout/post.ejs","hash":"db80040d4f4a821a2d88ec41f7489e53b1610ee3","modified":1649358313374},{"_id":"themes/nexmoe/layout/_partial/comment.ejs","hash":"6e48ae4a79ad9e14d00244c15cd6e9ad04b99eb4","modified":1618335901734},{"_id":"themes/nexmoe/layout/_partial/copyright.ejs","hash":"64f441c4936bcf2c02ca39313531d01ca68e135c","modified":1649349521438},{"_id":"themes/nexmoe/layout/_partial/paginator.ejs","hash":"20caf7c8ab390cfd125a12cbc71e51f868899050","modified":1618335901734},{"_id":"themes/nexmoe/layout/_partial/sidebar.ejs","hash":"58c53d620cc0695b68c1e18a9f0d97fc888357cc","modified":1618335901734},{"_id":"themes/nexmoe/layout/_partial/analytics.ejs","hash":"e53883f2bb9921cb08437f433d5d4d5cf52ab297","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/after-footer.ejs","hash":"7b39afe0e88edb5afe9405568b3f5f8b8f895326","modified":1618335901724},{"_id":"themes/nexmoe/layout/_widget/archive.ejs","hash":"2438c7647bab143de571bd41224784f097b60653","modified":1618335901734},{"_id":"themes/nexmoe/layout/_partial/site-verification.ejs","hash":"600319729da09e366c05e104fe68a821b087c027","modified":1618335901734},{"_id":"themes/nexmoe/layout/_widget/link.ejs","hash":"d9104aa53f57a99d59ed1a06b3e1abca93082945","modified":1649346862611},{"_id":"themes/nexmoe/layout/_partial/header.ejs","hash":"389d835014748c9c5e36741093a403e2133c7733","modified":1649357216367},{"_id":"themes/nexmoe/scripts/helper/css_auto_version.js","hash":"63c90dac6ad0a102ef302bf9fd9e030d521a8232","modified":1618417110000},{"_id":"themes/nexmoe/layout/_widget/recent_posts.ejs","hash":"7d9eaf8228eda803aa4956e55432f78e056d6a01","modified":1618335901734},{"_id":"themes/nexmoe/scripts/helper/image_auto_lazyload.js","hash":"f93a65c5a910c2d441f30497b1cea4505fd55b10","modified":1655179800955},{"_id":"themes/nexmoe/layout/_widget/social.ejs","hash":"d0f2a8386de1a08deb431a6fa9a3f4a299d0cd1a","modified":1618335901734},{"_id":"themes/nexmoe/layout/_widget/search.ejs","hash":"588b01cf982e18a59e869f1cbf793511c219d89e","modified":1618335901734},{"_id":"themes/nexmoe/scripts/helper/js_auto_version.js","hash":"338cb31ea975bbcb00a7fa5afb0294dbdc385165","modified":1618417110000},{"_id":"themes/nexmoe/scripts/tag/gallery.js","hash":"79a37a1f1cf6b90b34a6f620d230d77ec9a4cb7b","modified":1618417110000},{"_id":"themes/nexmoe/layout/_widget/tag.ejs","hash":"ddf844f08124454bea2a30f8349b63f3cb63ac16","modified":1618335901734},{"_id":"themes/nexmoe/layout/_widget/tagcloud.ejs","hash":"6636a70e3ed871f2e90550d37b773c951817f143","modified":1618335901734},{"_id":"themes/nexmoe/source/css/style.styl","hash":"8522e1f5bf671384e7c860be91f6cfa50d6349ef","modified":1649358517348},{"_id":"themes/nexmoe/layout/_widget/category.ejs","hash":"df9d0ebc60e4a5579be2d51a4f2844a69cce240b","modified":1618502055695},{"_id":"themes/nexmoe/layout/_partial/_analytics/baidu.ejs","hash":"cc782e1363c8bbb6277c3825bb9eac83762bc26d","modified":1618335901714},{"_id":"themes/nexmoe/source/js/app.js","hash":"77ea9a10ed94fcbba5174064414c649fd8ae6de9","modified":1618335901774},{"_id":"themes/nexmoe/layout/_partial/_analytics/cnzz.ejs","hash":"345ed559b76930bed05e1b393c12f09d42c2312e","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/google.ejs","hash":"97f3a717495c8cc71d5d3c7ab69ddd589a69a038","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtm-body.ejs","hash":"1471e3a49ad6c93fd33b18545b43805c48695e23","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtags.ejs","hash":"2c429eef83e712531a08de370b06f1f00ac7398b","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/la.ejs","hash":"e08b1f111068c62e625b6790e66d8a5f625246ba","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtm-head.ejs","hash":"5638bed9cfe2e86aeee77adc883b2a3e1ecd76ff","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/DiscussBot.ejs","hash":"92fb25b5204b325eb18eea0c15ddb4f4116e35e2","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_analytics/tencent.ejs","hash":"6f7d514f157fbdb505e52dda2dc4f35dcdb2685e","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/disqusjs.ejs","hash":"7518e88f2504b9844f71190e079df07f51847472","modified":1649348001192},{"_id":"themes/nexmoe/layout/_partial/_comment/gitalk.ejs","hash":"8f4aa892e815c0ca419507ba5261e84c58a4bc35","modified":1649345123013},{"_id":"themes/nexmoe/layout/_partial/_comment/gitment.ejs","hash":"d4a99db9f2daf7bcdbcf637f478d925d5d840fe4","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/livere.ejs","hash":"e96e1510ba2a8ccb1edebc378c566fadaed09e50","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/valine.ejs","hash":"97a699da23500cd6b16c857a60d123064d1653f9","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_post/meta.ejs","hash":"d5e036569417f7b83b391a417235be776acc4852","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/changyan.ejs","hash":"8a520fd9a9704208c23abcb689bae33acd1167db","modified":1618335901724},{"_id":"themes/nexmoe/layout/_partial/_comment/disqus.ejs","hash":"e1e70a619cf3499ef8b054c8fb4b23865a554b6b","modified":1649347052636},{"_id":"themes/nexmoe/source/css/_partial/archives.styl","hash":"3a326aa676943e398a3e33ea63399d1770000f1f","modified":1618417110000},{"_id":"themes/nexmoe/layout/_partial/_post/tag.ejs","hash":"c265ae74f31bb046922a052bb7d5eef4416d1357","modified":1618335901724},{"_id":"themes/nexmoe/source/css/_partial/py.styl","hash":"58a0e0c92d8567074544a92530fc32860138a7cb","modified":1618417110000},{"_id":"themes/nexmoe/source/css/_partial/article.styl","hash":"4e748e651ca29eecac8176c6ccdb91af0634585e","modified":1618417110000},{"_id":"themes/nexmoe/source/image/article/20200602172212687.png","hash":"fb3fb5f0a81f50ab0a85fa8946bcf6fdd282e032","modified":1620047284031},{"_id":"themes/nexmoe/source/image/article/20200623164809990.png","hash":"672f4b5debba72461fb29d60250360024f82b80e","modified":1619940479046},{"_id":"themes/nexmoe/source/image/article/1NF-2.png","hash":"0d1958fa7ee8dae27eb07a4b69e2d45984bd2449","modified":1619506342309},{"_id":"themes/nexmoe/source/image/article/1NF-1.png","hash":"9be315594c8ed00ff8442efe610904ab9f23df7d","modified":1619506328936},{"_id":"themes/nexmoe/source/image/article/2020062316474822.png","hash":"3304ac796ac347f347371db4997e618133e384a0","modified":1619938932835},{"_id":"themes/nexmoe/source/image/article/20200602175224360.png","hash":"e6cae61c608e17c9321a5dda1d95663290e935d4","modified":1620047336649},{"_id":"themes/nexmoe/source/image/article/20200623164833872.png","hash":"3a97cbbc06053b11cde7e97fad535249292647d9","modified":1619941008788},{"_id":"themes/nexmoe/source/image/article/20200623164853569.png","hash":"eae28eb4f266a782b60f8b78e542bd8e22c3f891","modified":1619941304087},{"_id":"themes/nexmoe/source/image/article/20200623164845962.png","hash":"5438586d71f86fd7883b2783783e33466c66a746","modified":1619941218285},{"_id":"themes/nexmoe/source/image/article/20200623164920502.png","hash":"0ecde638bef77ab6e7316b79f4fa1157693a179c","modified":1619944209396},{"_id":"themes/nexmoe/source/image/article/20200623165129955.png","hash":"c5c2db8aa57fb4e07083cbda586747a58ffaf819","modified":1619972994303},{"_id":"themes/nexmoe/source/image/article/20200623164901861.png","hash":"73ce29f142c92422407fd99858d60862c18ce311","modified":1619941411956},{"_id":"themes/nexmoe/source/image/article/20210427183235.png","hash":"95d3b4f94240d63518ee302aa6e9d69ba80f32f1","modified":1619519561906},{"_id":"themes/nexmoe/source/image/article/20210427182334.png","hash":"941cb3d455a618bb041fff7457f30535420ee79a","modified":1619519030523},{"_id":"themes/nexmoe/source/image/article/20210427182427.png","hash":"8d12acaee10b52c278c01614f19038e08e141f2e","modified":1619519074761},{"_id":"themes/nexmoe/source/image/article/20210428131402.png","hash":"e8aa733529db3538ff4acc8a79799aedac39e8d5","modified":1619586852965},{"_id":"themes/nexmoe/source/image/article/20210428162631.png","hash":"643cdb25a713560b7fae5ef45a4c7d8f6369c915","modified":1619598395584},{"_id":"themes/nexmoe/source/image/article/20210428162806.png","hash":"9a4a6c856512b4de91d8409d9051a871ca4480e1","modified":1619598491119},{"_id":"themes/nexmoe/source/image/article/20210428171331.png","hash":"9fa7b593882e02a1a19f7880b3775e6e821bf228","modified":1619601217349},{"_id":"themes/nexmoe/source/image/article/20210428171043.png","hash":"6d8fbc93df2eafaa12c13f521acdbe25b7dd4e21","modified":1619601047411},{"_id":"themes/nexmoe/source/image/article/20210428170220.png","hash":"438b1098c9a2b949d8b9bcf02ad8d227dc008edc","modified":1619600548696},{"_id":"themes/nexmoe/source/image/article/20210428172011.png","hash":"37e945f159aef4501c7390048bc2c05f5b78b4b1","modified":1619601616450},{"_id":"themes/nexmoe/source/image/article/20210511152803.png","hash":"664c48a46e7b2d24aa5c3be85680390afe5f37ea","modified":1620718137480},{"_id":"themes/nexmoe/source/image/article/2NF-1.png","hash":"448427257c9a470d2d71bc919a5ca2fa11f98020","modified":1619506359403},{"_id":"themes/nexmoe/source/image/article/2NF-2.png","hash":"fb2a7b41f7f9aec8e825394b9b2b0afc15745629","modified":1619506368549},{"_id":"themes/nexmoe/source/image/article/2NF-3.png","hash":"bc038414d898f95832038be3bf02f44eaa610d03","modified":1619506648253},{"_id":"themes/nexmoe/source/image/article/3NF-2.png","hash":"5129be82b72c305e613d2a0632c22357ab92ab3e","modified":1619506386592},{"_id":"themes/nexmoe/source/image/article/3NF-3.png","hash":"04ac0821ceffe6157072052a69226e7808e89974","modified":1619506747833},{"_id":"themes/nexmoe/source/image/article/image-20200227090842247.png","hash":"98b862f34d7a5fc816dc683ea16aaae336a5da10","modified":1582765722275},{"_id":"themes/nexmoe/source/image/article/3NF-1.png","hash":"398d2f1de0f14da5b3ce8731e3ca86a14ae8b5ea","modified":1619506377852},{"_id":"themes/nexmoe/source/image/article/20210428230921.png","hash":"cf4e015b07d174ba54363e832801ef82daf987dd","modified":1619622565973},{"_id":"themes/nexmoe/source/image/article/image-20200227093004793.png","hash":"c3381d0eed75bbb86cf351dd5381e95be0e36294","modified":1582767004803},{"_id":"themes/nexmoe/source/image/article/image-20200227092939646.png","hash":"67621863b4f78b52cbd6a47528de291fdfa8a023","modified":1582766979656},{"_id":"themes/nexmoe/source/image/article/image-20210414201814306.png","hash":"060f9940d46df3ceb07212971dddfc0cbd536d00","modified":1618402694336},{"_id":"themes/nexmoe/source/image/article/image-20210414201800584.png","hash":"7e1b9f7feab037dae850ae28dc589c1a515b7731","modified":1618402680609},{"_id":"themes/nexmoe/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1618335901774},{"_id":"themes/nexmoe/source/lib/iconfont/gitee.svg","hash":"087346df20b0d8df4e719f3c3427c2617a410209","modified":1618497048041},{"_id":"themes/nexmoe/source/lib/iconfont/demo_index.html","hash":"83a1dd51b3edf9ce44354b57ce109de5a3d38a90","modified":1618335901774},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.eot","hash":"465966dac936ddff3e7313dea360f59c43fab804","modified":1618335901774},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.css","hash":"2bfbd212535c6bd56f0b47969d484ca2f3fd907e","modified":1618502060237},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.js","hash":"bcd569bf13e40a6d49f55aa8f4e488ab89e1041a","modified":1618335901774},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.svg","hash":"4807f0720e2a2a8375a1f085f50a113be674a0a0","modified":1618502062476},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.json","hash":"a6045f33dfb7a4ade26c5ed8e9c952b785aed305","modified":1618335901774},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff","hash":"15f15f4b1219ba1bc08267f2e70d2cac5bb3d496","modified":1618335901784},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff2","hash":"d966e8fdd11265e4e7d84bbff903e89aa778bd18","modified":1618335901784},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.ttf","hash":"1b497f21aff9732f4e9f66881b028c3eb0e0763e","modified":1618335901784},{"_id":"themes/nexmoe/source/image/author.png","hash":"3ac90abffe8914e445293906dba277fb773fb45b","modified":1618331308544},{"_id":"themes/nexmoe/source/image/article/2020062316493391.png","hash":"fab4f2de8378741e2acf24babeef1ed5afab8140","modified":1619944895256},{"_id":"themes/nexmoe/source/image/article/20200623165014965.png","hash":"82f5989cd3fdec95036c5c7e2a45300de4acad87","modified":1619951819609},{"_id":"themes/nexmoe/source/image/article/20200623165030775.png","hash":"b6ff53f34d91db65010555e1aad50754beb58951","modified":1619951850545},{"_id":"themes/nexmoe/source/image/article/20200623164958936.png","hash":"71c678a261cf8263e0c1204de3eac15b46633f84","modified":1619948330024},{"_id":"themes/nexmoe/source/image/article/20200628180016435.png","hash":"817384246ef49d381f2f367586cde75aa4579978","modified":1620025378518},{"_id":"themes/nexmoe/source/image/article/20200628180025728.png","hash":"a5e1e8ecc9f441667550f4e0f6aa15a9c34c59f3","modified":1620025398437},{"_id":"themes/nexmoe/source/image/article/20200628180055895.png","hash":"0bbc4bc09d17f57bf5790ff85163ca1c7ae5d46e","modified":1620025769527},{"_id":"themes/nexmoe/source/image/article/20210426163943.png","hash":"79ddffda55792fe4129c2611ad5342f4803e58ed","modified":1619426389854},{"_id":"themes/nexmoe/source/image/article/20200628180128654.png","hash":"2f6abb04f25085e5925e94ea6433b50e0b75acd9","modified":1620038452310},{"_id":"themes/nexmoe/source/image/article/20200628180116257.png","hash":"a9ea671f5b72a18e88946e3b34d14940daa5aed7","modified":1620035349753},{"_id":"themes/nexmoe/source/image/article/20210426184359.png","hash":"33e352dcf71f6157da2f78645c51e5a0acac4040","modified":1619433843593},{"_id":"themes/nexmoe/source/image/article/20200628180035980.png","hash":"2701e203e3d7aa6b77288c421a3c9767b5115ad9","modified":1620025491876},{"_id":"themes/nexmoe/source/image/article/20210426184103.png","hash":"f53d39f91e96136c2e1bd638bca239daf321476d","modified":1619433667271},{"_id":"themes/nexmoe/source/image/article/20210428131746.png","hash":"c8eb07bd9bbb6eb01fae64b397e061df7382d0b6","modified":1619587071809},{"_id":"themes/nexmoe/source/image/article/20210426183748.png","hash":"40a9ffcec6ff2fc14adf75416fb263126ab23d45","modified":1619433473366},{"_id":"themes/nexmoe/source/image/article/20210428135406.png","hash":"ecd95b84e90131404a5f68f576eafae323ea8c5b","modified":1619589251466},{"_id":"themes/nexmoe/source/image/article/20210428170647.png","hash":"d00c8ec317dfbb2c2e3d24ba2d28da0242ab8ec7","modified":1619600811306},{"_id":"themes/nexmoe/source/image/article/20210428162308.png","hash":"4fd737678286d9693aa93807135fadd2a66d481e","modified":1619598222918},{"_id":"themes/nexmoe/source/image/article/image-20210411183018803.png","hash":"1331a7e86049cfa7f68aaac4249a2cabb9f0cdc4","modified":1618137018846},{"_id":"themes/nexmoe/source/image/article/20210430200702.png","hash":"c54c9ed6e5509576cb499ca99730d447c399562c","modified":1619784431207},{"_id":"themes/nexmoe/source/image/article/image-20210411183039107.png","hash":"40c6753229e714b8179f2c095d8e9805ac1bd6b6","modified":1618137039142},{"_id":"themes/nexmoe/source/image/article/image-20210414173909852.png","hash":"4e015f3011f722fdd3fcf56855538fd016c2e44e","modified":1618393149877},{"_id":"themes/nexmoe/source/image/article/image-20210414170751285.png","hash":"eed9851c4ad7d13869b44c8aa855bb74198e6a2a","modified":1618391271320},{"_id":"themes/nexmoe/source/image/article/image-20210414184512856.png","hash":"a22476abcfaf616913a9d3bba7aeb85d8582d566","modified":1618397112877},{"_id":"themes/nexmoe/source/image/article/shaxiang1.png","hash":"cfeaee29d4daea733c50789f032d7f247b6795db","modified":1619254004623},{"_id":"themes/nexmoe/source/image/cover/JAVA.png","hash":"c10bb02ac04f469fe75abd50fe19896c98e675c4","modified":1619978321177},{"_id":"themes/nexmoe/source/image/article/shaxiang3.png","hash":"da67be87af6a8f6ffa9dae25dfddff29e4fa94db","modified":1619255088485},{"_id":"themes/nexmoe/source/image/cover/Spring.png","hash":"32585e088f095d01197ffccd727c5f9cbb41f049","modified":1620055251634},{"_id":"themes/nexmoe/source/image/cover/leetcode.png","hash":"014977aa4ccafcaae5a9adf181255c7f7a962ea8","modified":1618822789878},{"_id":"themes/nexmoe/source/image/article/20191108105314115.png","hash":"f4d016d039781f9bbfb2f312ed0bd2af59c33124","modified":1619446163881},{"_id":"themes/nexmoe/source/image/article/20210428132115.png","hash":"23b651f8d7858b06a76ad2a8bd00ad83ff0cb87b","modified":1619587280054},{"_id":"themes/nexmoe/source/image/article/20210430181656.png","hash":"44f664a50fdc074ea85d975fe9f3dd7641c6242b","modified":1619777824789},{"_id":"themes/nexmoe/source/image/article/20210428133849.png","hash":"d98761a7f281cd12c5e9602c221ac89006965d2e","modified":1619588333911},{"_id":"themes/nexmoe/source/image/article/20210428133859.png","hash":"4e75c79c72667c09a040cbf92532f2804c49edbe","modified":1619588344241},{"_id":"themes/nexmoe/source/image/cover/5c3aec85a4343.jpg","hash":"61592b637f730d89bc12ce89637bf08a4763f568","modified":1618592687502},{"_id":"themes/nexmoe/source/image/article/image-20210407105452970.png","hash":"185bfa07df8ee679148ce90780c72018d98e6455","modified":1617764093136},{"_id":"themes/nexmoe/source/image/article/shaxiang2.png","hash":"b185ed0563c1e49378377916bae65ac9abc43279","modified":1619254252795},{"_id":"themes/nexmoe/source/image/cover/cover-20210415151105.jpg","hash":"2f7f1be375f2ed53afd78b703155bd0a49aaee85","modified":1618676866687},{"_id":"themes/nexmoe/source/image/cover/MyBatis.png","hash":"656a9d8cb66f8b5d83db096e2fdd85221fa8208e","modified":1619977114889},{"_id":"themes/nexmoe/source/image/article/20210426183040.png","hash":"2c757d27afc8af66daebb623db699b1bb072ddb8","modified":1619433048113},{"_id":"themes/nexmoe/source/image/article/image-20210414150428147.png","hash":"5126f8c1a301c483a65fd43167081d60c3797572","modified":1618383868214},{"_id":"themes/nexmoe/source/image/article/20210428201314.png","hash":"7f79e98efab6e1768c11174bf4e2a9f120666647","modified":1619612001533},{"_id":"themes/nexmoe/source/image/article/image-20210414150356108.png","hash":"5055be2719de2e1ea1e43c4ccb9dced2282c2dfc","modified":1618383836169},{"_id":"themes/nexmoe/source/image/article/image-20210414173959254.png","hash":"3c075618d326c8ea614ca8704f5477ee5a8aaa2f","modified":1618393199309},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/js/mdui.js","hash":"1b3f4e4b7d1b944dd2a8ca09cc60614435195c67","modified":1649355963592},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/css/mdui.css","hash":"1500b5d27b8ce2e7c543bb6d7205de43059378db","modified":1618335901784},{"_id":"themes/nexmoe/source/image/article/20190216114129109.png","hash":"a36900d235bc3fdc84780d00c22d9d15031223a3","modified":1618732050267},{"_id":"themes/nexmoe/source/image/article/image-20210414143319605.png","hash":"abc5097a2c8df371cf3da2cbf9a7ecd2b7687ab1","modified":1618381999681},{"_id":"themes/nexmoe/source/image/article/image-20210414153626283.png","hash":"1c5a938cb61a8597a2b001bde3c227f2d1dc63d7","modified":1618385786350},{"_id":"themes/nexmoe/source/image/cover/mysql.png","hash":"df9303b3fae755ab59662cea0d60f6d7a9080ef0","modified":1619978449894},{"_id":"themes/nexmoe/source/image/article/20210426184621.png","hash":"d72c5f4e5648f78988d9d31af087c3773acffc0e","modified":1619433985895},{"_id":"themes/nexmoe/source/image/cover/fw658.gif","hash":"720009d288622f2631518ebd9b884117ca53f489","modified":1618729520629},{"_id":"source/_posts/img/.git/FETCH_HEAD","hash":"de9bc812c4f45677979c1eefcb6989274313bec4","modified":1723561726720},{"_id":"themes/nexmoe/source/image/article/2020121722082798.png","hash":"266f925d25a3ff4628f49ebf3ea1d851cb039f3d","modified":1619446210728},{"_id":"source/about.md","hash":"f40fa2884a0c9f898a3beb0960193f986b6a9e3d","modified":1618729245462},{"_id":"source/archives.md","hash":"96a01db45741c99e78b6d25286bdba910f66bc88","modified":1618499844907},{"_id":"source/_posts/20210808-vue中让echarts随屏幕大小变化.md","hash":"33075d15fa2a88d6e74cebcfe86e5b162755dbec","modified":1649352327677},{"_id":"source/_posts/20210809-Vue中使用Vue-jsonp请求jsonp数据.md","hash":"e75337109d92dac17af2e0c473a553d0ad583a31","modified":1649352327680},{"_id":"source/_posts/20210808-基于Vue-cli的cesium封装插件.md","hash":"d2d7c54c26518497e054c750d13ff19631056f43","modified":1649352327680},{"_id":"source/_posts/20210831-Cesium-billboard贴地形表.md","hash":"9de915316e73461f87a1a1a2f8ae3c2957e04642","modified":1649352327680},{"_id":"source/_posts/20210808-『批处理』批量删除文本文件前n行.md","hash":"5fa30607270d925c5d1e9cc63d9d7b05e2e844d9","modified":1649352327678},{"_id":"source/_posts/Cesium中billboard广告牌使用PinBuilder创建的自定义样式地图图钉-20210808.md","hash":"a026c7d55f134d239ac7de8d5a59bbf494183636","modified":1649352327684},{"_id":"source/_posts/JAVA-IO流-20210417.md","hash":"c6e9795ac39877f5be860edef53900c3c3882af8","modified":1655179740756},{"_id":"source/_posts/20220413-mysql查询数据库内全部表名；查询表内全部字段名.md","hash":"b2fe46b6de3509d962f23a3cc6ec66efddf1da21","modified":1649857476721},{"_id":"source/_posts/20210926-什么是计算机图形学.md","hash":"b79c6928098a717becd2ad23cbb0d48c293ee9ac","modified":1655179740349},{"_id":"source/_posts/JAVA-Spring5-20210503.md","hash":"9a54882e78f2e885bff2f2b214cc0eca2340da80","modified":1655179740756},{"_id":"source/_posts/JAVA-MyBatis-20210503.md","hash":"4c3e330d35eff07f74c8db54b686ac22f56db1bb","modified":1655179740711},{"_id":"source/_posts/JAVA-javaweb-20210430.md","hash":"7295d9117288d37dd1147353b3642941931cfc4a","modified":1655179740811},{"_id":"source/_posts/JAVA-基础.md","hash":"efb106a1021dcbbbf137e8d2978f1663766ffe67","modified":1649352327691},{"_id":"source/_posts/JAVA-JVM基础-20210426.md","hash":"ae12faf5ba4c38b4cf077e3fad5805bb9c293d6d","modified":1655179740810},{"_id":"source/_posts/JAVA-常用类-20210416.md","hash":"36d32ab701ef6f456f680d95624f6d5593f08be2","modified":1649352327693},{"_id":"source/_posts/JAVA-注解和反射-20210418.md","hash":"0371718c92f5b17190c75cadf1e292358e15b363","modified":1655179740753},{"_id":"source/_posts/JAVA-网络编程-20210418.md","hash":"10b6d33fcc67c9c2173b21fae0e277f7e41026de","modified":1649352327697},{"_id":"source/_posts/JAVA-线程-20210418.md","hash":"9edf1f6b424fe49349d59989ce7d128092007a90","modified":1655179740349},{"_id":"source/_posts/Leetcode-001-两数之和-20210418.md","hash":"68b570030c6b0033a1b93fcd1337bf323517c8b1","modified":1649352327699},{"_id":"source/_posts/JAVA-集合框架-20210418.md","hash":"b3abdbf882ccaaa8e28108d92e02eb400b63243f","modified":1655179740341},{"_id":"source/_posts/Leetcode-002-两数相加-20210420.md","hash":"f567e374e3d34b81fa2cddc830cf10a0b417396d","modified":1649352327699},{"_id":"source/_posts/Leetcode-004-寻找两个正序数组的中位数-20210426.md","hash":"d23717676d14eede287d983c3c652d7d269a3240","modified":1649352327700},{"_id":"source/_posts/Leetcode—003-无重复字符的最长子串-20210421.md","hash":"53b987f612f5ce4fc96f2770fc0e1166419ad1eb","modified":1649352327701},{"_id":"source/_posts/Mysql数据库-20210427.md","hash":"9f6e5404c799911902f0564e46292e27011f3636","modified":1655179740352},{"_id":"source/_posts/将博客搬至CSDN-20210808.md","hash":"d2b39bb5f61762cb99695526353457d5730cd536","modified":1655180251498},{"_id":"source/_posts/博客搭建踩坑-20210418.md","hash":"282ead76de4045875f27d11f11fdbdc5fa1deb73","modified":1649352327741},{"_id":"source/_posts/PostGis数据类型-20210808.md","hash":"4cced0e585c160f1fbe8f03dfb6fe3efe3b927fc","modified":1649352327702},{"_id":"source/_posts/img/.git/COMMIT_EDITMSG","hash":"a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0","modified":1723561735439},{"_id":"source/_posts/img/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1628408457612},{"_id":"source/_posts/hello-world.md","hash":"23887b5588a68fb55f518db0ae18fb36514e05e8","modified":1723559822575},{"_id":"source/_posts/稀疏数组-20210401.md","hash":"aacfc1f4cc160ed737d85c3430fa3d142e098efa","modified":1649352327743},{"_id":"source/_posts/img/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1628408602965},{"_id":"source/_posts/img/.git/config","hash":"744a5c4d87b42bcc1b3e1f186d8335e4522dfcaa","modified":1723562088975},{"_id":"source/_posts/img/.idea/img.iml","hash":"32fca3a41af0e658297ab10969630d1f8f1548b4","modified":1649352327704},{"_id":"source/_posts/img/.idea/misc.xml","hash":"0d81a7654b3ab7b1fa88a882ac9120820be781d1","modified":1649352327704},{"_id":"source/_posts/img/.idea/vcs.xml","hash":"d222c1e95ba289f2814d142867f8b3c8b656bcc6","modified":1649352327705},{"_id":"source/_posts/img/.idea/modules.xml","hash":"bef409256402bfa310f660655765f39a131cd6d4","modified":1649352327705},{"_id":"source/_posts/img/.git/packed-refs","hash":"b87768695bbfa0ff94952151224ddeb01ed48767","modified":1628409849031},{"_id":"source/_posts/img/.git/index","hash":"f717ef107338dce53970c10d6a5012f91b0f0853","modified":1723561651781},{"_id":"source/_posts/img/.idea/workspace.xml","hash":"8bb952c7124624b3d00554e423ff4eb6bd803b08","modified":1649352327706},{"_id":"source/_posts/img/cover/Vue.jpeg","hash":"ab1bac752a3ed55110ac9c547ac9e9f6f69747ed","modified":1649352327738},{"_id":"source/_posts/img/cover/postgre.jpeg","hash":"2155be5ec9ed456b2a078b2d876042bc051c6689","modified":1649352327739},{"_id":"source/_posts/img/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1628408457744},{"_id":"source/_posts/img/.git/info/refs","hash":"b8fd8a0b8b57fefdcf5c30f8b845d8f16f88f55d","modified":1628409286445},{"_id":"source/_posts/img/.git/logs/HEAD","hash":"9a3c29ebdeb5776bb5175beebec2a7e7cf6a59a1","modified":1723561721572},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image002.jpg","hash":"cd6fbc1fe5cc846f9e158ad2eb89f05210727ace","modified":1649352327708},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image004.jpg","hash":"a8249ac4cc583d4b11fd7686a75e427a2bed7ba4","modified":1649352327709},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image006.jpg","hash":"62b2e88054b1f2d5e7462c564cce555713cdfafb","modified":1649352327710},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image008.jpg","hash":"364c4173fc2701cc7362e409c82dbb5feea55729","modified":1649352327711},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image010.jpg","hash":"64ffac57d102c33ca6be41b75dd8af7d2a96c40c","modified":1649352327712},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image014.jpg","hash":"6fd1ff0d84072f76f904ef17af503f1371db8e52","modified":1649352327715},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image018.jpg","hash":"cc86e4a6390a659fbad1c168a9facd0295df8158","modified":1649352327717},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image016.jpg","hash":"88629ac50a617c0b3cf3a87cf20ecb2496c786e3","modified":1649352327716},{"_id":"source/_posts/img/article/JAVA-IO流-20210417/image-20210409191717082.png","hash":"539db25ebda394dab4777650fed020b391d1d86a","modified":1617967037103},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/2020062316474822.png","hash":"3304ac796ac347f347371db4997e618133e384a0","modified":1619938932835},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164809990.png","hash":"672f4b5debba72461fb29d60250360024f82b80e","modified":1619940479046},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164845962.png","hash":"5438586d71f86fd7883b2783783e33466c66a746","modified":1619941218285},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164833872.png","hash":"3a97cbbc06053b11cde7e97fad535249292647d9","modified":1619941008788},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164853569.png","hash":"eae28eb4f266a782b60f8b78e542bd8e22c3f891","modified":1619941304087},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164901861.png","hash":"73ce29f142c92422407fd99858d60862c18ce311","modified":1619941411956},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164920502.png","hash":"0ecde638bef77ab6e7316b79f4fa1157693a179c","modified":1619944209396},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623165129955.png","hash":"c5c2db8aa57fb4e07083cbda586747a58ffaf819","modified":1619972994303},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428131402.png","hash":"e8aa733529db3538ff4acc8a79799aedac39e8d5","modified":1619586852965},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428162631.png","hash":"643cdb25a713560b7fae5ef45a4c7d8f6369c915","modified":1619598395584},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428170220.png","hash":"438b1098c9a2b949d8b9bcf02ad8d227dc008edc","modified":1619600548696},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428162806.png","hash":"9a4a6c856512b4de91d8409d9051a871ca4480e1","modified":1619598491119},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428171043.png","hash":"6d8fbc93df2eafaa12c13f521acdbe25b7dd4e21","modified":1619601047411},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428172011.png","hash":"37e945f159aef4501c7390048bc2c05f5b78b4b1","modified":1619601616450},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428171331.png","hash":"9fa7b593882e02a1a19f7880b3775e6e821bf228","modified":1619601217349},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428230921.png","hash":"cf4e015b07d174ba54363e832801ef82daf987dd","modified":1619622565973},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414201814306.png","hash":"060f9940d46df3ceb07212971dddfc0cbd536d00","modified":1618402694336},{"_id":"source/_posts/img/article/Mysql数据库-20210427/20210427182334.png","hash":"941cb3d455a618bb041fff7457f30535420ee79a","modified":1619519030523},{"_id":"source/_posts/img/article/Mysql数据库-20210427/1NF-1.png","hash":"9be315594c8ed00ff8442efe610904ab9f23df7d","modified":1619506328936},{"_id":"source/_posts/img/article/Mysql数据库-20210427/20210427182427.png","hash":"8d12acaee10b52c278c01614f19038e08e141f2e","modified":1619519074761},{"_id":"source/_posts/img/article/Mysql数据库-20210427/1NF-2.png","hash":"0d1958fa7ee8dae27eb07a4b69e2d45984bd2449","modified":1619506342309},{"_id":"source/_posts/img/article/Mysql数据库-20210427/2NF-1.png","hash":"448427257c9a470d2d71bc919a5ca2fa11f98020","modified":1619506359403},{"_id":"source/_posts/img/article/Mysql数据库-20210427/2NF-2.png","hash":"fb2a7b41f7f9aec8e825394b9b2b0afc15745629","modified":1619506368549},{"_id":"source/_posts/img/article/Mysql数据库-20210427/2NF-3.png","hash":"bc038414d898f95832038be3bf02f44eaa610d03","modified":1619506648253},{"_id":"source/_posts/img/article/Mysql数据库-20210427/3NF-2.png","hash":"5129be82b72c305e613d2a0632c22357ab92ab3e","modified":1619506386592},{"_id":"source/_posts/img/article/Mysql数据库-20210427/3NF-1.png","hash":"398d2f1de0f14da5b3ce8731e3ca86a14ae8b5ea","modified":1619506377852},{"_id":"source/_posts/img/article/Mysql数据库-20210427/3NF-3.png","hash":"04ac0821ceffe6157072052a69226e7808e89974","modified":1619506747833},{"_id":"source/_posts/img/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1628408457614},{"_id":"source/_posts/img/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1628408457643},{"_id":"source/_posts/img/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1628408457644},{"_id":"source/_posts/img/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1628408457671},{"_id":"source/_posts/img/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1628408457629},{"_id":"source/_posts/img/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1628408457696},{"_id":"source/_posts/img/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1628408457696},{"_id":"source/_posts/img/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1628408457719},{"_id":"source/_posts/img/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1628408457719},{"_id":"source/_posts/img/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1628408457729},{"_id":"source/_posts/img/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1628408457735},{"_id":"source/_posts/img/.git/objects/19/e4cbdb7b6f05e560ba505f366fdda39fb04347","hash":"fe71380c258cc653edf12080cbebf5f46c8d8821","modified":1630513070916},{"_id":"source/_posts/img/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1628408457743},{"_id":"source/_posts/img/.git/objects/0a/7898b76b1021d699876501201c8f7ae8bd6bd7","hash":"104dde97722220d2e8844846f2d2f2937bfabf1e","modified":1628411101576},{"_id":"source/_posts/img/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1628408457705},{"_id":"source/_posts/img/.git/objects/2d/24f1e96e871684fd375e3d3897832118af1683","hash":"9c74b5419ceaafa22cd7e790869f435868ca6ac4","modified":1628412392800},{"_id":"source/_posts/img/.git/objects/1b/1aa87008b954efaffd825c5463d78062e8c88b","hash":"348e19d07c7a630892931d3aecd73a8061620c74","modified":1632643670337},{"_id":"source/_posts/img/.git/objects/28/a804d8932aba40f168fd757a74cb718a955a1a","hash":"d06a53d1c553d081ff999fe425454d460b32740b","modified":1630513044002},{"_id":"source/_posts/img/.git/objects/2b/6ec4fb8cbf3444bb45baf8fe06a25ba5eee297","hash":"d0a6b887b19f5bcc2b216a289e1a9ff95e523159","modified":1628410907610},{"_id":"source/_posts/img/.git/objects/22/1dae1f4ed5c4f032acf9d74a383afa334a241f","hash":"1b3aae25a6075e53af28d4467ce9d4995c1b16d2","modified":1632643669907},{"_id":"source/_posts/img/.git/objects/33/314dec47908d08618e9dff6fbd66118ba222ac","hash":"c77e38f13d84697cbc114cf48f7f991ab7472975","modified":1632643674844},{"_id":"source/_posts/img/.git/objects/39/19267eda9d1f5c05f969e1b496b03e69066c32","hash":"84425db6a72e52ba40e9b4a16ea17c7cb02b0112","modified":1628414166542},{"_id":"source/_posts/img/.git/objects/32/5c2bc9d74c090441d99f3b2ff4dc1e97954a2a","hash":"7d036e6594cda01d7e1adfb55365b67c66e5dfd7","modified":1649355301128},{"_id":"source/_posts/img/.git/objects/3a/ca642d58244ca4cfa7865e9ea8e5c5a8c88ffa","hash":"282fcc2c89a06c3fa29f1fc10ed82ceb7f010243","modified":1630513070773},{"_id":"source/_posts/img/.git/objects/45/538141f3721ab8b22febdd196d477b90c94791","hash":"b3f6a532930fa9be9a7b0bd3cea1b47b6b1f4dd5","modified":1632643674914},{"_id":"source/_posts/img/.git/objects/5f/8e392b0fed142bb72bb1be8fd8361be92074b6","hash":"f671935d9f61d8e9a1996261bb617bd3b68c3e01","modified":1630513070640},{"_id":"source/_posts/img/.git/objects/5d/f5d42b96365f2ce4787272af3f986b45e38aa7","hash":"69b240e9847e197ca9d6a3d86d6e2090d4ebdc3c","modified":1628414166368},{"_id":"source/_posts/img/.git/objects/59/67b4c1582166424626e9ca9af29dfa694985e1","hash":"6eb438f28326fbc7f79d724e8dfdee1cbf051d6b","modified":1632643670096},{"_id":"source/_posts/img/.git/objects/68/2b0a227620fab44e7bec16d7ae83d00cc09f91","hash":"a7808e00d93f2b9852b5bd2ff50f6a67d4aadbb7","modified":1628410907452},{"_id":"source/_posts/img/.git/objects/31/489b17aa0620d8b99d95c7da0316be856f3606","hash":"3d362c0a780df0e2104d17996bb47dcf7df54dd0","modified":1628412392855},{"_id":"source/_posts/img/.git/objects/74/cc05592629d4db827398c2c6f6e1095d63d441","hash":"bccd044f6d50b6d04f941d392d79b06492463fee","modified":1628414166502},{"_id":"source/_posts/img/.git/objects/6e/3fd80340517315685125fd945bfdf81079e569","hash":"63128e11d1f13183788dc7ecf50df3d3b8a9ed32","modified":1632643669650},{"_id":"source/_posts/img/.git/objects/7b/7bec5d8900e13db0c74cdc8d0780f95f53a84e","hash":"7c75d136f7f942f0692840b1b77ac65ff7a1f66a","modified":1632643670228},{"_id":"source/_posts/img/.git/objects/68/49b15114c9eb6f111f51a5f4273e7b303d86a6","hash":"5b266702c470596caac31d2f1c0439eb7c77e4a9","modified":1632643674780},{"_id":"source/_posts/img/.git/objects/64/6c53342dfd26d29d339661f652b1f14cd0a45b","hash":"7c0bda9ee40c4bb9aeadae052a5c7a33b9475eff","modified":1632643674988},{"_id":"source/_posts/img/.git/objects/73/b5b82c59defe648634a4657c69275a40c201bf","hash":"5f9d345e6777d446836fc94ae2ef7d7b2f050d78","modified":1632643675077},{"_id":"source/_posts/img/.git/objects/82/0f93bc33eee256c116c019652cdfb8da5eca5b","hash":"1a2c1516cef37200b11e2670d58a34658ccb7f9c","modified":1628412392916},{"_id":"source/_posts/img/.git/objects/94/a25f7f4cb416c083d265558da75d457237d671","hash":"6f9de705881aec3b6a1b49a174d055e104bc3c8f","modified":1630513044155},{"_id":"source/_posts/img/.git/objects/a1/320dca0d4a08253d6b0be223466d8eb99ff9c1","hash":"5dbed1ea38ca30312735d31794061de67167bf17","modified":1649355301008},{"_id":"source/_posts/img/.git/objects/a2/3df096013e6c68cb2e28ea2789bf666d85b488","hash":"b7b2636e89ce950fce0a8842220759a3674f1543","modified":1628410907577},{"_id":"source/_posts/img/.git/objects/98/2dcc367c9fcd024a1e4b71d2322e8497574462","hash":"ffd15f8bac08d0bb2df93a4ab11b0e768f207a38","modified":1632643674501},{"_id":"source/_posts/img/.git/objects/b1/3f092a7f45704a4e8d8684ed303207b9b48196","hash":"2e3c9814631082156eae480b1adc422fbe3a9263","modified":1632643669587},{"_id":"source/_posts/img/.git/objects/ba/6220d36301aa52a24bccae93e5b82d699ba826","hash":"e59cff77ae773f553f3b2498961c84e41c086eb1","modified":1628410940649},{"_id":"source/_posts/img/.git/objects/b4/44a54226c9f54c9b08917b39ca924189b0353b","hash":"9543b89918f254fec43d7aeafa2f55788434b287","modified":1632643669782},{"_id":"source/_posts/img/.git/objects/c0/3eb9d1583defed8eb402aef2e6e872489ec234","hash":"fa5bbc80a852d5c69ff68c21e185cfa5b543ce6b","modified":1630513070840},{"_id":"source/_posts/img/.git/objects/b7/b3eb5ea872a28f57c128bbbfb39cb0452b44e6","hash":"66499905bba5db7163ee47a3f670188a32064493","modified":1628414161273},{"_id":"source/_posts/img/.git/objects/c9/56989b29ad0767edc6cf3a202545927c3d1e76","hash":"40f5dd0bfdf741983d982d96e954594e2b8834a3","modified":1630513043929},{"_id":"source/_posts/img/.git/objects/c7/c7fd0d7dad88012fbca1e93766925e842f9386","hash":"caefdd8762f1b07fe5c23c6d307461be053fc60c","modified":1628412385741},{"_id":"source/_posts/img/.git/objects/ca/8b2a4a4d6e001388462d8e02c164bc66d39951","hash":"f1de80d2a420678497471b46d5afc10e971b3fd5","modified":1649355301172},{"_id":"source/_posts/img/.git/objects/cd/26d19d01e5b5842b5e20d46cd7008101ae61ce","hash":"f8ae44b46f729156849b33d267ef6137eb7b995a","modified":1630513044086},{"_id":"source/_posts/img/.git/objects/d8/66ee54b3089894f43d97dae114e5c7a47714c0","hash":"6b416ac59f6afe710796688afdaca2c2fbb8b7b2","modified":1649355301209},{"_id":"source/_posts/img/.git/objects/d2/17db8a31515cb5189d02e905683bfca423341a","hash":"e6af3f23141e92984cbc90b5feaf86edbcd3cd1e","modified":1628410907649},{"_id":"source/_posts/img/.git/objects/d1/b219d8b235bfd51c81d0edae43e635cfac6085","hash":"b6a92a567937b6aee4fe4f6f5b449be36d9595e8","modified":1628412392743},{"_id":"source/_posts/img/.git/objects/e5/05e2b1f580d4cb9927fc431747f8ef5cdbb022","hash":"f3feb6c85d3232f64dc9279bc4d1886f837eef85","modified":1632643669713},{"_id":"source/_posts/img/.git/objects/db/c54c4b3cfc5618e96d374d63ef2ba860b13dd2","hash":"93e7dfd01656241af72fa922323f49eb1873533d","modified":1628412385599},{"_id":"source/_posts/img/.git/objects/95/fb13c254fc90655a9c56e50ad4a27097c15697","hash":"02abf56c38ede86bf0bb2a203d92a9e0eece9106","modified":1630513071017},{"_id":"source/_posts/img/.git/refs/heads/master","hash":"03e7816509ac80c01f369fb36cc6f2bd51cc5281","modified":1723561721572},{"_id":"source/_posts/img/.git/objects/fa/a3892b9074c0a7a47e6f650cb0724a13ac6f37","hash":"7e1ff9a23ff69ba1c8afbf2839beb0f8cef1ccda","modified":1649355296567},{"_id":"source/_posts/img/.git/objects/a3/ed86cf09432029169582afc84a8f0d3f9fe163","hash":"6223e95200a69cfa85d4bcbdef98151f35616bbd","modified":1628411252884},{"_id":"source/_posts/img/.git/objects/fe/168ef6b9720a3258bdfdfde1ef54ae51b0fb43","hash":"9281c15c84ff14609160555fb27622405807f497","modified":1628411101734},{"_id":"source/_posts/img/.git/objects/info/packs","hash":"81c00a4f21872981921126302a58f3434fd6b6c9","modified":1628409286448},{"_id":"source/_posts/img/.git/objects/e7/41c6848e2159b45b3cfc84e248db7011faffde","hash":"8ebb7dd1d700a2a758de27a2610c0d7e0fcfac05","modified":1630513043879},{"_id":"source/_posts/img/.git/objects/fc/8baac4663a5e6f8e3c3768cfe56f9dfb53939a","hash":"eb51e43c01f5a901e2f9de2fe4ab591df2858e1f","modified":1632126647124},{"_id":"source/_posts/img/.git/objects/97/97f12c64937d250afef6b4767e2120a2c242b9","hash":"5d97da36f0f89afbc337d5dc2374f92b511aa40b","modified":1632126647171},{"_id":"source/_posts/img/.git/objects/pack/pack-01c07c8e373fa387247d9f7d4e82d1138544ab00.idx","hash":"9fdb686a0112510b4379bd12daa28de88989b4b3","modified":1628409286229},{"_id":"source/_posts/img/.git/refs/remotes/origin/master","hash":"03e7816509ac80c01f369fb36cc6f2bd51cc5281","modified":1723561740763},{"_id":"source/_posts/img/.git/logs/refs/heads/master","hash":"b6dec787998d06d5a67fff7864cc0ca65a177894","modified":1723561721572},{"_id":"source/_posts/img/cover/JAVA.png","hash":"c10bb02ac04f469fe75abd50fe19896c98e675c4","modified":1619978321177},{"_id":"source/_posts/img/.git/logs/refs/remotes/origin/master","hash":"78ff1f782210a3800dbf977dd48cb28beaeaf4f2","modified":1723561740763},{"_id":"source/_posts/img/cover/Cesium.jpeg","hash":"4b800eb296c5174fa0e1e0b0c6a4ed9b0fd185a9","modified":1628407712426},{"_id":"source/_posts/img/article/20210926-什么是计算机图形学/image012.gif","hash":"9c347838f7926a8c393e9d8be32367c504993e8b","modified":1649352327714},{"_id":"source/_posts/img/cover/Spring.png","hash":"32585e088f095d01197ffccd727c5f9cbb41f049","modified":1620055251634},{"_id":"source/_posts/img/cover/leetcode.png","hash":"014977aa4ccafcaae5a9adf181255c7f7a962ea8","modified":1618822789878},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426184103.png","hash":"f53d39f91e96136c2e1bd638bca239daf321476d","modified":1619433667271},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426163943.png","hash":"79ddffda55792fe4129c2611ad5342f4803e58ed","modified":1619426389854},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/shaxiang1.png","hash":"cfeaee29d4daea733c50789f032d7f247b6795db","modified":1619254004623},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426184359.png","hash":"33e352dcf71f6157da2f78645c51e5a0acac4040","modified":1619433843593},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623164958936.png","hash":"71c678a261cf8263e0c1204de3eac15b46633f84","modified":1619948330024},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/shaxiang3.png","hash":"da67be87af6a8f6ffa9dae25dfddff29e4fa94db","modified":1619255088485},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623165030775.png","hash":"b6ff53f34d91db65010555e1aad50754beb58951","modified":1619951850545},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623165014965.png","hash":"82f5989cd3fdec95036c5c7e2a45300de4acad87","modified":1619951819609},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180016435.png","hash":"817384246ef49d381f2f367586cde75aa4579978","modified":1620025378518},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180025728.png","hash":"a5e1e8ecc9f441667550f4e0f6aa15a9c34c59f3","modified":1620025398437},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426183748.png","hash":"40a9ffcec6ff2fc14adf75416fb263126ab23d45","modified":1619433473366},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180035980.png","hash":"2701e203e3d7aa6b77288c421a3c9767b5115ad9","modified":1620025491876},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/2020062316493391.png","hash":"fab4f2de8378741e2acf24babeef1ed5afab8140","modified":1619944895256},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180055895.png","hash":"0bbc4bc09d17f57bf5790ff85163ca1c7ae5d46e","modified":1620025769527},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180128654.png","hash":"2f6abb04f25085e5925e94ea6433b50e0b75acd9","modified":1620038452310},{"_id":"source/_posts/img/article/JAVA-Spring5-20210503/20200628180116257.png","hash":"a9ea671f5b72a18e88946e3b34d14940daa5aed7","modified":1620035349753},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428135406.png","hash":"ecd95b84e90131404a5f68f576eafae323ea8c5b","modified":1619589251466},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428131746.png","hash":"c8eb07bd9bbb6eb01fae64b397e061df7382d0b6","modified":1619587071809},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428162308.png","hash":"4fd737678286d9693aa93807135fadd2a66d481e","modified":1619598222918},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428170647.png","hash":"d00c8ec317dfbb2c2e3d24ba2d28da0242ab8ec7","modified":1619600811306},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414173909852.png","hash":"4e015f3011f722fdd3fcf56855538fd016c2e44e","modified":1618393149877},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414170751285.png","hash":"eed9851c4ad7d13869b44c8aa855bb74198e6a2a","modified":1618391271320},{"_id":"source/_posts/img/article/JAVA-线程-20210418/image-20210411183018803.png","hash":"1331a7e86049cfa7f68aaac4249a2cabb9f0cdc4","modified":1618137018846},{"_id":"source/_posts/img/article/JAVA-线程-20210418/image-20210411183039107.png","hash":"40c6753229e714b8179f2c095d8e9805ac1bd6b6","modified":1618137039142},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210430200702.png","hash":"c54c9ed6e5509576cb499ca99730d447c399562c","modified":1619784431207},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414184512856.png","hash":"a22476abcfaf616913a9d3bba7aeb85d8582d566","modified":1618397112877},{"_id":"source/_posts/img/.git/objects/43/06ee3509f4441eec0c5fd4089e75cb64cd85e6","hash":"8100cf12dd9dced5ed1b69e8fe0c290de8cdea82","modified":1632643669998},{"_id":"themes/nexmoe/source/image/cover/IMG_0488(20210213-001329).JPG","hash":"1223ec7d39cb22762619e7a490e57b98d64dbdb2","modified":1613180652956},{"_id":"source/_posts/img/author.png","hash":"ccfe465db1a5801ead8f1f714d5301e3a84c2eef","modified":1649352327737},{"_id":"source/_posts/img/cover/5c3aec85a4343.jpg","hash":"61592b637f730d89bc12ce89637bf08a4763f568","modified":1618592687502},{"_id":"source/_posts/img/cover/cover-20210415151105.jpg","hash":"2f7f1be375f2ed53afd78b703155bd0a49aaee85","modified":1618676866687},{"_id":"source/_posts/img/cover/MyBatis.png","hash":"656a9d8cb66f8b5d83db096e2fdd85221fa8208e","modified":1619977114889},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20191108105314115.png","hash":"f4d016d039781f9bbfb2f312ed0bd2af59c33124","modified":1619446163881},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/shaxiang2.png","hash":"b185ed0563c1e49378377916bae65ac9abc43279","modified":1619254252795},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428132115.png","hash":"23b651f8d7858b06a76ad2a8bd00ad83ff0cb87b","modified":1619587280054},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428133849.png","hash":"d98761a7f281cd12c5e9602c221ac89006965d2e","modified":1619588333911},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426183040.png","hash":"2c757d27afc8af66daebb623db699b1bb072ddb8","modified":1619433048113},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428133859.png","hash":"4e75c79c72667c09a040cbf92532f2804c49edbe","modified":1619588344241},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210430181656.png","hash":"44f664a50fdc074ea85d975fe9f3dd7641c6242b","modified":1619777824789},{"_id":"source/_posts/img/article/JAVA-集合框架-20210418/image-20210407105452970.png","hash":"185bfa07df8ee679148ce90780c72018d98e6455","modified":1617764093136},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/可选左右展示图层的分屏功能.jpg","hash":"a98066a7af667f8a174b41b9e8ae6fe61949d26a","modified":1649352327719},{"_id":"source/_posts/20210908-中国城市坐标-包含市辖区.md","hash":"47ebbf5ff0d82b94c12a0e8ba094513bbb50fb8b","modified":1649352327682},{"_id":"source/_posts/img/.git/objects/c5/00d73b5d4e935ac58803ac78f0457a466cf524","hash":"fdf96a7203536e69ca66900bd97958ca418299d8","modified":1630513044245},{"_id":"source/_posts/img/.git/objects/81/c7dc7d83b2f8475200145d3b9a319ce19afd31","hash":"33aa3cd6379d4098945dd7ab559c83ad435a8ac5","modified":1632126631917},{"_id":"source/_posts/img/article/JAVA-javaweb-20210430/20210428201314.png","hash":"7f79e98efab6e1768c11174bf4e2a9f120666647","modified":1619612001533},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414150428147.png","hash":"5126f8c1a301c483a65fd43167081d60c3797572","modified":1618383868214},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414173959254.png","hash":"3c075618d326c8ea614ca8704f5477ee5a8aaa2f","modified":1618393199309},{"_id":"themes/nexmoe/source/image/article/20200623165404113.png","hash":"f93e9ee3760465868fb1ae645db2c748b6b3f568","modified":1619973143007},{"_id":"source/_posts/img/cover/mysql.png","hash":"df9303b3fae755ab59662cea0d60f6d7a9080ef0","modified":1619978449894},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20190216114129109.png","hash":"a36900d235bc3fdc84780d00c22d9d15031223a3","modified":1618732050267},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414153626283.png","hash":"1c5a938cb61a8597a2b001bde3c227f2d1dc63d7","modified":1618385786350},{"_id":"source/_posts/img/article/JAVA-注解和反射-20210418/image-20210414143319605.png","hash":"abc5097a2c8df371cf3da2cbf9a7ecd2b7687ab1","modified":1618381999681},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/高德api-行政区搜索.jpg","hash":"ee8e32c6d52159c81788390d1ca04de73bebeb10","modified":1649352327735},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/添加标记.jpg","hash":"9df6fc016ea405245b5766dffdc39d0536862689","modified":1649352327722},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/透明度亮度对比度按图层调节.jpg","hash":"d17a6765cd77ac661886a58c73ad6f05a149f03b","modified":1649352327729},{"_id":"source/_posts/img/.git/objects/ab/29c51dc236de23cd052756c5d66d2114beda04","hash":"02d4deb982d2fc86bbee506311b8a1a4864ec00a","modified":1630513044727},{"_id":"source/_posts/img/.git/objects/7d/ba9d7b33f4e2d6d03e723771fe190a4228f9eb","hash":"69f597c512f8f0bd3db41328b0ee4bae00bb17ea","modified":1630513045012},{"_id":"source/_posts/img/.git/objects/cf/560a9bd2bd691905b0e91f1e231e85c29dc274","hash":"7643fad00f9cda6563292b1d6d78aa1f35c6a569","modified":1630513044373},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/20210426184621.png","hash":"d72c5f4e5648f78988d9d31af087c3773acffc0e","modified":1619433985895},{"_id":"source/_posts/img/.git/objects/79/9f69c4e443bad8c62b89dcf16a62bac149a438","hash":"58e4ab54168db986e5a9afffe6ab55fa371f06f1","modified":1649355297428},{"_id":"source/_posts/img/cover/fw658.gif","hash":"720009d288622f2631518ebd9b884117ca53f489","modified":1618729520629},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/自定义气泡窗口.jpg","hash":"be4f190f6d6821324f4caf3577b0cc02174b221b","modified":1649352327726},{"_id":"source/_posts/img/cover/ddus0vy-a5d36162-0773-4822-a8ae-dc7d8c313a47.jpg","hash":"74ea617cd9fbb5f0517b8e5c96558842fc029f28","modified":1647883865128},{"_id":"source/_posts/img/article/Vue-Cesium-ReadMe/高德api-POI搜索.jpg","hash":"20cfdb7f3a0a9b0256a3b1669ce853a9adacfd24","modified":1649352327731},{"_id":"source/_posts/img/.git/objects/fc/fa12d59b1ded0ef65d9092f343c472c6d525b0","hash":"30e0c08dc2a4b567d5a653cac71cf8d31b52d3b3","modified":1630513044524},{"_id":"source/_posts/img/.git/objects/e2/5c58f1e993f6effe848fb7e375b2bec011e8f3","hash":"e591fd9fc4d5ae335f8f2ee204271c8f89db1834","modified":1630513044877},{"_id":"source/_posts/img/cover/IMG_0488(20210213-001329).JPG","hash":"1223ec7d39cb22762619e7a490e57b98d64dbdb2","modified":1613180652956},{"_id":"themes/nexmoe/cover.png","hash":"23d58c5a7f388514246d49f27f1529be3fdbe09d","modified":1618335901714},{"_id":"source/_posts/img/article/JAVA-JVM基础-20210426/2020121722082798.png","hash":"266f925d25a3ff4628f49ebf3ea1d851cb039f3d","modified":1619446210728},{"_id":"source/_posts/img/article/JAVA-MyBatis-20210503/20200623165404113.png","hash":"f93e9ee3760465868fb1ae645db2c748b6b3f568","modified":1619973143007},{"_id":"source/_posts/img/cover/3cd8a445-e37c-407a-b09b-063f99f6399c.jpg","hash":"96f429ed0da81ab5216ba3df5d3977dada9bbc15","modified":1647884125722},{"_id":"source/_posts/img/.git/objects/b9/a072a5c818928cab160bfccd7df38d329265a1","hash":"f63ef87ecb13dd6c5ccb6ee07d97b72a5ee78cd5","modified":1649355297328},{"_id":"source/_posts/img/cover/727ba3c1-ee2b-42b9-9522-92d3a9a5295e.jpg","hash":"2939bee96342e681c9594f700d31526720e4dd38","modified":1647884365200},{"_id":"source/_posts/img/.git/objects/78/f858e3b3ab4649f7f3a136d5cfb93920144662","hash":"447ca7c7f2bdca8e0ca3ce4c77402a9b94b45fc5","modified":1649355296958},{"_id":"source/_posts/img/.git/objects/c4/3b78c43ddd4608309af82a5475fc1c21d19055","hash":"69494e9dbbfbb123068d989cc225c7c1b81b8e2a","modified":1649355297138},{"_id":"source/_posts/img/cover/5887c2f1-b191-4890-aab5-2ce62d9955df.jpg","hash":"8f81b6c17ba9e1bb35d078d23907342cd7ed007a","modified":1647886149154},{"_id":"source/_posts/img/cover/1131782.jpg","hash":"1094bba9f0005fb0d3be5bba3f52575c36e77038","modified":1647882949531},{"_id":"source/_posts/img/.git/objects/dc/759b5e7e392f8565e2c470a4d5f63b967b5601","hash":"1e1493e36b9fdb939fd5f31f349ba4caa262d69c","modified":1649355297907},{"_id":"source/_posts/img/.git/objects/1c/cbd4f40e6a755d9bb99c68f05c7eed8fd9a21d","hash":"b9c0ca49d39730aee10e4f23e6763ff2eb65771c","modified":1649355296693},{"_id":"source/_posts/img/cover/infinity-1844433.jpg","hash":"7ec5f0d925f0628392c5d29d39a4cf7152587024","modified":1646937026168},{"_id":"source/_posts/img/.git/objects/03/dd5eb3063275ecabf51f2c0526847148906c4c","hash":"fda60550f94840cc4567b53df1b4d40da5e2603e","modified":1649355297660},{"_id":"source/_posts/img/cover/infinity-1584945.jpg","hash":"fb33550fcbd4791f7c49b43a0b12334e261ba6a0","modified":1646936996449},{"_id":"themes/nexmoe/source/image/cover/MKTO-Classic.jpg","hash":"f63bc6657c83c54fcdada28b494e40101ba514a7","modified":1484751873380},{"_id":"source/_posts/img/cover/MKTO-Classic.jpg","hash":"f63bc6657c83c54fcdada28b494e40101ba514a7","modified":1484751873380},{"_id":"source/_posts/img/.git/objects/pack/pack-01c07c8e373fa387247d9f7d4e82d1138544ab00.pack","hash":"5d8c2109f90b56af01d5c1163ceb83fdc1b543e1","modified":1628411252875},{"_id":"public/archives/2022/index.html","hash":"8626a5eb6b825821dc22bd67ed903142a303dc2d","modified":1723559922956},{"_id":"public/archives/2022/04/index.html","hash":"a46829d8d8462935abc85604ea8d8244a76129f2","modified":1723559922956},{"_id":"public/tags/批处理工具/index.html","hash":"d41df92bdb44b44058e8d0e4e250e8dd4e21544f","modified":1723559922956},{"_id":"public/tags/vue/index.html","hash":"9fc6bffd9e43545ba99ba2b3ceed3123a732fd9a","modified":1723559922956},{"_id":"public/tags/echart/index.html","hash":"282ea635ef568683d7f61ac4112ebb69d8807c59","modified":1723559922956},{"_id":"public/tags/DB/index.html","hash":"1a58c1001de9da9a295966dc9561c6d0d05d0898","modified":1723559922956},{"_id":"public/tags/spring/index.html","hash":"bb2d9b566235a9e1e8aa0480c35d406f0e58e027","modified":1723559922956},{"_id":"public/tags/资源/index.html","hash":"32fe38b2c2d84aa56bde9cdadffedefcf6047271","modified":1723559922956},{"_id":"public/tags/mysql/index.html","hash":"c8765b1cf69d1bce8075cc88b410da3736eb2958","modified":1723559922956},{"_id":"public/tags/GIS/index.html","hash":"31acf6e50595a9fd4400a36a20732ecf831f25ff","modified":1723559922956},{"_id":"public/tags/数据库/index.html","hash":"4c6cafdd5c3bd16d42dcdef360d2edb7fe99dfe8","modified":1723559922956},{"_id":"public/tags/java/index.html","hash":"1876b006acc69d198b3b855df07ddbf82fc19876","modified":1723559922956},{"_id":"public/tags/blog搭建/index.html","hash":"b622e8ecc40649929169155463a2212ef0dd1fbe","modified":1723559922956},{"_id":"public/categories/mysql/index.html","hash":"548763e4f8a124c2e209f3d13b04fa0f18ae8f8c","modified":1723559922956},{"_id":"public/categories/资源/index.html","hash":"903c2b8fa800c9d8c9928581eda09bc310a7e7b4","modified":1723559922956},{"_id":"public/categories/blog搭建/index.html","hash":"d4cdd5afb3e0bea2a471e640823e7b23670d2b81","modified":1723559922956},{"_id":"public/about.html","hash":"1bb727fa9e4a5bb4c847c46cd33aaffdae7e2a37","modified":1723559922956},{"_id":"public/2022/04/13/7533e8f3cb4c/index.html","hash":"90726d692ea000653e7257172c4ad7958da1c7f6","modified":1723559922956},{"_id":"public/archives.html","hash":"38c2268b9ffa15c2d16f8ab4c2a4d6f4490a7866","modified":1723559922956},{"_id":"public/2021/09/26/ee931b51117c/index.html","hash":"3d52777e464b3658be825478b968e14aa310200a","modified":1723559922956},{"_id":"public/2021/09/08/9adeea845004/index.html","hash":"39f98b1fd3f5494dc4ebe880f2bdccd3892327f2","modified":1723559922956},{"_id":"public/2021/08/31/7ba201dda6cb/index.html","hash":"850b3d1407f01a67d982d5bb9cd93c73f297e034","modified":1723559922956},{"_id":"public/2021/08/09/0d3ed7d31d83/index.html","hash":"629f35821a902c1b12c4de1370d7042e10173c09","modified":1723559922956},{"_id":"public/2021/08/08/0511666e05a1/index.html","hash":"0e331c29ac8d8ce434fb2bce005e3b80bf60cff4","modified":1723559922956},{"_id":"public/2021/08/08/a282a603af01/index.html","hash":"c7672877e18973bc1ea2bd84ed8dbebc3f06cd94","modified":1723559922956},{"_id":"public/2021/08/08/8ca546f02211/index.html","hash":"3272e3a42e95d16c1a5244da7aa0840521242463","modified":1723559922956},{"_id":"public/2021/08/08/425fb9b156c6/index.html","hash":"517bf7de6049a3068c77eef3c28ba96d2878d764","modified":1723559922956},{"_id":"public/2021/08/08/a53ec01c1bf3/index.html","hash":"e3111fd46cc95d7780dc4e6dceb6cdbddf32f933","modified":1723559922956},{"_id":"public/2021/08/08/4aeb45ead56c/index.html","hash":"c218262e59a2b6c5600ec09f771107a7ba6783a7","modified":1723559922956},{"_id":"public/2021/05/03/33b6a07e76bd/index.html","hash":"25fa6e5d64a08f99cb102e40345c3a3ceeb7034f","modified":1723559922956},{"_id":"public/2021/05/03/5fd29565f315/index.html","hash":"50bdc61afef9cdc6773d49ea9b3bef48cf85654a","modified":1723559922956},{"_id":"public/2021/04/30/6cdc310e6784/index.html","hash":"35064a85fe93b5c6f11e1427dda622af9a7e6f78","modified":1723559922956},{"_id":"public/2021/04/27/b8128014f023/index.html","hash":"2acefefc7f0c75f65fd0b2d9b88d27f5aa80516b","modified":1723559922956},{"_id":"public/2021/04/26/0aa35a941987/index.html","hash":"42a7133eef6abc494184e8a10066fa30b7fdb273","modified":1723559922956},{"_id":"public/2021/04/26/dd0d618383ec/index.html","hash":"f254f1bc2913e3c67500db4f179aa74107355ec5","modified":1723559922956},{"_id":"public/2021/04/21/bb7e5f9a2804/index.html","hash":"3ecd42bd4b5c0c79bad8792fe7eaed37b204ec40","modified":1723559922956},{"_id":"public/2021/04/20/714a4572ad94/index.html","hash":"745ee65f2c281517bcba6ef8c04f1372090e003b","modified":1723559922956},{"_id":"public/2021/04/18/38a5f92b31f2/index.html","hash":"d17ba5b58e3aebd6a9e6b415597ec6406ca0506c","modified":1723559922956},{"_id":"public/2021/04/18/c82a438b4928/index.html","hash":"20c12b2891ccc83c9dd6f5486b3b37912ac7768a","modified":1723559922956},{"_id":"public/2021/04/12/6b4cf36b2046/index.html","hash":"779857a60c872e2082d61ffe58059aeb6dca4e38","modified":1723559922956},{"_id":"public/2021/04/12/1d5c91f96393/index.html","hash":"b97878e101012ea1a291d525bea9e86a557a1190","modified":1723559922956},{"_id":"public/2021/04/10/240e3566888e/index.html","hash":"6d2628e70e867e2a5e10a47ebfc2c7084b3dfe6b","modified":1723559922956},{"_id":"public/2021/04/09/c6fe409c993d/index.html","hash":"66a4518f13089643cc30b9f7376c7dc52d114f63","modified":1723559922956},{"_id":"public/2021/04/06/e3cec34b39ef/index.html","hash":"07dbc3fac85be2e5cdb17789c691bd88a0c61d60","modified":1723559922956},{"_id":"public/2021/04/04/70aff1e72e3b/index.html","hash":"5321800fc9dc7d6bfbb841c1989bf87f85132dca","modified":1723559922956},{"_id":"public/2021/04/02/172ab8a53c56/index.html","hash":"daa8bf131387c88ca42db651d5a87038e83e9025","modified":1723559922956},{"_id":"public/2021/04/01/59f21206d8fb/index.html","hash":"1085d898317f1a7129006b50339a48faa12d2caf","modified":1723559922956},{"_id":"public/2021/04/01/ea0a76b44e41/index.html","hash":"90ffe34f59f7040b43344c087d29c8b4f6e89b27","modified":1723559922956},{"_id":"public/archives/index.html","hash":"43b3c3a744edcffd0cefa7cc8a01c5c4d5357abc","modified":1723559922956},{"_id":"public/archives/page/2/index.html","hash":"f19a77a65e4babfef4dadb101c0719b03bc3881c","modified":1723559922956},{"_id":"public/archives/page/3/index.html","hash":"d90982cd37c074e5615b041037eee48784040fde","modified":1723559922956},{"_id":"public/archives/2021/index.html","hash":"8742393f92167ea1cdf17d71e94d60bd1ee85c9f","modified":1723559922956},{"_id":"public/archives/2021/page/2/index.html","hash":"3d78767d62d59fea8b1ad01955f3990e424924dc","modified":1723559922956},{"_id":"public/archives/2021/page/3/index.html","hash":"6054fd66cfb13e989b7f8ef9314d86ce0fda1f58","modified":1723559922956},{"_id":"public/archives/2021/04/index.html","hash":"c63bd2c2dea4e6b71c41731d540c2e4a0471133b","modified":1723559922956},{"_id":"public/archives/2021/04/page/2/index.html","hash":"ba5c8f0608c315953c99e4bdd4017cc1564aa6a1","modified":1723559922956},{"_id":"public/archives/2021/05/index.html","hash":"87b55a9e8d5d96e3960ce2db7c96ec89ec7a6656","modified":1723559922956},{"_id":"public/archives/2021/08/index.html","hash":"54acfdf998d6bcb2fbf37c2ca66de0196492cc81","modified":1723559922956},{"_id":"public/archives/2021/09/index.html","hash":"da4be9a014b8433e0fb5099abab7422e1e7c12c7","modified":1723559922956},{"_id":"public/index.html","hash":"817dc13fc2ef0bd3be30ed2b85f56b1eb15920bd","modified":1723559922956},{"_id":"public/page/2/index.html","hash":"c2e288068468d08840d6004dc8d381967f99b99e","modified":1723559922956},{"_id":"public/page/3/index.html","hash":"ac59a548d6fdd92a08b8cb91e0d61bb54e11c23b","modified":1723559922956},{"_id":"public/tags/Vue/index.html","hash":"77e1e1bc81dabea7dc0e04ae76f20b49614fa27d","modified":1723559922956},{"_id":"public/tags/Cesium/index.html","hash":"5d32e0e47b61560fdb1176a5c8b126201b968849","modified":1723559922956},{"_id":"public/tags/java基础/index.html","hash":"85266d9b9512c2f24f6418e2e668b5615eeebffa","modified":1723559922956},{"_id":"public/tags/狂神说/index.html","hash":"082c11730a8a8639ae4423de7e4d44eded4e408b","modified":1723559922956},{"_id":"public/tags/Leetcode/index.html","hash":"c9b61e8905e2c12451e44d316844647f07c5efc3","modified":1723559922956},{"_id":"public/categories/Vue/index.html","hash":"5f128dde8b477210067d65481dfe7754920629b9","modified":1723559922956},{"_id":"public/categories/Cesium/index.html","hash":"8c297d7ee7deaf05536c0c9c37f0c6eb94051bbc","modified":1723559922956},{"_id":"public/categories/java/index.html","hash":"a68233c04e3a61401c814e78eb7a6d20315e87ef","modified":1723559922956},{"_id":"public/categories/java/page/2/index.html","hash":"07e07a62c65c0483b81d05937f0ba1adffe0e766","modified":1723559922956},{"_id":"public/categories/Leetcode/index.html","hash":"6a792df4449e0d368956d2a87033816d6b90b144","modified":1723559922956},{"_id":"public/categories/DB/index.html","hash":"ec5b06648c8d7c17a9d025a1a9a98ac73c2dbb58","modified":1723559922956},{"_id":"public/image/article/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1723559562265},{"_id":"public/image/article/1NF-1.png","hash":"9be315594c8ed00ff8442efe610904ab9f23df7d","modified":1723559562265},{"_id":"public/image/article/1NF-2.png","hash":"0d1958fa7ee8dae27eb07a4b69e2d45984bd2449","modified":1723559562265},{"_id":"public/image/article/20200602172212687.png","hash":"fb3fb5f0a81f50ab0a85fa8946bcf6fdd282e032","modified":1723559562265},{"_id":"public/image/article/20200602175224360.png","hash":"e6cae61c608e17c9321a5dda1d95663290e935d4","modified":1723559562265},{"_id":"public/image/article/2020062316474822.png","hash":"3304ac796ac347f347371db4997e618133e384a0","modified":1723559562265},{"_id":"public/image/article/20200623164809990.png","hash":"672f4b5debba72461fb29d60250360024f82b80e","modified":1723559562265},{"_id":"public/image/article/20200623164833872.png","hash":"3a97cbbc06053b11cde7e97fad535249292647d9","modified":1723559562265},{"_id":"public/image/article/20200623164853569.png","hash":"eae28eb4f266a782b60f8b78e542bd8e22c3f891","modified":1723559562265},{"_id":"public/image/article/20200623164845962.png","hash":"5438586d71f86fd7883b2783783e33466c66a746","modified":1723559562265},{"_id":"public/image/article/20200623164901861.png","hash":"73ce29f142c92422407fd99858d60862c18ce311","modified":1723559562265},{"_id":"public/image/article/20200623164920502.png","hash":"0ecde638bef77ab6e7316b79f4fa1157693a179c","modified":1723559562265},{"_id":"public/image/article/20200623165129955.png","hash":"c5c2db8aa57fb4e07083cbda586747a58ffaf819","modified":1723559562265},{"_id":"public/image/article/20210427183235.png","hash":"95d3b4f94240d63518ee302aa6e9d69ba80f32f1","modified":1723559562265},{"_id":"public/image/article/20210427182334.png","hash":"941cb3d455a618bb041fff7457f30535420ee79a","modified":1723559562265},{"_id":"public/image/article/20210427182427.png","hash":"8d12acaee10b52c278c01614f19038e08e141f2e","modified":1723559562265},{"_id":"public/image/article/20210428131402.png","hash":"e8aa733529db3538ff4acc8a79799aedac39e8d5","modified":1723559562265},{"_id":"public/image/article/20210428162631.png","hash":"643cdb25a713560b7fae5ef45a4c7d8f6369c915","modified":1723559562265},{"_id":"public/image/article/20210428162806.png","hash":"9a4a6c856512b4de91d8409d9051a871ca4480e1","modified":1723559562265},{"_id":"public/image/article/20210428170220.png","hash":"438b1098c9a2b949d8b9bcf02ad8d227dc008edc","modified":1723559562265},{"_id":"public/image/article/20210428171043.png","hash":"6d8fbc93df2eafaa12c13f521acdbe25b7dd4e21","modified":1723559562265},{"_id":"public/image/article/20210428171331.png","hash":"9fa7b593882e02a1a19f7880b3775e6e821bf228","modified":1723559562265},{"_id":"public/image/article/20210428172011.png","hash":"37e945f159aef4501c7390048bc2c05f5b78b4b1","modified":1723559562265},{"_id":"public/image/article/20210428230921.png","hash":"cf4e015b07d174ba54363e832801ef82daf987dd","modified":1723559562265},{"_id":"public/image/article/20210511152803.png","hash":"664c48a46e7b2d24aa5c3be85680390afe5f37ea","modified":1723559562265},{"_id":"public/image/article/2NF-1.png","hash":"448427257c9a470d2d71bc919a5ca2fa11f98020","modified":1723559562265},{"_id":"public/image/article/2NF-2.png","hash":"fb2a7b41f7f9aec8e825394b9b2b0afc15745629","modified":1723559562265},{"_id":"public/image/article/2NF-3.png","hash":"bc038414d898f95832038be3bf02f44eaa610d03","modified":1723559562265},{"_id":"public/image/article/3NF-2.png","hash":"5129be82b72c305e613d2a0632c22357ab92ab3e","modified":1723559562265},{"_id":"public/image/article/3NF-1.png","hash":"398d2f1de0f14da5b3ce8731e3ca86a14ae8b5ea","modified":1723559562265},{"_id":"public/image/article/3NF-3.png","hash":"04ac0821ceffe6157072052a69226e7808e89974","modified":1723559562265},{"_id":"public/image/article/image-20200227090842247.png","hash":"98b862f34d7a5fc816dc683ea16aaae336a5da10","modified":1723559562265},{"_id":"public/image/article/image-20200227092939646.png","hash":"67621863b4f78b52cbd6a47528de291fdfa8a023","modified":1723559562265},{"_id":"public/image/article/image-20200227093004793.png","hash":"c3381d0eed75bbb86cf351dd5381e95be0e36294","modified":1723559562265},{"_id":"public/image/article/image-20210414201800584.png","hash":"7e1b9f7feab037dae850ae28dc589c1a515b7731","modified":1723559562265},{"_id":"public/image/article/image-20210414201814306.png","hash":"060f9940d46df3ceb07212971dddfc0cbd536d00","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.svg","hash":"4807f0720e2a2a8375a1f085f50a113be674a0a0","modified":1723559562265},{"_id":"public/lib/iconfont/gitee.svg","hash":"087346df20b0d8df4e719f3c3427c2617a410209","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.eot","hash":"465966dac936ddff3e7313dea360f59c43fab804","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.ttf","hash":"1b497f21aff9732f4e9f66881b028c3eb0e0763e","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.woff","hash":"15f15f4b1219ba1bc08267f2e70d2cac5bb3d496","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.woff2","hash":"d966e8fdd11265e4e7d84bbff903e89aa778bd18","modified":1723559562265},{"_id":"public/image/article/2020062316493391.png","hash":"fab4f2de8378741e2acf24babeef1ed5afab8140","modified":1723559562265},{"_id":"public/image/article/20200623164958936.png","hash":"71c678a261cf8263e0c1204de3eac15b46633f84","modified":1723559562265},{"_id":"public/image/article/20200623165030775.png","hash":"b6ff53f34d91db65010555e1aad50754beb58951","modified":1723559562265},{"_id":"public/image/article/20200623165014965.png","hash":"82f5989cd3fdec95036c5c7e2a45300de4acad87","modified":1723559562265},{"_id":"public/image/article/20200628180016435.png","hash":"817384246ef49d381f2f367586cde75aa4579978","modified":1723559562265},{"_id":"public/image/article/20200628180025728.png","hash":"a5e1e8ecc9f441667550f4e0f6aa15a9c34c59f3","modified":1723559562265},{"_id":"public/image/article/20200628180055895.png","hash":"0bbc4bc09d17f57bf5790ff85163ca1c7ae5d46e","modified":1723559562265},{"_id":"public/image/article/20200628180035980.png","hash":"2701e203e3d7aa6b77288c421a3c9767b5115ad9","modified":1723559562265},{"_id":"public/image/article/20200628180128654.png","hash":"2f6abb04f25085e5925e94ea6433b50e0b75acd9","modified":1723559562265},{"_id":"public/image/article/20200628180116257.png","hash":"a9ea671f5b72a18e88946e3b34d14940daa5aed7","modified":1723559562265},{"_id":"public/image/article/20210426163943.png","hash":"79ddffda55792fe4129c2611ad5342f4803e58ed","modified":1723559562265},{"_id":"public/image/article/20210426183748.png","hash":"40a9ffcec6ff2fc14adf75416fb263126ab23d45","modified":1723559562265},{"_id":"public/image/article/20210426184103.png","hash":"f53d39f91e96136c2e1bd638bca239daf321476d","modified":1723559562265},{"_id":"public/image/article/20210426184359.png","hash":"33e352dcf71f6157da2f78645c51e5a0acac4040","modified":1723559562265},{"_id":"public/image/article/20210428131746.png","hash":"c8eb07bd9bbb6eb01fae64b397e061df7382d0b6","modified":1723559562265},{"_id":"public/image/article/20210428135406.png","hash":"ecd95b84e90131404a5f68f576eafae323ea8c5b","modified":1723559562265},{"_id":"public/image/article/20210428162308.png","hash":"4fd737678286d9693aa93807135fadd2a66d481e","modified":1723559562265},{"_id":"public/image/article/20210428170647.png","hash":"d00c8ec317dfbb2c2e3d24ba2d28da0242ab8ec7","modified":1723559562265},{"_id":"public/image/article/20210430200702.png","hash":"c54c9ed6e5509576cb499ca99730d447c399562c","modified":1723559562265},{"_id":"public/image/article/image-20210411183039107.png","hash":"40c6753229e714b8179f2c095d8e9805ac1bd6b6","modified":1723559562265},{"_id":"public/image/article/image-20210411183018803.png","hash":"1331a7e86049cfa7f68aaac4249a2cabb9f0cdc4","modified":1723559562265},{"_id":"public/image/article/image-20210414170751285.png","hash":"eed9851c4ad7d13869b44c8aa855bb74198e6a2a","modified":1723559562265},{"_id":"public/image/article/image-20210414173909852.png","hash":"4e015f3011f722fdd3fcf56855538fd016c2e44e","modified":1723559562265},{"_id":"public/image/article/image-20210414184512856.png","hash":"a22476abcfaf616913a9d3bba7aeb85d8582d566","modified":1723559562265},{"_id":"public/image/article/shaxiang1.png","hash":"cfeaee29d4daea733c50789f032d7f247b6795db","modified":1723559562265},{"_id":"public/image/cover/JAVA.png","hash":"c10bb02ac04f469fe75abd50fe19896c98e675c4","modified":1723559562265},{"_id":"public/image/article/shaxiang3.png","hash":"da67be87af6a8f6ffa9dae25dfddff29e4fa94db","modified":1723559562265},{"_id":"public/image/cover/Spring.png","hash":"32585e088f095d01197ffccd727c5f9cbb41f049","modified":1723559562265},{"_id":"public/image/cover/leetcode.png","hash":"014977aa4ccafcaae5a9adf181255c7f7a962ea8","modified":1723559562265},{"_id":"public/image/author.png","hash":"3ac90abffe8914e445293906dba277fb773fb45b","modified":1723559562265},{"_id":"public/image/article/20191108105314115.png","hash":"f4d016d039781f9bbfb2f312ed0bd2af59c33124","modified":1723559562265},{"_id":"public/image/article/20210428132115.png","hash":"23b651f8d7858b06a76ad2a8bd00ad83ff0cb87b","modified":1723559562265},{"_id":"public/image/article/20210428133859.png","hash":"4e75c79c72667c09a040cbf92532f2804c49edbe","modified":1723559562265},{"_id":"public/image/article/20210430181656.png","hash":"44f664a50fdc074ea85d975fe9f3dd7641c6242b","modified":1723559562265},{"_id":"public/image/article/image-20210407105452970.png","hash":"185bfa07df8ee679148ce90780c72018d98e6455","modified":1723559562265},{"_id":"public/image/cover/MyBatis.png","hash":"656a9d8cb66f8b5d83db096e2fdd85221fa8208e","modified":1723559562265},{"_id":"public/image/cover/cover-20210415151105.jpg","hash":"2f7f1be375f2ed53afd78b703155bd0a49aaee85","modified":1723559562265},{"_id":"public/js/app.js","hash":"eca1fbe3fea9a2ecd24191656222a248cf90aadc","modified":1723559562265},{"_id":"public/lib/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.css","hash":"a778d38bdc67fbeb3c5e63f75a6a5528adcd91e1","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.json","hash":"03e829ff4d38d43953051e0639e5700629df3c5d","modified":1723559562265},{"_id":"public/image/article/20210426183040.png","hash":"2c757d27afc8af66daebb623db699b1bb072ddb8","modified":1723559562265},{"_id":"public/image/article/20210428133849.png","hash":"d98761a7f281cd12c5e9602c221ac89006965d2e","modified":1723559562265},{"_id":"public/image/article/image-20210414150428147.png","hash":"5126f8c1a301c483a65fd43167081d60c3797572","modified":1723559562265},{"_id":"public/image/cover/5c3aec85a4343.jpg","hash":"61592b637f730d89bc12ce89637bf08a4763f568","modified":1723559562265},{"_id":"public/image/article/shaxiang2.png","hash":"b185ed0563c1e49378377916bae65ac9abc43279","modified":1723559562265},{"_id":"public/css/style.css","hash":"893ed01bf9a8305596332b868166cbbb49ad0e38","modified":1723559562265},{"_id":"public/image/article/20190216114129109.png","hash":"a36900d235bc3fdc84780d00c22d9d15031223a3","modified":1723559562265},{"_id":"public/image/article/20210428201314.png","hash":"7f79e98efab6e1768c11174bf4e2a9f120666647","modified":1723559562265},{"_id":"public/lib/iconfont/demo_index.html","hash":"77a7fde76271989fb498422f582f29d2ba61b90d","modified":1723559562265},{"_id":"public/lib/iconfont/iconfont.js","hash":"bcd569bf13e40a6d49f55aa8f4e488ab89e1041a","modified":1723559562265},{"_id":"public/image/article/image-20210414150356108.png","hash":"5055be2719de2e1ea1e43c4ccb9dced2282c2dfc","modified":1723559562265},{"_id":"public/image/article/image-20210414173959254.png","hash":"3c075618d326c8ea614ca8704f5477ee5a8aaa2f","modified":1723559562265},{"_id":"public/image/article/image-20210414143319605.png","hash":"abc5097a2c8df371cf3da2cbf9a7ecd2b7687ab1","modified":1723559562265},{"_id":"public/image/article/image-20210414153626283.png","hash":"1c5a938cb61a8597a2b001bde3c227f2d1dc63d7","modified":1723559562265},{"_id":"public/image/article/20210426184621.png","hash":"d72c5f4e5648f78988d9d31af087c3773acffc0e","modified":1723559562265},{"_id":"public/image/cover/mysql.png","hash":"df9303b3fae755ab59662cea0d60f6d7a9080ef0","modified":1723559562265},{"_id":"public/image/cover/fw658.gif","hash":"720009d288622f2631518ebd9b884117ca53f489","modified":1723559562265},{"_id":"public/image/cover/IMG_0488(20210213-001329).JPG","hash":"1223ec7d39cb22762619e7a490e57b98d64dbdb2","modified":1723559562265},{"_id":"public/image/article/2020121722082798.png","hash":"266f925d25a3ff4628f49ebf3ea1d851cb039f3d","modified":1723559562265},{"_id":"public/lib/mdui_043tiny/js/mdui.js","hash":"9feeebf8c11d8ce8549ec94896c630ba2334613c","modified":1723559562265},{"_id":"public/lib/mdui_043tiny/css/mdui.css","hash":"b79ef94d2b11f8ce05ba048f5d74a3bd09f12e4d","modified":1723559562265},{"_id":"public/image/article/20200623165404113.png","hash":"f93e9ee3760465868fb1ae645db2c748b6b3f568","modified":1723559562265},{"_id":"public/image/cover/MKTO-Classic.jpg","hash":"f63bc6657c83c54fcdada28b494e40101ba514a7","modified":1723559562265},{"_id":"source/_posts/20240813-无人驾驶.md","hash":"2d718251bcfd022da0d911250d15407dd52689ee","modified":1723559727091},{"_id":"public/2024/08/13/6abe7b71ef31/index.html","hash":"febd81a0549ca2d71f8e3e873ff29dc6202aeb31","modified":1723559922956},{"_id":"public/archives/page/4/index.html","hash":"a9d1fe788ea0863c1ce382c7c3bee9dcb594270d","modified":1723559922956},{"_id":"public/archives/2024/index.html","hash":"48b91a43264f7127bcb4d6bcafee77211d69d3c2","modified":1723559922956},{"_id":"public/archives/2024/08/index.html","hash":"6589b3da2029048989344028cbc8438972e52103","modified":1723559922956},{"_id":"public/categories/无人驾驶/index.html","hash":"99952f9c93249396b50d3e9f9c764fec37e2a59f","modified":1723559922956},{"_id":"public/page/4/index.html","hash":"4307f4fe8ee2d6b0c0f4f74329372cfe3d4253e3","modified":1723559922956},{"_id":"public/tags/无人驾驶/index.html","hash":"0e3ed22c0ad070adcca099d3d1b791f7007a1fa7","modified":1723559922956},{"_id":"source/_posts/img/1.txt","hash":"40bd001563085fc35165329ea1ff5c5ecbdbbeef","modified":1723561494061},{"_id":"source/_posts/img/.git/MERGE_MSG.save","hash":"1f7a4347cea628d99c3f76ba5331bf58350eedd0","modified":1723561516790},{"_id":"source/_posts/img/.git/ORIG_HEAD","hash":"03e7816509ac80c01f369fb36cc6f2bd51cc5281","modified":1723561726724},{"_id":"source/_posts/img/.git/objects/17/02674b425815ca9b7fa181913144c2b4e36558","hash":"89ad018fb90e0482214cc46d4602ba0211378168","modified":1723561097823},{"_id":"source/_posts/img/.git/objects/2d/6d85bf1f5f54c88f197721a43874f289faa4f6","hash":"74494180682f7f37aa987e1e703a34b93d57a411","modified":1723561097823},{"_id":"source/_posts/img/.git/objects/76/c459bc64b9c1875d078cd6b4daffebb41fed81","hash":"58c9885ceced6b08281a703ca36f505d3189c3e2","modified":1723561474623},{"_id":"source/_posts/img/.git/objects/7e/0bd89d85f5d24609e3c7d694b2c2fd45471fc2","hash":"4be9d77f7b79669456cc4281c5e5078516ab12a9","modified":1723561097823},{"_id":"source/_posts/img/.git/objects/96/61ac713428efbad557d3ba3a62216b5bb7d226","hash":"dc6051c4c037560bb5408ef4f461dc2ecddf7732","modified":1723561090735},{"_id":"source/_posts/img/.git/objects/97/1d91f43271d62caacda3fe8fb1ea31cbc75647","hash":"87e3c47050effbb205712bdde7509dc77eadce64","modified":1723561651781},{"_id":"source/_posts/img/.git/objects/a1/6685ea3e1ce565517e53616cc653ff7cbd31b5","hash":"2e0be8c6ac3c13bb8d0f03c0bed17bb068ae8d3f","modified":1723561635550},{"_id":"source/_posts/img/.git/objects/bf/4c9d396a05d71ccc8871b36d978161060bcedf","hash":"c83debbed755a0a008a4546b8acf3500b3ba14a9","modified":1723561090735},{"_id":"source/_posts/img/.git/objects/c9/4a2c026bb3f784dad648fa8810bf8fdbdd6f24","hash":"dbac090e450fbc79477ad90980bb2335e772f8ff","modified":1723561090735},{"_id":"source/_posts/img/.git/objects/cc/0df83351beec8c28648ecfe1e828d2192fa9fc","hash":"ca8480bd1b365edf505040540b6c22bc3b977434","modified":1723561090735},{"_id":"source/_posts/img/.git/objects/d8/00886d9c86731ae5c4a62b0b77c437015e00d2","hash":"3c7fc7438fa172b4b3fcb2ed735eb6b4a1b2c56b","modified":1723561557909},{"_id":"source/_posts/img/.git/objects/df/316b029d83d7758bc4d1a6867d18561375cfda","hash":"34786bf86f313a001b4d31a5b985df7b96bbb429","modified":1723561474623},{"_id":"source/_posts/img/.git/objects/ef/004d16cf58eee09fe9b1ad2875fca0f8f72214","hash":"3847325e56e47974d5d09fa272f845fbc3eac4ef","modified":1723561090735},{"_id":"source/_posts/img/.git/objects/fa/263018774630e01d53039db38acf819b2949a6","hash":"44dd6fab1eb006593430d6c5de93f98ab37b6c3f","modified":1723561721572}],"Category":[{"name":"Vue","_id":"clana7x0x0006y4w11bqseu9d"},{"name":"Cesium","_id":"clana7x14000gy4w1h2l5a24k"},{"name":"-mysql","_id":"clana7x19000sy4w1aw9selod"},{"name":"java","_id":"clana7x1e0013y4w1a60abapq"},{"name":"资源","_id":"clana7x1t0026y4w16etm1gdp"},{"name":"Leetcode","_id":"clana7x1u002dy4w177aqdc3q"},{"name":"DB","_id":"clana7x29003sy4w1bdmx8lu1"},{"name":"blog搭建","_id":"clana7x2e0044y4w17ijz0zfj"},{"name":"无人驾驶","_id":"clzsiyqlo00015m7l09opfjus"}],"Data":[],"Page":[{"title":"关于博客","layout":"about","_content":"\n\n\n## 博客相关\n\n- 本博客主要用于分享学习笔记以及各种踩坑记录。\n- 搭建方式为 hexo + github page + nexmoe主题。","source":"about.md","raw":"---\ntitle: 关于博客\nlayout: about\n---\n\n\n\n## 博客相关\n\n- 本博客主要用于分享学习笔记以及各种踩坑记录。\n- 搭建方式为 hexo + github page + nexmoe主题。","date":"2021-04-18T07:00:45.462Z","updated":"2021-04-18T07:00:45.462Z","path":"about.html","comments":1,"_id":"clana7x0l0000y4w11gob3sq2","content":"<h2 id=\"博客相关\"><a href=\"#博客相关\" class=\"headerlink\" title=\"博客相关\"></a>博客相关</h2><ul>\n<li>本博客主要用于分享学习笔记以及各种踩坑记录。</li>\n<li>搭建方式为 hexo + github page + nexmoe主题。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"博客相关\"><a href=\"#博客相关\" class=\"headerlink\" title=\"博客相关\"></a>博客相关</h2><ul>\n<li>本博客主要用于分享学习笔记以及各种踩坑记录。</li>\n<li>搭建方式为 hexo + github page + nexmoe主题。</li>\n</ul>\n"},{"title":"文章归档","layout":"archives","_content":"","source":"archives.md","raw":"---\ntitle: 文章归档\nlayout: archives\n---\n","date":"2021-04-15T15:17:24.907Z","updated":"2021-04-15T15:17:24.907Z","path":"archives.html","comments":1,"_id":"clana7x0s0002y4w1ctu49tn0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"『批处理』批量删除文本文件前n行","date":"2021-08-08T08:45:48.000Z","_content":"\n\n\n====\n\n<!--more-->\n\n**使用方法**：新建文本文档，复制下方代码，保存，修改后缀为**.bat**，双击即可执行。\n\n\n```vbnet\n@ECHO OFF\nSET TxtDir=\"%~dp0\"\nSET /A N=6\nECHO 删除行操作开始，请耐心等待。\nECHO 正在执行，请勿关闭本窗口。\nECHO ...\nCD /D %TxtDir%\nFOR /F \"tokens=1 delims=\" %%I IN ('DIR /A /B *.txt') DO ((MORE +%N% \"%%I\">\"%%I_\")&(DEL /A /F /Q \"%%I\")&(REN \"%%I_\" \"%%I\"))\nECHO 执行任务结束。\nPAUSE\n```\n\n\n\n\n**可以修改的部分：**\n\n第二行，可以通过修改更改操作目录(替换`%~dp0`)，不修改则为批处理文件当前目录。\n\n第三行，可以通过修改`N= `修改删除行数。\n\n第八行，可以通过修改`*.txt`修改操作文件格式","source":"_posts/20210808-『批处理』批量删除文本文件前n行.md","raw":"---\ntitle: 『批处理』批量删除文本文件前n行\ndate: 2021-08-08 16:45:48\ntags:\n- 批处理工具\ncategories:\n---\n\n\n\n====\n\n<!--more-->\n\n**使用方法**：新建文本文档，复制下方代码，保存，修改后缀为**.bat**，双击即可执行。\n\n\n```vbnet\n@ECHO OFF\nSET TxtDir=\"%~dp0\"\nSET /A N=6\nECHO 删除行操作开始，请耐心等待。\nECHO 正在执行，请勿关闭本窗口。\nECHO ...\nCD /D %TxtDir%\nFOR /F \"tokens=1 delims=\" %%I IN ('DIR /A /B *.txt') DO ((MORE +%N% \"%%I\">\"%%I_\")&(DEL /A /F /Q \"%%I\")&(REN \"%%I_\" \"%%I\"))\nECHO 执行任务结束。\nPAUSE\n```\n\n\n\n\n**可以修改的部分：**\n\n第二行，可以通过修改更改操作目录(替换`%~dp0`)，不修改则为批处理文件当前目录。\n\n第三行，可以通过修改`N= `修改删除行数。\n\n第八行，可以通过修改`*.txt`修改操作文件格式","slug":"『批处理』批量删除文本文件前n行","published":1,"updated":"2022-04-07T17:25:27.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x0p0001y4w18koocdxv","content":"<p>====</p>\n<span id=\"more\"></span>\n\n<p><strong>使用方法</strong>：新建文本文档，复制下方代码，保存，修改后缀为**.bat**，双击即可执行。</p>\n<pre><code class=\"vbnet\">@ECHO OFF\nSET TxtDir=&quot;%~dp0&quot;\nSET /A N=6\nECHO 删除行操作开始，请耐心等待。\nECHO 正在执行，请勿关闭本窗口。\nECHO ...\nCD /D %TxtDir%\nFOR /F &quot;tokens=1 delims=&quot; %%I IN (&#39;DIR /A /B *.txt&#39;) DO ((MORE +%N% &quot;%%I&quot;&gt;&quot;%%I_&quot;)&amp;(DEL /A /F /Q &quot;%%I&quot;)&amp;(REN &quot;%%I_&quot; &quot;%%I&quot;))\nECHO 执行任务结束。\nPAUSE\n</code></pre>\n<p><strong>可以修改的部分：</strong></p>\n<p>第二行，可以通过修改更改操作目录(替换<code>%~dp0</code>)，不修改则为批处理文件当前目录。</p>\n<p>第三行，可以通过修改<code>N= </code>修改删除行数。</p>\n<p>第八行，可以通过修改<code>*.txt</code>修改操作文件格式</p>\n","site":{"data":{}},"excerpt":"<p>====</p>","more":"<p><strong>使用方法</strong>：新建文本文档，复制下方代码，保存，修改后缀为**.bat**，双击即可执行。</p>\n<pre><code class=\"vbnet\">@ECHO OFF\nSET TxtDir=&quot;%~dp0&quot;\nSET /A N=6\nECHO 删除行操作开始，请耐心等待。\nECHO 正在执行，请勿关闭本窗口。\nECHO ...\nCD /D %TxtDir%\nFOR /F &quot;tokens=1 delims=&quot; %%I IN (&#39;DIR /A /B *.txt&#39;) DO ((MORE +%N% &quot;%%I&quot;&gt;&quot;%%I_&quot;)&amp;(DEL /A /F /Q &quot;%%I&quot;)&amp;(REN &quot;%%I_&quot; &quot;%%I&quot;))\nECHO 执行任务结束。\nPAUSE\n</code></pre>\n<p><strong>可以修改的部分：</strong></p>\n<p>第二行，可以通过修改更改操作目录(替换<code>%~dp0</code>)，不修改则为批处理文件当前目录。</p>\n<p>第三行，可以通过修改<code>N= </code>修改删除行数。</p>\n<p>第八行，可以通过修改<code>*.txt</code>修改操作文件格式</p>"},{"title":"vue中让echarts随屏幕大小变化","date":"2021-08-08T09:12:00.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Vue.jpeg","_content":"\n====\n\n<!--more-->\n\n```\nlet myChart = this.$echarts.init(document.getElementById('myChart'))\n```\n\n给echart实体添加监听`resize()`事件\n\n```\nwindow.addEventListener(\"resize\", () => {\n        myChart.resize();\n});    \n```\n\n","source":"_posts/20210808-vue中让echarts随屏幕大小变化.md","raw":"---\ntitle: vue中让echarts随屏幕大小变化\ndate: 2021-08-08 17:12:00\ntags:\n- vue\n- echart\ncategories:\n- Vue\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Vue.jpeg\n---\n\n====\n\n<!--more-->\n\n```\nlet myChart = this.$echarts.init(document.getElementById('myChart'))\n```\n\n给echart实体添加监听`resize()`事件\n\n```\nwindow.addEventListener(\"resize\", () => {\n        myChart.resize();\n});    \n```\n\n","slug":"vue中让echarts随屏幕大小变化","published":1,"updated":"2022-04-07T17:25:27.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x0t0003y4w1dr041qcp","content":"<p>====</p>\n<span id=\"more\"></span>\n\n<pre><code>let myChart = this.$echarts.init(document.getElementById(&#39;myChart&#39;))\n</code></pre>\n<p>给echart实体添加监听<code>resize()</code>事件</p>\n<pre><code>window.addEventListener(&quot;resize&quot;, () =&gt; &#123;\n        myChart.resize();\n&#125;);    \n</code></pre>\n","site":{"data":{}},"excerpt":"<p>====</p>","more":"<pre><code>let myChart = this.$echarts.init(document.getElementById(&#39;myChart&#39;))\n</code></pre>\n<p>给echart实体添加监听<code>resize()</code>事件</p>\n<pre><code>window.addEventListener(&quot;resize&quot;, () =&gt; &#123;\n        myChart.resize();\n&#125;);    \n</code></pre>"},{"title":"Vue中使用Vue-jsonp请求jsonp数据","date":"2021-08-09T13:28:17.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Vue.jpeg","_content":"\n\n\n====\n\n<!--more-->\n\n# Vue-jsonp\n\n为了解决axios无法发起jsonp格式的请求问题，使用`vue-jsonp`组件。\n\n## 一、添加依赖\n\n`npm install vue-jsonp -save`\n\n\n\n## 二、main.js\n\n在vue cli项目main.js中添加\n\n```js\nimport { VueJsonp } from 'vue-jsonp' // 网上很多博客引用不加{}，会报错\nVue.use(VueJsonp)\n```\n\n\n\n## 三、使用\n\n```js\nlet url = \"https://view.inews.qq.com/g2/getOnsInfo?\";\nlet param = {\n          name: \"disease_h5\"\n        };\nthis.$jsonp(url, param).then(res => {\n    console.log(res);\n});\n```\n\n","source":"_posts/20210809-Vue中使用Vue-jsonp请求jsonp数据.md","raw":"---\ntitle: Vue中使用Vue-jsonp请求jsonp数据\ndate: 2021-08-09 21:28:17\ntags:\n- Vue\ncategories:\n- Vue\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Vue.jpeg\n---\n\n\n\n====\n\n<!--more-->\n\n# Vue-jsonp\n\n为了解决axios无法发起jsonp格式的请求问题，使用`vue-jsonp`组件。\n\n## 一、添加依赖\n\n`npm install vue-jsonp -save`\n\n\n\n## 二、main.js\n\n在vue cli项目main.js中添加\n\n```js\nimport { VueJsonp } from 'vue-jsonp' // 网上很多博客引用不加{}，会报错\nVue.use(VueJsonp)\n```\n\n\n\n## 三、使用\n\n```js\nlet url = \"https://view.inews.qq.com/g2/getOnsInfo?\";\nlet param = {\n          name: \"disease_h5\"\n        };\nthis.$jsonp(url, param).then(res => {\n    console.log(res);\n});\n```\n\n","slug":"Vue中使用Vue-jsonp请求jsonp数据","published":1,"updated":"2022-04-07T17:25:27.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x0w0005y4w1d0ad5xya","content":"<p>====</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vue-jsonp\"><a href=\"#Vue-jsonp\" class=\"headerlink\" title=\"Vue-jsonp\"></a>Vue-jsonp</h1><p>为了解决axios无法发起jsonp格式的请求问题，使用<code>vue-jsonp</code>组件。</p>\n<h2 id=\"一、添加依赖\"><a href=\"#一、添加依赖\" class=\"headerlink\" title=\"一、添加依赖\"></a>一、添加依赖</h2><p><code>npm install vue-jsonp -save</code></p>\n<h2 id=\"二、main-js\"><a href=\"#二、main-js\" class=\"headerlink\" title=\"二、main.js\"></a>二、main.js</h2><p>在vue cli项目main.js中添加</p>\n<pre><code class=\"js\">import &#123; VueJsonp &#125; from &#39;vue-jsonp&#39; // 网上很多博客引用不加&#123;&#125;，会报错\nVue.use(VueJsonp)\n</code></pre>\n<h2 id=\"三、使用\"><a href=\"#三、使用\" class=\"headerlink\" title=\"三、使用\"></a>三、使用</h2><pre><code class=\"js\">let url = &quot;https://view.inews.qq.com/g2/getOnsInfo?&quot;;\nlet param = &#123;\n          name: &quot;disease_h5&quot;\n        &#125;;\nthis.$jsonp(url, param).then(res =&gt; &#123;\n    console.log(res);\n&#125;);\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>====</p>","more":"<h1 id=\"Vue-jsonp\"><a href=\"#Vue-jsonp\" class=\"headerlink\" title=\"Vue-jsonp\"></a>Vue-jsonp</h1><p>为了解决axios无法发起jsonp格式的请求问题，使用<code>vue-jsonp</code>组件。</p>\n<h2 id=\"一、添加依赖\"><a href=\"#一、添加依赖\" class=\"headerlink\" title=\"一、添加依赖\"></a>一、添加依赖</h2><p><code>npm install vue-jsonp -save</code></p>\n<h2 id=\"二、main-js\"><a href=\"#二、main-js\" class=\"headerlink\" title=\"二、main.js\"></a>二、main.js</h2><p>在vue cli项目main.js中添加</p>\n<pre><code class=\"js\">import &#123; VueJsonp &#125; from &#39;vue-jsonp&#39; // 网上很多博客引用不加&#123;&#125;，会报错\nVue.use(VueJsonp)\n</code></pre>\n<h2 id=\"三、使用\"><a href=\"#三、使用\" class=\"headerlink\" title=\"三、使用\"></a>三、使用</h2><pre><code class=\"js\">let url = &quot;https://view.inews.qq.com/g2/getOnsInfo?&quot;;\nlet param = &#123;\n          name: &quot;disease_h5&quot;\n        &#125;;\nthis.$jsonp(url, param).then(res =&gt; &#123;\n    console.log(res);\n&#125;);\n</code></pre>"},{"title":"基于Vue-cli的cesium封装插件","date":"2021-08-08T09:30:27.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg","_content":"\n\n\n====\n\n<!--more-->\n\n\n\n市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue\n\n通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑\n\n其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦\n\n`vue-cli-plugin-cesium` 就是为了解决这个问题\n\n\n\ngithub:https://github.com/isboyjc/vue-cli-plugin-cesium","source":"_posts/20210808-基于Vue-cli的cesium封装插件.md","raw":"---\ntitle: 基于Vue-cli的cesium封装插件\ndate: 2021-08-08 17:30:27\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg\ntags:\n- Vue\n- Cesium\ncategories:\n- Cesium\n---\n\n\n\n====\n\n<!--more-->\n\n\n\n市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue\n\n通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑\n\n其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦\n\n`vue-cli-plugin-cesium` 就是为了解决这个问题\n\n\n\ngithub:https://github.com/isboyjc/vue-cli-plugin-cesium","slug":"基于Vue-cli的cesium封装插件","published":1,"updated":"2022-04-07T17:25:27.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x0x0007y4w171lph7ee","content":"<p>====</p>\n<span id=\"more\"></span>\n\n\n\n<p>市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue</p>\n<p>通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑</p>\n<p>其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦</p>\n<p><code>vue-cli-plugin-cesium</code> 就是为了解决这个问题</p>\n<p>github:<a href=\"https://github.com/isboyjc/vue-cli-plugin-cesium\">https://github.com/isboyjc/vue-cli-plugin-cesium</a></p>\n","site":{"data":{}},"excerpt":"<p>====</p>","more":"<p>市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue</p>\n<p>通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑</p>\n<p>其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦</p>\n<p><code>vue-cli-plugin-cesium</code> 就是为了解决这个问题</p>\n<p>github:<a href=\"https://github.com/isboyjc/vue-cli-plugin-cesium\">https://github.com/isboyjc/vue-cli-plugin-cesium</a></p>"},{"title":"Cesium billboard贴地形表","date":"2021-08-31T13:46:22.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg","_content":"\n==============\n\n<!--more-->\n\n\n\n# 获取点击位置高程的方法，cartographic 中包含:\n - `longitude` 经度\n - `latitude` 维度\n - `height` 高程\n```javascript\nlet ray = viewer.camera.getPickRay(movement.position);\nlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\nlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n```\n# billboard贴地形表\n```javascript\nbillboard: {\n              image: locationMark, \n              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,\n              horizontalOrigin: Cesium.HorizontalOrigin.CENTER, // //相对于对象的原点（注意是原点的位置）的水平位置\n              verticalOrigin: Cesium.VerticalOrigin.BOTTOM //相对于对象的原点的垂直位置，BOTTOM时锚点在下，对象在上\n}\n```\n\n# 结合使用，点击添加图标\n```javascript\nif(flag){\n\tviewer.screenSpaceEventHandler.setInputAction(function (movement) {\n\t\tlet ray = viewer.camera.getPickRay(movement.position);\n    \tlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\n    \tlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n    \tlet billboard = new Cesium.Entity({\n    \t\tname: \"Draw-Handler-point\",\n        \tposition: Cesium.Cartesian3.fromDegrees(\n           \t\tCesium.Math.toDegrees(cartographic.longitude),\n           \t\tCesium.Math.toDegrees(cartographic.latitude),\n           \t\tcartographic.height),\n        \tbillboard: {\n        \t\timage: location4, // default: undefined\n        \t\twidth: 30, // default: undefined\n        \t\theight: 40, // default: undefined\n       }\n    });\n    viewer.entities.add(billboard);\n    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n\t}else{\n    \tviewer.screenSpaceEventHandler.removeInputAction(\n    \tCesium.ScreenSpaceEventType.LEFT_CLICK); //移除事件\n    \t}\n```","source":"_posts/20210831-Cesium-billboard贴地形表.md","raw":"---\ntitle: Cesium billboard贴地形表\ndate: 2021-08-31 21:46:22\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg\ntags:\n  - Vue\n  - Cesium\ncategories:\n  - Cesium\n---\n\n==============\n\n<!--more-->\n\n\n\n# 获取点击位置高程的方法，cartographic 中包含:\n - `longitude` 经度\n - `latitude` 维度\n - `height` 高程\n```javascript\nlet ray = viewer.camera.getPickRay(movement.position);\nlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\nlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n```\n# billboard贴地形表\n```javascript\nbillboard: {\n              image: locationMark, \n              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,\n              horizontalOrigin: Cesium.HorizontalOrigin.CENTER, // //相对于对象的原点（注意是原点的位置）的水平位置\n              verticalOrigin: Cesium.VerticalOrigin.BOTTOM //相对于对象的原点的垂直位置，BOTTOM时锚点在下，对象在上\n}\n```\n\n# 结合使用，点击添加图标\n```javascript\nif(flag){\n\tviewer.screenSpaceEventHandler.setInputAction(function (movement) {\n\t\tlet ray = viewer.camera.getPickRay(movement.position);\n    \tlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\n    \tlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n    \tlet billboard = new Cesium.Entity({\n    \t\tname: \"Draw-Handler-point\",\n        \tposition: Cesium.Cartesian3.fromDegrees(\n           \t\tCesium.Math.toDegrees(cartographic.longitude),\n           \t\tCesium.Math.toDegrees(cartographic.latitude),\n           \t\tcartographic.height),\n        \tbillboard: {\n        \t\timage: location4, // default: undefined\n        \t\twidth: 30, // default: undefined\n        \t\theight: 40, // default: undefined\n       }\n    });\n    viewer.entities.add(billboard);\n    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n\t}else{\n    \tviewer.screenSpaceEventHandler.removeInputAction(\n    \tCesium.ScreenSpaceEventType.LEFT_CLICK); //移除事件\n    \t}\n```","slug":"Cesium-billboard贴地形表","published":1,"updated":"2022-04-07T17:25:27.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x0y0008y4w1hpqz70qf","content":"<p>==============</p>\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"获取点击位置高程的方法，cartographic-中包含\"><a href=\"#获取点击位置高程的方法，cartographic-中包含\" class=\"headerlink\" title=\"获取点击位置高程的方法，cartographic 中包含:\"></a>获取点击位置高程的方法，cartographic 中包含:</h1><ul>\n<li><code>longitude</code> 经度</li>\n<li><code>latitude</code> 维度</li>\n<li><code>height</code> 高程<pre><code class=\"javascript\">let ray = viewer.camera.getPickRay(movement.position);\nlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\nlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n</code></pre>\n<h1 id=\"billboard贴地形表\"><a href=\"#billboard贴地形表\" class=\"headerlink\" title=\"billboard贴地形表\"></a>billboard贴地形表</h1><pre><code class=\"javascript\">billboard: &#123;\n           image: locationMark, \n           heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,\n           horizontalOrigin: Cesium.HorizontalOrigin.CENTER, // //相对于对象的原点（注意是原点的位置）的水平位置\n           verticalOrigin: Cesium.VerticalOrigin.BOTTOM //相对于对象的原点的垂直位置，BOTTOM时锚点在下，对象在上\n&#125;\n</code></pre>\n</li>\n</ul>\n<h1 id=\"结合使用，点击添加图标\"><a href=\"#结合使用，点击添加图标\" class=\"headerlink\" title=\"结合使用，点击添加图标\"></a>结合使用，点击添加图标</h1><pre><code class=\"javascript\">if(flag)&#123;\n    viewer.screenSpaceEventHandler.setInputAction(function (movement) &#123;\n        let ray = viewer.camera.getPickRay(movement.position);\n        let earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\n        let cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n        let billboard = new Cesium.Entity(&#123;\n            name: &quot;Draw-Handler-point&quot;,\n            position: Cesium.Cartesian3.fromDegrees(\n                   Cesium.Math.toDegrees(cartographic.longitude),\n                   Cesium.Math.toDegrees(cartographic.latitude),\n                   cartographic.height),\n            billboard: &#123;\n                image: location4, // default: undefined\n                width: 30, // default: undefined\n                height: 40, // default: undefined\n       &#125;\n    &#125;);\n    viewer.entities.add(billboard);\n    &#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n    &#125;else&#123;\n        viewer.screenSpaceEventHandler.removeInputAction(\n        Cesium.ScreenSpaceEventType.LEFT_CLICK); //移除事件\n        &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>==============</p>","more":"<h1 id=\"获取点击位置高程的方法，cartographic-中包含\"><a href=\"#获取点击位置高程的方法，cartographic-中包含\" class=\"headerlink\" title=\"获取点击位置高程的方法，cartographic 中包含:\"></a>获取点击位置高程的方法，cartographic 中包含:</h1><ul>\n<li><code>longitude</code> 经度</li>\n<li><code>latitude</code> 维度</li>\n<li><code>height</code> 高程<pre><code class=\"javascript\">let ray = viewer.camera.getPickRay(movement.position);\nlet earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\nlet cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n</code></pre>\n<h1 id=\"billboard贴地形表\"><a href=\"#billboard贴地形表\" class=\"headerlink\" title=\"billboard贴地形表\"></a>billboard贴地形表</h1><pre><code class=\"javascript\">billboard: &#123;\n           image: locationMark, \n           heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,\n           horizontalOrigin: Cesium.HorizontalOrigin.CENTER, // //相对于对象的原点（注意是原点的位置）的水平位置\n           verticalOrigin: Cesium.VerticalOrigin.BOTTOM //相对于对象的原点的垂直位置，BOTTOM时锚点在下，对象在上\n&#125;\n</code></pre>\n</li>\n</ul>\n<h1 id=\"结合使用，点击添加图标\"><a href=\"#结合使用，点击添加图标\" class=\"headerlink\" title=\"结合使用，点击添加图标\"></a>结合使用，点击添加图标</h1><pre><code class=\"javascript\">if(flag)&#123;\n    viewer.screenSpaceEventHandler.setInputAction(function (movement) &#123;\n        let ray = viewer.camera.getPickRay(movement.position);\n        let earthPosition = viewer.scene.globe.pick(ray, viewer.scene);\n        let cartographic = Cesium.Cartographic.fromCartesian(earthPosition);\n        let billboard = new Cesium.Entity(&#123;\n            name: &quot;Draw-Handler-point&quot;,\n            position: Cesium.Cartesian3.fromDegrees(\n                   Cesium.Math.toDegrees(cartographic.longitude),\n                   Cesium.Math.toDegrees(cartographic.latitude),\n                   cartographic.height),\n            billboard: &#123;\n                image: location4, // default: undefined\n                width: 30, // default: undefined\n                height: 40, // default: undefined\n       &#125;\n    &#125;);\n    viewer.entities.add(billboard);\n    &#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n    &#125;else&#123;\n        viewer.screenSpaceEventHandler.removeInputAction(\n        Cesium.ScreenSpaceEventType.LEFT_CLICK); //移除事件\n        &#125;\n</code></pre>"},{"title":"什么是计算机图形学？","date":"2021-09-26T07:35:15.000Z","reprint":true,"_content":"\n# 转：什么是计算机图形学？\n\n <!-- more -->\n\n原文地址：http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm\n\n**[什么是计算机图形学?](http://staff.ustc.edu.cn/~lgliu/Resources/SummerSchool/USTC-summer-school.html)**\n\n[刘利刚](http://staff.ustc.edu.cn/~lgliu)\n\n[中国科学技术大学](http://www.ustc.edu.cn/) [图形与几何计算实验室](http://gcl.ustc.edu.cn/)\n\nhttp://staff.ustc.edu.cn/~lgliu\n\n---\n\n【注】 由于时常有本科学生来向笔者询问计算机图形学是做什么的，为了使得学生能够快速了解计算机图形学，有利于他们在选择研究生方向做出适合自己的选择，特撰写此文。本文仅仅为笔者对计算机图形学浅薄的理解，不涉及对概念的定义，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下计算机图形学的内容及其应用，以帮助还未接触计算机图形学领域的学生来了解该学科方向。笔者对其中的有些内容的理解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。\n\n---\n\n**一、什么是计算机图形学？**\n\n什么是计算机图形学？计算机图形学(Computer Graphics，简称 CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。\n\n在“Wiki 百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。虽然通常认为 CG 是指三维图形的处理，事实上也包括了二维图形及图像的处理。\n\n狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程：计算机图形学是用计算机来画图像的学科，数字图象处理是把外界获得的图象用计算机进行处理的学科，计算机视觉是根据获取的图像来理解和识别其中的物体的三维信息及其他信息。\n\n注意，这些都是不确切的定义，实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别不是非常清晰，很多概念是相通的，而且随着研究的深入，这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing)。这是后话，此处不详述。\n\n**二、计算机图形学的主要内容**\n\n在学科开创之初，计算机图形学要解决的是如何在计算机中表示三维几何图形,以及如何利用计算机进行图形的生成、处理和显示的相关原理与算法，产生令人赏心悦目的真实感图像。这是狭义的计算机图形学的范畴。随着近 40 年的发展，计算机图形学的内容已经远远不止这些了。广义的计算机图形学的研究内容非常广泛，如图形硬件、图形标准、图形交互技术、光栅图形生成算法、曲线曲面造型、实体造型、真实感图形计算与显示算法，以及科学计算可视化、计算机动画、自然景物仿真、虚拟现实等。\n\n根据笔者的理解，计算机图形学主要包含四大部分的内容：建模(Modeling)、渲染(Rendering)、动画(Animation)和人机交互(Human–computer Interaction, HCI)。\n\n**1、 建模(Modeling)**\n\n要在计算机中表示一个三维物体，首先要有它的几何模型表达。因此，三维模型的建模是计算机图形学的基础，是其他内容的前提。表达一个几何物体可以是用数学上的样条函数或隐式函数来表达；也可以是用光滑曲面上的采样点及其连接关系所表达的三角网格来表达（即连续曲面的分片线性逼近），如下图所示。\n\n三维建模方法主要包含如下的一些方法：\n\nl 计算机辅助设计(CAD)中的主流方法是采用 NURBS（非均匀有理 B-样条、Bezier 曲线曲面）方法（已成为 CAD 工业领域的标准），这也是计算机辅助几何设计(CAGD)所研究的主要内容。此类表达方法有一些难点问题仍未解决，比如非正规情况下的曲面光滑拼合，复杂曲面表达等。这部分涉及的数学比较多，国内做这块的学者比较多些。\n\nl 细分曲面(Subdivision surface)造型方法，作为一种离散迭代的曲面构造方法，由于其构造过程朴素简单以及实现容易，是一个方兴未艾的研究热点。经过十多年的研究发展，细分曲面造型取得了较大的进展，包括奇异点处的连续性构造方法以及与 GPU 图形硬件相结合的曲面处理方法。\n\nl 利用软件的直接手工建模。现在主流的商业化的三维建模软件有 Autodesk 3D Max 和 Maya。其他还有面向特定领域的商业化软件，比如面向建筑模型造型的 Google Sketchup，面向 CAD/CAM/CAE 的 CATIA 和 AutoCAD，面向机械设计的 SolidWorks，面向造船行业的 Rhino 等。这些软件需要建模人员有较强的专业知识，而且需要一定时期的培训才能掌握，建模效率低而学习门槛高，不易于普及和让非专业用户使用。\n\nl 基于笔划或草图交互方式的三维建模方法。草图交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单，是最近几年研究的热点建模方法。其难点是根据具体的应用场合，如何正确地理解和识别用户的交互所表达的语义，构造出用户所希望的模型。\n\nl 基于语法及规则的过程式建模方法。特别适合具有重复特征和结构化的几何物体与场景，比如建筑、树木等。最近几年有较多的论文及较大的发展。\n\nl 基于图像或视频的建模方法。这是传统的计算机视觉所要解决的基本问题。在计算机图形学领域，这方面的发展也很迅速。有一些商业化软件或云服务(比如 Autodesk 的 123D)，已经能从若干张照片重建出所拍摄物体的三维模型。该方法的问题是需要物体本身已经存在，而且重建的三维模型的精度有限。\n\nl 基于扫描点云（深度图像如 Kinect、结构光扫描、激光扫描、LiDAR 扫描等）的建模(Reconstruction)方法。随着深度相机的出现及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维模型的工作在最近几年的 Siggraph(Asia)上能常见到。但是，单纯的重建方式存在精度低、稳定性差和运算量大等不足，远未能满足实际的需求。\n\nl 基于现有模型来合成建模的方法。随着三维模型的逐渐增多，可以利用现有的三维模型通过简单的操作，比如 cut and paste，或者分析及变形等手段，来拼接或合成新的三维模型。这种通过“学习”模型数据库的知识来进行建模的手段在近 3-5 年里研究得非常热门。从某方面来讲，就是“大数据时代”背景下计算机图形学领域中的一个具体的表现。\n\n除了上述的这些建模方法，还有其他的一些建模方法，在此不再一一列举。\n\n在对三维几何模型的构建过程中，还会涉及到很多需要处理的几何问题，比如数据去噪(denoising or smoothing)、补洞(repairing)、简化(simplification)、层次细节(level of detail)、参数化(parameterization)、变形(deformation or editing)、分割(segmentation)、形状分析及检索(shape analysis and retrieval)等。这些问题构成“数字几何处理”的主要研究内容。笔者自 2005 年起开设了多年的《数字几何处理》的研究生课程：\n\nhttp://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm\n\n虽然有上述所提到的这么多的三维建模方式，但是至今为止，仍没有适合一般家庭用户的轻松简单的建模工具。现有的电子设备（比如相机，手机等）能够帮助人们轻松获得图像和视频，但是，不是人人都有能力来构建三维几何模型。如何让大众能够像获取图像那样能够随时随地地获取或者构建三维模型，仍然是计算机图形学的任重道远的主要任务之一！今天，计算机图形学仍未进入“大数据时代”。只有让大众能够轻松进行三维建模，并上载分享他们所构建的模型数据，计算机图形学才可能进入大数据时代。\n\n另外，随着三维打印(3D printing)的新兴技术的逐渐普及，人们对三维模型的需求也日益增加。笔者个人认为，几何建模和三维打印的未来是共呼吸，同命运的：也只有当人人都能轻松建模时，三维打印才有可能走向千家万户。\n\n三维几何建模的任务仍然任重道远，大家仍需共同努力！\n\n![img](img/article/20210926-什么是计算机图形学/image002.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image004.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image006.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image008.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image010.jpg)\n\n**2、 渲染(Rendering)**\n\n有了三维模型或场景，怎么把这些三维几何模型画出来，产生令人赏心悦目的真实感图像？这就是传统的计算机图形学的核心任务，在计算机辅助设计，影视动漫以及各类可视化应用中都对图形渲染结果的高真实感提出了很高的要求。\n\n上个世纪 80-90 年代研究的比较多些，包含了大量的渲染模型，包括局部光照模型(Local Illumination Model)、光线跟踪算法(Ray Tracing)、辐射度(Radiosity)等，以及到后面的更为复杂、真实、快速的渲染技术，比如全局光照模型(Global Illumination Model)、Photo mapping、BTF、BRDF、以及基于 GPU 的渲染技术等。\n\n现在的渲染技术已经能够将各种物体，包括皮肤、树木、花草、水、烟雾、毛发等渲染得非常逼真。一些商业化软件（比如 Maya, Blender, Pov Ray 等）也提供了强大的真实感渲染功能，在计算机图形学研究论文中作图中要经常用到这些工具来渲染漂亮的展示图或结果图。\n\n然而，已知的渲染实现方法，仍无法实现复杂的视觉特效，离实时的高真实感渲染还有很大差距，比如完整地实现适于[电影](http://baike.baidu.com/view/2382.htm)渲染（高真实感、高分辨率）制作的 RenderMan 标准，以及其他各类基于物理真实感的实时渲染算法等。因此，如何充分利用 GPU 的计算特性，结合分布式的集群技术，从而来构造低功耗的渲染服务是发展趋势之一。\n\n![](img/article/20210926-什么是计算机图形学/image012.gif)\n\n![](img/article/20210926-什么是计算机图形学/image014.jpg)\n\n![](img/article/20210926-什么是计算机图形学/image016.jpg)\n\n![](img/article/20210926-什么是计算机图形学/image018.jpg)\n\n**3、 动画(Animation)**\n\n动画是采用连续播放静止图像的方法产生物体运动的效果。计算机动画借助于编程或动画制作软件生成一系列的景物画面，是计算机图形学的研究热点之一。研究方向包括：物理仿真(simulation)，人体动画，关节动画，运动动画，脚本动画，具有人的意识的虚拟角色的动画系统等。另外，高度物理真实感的动态模拟，包括对各种形变、水、气、云、烟雾、燃烧、爆炸、撕裂、老化等物理现象的真实模拟，也是动画领域的主要问题。这些技术是各类动态仿真应用的核心技术，可以极大地提高虚拟现实系统的沉浸感 （其中的本质是数值求解各种偏微分方程）。计算机动画的应用领域广泛，比如动画片制作，广告、 电影特技，训练模拟，游戏等。\n\n网上的一些 3D 动画的视频：\n\nLarva 虫虫: http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html\n\nThe Killer Bean: http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html\n\n爱与孝: http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html\n\n房地产动画广告宣传片: http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html\n\n**4、 人机交互(Human–Computer Interaction, HCI)**\n\n人机交互（Human-Computer Interaction, 简写 HCI）是指人与计算机之间以一定的交互方式或交互界面，来完成确定任务的人与计算机之间的信息交换过程。简单来讲，就是人如何通过一定的交互方式告诉计算机来完成他所希望完成的任务。\n\n计算机图形学的顶级会议 ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”的缩写，缩写中只包含了 Graphics，而忽略了 Interactive Techniques，在长时间没有得到计算机图形学研究的重视。最近，包括在 SIGGRAPH 会议上，以及人机交互的顶级会议 SIGCHI 上，陆续出现了许多新兴的人机交互技术及研究论文。大家逐渐重视起来。\n\n在早期（上个世纪 60-70 年代），只有以键盘输入的字符界面；到了 80 年代，以 WIMP(窗口、图符、菜单、鼠标)为基础的图形用户界面(GUI)逐渐成为当今计算机用户界面的主流。\n\n近年来，以用户为中心的系统设计思想，增进人机交互的自然性，提高人机交互的效率是用户界面的主要研究方向。陆续提出了多通道用户界面的思想，它包括语言、姿势输入、头部跟踪、视觉跟踪、立体显示、三维交互技术、感觉反馈及自然语言界面等。\n\n事实上，人体的表面本身就是人机界面。人体的任何部分（姿势，手势，语言，眼睛，肌肉电波，脑波等）都可以成为人机对话的通道。比如 2010 年微软出的 Kinect 就是一种无需任何操纵杆的基于体感的人机界面，用户本身就是控制器。Kinect 在微软的 Xbox 游戏上取得了极大的成功，之后在其他方面也得到了很多的应用。\n\n特别是到了今年（2013 年），人机交互设备有了巨大的发展，各种自然的交互手段层出不穷，极大地丰富了用户与机器交互的体验，方便了用户的操作，轻松表达了用户的交互意图。可以说，\n\n**我们正处在图形与交互技术极速发展的浪尖！**\n\n以下是最近几年（特别是今年）出现的一些值得关注的新兴的人机交互设备：\n\nl Microsoft Kinect：http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html\n\n1.  Kinect 由微软于 2010 年推出的对 XBOX360 体感外设，它不需要使用任何控制器，仅依靠相机捕捉三维空间中玩家的运动，同时它导入了即时动态捕捉、影像辨识、麦克风输入、语音辨识、社群互动等功能。Kinect 彻底颠覆了游戏的单一操作。使人机互动的理念更加彻底的展现出来。之后，基于 Kinect 的各种应用像雨后春笋般的冒出来，包括人机交互，手势识别，几何建模等。\n\n2.  在 2013 年 5 月 28 日的 Xbox One 发布会上，微软展示了新一代 Kinect 2.0，新 Kinect 能感知的语音、手势和玩家感觉信息，将给玩家带来前所未有的互动性体验：\n\nhttp://v.youku.com/v_show/id_XNTIyODU0NDky.html\n\nl Leap Motion：http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html\n\nLeap Motion 为放在键盘和显示器之间的小小金属棒，就能让任何一位用户通过简单的手势完成人机交互。Leap Motion 的响应惊人的准确，对各种自然而简洁的手势都能识别。不必站起来或者摆动手臂，Leap Motion 是简单而毫不费力的交互方式。我们在 4 月份就预订了一台，到现在还未到货，估计要到下个月到货。到货后我们会对其进行评测。\n\nl MYO：http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html\n\nMYO 是一款能在用户挥动并指向屏幕时测量各种肌肉产生的电活动来完成交互的腕带。MYO 超越 Leap Motion 的一点是，MYO 对用户的位置没有限制。尽管 MYO 只听令于身体的一个部分（手臂），但是其应用的场合还是很多的。期望未来会有更多的听令于身体的其他部分的交互设备。\n\nl Google Glass：http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html\n\nGoogle Glass 为 Google 公司在 2012 的 I/O 开发者大会上正式公布的，在看起来普普通通的眼镜上配置强大的计算机和显示器。这款设备小巧而不显眼，可以在任何时间地点使用，即用户想要专注于周围环境时不会碍事。不过对其未来的发展各有说法，让我们拭目以待。\n\nl 3D Printer：这个就不用笔者详细说了，这两年太火了。正如上面所提到的观点，笔者觉得 3D 打印的出现带给了我们从事计算机图形学研究的工作者许多的机会。挑战和机会并存！我们应该要抓住这次机会！\n\nl 3Doodler：http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html\n\n3Doodler 是玩具和机器人公司 Wobble Works 开发的全球首款“3D 打印笔”，可以帮助人们在半空中创造出三维结构的模型。今后人们可以在三维空间中来“画图”交流和表达想法了。\n\nl Apple iWatch：http://v.youku.com/v_show/id_XNTIwODk0MzM2.html\n\niWatch 由苹果公司推出的一款智能手表。现在仍是概念产品，面世时间未定。其界面看看视频就知道有多酷。但是其技术上的实现笔者也没有完全想通，呵呵。\n\n除了上述介绍的外，最近还有其他很多新的人机交互类的电子科技产品，比如透明手机，可折叠的屏幕，具有气味和触感反馈的头盔等，就不一一介绍了。\n\n由此可见，以前在科幻电影里出现的“神器”逐渐被实现，计算机图形学及相关技术在其中发挥了重要的作用。同时，这些设备的出现，也带给了计算机图形学领域更多的探索和机会。\n\n**5、 其他内容**\n\n上述所提到的只是计算机图形学的主要的四个内容。事实上，与计算机图形学相关的学科还有很多，以下仅介绍几个最为相关的研究方向：\n\nl 虚拟现实(Virtual Reality)：利用计算机图形产生器，位置跟踪器，多功能传感器和控制器等有效地模拟实际场景和情形，从而能够使观察者产生一种真实的身临其境的感觉。虚拟现实技术主要研究用计算机模拟（构造）三维图形空间，并使用户能够自然地与该空间进行交互。对三维图形处理技术的要求特别高。简单的虚拟现实系统早在 70 年代便被应用于军事领域，训练驾驶员。80 年代后随着计算机软硬件技术的提高，它也得到重视并迅速发展。它已在航空航天、医学、教育、艺术、建筑等领域得到初步的应用。\n\nl 可视化(Visualization)：利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。现已成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。上面提到的虚拟现实技术也是以图形图像的可视化技术为依托的。在现在的大数据时代的背景下，可视化的内容除了传统的科学可视化外，现在还有信息可视化，可视分析等方面。\n\nl 可视媒体计算与处理(Visual Media Processing)：几何数据，被认为是继声音、图像、视频之后的新一代数字媒体，是计算机图形学的研究重点。最近几年，计算机图形学与图像视频处理技术相结合的研究与技术日益增多。正如笔者在上面所提及的，图像和视频的大数据处理能带给计算机图形学很多处理手段上的更新。另一方面，随着而计算机图形学技术，恰可以与这些图像处理，视觉方法相交叉融合，来直接地生成风格化的画面，实现基于图像三维建模，以及直接基于视频和图像数据来生成动画序列。当计算机图形学正向地图像生成方法和计算机视觉中逆向地从图像中恢复各种信息方法相结合，可以带来无可限量的想象空间，构造出很多视觉特效来，最终用于增强现实、数字地图、虚拟博物馆展示等多种应用中去。因此，在很多方面，计算机图形学与图像处理、视频处理、多媒体处理、计算机视觉等学科逐渐融合在一起，有成为一个更大的学科的趋势。\n\nl 医学图像处理(Medical Imaging)：随着医学成像技术的发展与进步，图像处理在医学研究与临床医学中的应用越来越广泛。与一般意义上的图像处理比较，医学图像处理有其特殊性和不同的侧重点。医学图像处理由生物医学成像(X 射线、CT、MRI)和生物医学图像处理两部分组成，在生命科学研究、医学诊断、临床治疗等方面起着重要的作用。医学图像分析中涉及的两个最为重要的内容为图像分割与图像配准。\n\nl 计算机艺术(Computational Arts)：计算机图形学的发展也提供给了艺术家发挥和实现想象的丰富的技术手段。计算机艺术的发展速度远远超出了人们的想象，在代表计算机图形研究最高水平的历届 SIGGRAPH 年会上，精彩的计算机艺术作品层出不穷。在计算机图形学领域，还有几个关于计算艺术方面的会议，包括非真实性图形学(Non-Photorealistic Graphics)和 Computational Aesthetics(计算美学)等。吸引了计算机工作者、艺术家、建筑师、设计师等方面的人员在一起，通过头脑风暴和交流讨论的方式进行一些有创意的技术研究。\n\n**三、 学习计算机图形学需要哪些基础？**\n\n计算机图形学是一门与很多学科都交叉的学科方向。因此，要学好计算机图形学和做好计算机图形学方面的研究，除了计算机图形学的基础知识以外，你还需要有其他方面的一些知识。当然你懂得越多当然会越好。\n\n**1、 数学**\n\n计算机图形学进入我国大概在上个世纪 70 年代末和 80 年代初，那时国内还没有计算机学科。于是，开始学习和研究计算机图形学的大部分都是搞数学的一些学者和教授。由此可见，计算机图形学是需要数学知识较多的一门计算机应用技术学科，在我国也是应用数学的一个重要分支（国内的很多高校和科研院所的数学专业都有计算机图形学方向）。\n\n计算机图形学里面用到的数学比较多，列举一些常用的，包括：微积分、线性代数、矩阵计算、微分几何、数值计算和分析、计算方法、偏微分方程、微分方程数值解、最优化、概率、统计、计算几何等。\n\n计算机图形学领域的一位优秀学者 Greg Turk 教授在 1997 年曾写过一篇“计算机图形学中的数学”(Mathematics for Computer Graphics)的帖子，详细可见：\n\nhttp://www.cc.gatech.edu/~turk/math_gr.html\n\n其中文翻译版本可见：\n\nhttp://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm\n\n笔者在多年从事计算机图形学研究中对数学的体会是：“数学不是没有用，而是不够用！”。对数学的学习和应用将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解其中的数学思想和数学方法。\n\n另一方面，想成为一名计算机图形学的研究者也不必精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？以上提到的常用的数学课程你不必都要熟悉，许多研究工作者从不需要考虑其中提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！\n\n总之，关于计算机图形学与数学的关系，归纳起来就是以下几个原则：\n\nl 计算机图形学的研究需要用到较多的数学知识，有较好数学功底的学生从事计算机图形学有一定优势；\n\nl 即使没有学太多的数学也不要紧。数学的知识不需要都学会了再去做问题，在解决问题的过程中去学习数学是最快的学习方法。即，研究过程中若遇到什么数学知识再去学相关的知识，学习起来会更有兴趣，掌握起来会更快更扎实；\n\nl 学习数学要结合图形，即“数形结合”，需要有图形的想象能力；数学公式不重要，是“纸老虎”，重要的是背后的思想及其所表达的概念，公式只是它们的一个抽象表达；\n\nl 活到老，学到老。要不断学习新的知识和技术，使自己不断进步和增长功力，才是王道。\n\n**2、 编程**\n\n在计算机图形学中，大部分的想法都要通过实际例子来验证的，再好的理论也要拿实际例子来得到验证和应用。因此，利用编程语言来实现想法或算法是必须要有的能力。C/C++是计算机图形学最常用的编程语言。\n\n笔者要求学生必须掌握 C++编程语言和面向对象编程思想，这是大家通用的“语言”。网上的大部分的资源、类库、算法代码基本上都是 C++写的，因此，你若需要利用这些资源，必须掌握甚至精通 C++语言。\n\n关于计算机图形学所需要的编程能力的几点看法：\n\nl 从事计算机图形学和图像处理的研究需要有较强的编程能力，要对编程有极大的兴趣和热情；\n\nl 如果你对编程比较“感冒”或“厌恶”，则建议你不要选择计算机图形学方向；\n\nl 不太会编程不要紧，任何人都是从不会到会的！只要你对编程有兴趣，觉得编程“好玩”，您完全可以在很短的时间内极大地提高您的编程水平。笔者在长期的教学实验和科研过程中，摸索和发展出一套有效的方法，能够在最短的时间内，帮助学生（包括数学专业的学生）快速提高编程的能力。\n\n**3、 其他**\n\nl 英语基础要好，因为需要大量阅读英文文献和进行英文论文的写作；英文的听说能力也要好些，因为要跟国际学者交流讨论；\n\nl 计算机图形学中的很多算法是真实物理世界的模拟，因此，如果你要进行基于物理的建模和仿真，一些物理知识和理论也需要的，比如力学（动力学，运动学，流体力学）和光学等；\n\nl 其他学科的知识，根据具体研究的需要去学习即可，不必刻意去提前学多少。\n\n**4、 计算机图形学的教材**\n\n上面列举的只是在你从事计算机图形学的学习和研究中可能要用到的东西，不必所有的都学会才能开始计算机图形学的学习和研究。一门知识点不懂不要紧，重要的是要能尽快学习新知识的能力和速度！事实上，最好的学习方法就是在使用中学习。因此，计算机图形学的学习和研究提供了你学习其他相关知识的好的过程。\n\n现在市面上的计算机图形学的教材有很多，但是很多教材的内容仅仅是计算机图形学的基本知识，知识点也比较陈旧。不能指望通过一本或几本教材就能学会计算机图形学。计算机图形学的内容远比教材中或你想象中的内容多得多。正如笔者上面所述，计算机图形学作为一门技术科学，特别是在当前的互联网、移动互联网、大数据时代及第三次工业革命的时代背景下，最近几年的发展日新月异！务必要通过跟着老师做相关研究来了解计算机图形学最新的发展和趋势。除了阅读最新的最新的科研论文外，还需要不断关注信息科技及电子科技的一些前沿发展。要相信，计算机图形学是好玩的，是有用的，更是有未来的！充满热情和激情，才能做好计算机图形学方面的研究。\n\n**四、SIGGRAPH 简介**\n\n说到计算机图形学，不能不提 SIGGRAPH。\n\nACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”（[美国计算机协会](http://zh.wikipedia.org/wiki/美国计算机协会)计算机图形专业组）的缩写，成立于 1967 年，致力于推广和发展计算机绘图和动画制作的软硬件技术。从 1974 年开始，ACM SIGGRAPH 每年都会举办一次年会（也称为 SIGGRAPH），至今年已经举办了 40 次。SIGGRAPH 是计算机图形学顶级年度会议，代表着世界级水平的研究，能在 SIGGRAPH 上发表论文是许多从事计算机图形学研究的工作者的梦想。\n\nSIGGRAPH 每年 7 月底或 8 月初在美国召开（2011 年在加拿大温哥华召开，是 SIGGRAPH 首次在美国以外的城市举行）。事实上，SIGGRAPH 是世界上影响最广、规模最大，同时也是最权威的一个集科学、艺术、商业于一身的 CG 展示、学术研讨会，参会人数众多，一般有 2--4 万人。绝大部分计算机图技术软硬件厂商每年都会将最新研究成果拿到 SIGGRAPH 年会上发布，大部分游戏的[电脑动画](http://baike.baidu.com/view/217213.htm)创作者也将他们本年度最杰出的艺术作品集中在 SIGGRAPH 上展示。因此，SIGGRAPH 在图形图像技术，计算机软硬件以及 CG 等方面都有着相当的影响力。\n\n从 2008 年开始，Siggraph 来到亚洲，每年冬天（11 或 12 月）在亚洲的一个城市（2008，新加坡；2009，日本[横滨](http://baike.baidu.com/view/72581.htm)；2010，韩国[首尔](http://baike.baidu.com/view/4005.htm)；2011，中国香港；2012，新加坡）召开，称为 SIGGRAPH Asia。今年的 Siggraph Asia 将在 2013 年 11 月 19-22 号于中国香港召开。\n\n与 SIGGRAPH 一样，发表者 SIGGRAPH Asia 上的研究论文也代表着计算机图形学领域的最前沿和最高水准，所有研究论文都发表在 ACM Transactions on Graphics 期刊上，这是计算机图形学领域唯一的一个 Top (I 区)的学术期刊。可以形象地将 SIGGRAPH 和 SIGGRAPH Asia 分别比喻为计算机图形学领域的“夏季奥运会”和“冬季奥运会”。\n\n在 SIGGRAPH 会议上，除了研究论文外，还有很多其他内容，比如课程、短文、海报、CG 企业展示、电子剧场、动画节、新型科技展示、艺术画廊、教育等，比你想象得要多得多。很多活动都是并行的，因此你需要每天提前计划好所参加的活动。视觉中国网站的“Siggraph 2007 会议报道”有详尽的关于 Siggraph 2007 年的报道：\n\nhttp://static.chinavisual.com/storage/topics/39942/index.shtml\n\n虽然这是 6 年前的 Siggraph 介绍，但上述链接的内容仍然是对 SIGGRAPH 比较全面的介绍。其中有很多视频和材料，详细介绍了 Siggraph 盛会的情况，而且有对计算机图形学的历史发展的介绍。建议详细查看。\n\n**五、其他问题**\n\n1、 如何选择适合自己的工作（研究方向）？\n\nA: 就两点：兴趣 + 擅长！\n\n兴趣是第一位的，是否擅长需要尝试和不断学习成长！将学会将自己的天赋发挥到极致！\n\n2、 自己是否适合学习和从事计算机图形学的研究？\n\nA: 看看自己是否满足以下两个条件：\n\n1.  对计算机图形学或图像处理具有强烈的兴趣和激情；\n\n2.  喜欢算法设计和编程。\n\n若上述两个条件都满足（觉得好玩！），则可以尝试选择计算机图形学作为自己的研究方向。\n\n3、 从事研究工作需要哪些品质？\n\nA: 激情、好奇心、努力！\n\n4、 为何选择从事研究工作？\n\nA: http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar\n\n5、 如何在研究生期间取得成功？\n\nA: http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar\n\n**六、更多参考材料**\n\nl 有关更多地了解计算机图形的知识和内容，可搜索并参考 Internet 上的丰富的资源介绍，比如[百度百科](http://baike.baidu.com/view/13769.htm)，[维基百科](http://zh.wikipedia.org/wiki/计算机图形学)等。本文的写作过程中也参考了网上的许多资源。\n\nl 国外和国内有很多有关《计算机图形学》的课程网站，可以通过查看相关视频和课件更多地了解计算机图形学的内容。\n\nl 国内外有很多从事计算机图形学研究的教授学者的网站，会列出他们所做的有关计算机图形学方面的研究，可以更为深入了解计算机图形学领域所研究的东西。\n\nl 与计算机其他学科一样，每年都有计算机图形学方面的很多会议。这些会议会有该领域的最新进展和研究工作，是了解计算机图形学发展及趋势的重要手段。在计算机图形学方面，可以通过以下链接来获得各个会议的信息http://kesen.realtimerendering.com/ 建议加该链接为你的浏览器的标签。\n\nl Internet 上经常会有计算机图形学相关的科技信息，要有意识经常关注，随时了解该学科方向的动态、发展和未来。\n\nl 计算机图形学及相关学科在近些年来得到迅速的发展，特别是 2013 年出现的各种交互人机交互技术的出现，我们正处在技术极速发展的浪尖！计算机图形学前景诱人，形势逼人。相对于美国等西方国家，我国的计算机图形学相关产业还相对落后，但这正是留给我们这代人的机会！相信通过我们的努力，是可以逐渐缩短差距的，也带来了巨大的挑战和机会。\n\nl 最后，要相信，计算机图形学是很好玩的，是有用的，更是有未来的。“相信是成功的开始”。祝各位能够感受计算机图形的美妙，能够在计算机图形学的海洋中享受快乐和成功！J\n\n祝您健康、快乐、成功！\n\n刘利刚\n\n中国科学技术大学图形与几何计算实验室([http://gcl.ustc.edu.cn](http://gcl.ustc.edu.cn/))\n\n个人主页：http://staff.ustc.edu.cn/~lgliu\n\n电子邮箱：[lgliu@ustc.edu.cn](mailto:lgliu@ustc.edu.cn)\n\n2013 年 8 月 8 日\n\n---\n\n【2016 年 9 月 9 日添加】刘永进. 中国计算机图形学研究进展[J]. 科技导报, 2016, 34(14): 76-85. [[link](http://www.kjdb.org/CN/10.3981/j.issn.1000-7857.2016.14.009)] [[PDF, 5.1M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201609_ProgressCG-China.pdf)]\n\n【2018 年 8 月 16 日添加】AMiner. 计算机图形学研究报告. [[link](https://www.aminer.cn/)] [[PDF, 3.5M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey.pdf)][[PPT, 2.3M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey-PPT.pdf)]\n\n【2020 年 7 月 14 日添加】GAMES：计算机图形学的在线学习和交流平台，其中有大量的课程、报告（均有 PPT 和录频等）。[[link](http://games-cn.org/)]\n\n计算机图形学基础课程推荐（含课程录频和 PPT 等）：\n\n- GAMES 101（闫令琪）[[link](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)]\n- 中国科学技术大学《计算机图形学》本科课程-2020 年（刘利刚）[[link](http://staff.ustc.edu.cn/~lgliu/Courses/ComputerGraphics_2020_spring-summer/default.htm)]\n\n---\n\n版权所有@刘利刚\n","source":"_posts/20210926-什么是计算机图形学.md","raw":"---\ntitle: 什么是计算机图形学？\ndate: 2021-09-26 15:35:15\nreprint: true\ntags:\ncategories:\n---\n\n# 转：什么是计算机图形学？\n\n <!-- more -->\n\n原文地址：http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm\n\n**[什么是计算机图形学?](http://staff.ustc.edu.cn/~lgliu/Resources/SummerSchool/USTC-summer-school.html)**\n\n[刘利刚](http://staff.ustc.edu.cn/~lgliu)\n\n[中国科学技术大学](http://www.ustc.edu.cn/) [图形与几何计算实验室](http://gcl.ustc.edu.cn/)\n\nhttp://staff.ustc.edu.cn/~lgliu\n\n---\n\n【注】 由于时常有本科学生来向笔者询问计算机图形学是做什么的，为了使得学生能够快速了解计算机图形学，有利于他们在选择研究生方向做出适合自己的选择，特撰写此文。本文仅仅为笔者对计算机图形学浅薄的理解，不涉及对概念的定义，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下计算机图形学的内容及其应用，以帮助还未接触计算机图形学领域的学生来了解该学科方向。笔者对其中的有些内容的理解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。\n\n---\n\n**一、什么是计算机图形学？**\n\n什么是计算机图形学？计算机图形学(Computer Graphics，简称 CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。\n\n在“Wiki 百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。虽然通常认为 CG 是指三维图形的处理，事实上也包括了二维图形及图像的处理。\n\n狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程：计算机图形学是用计算机来画图像的学科，数字图象处理是把外界获得的图象用计算机进行处理的学科，计算机视觉是根据获取的图像来理解和识别其中的物体的三维信息及其他信息。\n\n注意，这些都是不确切的定义，实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别不是非常清晰，很多概念是相通的，而且随着研究的深入，这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing)。这是后话，此处不详述。\n\n**二、计算机图形学的主要内容**\n\n在学科开创之初，计算机图形学要解决的是如何在计算机中表示三维几何图形,以及如何利用计算机进行图形的生成、处理和显示的相关原理与算法，产生令人赏心悦目的真实感图像。这是狭义的计算机图形学的范畴。随着近 40 年的发展，计算机图形学的内容已经远远不止这些了。广义的计算机图形学的研究内容非常广泛，如图形硬件、图形标准、图形交互技术、光栅图形生成算法、曲线曲面造型、实体造型、真实感图形计算与显示算法，以及科学计算可视化、计算机动画、自然景物仿真、虚拟现实等。\n\n根据笔者的理解，计算机图形学主要包含四大部分的内容：建模(Modeling)、渲染(Rendering)、动画(Animation)和人机交互(Human–computer Interaction, HCI)。\n\n**1、 建模(Modeling)**\n\n要在计算机中表示一个三维物体，首先要有它的几何模型表达。因此，三维模型的建模是计算机图形学的基础，是其他内容的前提。表达一个几何物体可以是用数学上的样条函数或隐式函数来表达；也可以是用光滑曲面上的采样点及其连接关系所表达的三角网格来表达（即连续曲面的分片线性逼近），如下图所示。\n\n三维建模方法主要包含如下的一些方法：\n\nl 计算机辅助设计(CAD)中的主流方法是采用 NURBS（非均匀有理 B-样条、Bezier 曲线曲面）方法（已成为 CAD 工业领域的标准），这也是计算机辅助几何设计(CAGD)所研究的主要内容。此类表达方法有一些难点问题仍未解决，比如非正规情况下的曲面光滑拼合，复杂曲面表达等。这部分涉及的数学比较多，国内做这块的学者比较多些。\n\nl 细分曲面(Subdivision surface)造型方法，作为一种离散迭代的曲面构造方法，由于其构造过程朴素简单以及实现容易，是一个方兴未艾的研究热点。经过十多年的研究发展，细分曲面造型取得了较大的进展，包括奇异点处的连续性构造方法以及与 GPU 图形硬件相结合的曲面处理方法。\n\nl 利用软件的直接手工建模。现在主流的商业化的三维建模软件有 Autodesk 3D Max 和 Maya。其他还有面向特定领域的商业化软件，比如面向建筑模型造型的 Google Sketchup，面向 CAD/CAM/CAE 的 CATIA 和 AutoCAD，面向机械设计的 SolidWorks，面向造船行业的 Rhino 等。这些软件需要建模人员有较强的专业知识，而且需要一定时期的培训才能掌握，建模效率低而学习门槛高，不易于普及和让非专业用户使用。\n\nl 基于笔划或草图交互方式的三维建模方法。草图交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单，是最近几年研究的热点建模方法。其难点是根据具体的应用场合，如何正确地理解和识别用户的交互所表达的语义，构造出用户所希望的模型。\n\nl 基于语法及规则的过程式建模方法。特别适合具有重复特征和结构化的几何物体与场景，比如建筑、树木等。最近几年有较多的论文及较大的发展。\n\nl 基于图像或视频的建模方法。这是传统的计算机视觉所要解决的基本问题。在计算机图形学领域，这方面的发展也很迅速。有一些商业化软件或云服务(比如 Autodesk 的 123D)，已经能从若干张照片重建出所拍摄物体的三维模型。该方法的问题是需要物体本身已经存在，而且重建的三维模型的精度有限。\n\nl 基于扫描点云（深度图像如 Kinect、结构光扫描、激光扫描、LiDAR 扫描等）的建模(Reconstruction)方法。随着深度相机的出现及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维模型的工作在最近几年的 Siggraph(Asia)上能常见到。但是，单纯的重建方式存在精度低、稳定性差和运算量大等不足，远未能满足实际的需求。\n\nl 基于现有模型来合成建模的方法。随着三维模型的逐渐增多，可以利用现有的三维模型通过简单的操作，比如 cut and paste，或者分析及变形等手段，来拼接或合成新的三维模型。这种通过“学习”模型数据库的知识来进行建模的手段在近 3-5 年里研究得非常热门。从某方面来讲，就是“大数据时代”背景下计算机图形学领域中的一个具体的表现。\n\n除了上述的这些建模方法，还有其他的一些建模方法，在此不再一一列举。\n\n在对三维几何模型的构建过程中，还会涉及到很多需要处理的几何问题，比如数据去噪(denoising or smoothing)、补洞(repairing)、简化(simplification)、层次细节(level of detail)、参数化(parameterization)、变形(deformation or editing)、分割(segmentation)、形状分析及检索(shape analysis and retrieval)等。这些问题构成“数字几何处理”的主要研究内容。笔者自 2005 年起开设了多年的《数字几何处理》的研究生课程：\n\nhttp://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm\n\n虽然有上述所提到的这么多的三维建模方式，但是至今为止，仍没有适合一般家庭用户的轻松简单的建模工具。现有的电子设备（比如相机，手机等）能够帮助人们轻松获得图像和视频，但是，不是人人都有能力来构建三维几何模型。如何让大众能够像获取图像那样能够随时随地地获取或者构建三维模型，仍然是计算机图形学的任重道远的主要任务之一！今天，计算机图形学仍未进入“大数据时代”。只有让大众能够轻松进行三维建模，并上载分享他们所构建的模型数据，计算机图形学才可能进入大数据时代。\n\n另外，随着三维打印(3D printing)的新兴技术的逐渐普及，人们对三维模型的需求也日益增加。笔者个人认为，几何建模和三维打印的未来是共呼吸，同命运的：也只有当人人都能轻松建模时，三维打印才有可能走向千家万户。\n\n三维几何建模的任务仍然任重道远，大家仍需共同努力！\n\n![img](img/article/20210926-什么是计算机图形学/image002.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image004.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image006.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image008.jpg)\n\n![img](img/article/20210926-什么是计算机图形学/image010.jpg)\n\n**2、 渲染(Rendering)**\n\n有了三维模型或场景，怎么把这些三维几何模型画出来，产生令人赏心悦目的真实感图像？这就是传统的计算机图形学的核心任务，在计算机辅助设计，影视动漫以及各类可视化应用中都对图形渲染结果的高真实感提出了很高的要求。\n\n上个世纪 80-90 年代研究的比较多些，包含了大量的渲染模型，包括局部光照模型(Local Illumination Model)、光线跟踪算法(Ray Tracing)、辐射度(Radiosity)等，以及到后面的更为复杂、真实、快速的渲染技术，比如全局光照模型(Global Illumination Model)、Photo mapping、BTF、BRDF、以及基于 GPU 的渲染技术等。\n\n现在的渲染技术已经能够将各种物体，包括皮肤、树木、花草、水、烟雾、毛发等渲染得非常逼真。一些商业化软件（比如 Maya, Blender, Pov Ray 等）也提供了强大的真实感渲染功能，在计算机图形学研究论文中作图中要经常用到这些工具来渲染漂亮的展示图或结果图。\n\n然而，已知的渲染实现方法，仍无法实现复杂的视觉特效，离实时的高真实感渲染还有很大差距，比如完整地实现适于[电影](http://baike.baidu.com/view/2382.htm)渲染（高真实感、高分辨率）制作的 RenderMan 标准，以及其他各类基于物理真实感的实时渲染算法等。因此，如何充分利用 GPU 的计算特性，结合分布式的集群技术，从而来构造低功耗的渲染服务是发展趋势之一。\n\n![](img/article/20210926-什么是计算机图形学/image012.gif)\n\n![](img/article/20210926-什么是计算机图形学/image014.jpg)\n\n![](img/article/20210926-什么是计算机图形学/image016.jpg)\n\n![](img/article/20210926-什么是计算机图形学/image018.jpg)\n\n**3、 动画(Animation)**\n\n动画是采用连续播放静止图像的方法产生物体运动的效果。计算机动画借助于编程或动画制作软件生成一系列的景物画面，是计算机图形学的研究热点之一。研究方向包括：物理仿真(simulation)，人体动画，关节动画，运动动画，脚本动画，具有人的意识的虚拟角色的动画系统等。另外，高度物理真实感的动态模拟，包括对各种形变、水、气、云、烟雾、燃烧、爆炸、撕裂、老化等物理现象的真实模拟，也是动画领域的主要问题。这些技术是各类动态仿真应用的核心技术，可以极大地提高虚拟现实系统的沉浸感 （其中的本质是数值求解各种偏微分方程）。计算机动画的应用领域广泛，比如动画片制作，广告、 电影特技，训练模拟，游戏等。\n\n网上的一些 3D 动画的视频：\n\nLarva 虫虫: http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html\n\nThe Killer Bean: http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html\n\n爱与孝: http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html\n\n房地产动画广告宣传片: http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html\n\n**4、 人机交互(Human–Computer Interaction, HCI)**\n\n人机交互（Human-Computer Interaction, 简写 HCI）是指人与计算机之间以一定的交互方式或交互界面，来完成确定任务的人与计算机之间的信息交换过程。简单来讲，就是人如何通过一定的交互方式告诉计算机来完成他所希望完成的任务。\n\n计算机图形学的顶级会议 ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”的缩写，缩写中只包含了 Graphics，而忽略了 Interactive Techniques，在长时间没有得到计算机图形学研究的重视。最近，包括在 SIGGRAPH 会议上，以及人机交互的顶级会议 SIGCHI 上，陆续出现了许多新兴的人机交互技术及研究论文。大家逐渐重视起来。\n\n在早期（上个世纪 60-70 年代），只有以键盘输入的字符界面；到了 80 年代，以 WIMP(窗口、图符、菜单、鼠标)为基础的图形用户界面(GUI)逐渐成为当今计算机用户界面的主流。\n\n近年来，以用户为中心的系统设计思想，增进人机交互的自然性，提高人机交互的效率是用户界面的主要研究方向。陆续提出了多通道用户界面的思想，它包括语言、姿势输入、头部跟踪、视觉跟踪、立体显示、三维交互技术、感觉反馈及自然语言界面等。\n\n事实上，人体的表面本身就是人机界面。人体的任何部分（姿势，手势，语言，眼睛，肌肉电波，脑波等）都可以成为人机对话的通道。比如 2010 年微软出的 Kinect 就是一种无需任何操纵杆的基于体感的人机界面，用户本身就是控制器。Kinect 在微软的 Xbox 游戏上取得了极大的成功，之后在其他方面也得到了很多的应用。\n\n特别是到了今年（2013 年），人机交互设备有了巨大的发展，各种自然的交互手段层出不穷，极大地丰富了用户与机器交互的体验，方便了用户的操作，轻松表达了用户的交互意图。可以说，\n\n**我们正处在图形与交互技术极速发展的浪尖！**\n\n以下是最近几年（特别是今年）出现的一些值得关注的新兴的人机交互设备：\n\nl Microsoft Kinect：http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html\n\n1.  Kinect 由微软于 2010 年推出的对 XBOX360 体感外设，它不需要使用任何控制器，仅依靠相机捕捉三维空间中玩家的运动，同时它导入了即时动态捕捉、影像辨识、麦克风输入、语音辨识、社群互动等功能。Kinect 彻底颠覆了游戏的单一操作。使人机互动的理念更加彻底的展现出来。之后，基于 Kinect 的各种应用像雨后春笋般的冒出来，包括人机交互，手势识别，几何建模等。\n\n2.  在 2013 年 5 月 28 日的 Xbox One 发布会上，微软展示了新一代 Kinect 2.0，新 Kinect 能感知的语音、手势和玩家感觉信息，将给玩家带来前所未有的互动性体验：\n\nhttp://v.youku.com/v_show/id_XNTIyODU0NDky.html\n\nl Leap Motion：http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html\n\nLeap Motion 为放在键盘和显示器之间的小小金属棒，就能让任何一位用户通过简单的手势完成人机交互。Leap Motion 的响应惊人的准确，对各种自然而简洁的手势都能识别。不必站起来或者摆动手臂，Leap Motion 是简单而毫不费力的交互方式。我们在 4 月份就预订了一台，到现在还未到货，估计要到下个月到货。到货后我们会对其进行评测。\n\nl MYO：http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html\n\nMYO 是一款能在用户挥动并指向屏幕时测量各种肌肉产生的电活动来完成交互的腕带。MYO 超越 Leap Motion 的一点是，MYO 对用户的位置没有限制。尽管 MYO 只听令于身体的一个部分（手臂），但是其应用的场合还是很多的。期望未来会有更多的听令于身体的其他部分的交互设备。\n\nl Google Glass：http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html\n\nGoogle Glass 为 Google 公司在 2012 的 I/O 开发者大会上正式公布的，在看起来普普通通的眼镜上配置强大的计算机和显示器。这款设备小巧而不显眼，可以在任何时间地点使用，即用户想要专注于周围环境时不会碍事。不过对其未来的发展各有说法，让我们拭目以待。\n\nl 3D Printer：这个就不用笔者详细说了，这两年太火了。正如上面所提到的观点，笔者觉得 3D 打印的出现带给了我们从事计算机图形学研究的工作者许多的机会。挑战和机会并存！我们应该要抓住这次机会！\n\nl 3Doodler：http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html\n\n3Doodler 是玩具和机器人公司 Wobble Works 开发的全球首款“3D 打印笔”，可以帮助人们在半空中创造出三维结构的模型。今后人们可以在三维空间中来“画图”交流和表达想法了。\n\nl Apple iWatch：http://v.youku.com/v_show/id_XNTIwODk0MzM2.html\n\niWatch 由苹果公司推出的一款智能手表。现在仍是概念产品，面世时间未定。其界面看看视频就知道有多酷。但是其技术上的实现笔者也没有完全想通，呵呵。\n\n除了上述介绍的外，最近还有其他很多新的人机交互类的电子科技产品，比如透明手机，可折叠的屏幕，具有气味和触感反馈的头盔等，就不一一介绍了。\n\n由此可见，以前在科幻电影里出现的“神器”逐渐被实现，计算机图形学及相关技术在其中发挥了重要的作用。同时，这些设备的出现，也带给了计算机图形学领域更多的探索和机会。\n\n**5、 其他内容**\n\n上述所提到的只是计算机图形学的主要的四个内容。事实上，与计算机图形学相关的学科还有很多，以下仅介绍几个最为相关的研究方向：\n\nl 虚拟现实(Virtual Reality)：利用计算机图形产生器，位置跟踪器，多功能传感器和控制器等有效地模拟实际场景和情形，从而能够使观察者产生一种真实的身临其境的感觉。虚拟现实技术主要研究用计算机模拟（构造）三维图形空间，并使用户能够自然地与该空间进行交互。对三维图形处理技术的要求特别高。简单的虚拟现实系统早在 70 年代便被应用于军事领域，训练驾驶员。80 年代后随着计算机软硬件技术的提高，它也得到重视并迅速发展。它已在航空航天、医学、教育、艺术、建筑等领域得到初步的应用。\n\nl 可视化(Visualization)：利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。现已成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。上面提到的虚拟现实技术也是以图形图像的可视化技术为依托的。在现在的大数据时代的背景下，可视化的内容除了传统的科学可视化外，现在还有信息可视化，可视分析等方面。\n\nl 可视媒体计算与处理(Visual Media Processing)：几何数据，被认为是继声音、图像、视频之后的新一代数字媒体，是计算机图形学的研究重点。最近几年，计算机图形学与图像视频处理技术相结合的研究与技术日益增多。正如笔者在上面所提及的，图像和视频的大数据处理能带给计算机图形学很多处理手段上的更新。另一方面，随着而计算机图形学技术，恰可以与这些图像处理，视觉方法相交叉融合，来直接地生成风格化的画面，实现基于图像三维建模，以及直接基于视频和图像数据来生成动画序列。当计算机图形学正向地图像生成方法和计算机视觉中逆向地从图像中恢复各种信息方法相结合，可以带来无可限量的想象空间，构造出很多视觉特效来，最终用于增强现实、数字地图、虚拟博物馆展示等多种应用中去。因此，在很多方面，计算机图形学与图像处理、视频处理、多媒体处理、计算机视觉等学科逐渐融合在一起，有成为一个更大的学科的趋势。\n\nl 医学图像处理(Medical Imaging)：随着医学成像技术的发展与进步，图像处理在医学研究与临床医学中的应用越来越广泛。与一般意义上的图像处理比较，医学图像处理有其特殊性和不同的侧重点。医学图像处理由生物医学成像(X 射线、CT、MRI)和生物医学图像处理两部分组成，在生命科学研究、医学诊断、临床治疗等方面起着重要的作用。医学图像分析中涉及的两个最为重要的内容为图像分割与图像配准。\n\nl 计算机艺术(Computational Arts)：计算机图形学的发展也提供给了艺术家发挥和实现想象的丰富的技术手段。计算机艺术的发展速度远远超出了人们的想象，在代表计算机图形研究最高水平的历届 SIGGRAPH 年会上，精彩的计算机艺术作品层出不穷。在计算机图形学领域，还有几个关于计算艺术方面的会议，包括非真实性图形学(Non-Photorealistic Graphics)和 Computational Aesthetics(计算美学)等。吸引了计算机工作者、艺术家、建筑师、设计师等方面的人员在一起，通过头脑风暴和交流讨论的方式进行一些有创意的技术研究。\n\n**三、 学习计算机图形学需要哪些基础？**\n\n计算机图形学是一门与很多学科都交叉的学科方向。因此，要学好计算机图形学和做好计算机图形学方面的研究，除了计算机图形学的基础知识以外，你还需要有其他方面的一些知识。当然你懂得越多当然会越好。\n\n**1、 数学**\n\n计算机图形学进入我国大概在上个世纪 70 年代末和 80 年代初，那时国内还没有计算机学科。于是，开始学习和研究计算机图形学的大部分都是搞数学的一些学者和教授。由此可见，计算机图形学是需要数学知识较多的一门计算机应用技术学科，在我国也是应用数学的一个重要分支（国内的很多高校和科研院所的数学专业都有计算机图形学方向）。\n\n计算机图形学里面用到的数学比较多，列举一些常用的，包括：微积分、线性代数、矩阵计算、微分几何、数值计算和分析、计算方法、偏微分方程、微分方程数值解、最优化、概率、统计、计算几何等。\n\n计算机图形学领域的一位优秀学者 Greg Turk 教授在 1997 年曾写过一篇“计算机图形学中的数学”(Mathematics for Computer Graphics)的帖子，详细可见：\n\nhttp://www.cc.gatech.edu/~turk/math_gr.html\n\n其中文翻译版本可见：\n\nhttp://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm\n\n笔者在多年从事计算机图形学研究中对数学的体会是：“数学不是没有用，而是不够用！”。对数学的学习和应用将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解其中的数学思想和数学方法。\n\n另一方面，想成为一名计算机图形学的研究者也不必精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？以上提到的常用的数学课程你不必都要熟悉，许多研究工作者从不需要考虑其中提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！\n\n总之，关于计算机图形学与数学的关系，归纳起来就是以下几个原则：\n\nl 计算机图形学的研究需要用到较多的数学知识，有较好数学功底的学生从事计算机图形学有一定优势；\n\nl 即使没有学太多的数学也不要紧。数学的知识不需要都学会了再去做问题，在解决问题的过程中去学习数学是最快的学习方法。即，研究过程中若遇到什么数学知识再去学相关的知识，学习起来会更有兴趣，掌握起来会更快更扎实；\n\nl 学习数学要结合图形，即“数形结合”，需要有图形的想象能力；数学公式不重要，是“纸老虎”，重要的是背后的思想及其所表达的概念，公式只是它们的一个抽象表达；\n\nl 活到老，学到老。要不断学习新的知识和技术，使自己不断进步和增长功力，才是王道。\n\n**2、 编程**\n\n在计算机图形学中，大部分的想法都要通过实际例子来验证的，再好的理论也要拿实际例子来得到验证和应用。因此，利用编程语言来实现想法或算法是必须要有的能力。C/C++是计算机图形学最常用的编程语言。\n\n笔者要求学生必须掌握 C++编程语言和面向对象编程思想，这是大家通用的“语言”。网上的大部分的资源、类库、算法代码基本上都是 C++写的，因此，你若需要利用这些资源，必须掌握甚至精通 C++语言。\n\n关于计算机图形学所需要的编程能力的几点看法：\n\nl 从事计算机图形学和图像处理的研究需要有较强的编程能力，要对编程有极大的兴趣和热情；\n\nl 如果你对编程比较“感冒”或“厌恶”，则建议你不要选择计算机图形学方向；\n\nl 不太会编程不要紧，任何人都是从不会到会的！只要你对编程有兴趣，觉得编程“好玩”，您完全可以在很短的时间内极大地提高您的编程水平。笔者在长期的教学实验和科研过程中，摸索和发展出一套有效的方法，能够在最短的时间内，帮助学生（包括数学专业的学生）快速提高编程的能力。\n\n**3、 其他**\n\nl 英语基础要好，因为需要大量阅读英文文献和进行英文论文的写作；英文的听说能力也要好些，因为要跟国际学者交流讨论；\n\nl 计算机图形学中的很多算法是真实物理世界的模拟，因此，如果你要进行基于物理的建模和仿真，一些物理知识和理论也需要的，比如力学（动力学，运动学，流体力学）和光学等；\n\nl 其他学科的知识，根据具体研究的需要去学习即可，不必刻意去提前学多少。\n\n**4、 计算机图形学的教材**\n\n上面列举的只是在你从事计算机图形学的学习和研究中可能要用到的东西，不必所有的都学会才能开始计算机图形学的学习和研究。一门知识点不懂不要紧，重要的是要能尽快学习新知识的能力和速度！事实上，最好的学习方法就是在使用中学习。因此，计算机图形学的学习和研究提供了你学习其他相关知识的好的过程。\n\n现在市面上的计算机图形学的教材有很多，但是很多教材的内容仅仅是计算机图形学的基本知识，知识点也比较陈旧。不能指望通过一本或几本教材就能学会计算机图形学。计算机图形学的内容远比教材中或你想象中的内容多得多。正如笔者上面所述，计算机图形学作为一门技术科学，特别是在当前的互联网、移动互联网、大数据时代及第三次工业革命的时代背景下，最近几年的发展日新月异！务必要通过跟着老师做相关研究来了解计算机图形学最新的发展和趋势。除了阅读最新的最新的科研论文外，还需要不断关注信息科技及电子科技的一些前沿发展。要相信，计算机图形学是好玩的，是有用的，更是有未来的！充满热情和激情，才能做好计算机图形学方面的研究。\n\n**四、SIGGRAPH 简介**\n\n说到计算机图形学，不能不提 SIGGRAPH。\n\nACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”（[美国计算机协会](http://zh.wikipedia.org/wiki/美国计算机协会)计算机图形专业组）的缩写，成立于 1967 年，致力于推广和发展计算机绘图和动画制作的软硬件技术。从 1974 年开始，ACM SIGGRAPH 每年都会举办一次年会（也称为 SIGGRAPH），至今年已经举办了 40 次。SIGGRAPH 是计算机图形学顶级年度会议，代表着世界级水平的研究，能在 SIGGRAPH 上发表论文是许多从事计算机图形学研究的工作者的梦想。\n\nSIGGRAPH 每年 7 月底或 8 月初在美国召开（2011 年在加拿大温哥华召开，是 SIGGRAPH 首次在美国以外的城市举行）。事实上，SIGGRAPH 是世界上影响最广、规模最大，同时也是最权威的一个集科学、艺术、商业于一身的 CG 展示、学术研讨会，参会人数众多，一般有 2--4 万人。绝大部分计算机图技术软硬件厂商每年都会将最新研究成果拿到 SIGGRAPH 年会上发布，大部分游戏的[电脑动画](http://baike.baidu.com/view/217213.htm)创作者也将他们本年度最杰出的艺术作品集中在 SIGGRAPH 上展示。因此，SIGGRAPH 在图形图像技术，计算机软硬件以及 CG 等方面都有着相当的影响力。\n\n从 2008 年开始，Siggraph 来到亚洲，每年冬天（11 或 12 月）在亚洲的一个城市（2008，新加坡；2009，日本[横滨](http://baike.baidu.com/view/72581.htm)；2010，韩国[首尔](http://baike.baidu.com/view/4005.htm)；2011，中国香港；2012，新加坡）召开，称为 SIGGRAPH Asia。今年的 Siggraph Asia 将在 2013 年 11 月 19-22 号于中国香港召开。\n\n与 SIGGRAPH 一样，发表者 SIGGRAPH Asia 上的研究论文也代表着计算机图形学领域的最前沿和最高水准，所有研究论文都发表在 ACM Transactions on Graphics 期刊上，这是计算机图形学领域唯一的一个 Top (I 区)的学术期刊。可以形象地将 SIGGRAPH 和 SIGGRAPH Asia 分别比喻为计算机图形学领域的“夏季奥运会”和“冬季奥运会”。\n\n在 SIGGRAPH 会议上，除了研究论文外，还有很多其他内容，比如课程、短文、海报、CG 企业展示、电子剧场、动画节、新型科技展示、艺术画廊、教育等，比你想象得要多得多。很多活动都是并行的，因此你需要每天提前计划好所参加的活动。视觉中国网站的“Siggraph 2007 会议报道”有详尽的关于 Siggraph 2007 年的报道：\n\nhttp://static.chinavisual.com/storage/topics/39942/index.shtml\n\n虽然这是 6 年前的 Siggraph 介绍，但上述链接的内容仍然是对 SIGGRAPH 比较全面的介绍。其中有很多视频和材料，详细介绍了 Siggraph 盛会的情况，而且有对计算机图形学的历史发展的介绍。建议详细查看。\n\n**五、其他问题**\n\n1、 如何选择适合自己的工作（研究方向）？\n\nA: 就两点：兴趣 + 擅长！\n\n兴趣是第一位的，是否擅长需要尝试和不断学习成长！将学会将自己的天赋发挥到极致！\n\n2、 自己是否适合学习和从事计算机图形学的研究？\n\nA: 看看自己是否满足以下两个条件：\n\n1.  对计算机图形学或图像处理具有强烈的兴趣和激情；\n\n2.  喜欢算法设计和编程。\n\n若上述两个条件都满足（觉得好玩！），则可以尝试选择计算机图形学作为自己的研究方向。\n\n3、 从事研究工作需要哪些品质？\n\nA: 激情、好奇心、努力！\n\n4、 为何选择从事研究工作？\n\nA: http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar\n\n5、 如何在研究生期间取得成功？\n\nA: http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar\n\n**六、更多参考材料**\n\nl 有关更多地了解计算机图形的知识和内容，可搜索并参考 Internet 上的丰富的资源介绍，比如[百度百科](http://baike.baidu.com/view/13769.htm)，[维基百科](http://zh.wikipedia.org/wiki/计算机图形学)等。本文的写作过程中也参考了网上的许多资源。\n\nl 国外和国内有很多有关《计算机图形学》的课程网站，可以通过查看相关视频和课件更多地了解计算机图形学的内容。\n\nl 国内外有很多从事计算机图形学研究的教授学者的网站，会列出他们所做的有关计算机图形学方面的研究，可以更为深入了解计算机图形学领域所研究的东西。\n\nl 与计算机其他学科一样，每年都有计算机图形学方面的很多会议。这些会议会有该领域的最新进展和研究工作，是了解计算机图形学发展及趋势的重要手段。在计算机图形学方面，可以通过以下链接来获得各个会议的信息http://kesen.realtimerendering.com/ 建议加该链接为你的浏览器的标签。\n\nl Internet 上经常会有计算机图形学相关的科技信息，要有意识经常关注，随时了解该学科方向的动态、发展和未来。\n\nl 计算机图形学及相关学科在近些年来得到迅速的发展，特别是 2013 年出现的各种交互人机交互技术的出现，我们正处在技术极速发展的浪尖！计算机图形学前景诱人，形势逼人。相对于美国等西方国家，我国的计算机图形学相关产业还相对落后，但这正是留给我们这代人的机会！相信通过我们的努力，是可以逐渐缩短差距的，也带来了巨大的挑战和机会。\n\nl 最后，要相信，计算机图形学是很好玩的，是有用的，更是有未来的。“相信是成功的开始”。祝各位能够感受计算机图形的美妙，能够在计算机图形学的海洋中享受快乐和成功！J\n\n祝您健康、快乐、成功！\n\n刘利刚\n\n中国科学技术大学图形与几何计算实验室([http://gcl.ustc.edu.cn](http://gcl.ustc.edu.cn/))\n\n个人主页：http://staff.ustc.edu.cn/~lgliu\n\n电子邮箱：[lgliu@ustc.edu.cn](mailto:lgliu@ustc.edu.cn)\n\n2013 年 8 月 8 日\n\n---\n\n【2016 年 9 月 9 日添加】刘永进. 中国计算机图形学研究进展[J]. 科技导报, 2016, 34(14): 76-85. [[link](http://www.kjdb.org/CN/10.3981/j.issn.1000-7857.2016.14.009)] [[PDF, 5.1M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201609_ProgressCG-China.pdf)]\n\n【2018 年 8 月 16 日添加】AMiner. 计算机图形学研究报告. [[link](https://www.aminer.cn/)] [[PDF, 3.5M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey.pdf)][[PPT, 2.3M](http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey-PPT.pdf)]\n\n【2020 年 7 月 14 日添加】GAMES：计算机图形学的在线学习和交流平台，其中有大量的课程、报告（均有 PPT 和录频等）。[[link](http://games-cn.org/)]\n\n计算机图形学基础课程推荐（含课程录频和 PPT 等）：\n\n- GAMES 101（闫令琪）[[link](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)]\n- 中国科学技术大学《计算机图形学》本科课程-2020 年（刘利刚）[[link](http://staff.ustc.edu.cn/~lgliu/Courses/ComputerGraphics_2020_spring-summer/default.htm)]\n\n---\n\n版权所有@刘利刚\n","slug":"什么是计算机图形学","published":1,"updated":"2022-06-14T04:09:00.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x10000by4w1aasz0lob","content":"<h1 id=\"转：什么是计算机图形学？\"><a href=\"#转：什么是计算机图形学？\" class=\"headerlink\" title=\"转：什么是计算机图形学？\"></a>转：什么是计算机图形学？</h1> <span id=\"more\"></span>\n\n<p>原文地址：<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm\">http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm</a></p>\n<p><strong><a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/SummerSchool/USTC-summer-school.html\">什么是计算机图形学?</a></strong></p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu\">刘利刚</a></p>\n<p><a href=\"http://www.ustc.edu.cn/\">中国科学技术大学</a> <a href=\"http://gcl.ustc.edu.cn/\">图形与几何计算实验室</a></p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu\">http://staff.ustc.edu.cn/~lgliu</a></p>\n<hr>\n<p>【注】 由于时常有本科学生来向笔者询问计算机图形学是做什么的，为了使得学生能够快速了解计算机图形学，有利于他们在选择研究生方向做出适合自己的选择，特撰写此文。本文仅仅为笔者对计算机图形学浅薄的理解，不涉及对概念的定义，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下计算机图形学的内容及其应用，以帮助还未接触计算机图形学领域的学生来了解该学科方向。笔者对其中的有些内容的理解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。</p>\n<hr>\n<p><strong>一、什么是计算机图形学？</strong></p>\n<p>什么是计算机图形学？计算机图形学(Computer Graphics，简称 CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。</p>\n<p>在“Wiki 百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。虽然通常认为 CG 是指三维图形的处理，事实上也包括了二维图形及图像的处理。</p>\n<p>狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程：计算机图形学是用计算机来画图像的学科，数字图象处理是把外界获得的图象用计算机进行处理的学科，计算机视觉是根据获取的图像来理解和识别其中的物体的三维信息及其他信息。</p>\n<p>注意，这些都是不确切的定义，实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别不是非常清晰，很多概念是相通的，而且随着研究的深入，这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing)。这是后话，此处不详述。</p>\n<p><strong>二、计算机图形学的主要内容</strong></p>\n<p>在学科开创之初，计算机图形学要解决的是如何在计算机中表示三维几何图形,以及如何利用计算机进行图形的生成、处理和显示的相关原理与算法，产生令人赏心悦目的真实感图像。这是狭义的计算机图形学的范畴。随着近 40 年的发展，计算机图形学的内容已经远远不止这些了。广义的计算机图形学的研究内容非常广泛，如图形硬件、图形标准、图形交互技术、光栅图形生成算法、曲线曲面造型、实体造型、真实感图形计算与显示算法，以及科学计算可视化、计算机动画、自然景物仿真、虚拟现实等。</p>\n<p>根据笔者的理解，计算机图形学主要包含四大部分的内容：建模(Modeling)、渲染(Rendering)、动画(Animation)和人机交互(Human–computer Interaction, HCI)。</p>\n<p><strong>1、 建模(Modeling)</strong></p>\n<p>要在计算机中表示一个三维物体，首先要有它的几何模型表达。因此，三维模型的建模是计算机图形学的基础，是其他内容的前提。表达一个几何物体可以是用数学上的样条函数或隐式函数来表达；也可以是用光滑曲面上的采样点及其连接关系所表达的三角网格来表达（即连续曲面的分片线性逼近），如下图所示。</p>\n<p>三维建模方法主要包含如下的一些方法：</p>\n<p>l 计算机辅助设计(CAD)中的主流方法是采用 NURBS（非均匀有理 B-样条、Bezier 曲线曲面）方法（已成为 CAD 工业领域的标准），这也是计算机辅助几何设计(CAGD)所研究的主要内容。此类表达方法有一些难点问题仍未解决，比如非正规情况下的曲面光滑拼合，复杂曲面表达等。这部分涉及的数学比较多，国内做这块的学者比较多些。</p>\n<p>l 细分曲面(Subdivision surface)造型方法，作为一种离散迭代的曲面构造方法，由于其构造过程朴素简单以及实现容易，是一个方兴未艾的研究热点。经过十多年的研究发展，细分曲面造型取得了较大的进展，包括奇异点处的连续性构造方法以及与 GPU 图形硬件相结合的曲面处理方法。</p>\n<p>l 利用软件的直接手工建模。现在主流的商业化的三维建模软件有 Autodesk 3D Max 和 Maya。其他还有面向特定领域的商业化软件，比如面向建筑模型造型的 Google Sketchup，面向 CAD/CAM/CAE 的 CATIA 和 AutoCAD，面向机械设计的 SolidWorks，面向造船行业的 Rhino 等。这些软件需要建模人员有较强的专业知识，而且需要一定时期的培训才能掌握，建模效率低而学习门槛高，不易于普及和让非专业用户使用。</p>\n<p>l 基于笔划或草图交互方式的三维建模方法。草图交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单，是最近几年研究的热点建模方法。其难点是根据具体的应用场合，如何正确地理解和识别用户的交互所表达的语义，构造出用户所希望的模型。</p>\n<p>l 基于语法及规则的过程式建模方法。特别适合具有重复特征和结构化的几何物体与场景，比如建筑、树木等。最近几年有较多的论文及较大的发展。</p>\n<p>l 基于图像或视频的建模方法。这是传统的计算机视觉所要解决的基本问题。在计算机图形学领域，这方面的发展也很迅速。有一些商业化软件或云服务(比如 Autodesk 的 123D)，已经能从若干张照片重建出所拍摄物体的三维模型。该方法的问题是需要物体本身已经存在，而且重建的三维模型的精度有限。</p>\n<p>l 基于扫描点云（深度图像如 Kinect、结构光扫描、激光扫描、LiDAR 扫描等）的建模(Reconstruction)方法。随着深度相机的出现及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维模型的工作在最近几年的 Siggraph(Asia)上能常见到。但是，单纯的重建方式存在精度低、稳定性差和运算量大等不足，远未能满足实际的需求。</p>\n<p>l 基于现有模型来合成建模的方法。随着三维模型的逐渐增多，可以利用现有的三维模型通过简单的操作，比如 cut and paste，或者分析及变形等手段，来拼接或合成新的三维模型。这种通过“学习”模型数据库的知识来进行建模的手段在近 3-5 年里研究得非常热门。从某方面来讲，就是“大数据时代”背景下计算机图形学领域中的一个具体的表现。</p>\n<p>除了上述的这些建模方法，还有其他的一些建模方法，在此不再一一列举。</p>\n<p>在对三维几何模型的构建过程中，还会涉及到很多需要处理的几何问题，比如数据去噪(denoising or smoothing)、补洞(repairing)、简化(simplification)、层次细节(level of detail)、参数化(parameterization)、变形(deformation or editing)、分割(segmentation)、形状分析及检索(shape analysis and retrieval)等。这些问题构成“数字几何处理”的主要研究内容。笔者自 2005 年起开设了多年的《数字几何处理》的研究生课程：</p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm\">http://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm</a></p>\n<p>虽然有上述所提到的这么多的三维建模方式，但是至今为止，仍没有适合一般家庭用户的轻松简单的建模工具。现有的电子设备（比如相机，手机等）能够帮助人们轻松获得图像和视频，但是，不是人人都有能力来构建三维几何模型。如何让大众能够像获取图像那样能够随时随地地获取或者构建三维模型，仍然是计算机图形学的任重道远的主要任务之一！今天，计算机图形学仍未进入“大数据时代”。只有让大众能够轻松进行三维建模，并上载分享他们所构建的模型数据，计算机图形学才可能进入大数据时代。</p>\n<p>另外，随着三维打印(3D printing)的新兴技术的逐渐普及，人们对三维模型的需求也日益增加。笔者个人认为，几何建模和三维打印的未来是共呼吸，同命运的：也只有当人人都能轻松建模时，三维打印才有可能走向千家万户。</p>\n<p>三维几何建模的任务仍然任重道远，大家仍需共同努力！</p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image002.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image004.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image006.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image008.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image010.jpg\" alt=\"img\"></p>\n<p><strong>2、 渲染(Rendering)</strong></p>\n<p>有了三维模型或场景，怎么把这些三维几何模型画出来，产生令人赏心悦目的真实感图像？这就是传统的计算机图形学的核心任务，在计算机辅助设计，影视动漫以及各类可视化应用中都对图形渲染结果的高真实感提出了很高的要求。</p>\n<p>上个世纪 80-90 年代研究的比较多些，包含了大量的渲染模型，包括局部光照模型(Local Illumination Model)、光线跟踪算法(Ray Tracing)、辐射度(Radiosity)等，以及到后面的更为复杂、真实、快速的渲染技术，比如全局光照模型(Global Illumination Model)、Photo mapping、BTF、BRDF、以及基于 GPU 的渲染技术等。</p>\n<p>现在的渲染技术已经能够将各种物体，包括皮肤、树木、花草、水、烟雾、毛发等渲染得非常逼真。一些商业化软件（比如 Maya, Blender, Pov Ray 等）也提供了强大的真实感渲染功能，在计算机图形学研究论文中作图中要经常用到这些工具来渲染漂亮的展示图或结果图。</p>\n<p>然而，已知的渲染实现方法，仍无法实现复杂的视觉特效，离实时的高真实感渲染还有很大差距，比如完整地实现适于<a href=\"http://baike.baidu.com/view/2382.htm\">电影</a>渲染（高真实感、高分辨率）制作的 RenderMan 标准，以及其他各类基于物理真实感的实时渲染算法等。因此，如何充分利用 GPU 的计算特性，结合分布式的集群技术，从而来构造低功耗的渲染服务是发展趋势之一。</p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image012.gif\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image014.jpg\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image016.jpg\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image018.jpg\"></p>\n<p><strong>3、 动画(Animation)</strong></p>\n<p>动画是采用连续播放静止图像的方法产生物体运动的效果。计算机动画借助于编程或动画制作软件生成一系列的景物画面，是计算机图形学的研究热点之一。研究方向包括：物理仿真(simulation)，人体动画，关节动画，运动动画，脚本动画，具有人的意识的虚拟角色的动画系统等。另外，高度物理真实感的动态模拟，包括对各种形变、水、气、云、烟雾、燃烧、爆炸、撕裂、老化等物理现象的真实模拟，也是动画领域的主要问题。这些技术是各类动态仿真应用的核心技术，可以极大地提高虚拟现实系统的沉浸感 （其中的本质是数值求解各种偏微分方程）。计算机动画的应用领域广泛，比如动画片制作，广告、 电影特技，训练模拟，游戏等。</p>\n<p>网上的一些 3D 动画的视频：</p>\n<p>Larva 虫虫: <a href=\"http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html\">http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html</a></p>\n<p>The Killer Bean: <a href=\"http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html\">http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html</a></p>\n<p>爱与孝: <a href=\"http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html\">http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html</a></p>\n<p>房地产动画广告宣传片: <a href=\"http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html\">http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html</a></p>\n<p><strong>4、 人机交互(Human–Computer Interaction, HCI)</strong></p>\n<p>人机交互（Human-Computer Interaction, 简写 HCI）是指人与计算机之间以一定的交互方式或交互界面，来完成确定任务的人与计算机之间的信息交换过程。简单来讲，就是人如何通过一定的交互方式告诉计算机来完成他所希望完成的任务。</p>\n<p>计算机图形学的顶级会议 ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”的缩写，缩写中只包含了 Graphics，而忽略了 Interactive Techniques，在长时间没有得到计算机图形学研究的重视。最近，包括在 SIGGRAPH 会议上，以及人机交互的顶级会议 SIGCHI 上，陆续出现了许多新兴的人机交互技术及研究论文。大家逐渐重视起来。</p>\n<p>在早期（上个世纪 60-70 年代），只有以键盘输入的字符界面；到了 80 年代，以 WIMP(窗口、图符、菜单、鼠标)为基础的图形用户界面(GUI)逐渐成为当今计算机用户界面的主流。</p>\n<p>近年来，以用户为中心的系统设计思想，增进人机交互的自然性，提高人机交互的效率是用户界面的主要研究方向。陆续提出了多通道用户界面的思想，它包括语言、姿势输入、头部跟踪、视觉跟踪、立体显示、三维交互技术、感觉反馈及自然语言界面等。</p>\n<p>事实上，人体的表面本身就是人机界面。人体的任何部分（姿势，手势，语言，眼睛，肌肉电波，脑波等）都可以成为人机对话的通道。比如 2010 年微软出的 Kinect 就是一种无需任何操纵杆的基于体感的人机界面，用户本身就是控制器。Kinect 在微软的 Xbox 游戏上取得了极大的成功，之后在其他方面也得到了很多的应用。</p>\n<p>特别是到了今年（2013 年），人机交互设备有了巨大的发展，各种自然的交互手段层出不穷，极大地丰富了用户与机器交互的体验，方便了用户的操作，轻松表达了用户的交互意图。可以说，</p>\n<p><strong>我们正处在图形与交互技术极速发展的浪尖！</strong></p>\n<p>以下是最近几年（特别是今年）出现的一些值得关注的新兴的人机交互设备：</p>\n<p>l Microsoft Kinect：<a href=\"http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html\">http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html</a></p>\n<ol>\n<li><p> Kinect 由微软于 2010 年推出的对 XBOX360 体感外设，它不需要使用任何控制器，仅依靠相机捕捉三维空间中玩家的运动，同时它导入了即时动态捕捉、影像辨识、麦克风输入、语音辨识、社群互动等功能。Kinect 彻底颠覆了游戏的单一操作。使人机互动的理念更加彻底的展现出来。之后，基于 Kinect 的各种应用像雨后春笋般的冒出来，包括人机交互，手势识别，几何建模等。</p>\n</li>\n<li><p> 在 2013 年 5 月 28 日的 Xbox One 发布会上，微软展示了新一代 Kinect 2.0，新 Kinect 能感知的语音、手势和玩家感觉信息，将给玩家带来前所未有的互动性体验：</p>\n</li>\n</ol>\n<p><a href=\"http://v.youku.com/v_show/id_XNTIyODU0NDky.html\">http://v.youku.com/v_show/id_XNTIyODU0NDky.html</a></p>\n<p>l Leap Motion：<a href=\"http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html\">http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html</a></p>\n<p>Leap Motion 为放在键盘和显示器之间的小小金属棒，就能让任何一位用户通过简单的手势完成人机交互。Leap Motion 的响应惊人的准确，对各种自然而简洁的手势都能识别。不必站起来或者摆动手臂，Leap Motion 是简单而毫不费力的交互方式。我们在 4 月份就预订了一台，到现在还未到货，估计要到下个月到货。到货后我们会对其进行评测。</p>\n<p>l MYO：<a href=\"http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html\">http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html</a></p>\n<p>MYO 是一款能在用户挥动并指向屏幕时测量各种肌肉产生的电活动来完成交互的腕带。MYO 超越 Leap Motion 的一点是，MYO 对用户的位置没有限制。尽管 MYO 只听令于身体的一个部分（手臂），但是其应用的场合还是很多的。期望未来会有更多的听令于身体的其他部分的交互设备。</p>\n<p>l Google Glass：<a href=\"http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html\">http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html</a></p>\n<p>Google Glass 为 Google 公司在 2012 的 I/O 开发者大会上正式公布的，在看起来普普通通的眼镜上配置强大的计算机和显示器。这款设备小巧而不显眼，可以在任何时间地点使用，即用户想要专注于周围环境时不会碍事。不过对其未来的发展各有说法，让我们拭目以待。</p>\n<p>l 3D Printer：这个就不用笔者详细说了，这两年太火了。正如上面所提到的观点，笔者觉得 3D 打印的出现带给了我们从事计算机图形学研究的工作者许多的机会。挑战和机会并存！我们应该要抓住这次机会！</p>\n<p>l 3Doodler：<a href=\"http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html\">http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html</a></p>\n<p>3Doodler 是玩具和机器人公司 Wobble Works 开发的全球首款“3D 打印笔”，可以帮助人们在半空中创造出三维结构的模型。今后人们可以在三维空间中来“画图”交流和表达想法了。</p>\n<p>l Apple iWatch：<a href=\"http://v.youku.com/v_show/id_XNTIwODk0MzM2.html\">http://v.youku.com/v_show/id_XNTIwODk0MzM2.html</a></p>\n<p>iWatch 由苹果公司推出的一款智能手表。现在仍是概念产品，面世时间未定。其界面看看视频就知道有多酷。但是其技术上的实现笔者也没有完全想通，呵呵。</p>\n<p>除了上述介绍的外，最近还有其他很多新的人机交互类的电子科技产品，比如透明手机，可折叠的屏幕，具有气味和触感反馈的头盔等，就不一一介绍了。</p>\n<p>由此可见，以前在科幻电影里出现的“神器”逐渐被实现，计算机图形学及相关技术在其中发挥了重要的作用。同时，这些设备的出现，也带给了计算机图形学领域更多的探索和机会。</p>\n<p><strong>5、 其他内容</strong></p>\n<p>上述所提到的只是计算机图形学的主要的四个内容。事实上，与计算机图形学相关的学科还有很多，以下仅介绍几个最为相关的研究方向：</p>\n<p>l 虚拟现实(Virtual Reality)：利用计算机图形产生器，位置跟踪器，多功能传感器和控制器等有效地模拟实际场景和情形，从而能够使观察者产生一种真实的身临其境的感觉。虚拟现实技术主要研究用计算机模拟（构造）三维图形空间，并使用户能够自然地与该空间进行交互。对三维图形处理技术的要求特别高。简单的虚拟现实系统早在 70 年代便被应用于军事领域，训练驾驶员。80 年代后随着计算机软硬件技术的提高，它也得到重视并迅速发展。它已在航空航天、医学、教育、艺术、建筑等领域得到初步的应用。</p>\n<p>l 可视化(Visualization)：利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。现已成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。上面提到的虚拟现实技术也是以图形图像的可视化技术为依托的。在现在的大数据时代的背景下，可视化的内容除了传统的科学可视化外，现在还有信息可视化，可视分析等方面。</p>\n<p>l 可视媒体计算与处理(Visual Media Processing)：几何数据，被认为是继声音、图像、视频之后的新一代数字媒体，是计算机图形学的研究重点。最近几年，计算机图形学与图像视频处理技术相结合的研究与技术日益增多。正如笔者在上面所提及的，图像和视频的大数据处理能带给计算机图形学很多处理手段上的更新。另一方面，随着而计算机图形学技术，恰可以与这些图像处理，视觉方法相交叉融合，来直接地生成风格化的画面，实现基于图像三维建模，以及直接基于视频和图像数据来生成动画序列。当计算机图形学正向地图像生成方法和计算机视觉中逆向地从图像中恢复各种信息方法相结合，可以带来无可限量的想象空间，构造出很多视觉特效来，最终用于增强现实、数字地图、虚拟博物馆展示等多种应用中去。因此，在很多方面，计算机图形学与图像处理、视频处理、多媒体处理、计算机视觉等学科逐渐融合在一起，有成为一个更大的学科的趋势。</p>\n<p>l 医学图像处理(Medical Imaging)：随着医学成像技术的发展与进步，图像处理在医学研究与临床医学中的应用越来越广泛。与一般意义上的图像处理比较，医学图像处理有其特殊性和不同的侧重点。医学图像处理由生物医学成像(X 射线、CT、MRI)和生物医学图像处理两部分组成，在生命科学研究、医学诊断、临床治疗等方面起着重要的作用。医学图像分析中涉及的两个最为重要的内容为图像分割与图像配准。</p>\n<p>l 计算机艺术(Computational Arts)：计算机图形学的发展也提供给了艺术家发挥和实现想象的丰富的技术手段。计算机艺术的发展速度远远超出了人们的想象，在代表计算机图形研究最高水平的历届 SIGGRAPH 年会上，精彩的计算机艺术作品层出不穷。在计算机图形学领域，还有几个关于计算艺术方面的会议，包括非真实性图形学(Non-Photorealistic Graphics)和 Computational Aesthetics(计算美学)等。吸引了计算机工作者、艺术家、建筑师、设计师等方面的人员在一起，通过头脑风暴和交流讨论的方式进行一些有创意的技术研究。</p>\n<p><strong>三、 学习计算机图形学需要哪些基础？</strong></p>\n<p>计算机图形学是一门与很多学科都交叉的学科方向。因此，要学好计算机图形学和做好计算机图形学方面的研究，除了计算机图形学的基础知识以外，你还需要有其他方面的一些知识。当然你懂得越多当然会越好。</p>\n<p><strong>1、 数学</strong></p>\n<p>计算机图形学进入我国大概在上个世纪 70 年代末和 80 年代初，那时国内还没有计算机学科。于是，开始学习和研究计算机图形学的大部分都是搞数学的一些学者和教授。由此可见，计算机图形学是需要数学知识较多的一门计算机应用技术学科，在我国也是应用数学的一个重要分支（国内的很多高校和科研院所的数学专业都有计算机图形学方向）。</p>\n<p>计算机图形学里面用到的数学比较多，列举一些常用的，包括：微积分、线性代数、矩阵计算、微分几何、数值计算和分析、计算方法、偏微分方程、微分方程数值解、最优化、概率、统计、计算几何等。</p>\n<p>计算机图形学领域的一位优秀学者 Greg Turk 教授在 1997 年曾写过一篇“计算机图形学中的数学”(Mathematics for Computer Graphics)的帖子，详细可见：</p>\n<p><a href=\"http://www.cc.gatech.edu/~turk/math_gr.html\">http://www.cc.gatech.edu/~turk/math_gr.html</a></p>\n<p>其中文翻译版本可见：</p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm\">http://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm</a></p>\n<p>笔者在多年从事计算机图形学研究中对数学的体会是：“数学不是没有用，而是不够用！”。对数学的学习和应用将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解其中的数学思想和数学方法。</p>\n<p>另一方面，想成为一名计算机图形学的研究者也不必精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？以上提到的常用的数学课程你不必都要熟悉，许多研究工作者从不需要考虑其中提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！</p>\n<p>总之，关于计算机图形学与数学的关系，归纳起来就是以下几个原则：</p>\n<p>l 计算机图形学的研究需要用到较多的数学知识，有较好数学功底的学生从事计算机图形学有一定优势；</p>\n<p>l 即使没有学太多的数学也不要紧。数学的知识不需要都学会了再去做问题，在解决问题的过程中去学习数学是最快的学习方法。即，研究过程中若遇到什么数学知识再去学相关的知识，学习起来会更有兴趣，掌握起来会更快更扎实；</p>\n<p>l 学习数学要结合图形，即“数形结合”，需要有图形的想象能力；数学公式不重要，是“纸老虎”，重要的是背后的思想及其所表达的概念，公式只是它们的一个抽象表达；</p>\n<p>l 活到老，学到老。要不断学习新的知识和技术，使自己不断进步和增长功力，才是王道。</p>\n<p><strong>2、 编程</strong></p>\n<p>在计算机图形学中，大部分的想法都要通过实际例子来验证的，再好的理论也要拿实际例子来得到验证和应用。因此，利用编程语言来实现想法或算法是必须要有的能力。C/C++是计算机图形学最常用的编程语言。</p>\n<p>笔者要求学生必须掌握 C++编程语言和面向对象编程思想，这是大家通用的“语言”。网上的大部分的资源、类库、算法代码基本上都是 C++写的，因此，你若需要利用这些资源，必须掌握甚至精通 C++语言。</p>\n<p>关于计算机图形学所需要的编程能力的几点看法：</p>\n<p>l 从事计算机图形学和图像处理的研究需要有较强的编程能力，要对编程有极大的兴趣和热情；</p>\n<p>l 如果你对编程比较“感冒”或“厌恶”，则建议你不要选择计算机图形学方向；</p>\n<p>l 不太会编程不要紧，任何人都是从不会到会的！只要你对编程有兴趣，觉得编程“好玩”，您完全可以在很短的时间内极大地提高您的编程水平。笔者在长期的教学实验和科研过程中，摸索和发展出一套有效的方法，能够在最短的时间内，帮助学生（包括数学专业的学生）快速提高编程的能力。</p>\n<p><strong>3、 其他</strong></p>\n<p>l 英语基础要好，因为需要大量阅读英文文献和进行英文论文的写作；英文的听说能力也要好些，因为要跟国际学者交流讨论；</p>\n<p>l 计算机图形学中的很多算法是真实物理世界的模拟，因此，如果你要进行基于物理的建模和仿真，一些物理知识和理论也需要的，比如力学（动力学，运动学，流体力学）和光学等；</p>\n<p>l 其他学科的知识，根据具体研究的需要去学习即可，不必刻意去提前学多少。</p>\n<p><strong>4、 计算机图形学的教材</strong></p>\n<p>上面列举的只是在你从事计算机图形学的学习和研究中可能要用到的东西，不必所有的都学会才能开始计算机图形学的学习和研究。一门知识点不懂不要紧，重要的是要能尽快学习新知识的能力和速度！事实上，最好的学习方法就是在使用中学习。因此，计算机图形学的学习和研究提供了你学习其他相关知识的好的过程。</p>\n<p>现在市面上的计算机图形学的教材有很多，但是很多教材的内容仅仅是计算机图形学的基本知识，知识点也比较陈旧。不能指望通过一本或几本教材就能学会计算机图形学。计算机图形学的内容远比教材中或你想象中的内容多得多。正如笔者上面所述，计算机图形学作为一门技术科学，特别是在当前的互联网、移动互联网、大数据时代及第三次工业革命的时代背景下，最近几年的发展日新月异！务必要通过跟着老师做相关研究来了解计算机图形学最新的发展和趋势。除了阅读最新的最新的科研论文外，还需要不断关注信息科技及电子科技的一些前沿发展。要相信，计算机图形学是好玩的，是有用的，更是有未来的！充满热情和激情，才能做好计算机图形学方面的研究。</p>\n<p><strong>四、SIGGRAPH 简介</strong></p>\n<p>说到计算机图形学，不能不提 SIGGRAPH。</p>\n<p>ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”（<a href=\"http://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E4%BC%9A\">美国计算机协会</a>计算机图形专业组）的缩写，成立于 1967 年，致力于推广和发展计算机绘图和动画制作的软硬件技术。从 1974 年开始，ACM SIGGRAPH 每年都会举办一次年会（也称为 SIGGRAPH），至今年已经举办了 40 次。SIGGRAPH 是计算机图形学顶级年度会议，代表着世界级水平的研究，能在 SIGGRAPH 上发表论文是许多从事计算机图形学研究的工作者的梦想。</p>\n<p>SIGGRAPH 每年 7 月底或 8 月初在美国召开（2011 年在加拿大温哥华召开，是 SIGGRAPH 首次在美国以外的城市举行）。事实上，SIGGRAPH 是世界上影响最广、规模最大，同时也是最权威的一个集科学、艺术、商业于一身的 CG 展示、学术研讨会，参会人数众多，一般有 2–4 万人。绝大部分计算机图技术软硬件厂商每年都会将最新研究成果拿到 SIGGRAPH 年会上发布，大部分游戏的<a href=\"http://baike.baidu.com/view/217213.htm\">电脑动画</a>创作者也将他们本年度最杰出的艺术作品集中在 SIGGRAPH 上展示。因此，SIGGRAPH 在图形图像技术，计算机软硬件以及 CG 等方面都有着相当的影响力。</p>\n<p>从 2008 年开始，Siggraph 来到亚洲，每年冬天（11 或 12 月）在亚洲的一个城市（2008，新加坡；2009，日本<a href=\"http://baike.baidu.com/view/72581.htm\">横滨</a>；2010，韩国<a href=\"http://baike.baidu.com/view/4005.htm\">首尔</a>；2011，中国香港；2012，新加坡）召开，称为 SIGGRAPH Asia。今年的 Siggraph Asia 将在 2013 年 11 月 19-22 号于中国香港召开。</p>\n<p>与 SIGGRAPH 一样，发表者 SIGGRAPH Asia 上的研究论文也代表着计算机图形学领域的最前沿和最高水准，所有研究论文都发表在 ACM Transactions on Graphics 期刊上，这是计算机图形学领域唯一的一个 Top (I 区)的学术期刊。可以形象地将 SIGGRAPH 和 SIGGRAPH Asia 分别比喻为计算机图形学领域的“夏季奥运会”和“冬季奥运会”。</p>\n<p>在 SIGGRAPH 会议上，除了研究论文外，还有很多其他内容，比如课程、短文、海报、CG 企业展示、电子剧场、动画节、新型科技展示、艺术画廊、教育等，比你想象得要多得多。很多活动都是并行的，因此你需要每天提前计划好所参加的活动。视觉中国网站的“Siggraph 2007 会议报道”有详尽的关于 Siggraph 2007 年的报道：</p>\n<p><a href=\"http://static.chinavisual.com/storage/topics/39942/index.shtml\">http://static.chinavisual.com/storage/topics/39942/index.shtml</a></p>\n<p>虽然这是 6 年前的 Siggraph 介绍，但上述链接的内容仍然是对 SIGGRAPH 比较全面的介绍。其中有很多视频和材料，详细介绍了 Siggraph 盛会的情况，而且有对计算机图形学的历史发展的介绍。建议详细查看。</p>\n<p><strong>五、其他问题</strong></p>\n<p>1、 如何选择适合自己的工作（研究方向）？</p>\n<p>A: 就两点：兴趣 + 擅长！</p>\n<p>兴趣是第一位的，是否擅长需要尝试和不断学习成长！将学会将自己的天赋发挥到极致！</p>\n<p>2、 自己是否适合学习和从事计算机图形学的研究？</p>\n<p>A: 看看自己是否满足以下两个条件：</p>\n<ol>\n<li><p> 对计算机图形学或图像处理具有强烈的兴趣和激情；</p>\n</li>\n<li><p> 喜欢算法设计和编程。</p>\n</li>\n</ol>\n<p>若上述两个条件都满足（觉得好玩！），则可以尝试选择计算机图形学作为自己的研究方向。</p>\n<p>3、 从事研究工作需要哪些品质？</p>\n<p>A: 激情、好奇心、努力！</p>\n<p>4、 为何选择从事研究工作？</p>\n<p>A: <a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar\">http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar</a></p>\n<p>5、 如何在研究生期间取得成功？</p>\n<p>A: <a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar\">http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar</a></p>\n<p><strong>六、更多参考材料</strong></p>\n<p>l 有关更多地了解计算机图形的知识和内容，可搜索并参考 Internet 上的丰富的资源介绍，比如<a href=\"http://baike.baidu.com/view/13769.htm\">百度百科</a>，<a href=\"http://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6\">维基百科</a>等。本文的写作过程中也参考了网上的许多资源。</p>\n<p>l 国外和国内有很多有关《计算机图形学》的课程网站，可以通过查看相关视频和课件更多地了解计算机图形学的内容。</p>\n<p>l 国内外有很多从事计算机图形学研究的教授学者的网站，会列出他们所做的有关计算机图形学方面的研究，可以更为深入了解计算机图形学领域所研究的东西。</p>\n<p>l 与计算机其他学科一样，每年都有计算机图形学方面的很多会议。这些会议会有该领域的最新进展和研究工作，是了解计算机图形学发展及趋势的重要手段。在计算机图形学方面，可以通过以下链接来获得各个会议的信息<a href=\"http://kesen.realtimerendering.com/\">http://kesen.realtimerendering.com/</a> 建议加该链接为你的浏览器的标签。</p>\n<p>l Internet 上经常会有计算机图形学相关的科技信息，要有意识经常关注，随时了解该学科方向的动态、发展和未来。</p>\n<p>l 计算机图形学及相关学科在近些年来得到迅速的发展，特别是 2013 年出现的各种交互人机交互技术的出现，我们正处在技术极速发展的浪尖！计算机图形学前景诱人，形势逼人。相对于美国等西方国家，我国的计算机图形学相关产业还相对落后，但这正是留给我们这代人的机会！相信通过我们的努力，是可以逐渐缩短差距的，也带来了巨大的挑战和机会。</p>\n<p>l 最后，要相信，计算机图形学是很好玩的，是有用的，更是有未来的。“相信是成功的开始”。祝各位能够感受计算机图形的美妙，能够在计算机图形学的海洋中享受快乐和成功！J</p>\n<p>祝您健康、快乐、成功！</p>\n<p>刘利刚</p>\n<p>中国科学技术大学图形与几何计算实验室(<a href=\"http://gcl.ustc.edu.cn/\">http://gcl.ustc.edu.cn</a>)</p>\n<p>个人主页：<a href=\"http://staff.ustc.edu.cn/~lgliu\">http://staff.ustc.edu.cn/~lgliu</a></p>\n<p>电子邮箱：<a href=\"mailto:lgliu@ustc.edu.cn\">lgliu@ustc.edu.cn</a></p>\n<p>2013 年 8 月 8 日</p>\n<hr>\n<p>【2016 年 9 月 9 日添加】刘永进. 中国计算机图形学研究进展[J]. 科技导报, 2016, 34(14): 76-85. [<a href=\"http://www.kjdb.org/CN/10.3981/j.issn.1000-7857.2016.14.009\">link</a>] [<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201609_ProgressCG-China.pdf\">PDF, 5.1M</a>]</p>\n<p>【2018 年 8 月 16 日添加】AMiner. 计算机图形学研究报告. [<a href=\"https://www.aminer.cn/\">link</a>] [<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey.pdf\">PDF, 3.5M</a>][<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey-PPT.pdf\">PPT, 2.3M</a>]</p>\n<p>【2020 年 7 月 14 日添加】GAMES：计算机图形学的在线学习和交流平台，其中有大量的课程、报告（均有 PPT 和录频等）。[<a href=\"http://games-cn.org/\">link</a>]</p>\n<p>计算机图形学基础课程推荐（含课程录频和 PPT 等）：</p>\n<ul>\n<li>GAMES 101（闫令琪）[<a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">link</a>]</li>\n<li>中国科学技术大学《计算机图形学》本科课程-2020 年（刘利刚）[<a href=\"http://staff.ustc.edu.cn/~lgliu/Courses/ComputerGraphics_2020_spring-summer/default.htm\">link</a>]</li>\n</ul>\n<hr>\n<p>版权所有@刘利刚</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"转：什么是计算机图形学？\"><a href=\"#转：什么是计算机图形学？\" class=\"headerlink\" title=\"转：什么是计算机图形学？\"></a>转：什么是计算机图形学？</h1>","more":"<p>原文地址：<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm\">http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm</a></p>\n<p><strong><a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/SummerSchool/USTC-summer-school.html\">什么是计算机图形学?</a></strong></p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu\">刘利刚</a></p>\n<p><a href=\"http://www.ustc.edu.cn/\">中国科学技术大学</a> <a href=\"http://gcl.ustc.edu.cn/\">图形与几何计算实验室</a></p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu\">http://staff.ustc.edu.cn/~lgliu</a></p>\n<hr>\n<p>【注】 由于时常有本科学生来向笔者询问计算机图形学是做什么的，为了使得学生能够快速了解计算机图形学，有利于他们在选择研究生方向做出适合自己的选择，特撰写此文。本文仅仅为笔者对计算机图形学浅薄的理解，不涉及对概念的定义，是非学术性的。因此，笔者尽量尝试用通俗的语言介绍一下计算机图形学的内容及其应用，以帮助还未接触计算机图形学领域的学生来了解该学科方向。笔者对其中的有些内容的理解也是很有限的，值得进一步的学习和交流。有不当之处，还请读者谅解指正。</p>\n<hr>\n<p><strong>一、什么是计算机图形学？</strong></p>\n<p>什么是计算机图形学？计算机图形学(Computer Graphics，简称 CG)的内容比较丰富，与很多学科都有交叉，因此笔者认为是无法严格定义的。</p>\n<p>在“Wiki 百科”和“百度百科”上，对“计算机图形学”的解释为：计算机图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。虽然通常认为 CG 是指三维图形的处理，事实上也包括了二维图形及图像的处理。</p>\n<p>狭义地理解，计算机图形学是数字图象处理或计算机视觉的逆过程：计算机图形学是用计算机来画图像的学科，数字图象处理是把外界获得的图象用计算机进行处理的学科，计算机视觉是根据获取的图像来理解和识别其中的物体的三维信息及其他信息。</p>\n<p>注意，这些都是不确切的定义，实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别不是非常清晰，很多概念是相通的，而且随着研究的深入，这些学科方向不断的交叉融入，形成一个更大的学科方向，可称之为“可视计算”(Visual Computing)。这是后话，此处不详述。</p>\n<p><strong>二、计算机图形学的主要内容</strong></p>\n<p>在学科开创之初，计算机图形学要解决的是如何在计算机中表示三维几何图形,以及如何利用计算机进行图形的生成、处理和显示的相关原理与算法，产生令人赏心悦目的真实感图像。这是狭义的计算机图形学的范畴。随着近 40 年的发展，计算机图形学的内容已经远远不止这些了。广义的计算机图形学的研究内容非常广泛，如图形硬件、图形标准、图形交互技术、光栅图形生成算法、曲线曲面造型、实体造型、真实感图形计算与显示算法，以及科学计算可视化、计算机动画、自然景物仿真、虚拟现实等。</p>\n<p>根据笔者的理解，计算机图形学主要包含四大部分的内容：建模(Modeling)、渲染(Rendering)、动画(Animation)和人机交互(Human–computer Interaction, HCI)。</p>\n<p><strong>1、 建模(Modeling)</strong></p>\n<p>要在计算机中表示一个三维物体，首先要有它的几何模型表达。因此，三维模型的建模是计算机图形学的基础，是其他内容的前提。表达一个几何物体可以是用数学上的样条函数或隐式函数来表达；也可以是用光滑曲面上的采样点及其连接关系所表达的三角网格来表达（即连续曲面的分片线性逼近），如下图所示。</p>\n<p>三维建模方法主要包含如下的一些方法：</p>\n<p>l 计算机辅助设计(CAD)中的主流方法是采用 NURBS（非均匀有理 B-样条、Bezier 曲线曲面）方法（已成为 CAD 工业领域的标准），这也是计算机辅助几何设计(CAGD)所研究的主要内容。此类表达方法有一些难点问题仍未解决，比如非正规情况下的曲面光滑拼合，复杂曲面表达等。这部分涉及的数学比较多，国内做这块的学者比较多些。</p>\n<p>l 细分曲面(Subdivision surface)造型方法，作为一种离散迭代的曲面构造方法，由于其构造过程朴素简单以及实现容易，是一个方兴未艾的研究热点。经过十多年的研究发展，细分曲面造型取得了较大的进展，包括奇异点处的连续性构造方法以及与 GPU 图形硬件相结合的曲面处理方法。</p>\n<p>l 利用软件的直接手工建模。现在主流的商业化的三维建模软件有 Autodesk 3D Max 和 Maya。其他还有面向特定领域的商业化软件，比如面向建筑模型造型的 Google Sketchup，面向 CAD/CAM/CAE 的 CATIA 和 AutoCAD，面向机械设计的 SolidWorks，面向造船行业的 Rhino 等。这些软件需要建模人员有较强的专业知识，而且需要一定时期的培训才能掌握，建模效率低而学习门槛高，不易于普及和让非专业用户使用。</p>\n<p>l 基于笔划或草图交互方式的三维建模方法。草图交互方式由于其符合人类原有日常生活中的思考习惯，交互方式直观简单，是最近几年研究的热点建模方法。其难点是根据具体的应用场合，如何正确地理解和识别用户的交互所表达的语义，构造出用户所希望的模型。</p>\n<p>l 基于语法及规则的过程式建模方法。特别适合具有重复特征和结构化的几何物体与场景，比如建筑、树木等。最近几年有较多的论文及较大的发展。</p>\n<p>l 基于图像或视频的建模方法。这是传统的计算机视觉所要解决的基本问题。在计算机图形学领域，这方面的发展也很迅速。有一些商业化软件或云服务(比如 Autodesk 的 123D)，已经能从若干张照片重建出所拍摄物体的三维模型。该方法的问题是需要物体本身已经存在，而且重建的三维模型的精度有限。</p>\n<p>l 基于扫描点云（深度图像如 Kinect、结构光扫描、激光扫描、LiDAR 扫描等）的建模(Reconstruction)方法。随着深度相机的出现及扫描仪的价格迅速下降，人们采集三维数据变得容易，从采集到的三维点云来重建三维模型的工作在最近几年的 Siggraph(Asia)上能常见到。但是，单纯的重建方式存在精度低、稳定性差和运算量大等不足，远未能满足实际的需求。</p>\n<p>l 基于现有模型来合成建模的方法。随着三维模型的逐渐增多，可以利用现有的三维模型通过简单的操作，比如 cut and paste，或者分析及变形等手段，来拼接或合成新的三维模型。这种通过“学习”模型数据库的知识来进行建模的手段在近 3-5 年里研究得非常热门。从某方面来讲，就是“大数据时代”背景下计算机图形学领域中的一个具体的表现。</p>\n<p>除了上述的这些建模方法，还有其他的一些建模方法，在此不再一一列举。</p>\n<p>在对三维几何模型的构建过程中，还会涉及到很多需要处理的几何问题，比如数据去噪(denoising or smoothing)、补洞(repairing)、简化(simplification)、层次细节(level of detail)、参数化(parameterization)、变形(deformation or editing)、分割(segmentation)、形状分析及检索(shape analysis and retrieval)等。这些问题构成“数字几何处理”的主要研究内容。笔者自 2005 年起开设了多年的《数字几何处理》的研究生课程：</p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm\">http://staff.ustc.edu.cn/~lgliu/Courses/DGP_2012_spring-summer/default.htm</a></p>\n<p>虽然有上述所提到的这么多的三维建模方式，但是至今为止，仍没有适合一般家庭用户的轻松简单的建模工具。现有的电子设备（比如相机，手机等）能够帮助人们轻松获得图像和视频，但是，不是人人都有能力来构建三维几何模型。如何让大众能够像获取图像那样能够随时随地地获取或者构建三维模型，仍然是计算机图形学的任重道远的主要任务之一！今天，计算机图形学仍未进入“大数据时代”。只有让大众能够轻松进行三维建模，并上载分享他们所构建的模型数据，计算机图形学才可能进入大数据时代。</p>\n<p>另外，随着三维打印(3D printing)的新兴技术的逐渐普及，人们对三维模型的需求也日益增加。笔者个人认为，几何建模和三维打印的未来是共呼吸，同命运的：也只有当人人都能轻松建模时，三维打印才有可能走向千家万户。</p>\n<p>三维几何建模的任务仍然任重道远，大家仍需共同努力！</p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image002.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image004.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image006.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image008.jpg\" alt=\"img\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image010.jpg\" alt=\"img\"></p>\n<p><strong>2、 渲染(Rendering)</strong></p>\n<p>有了三维模型或场景，怎么把这些三维几何模型画出来，产生令人赏心悦目的真实感图像？这就是传统的计算机图形学的核心任务，在计算机辅助设计，影视动漫以及各类可视化应用中都对图形渲染结果的高真实感提出了很高的要求。</p>\n<p>上个世纪 80-90 年代研究的比较多些，包含了大量的渲染模型，包括局部光照模型(Local Illumination Model)、光线跟踪算法(Ray Tracing)、辐射度(Radiosity)等，以及到后面的更为复杂、真实、快速的渲染技术，比如全局光照模型(Global Illumination Model)、Photo mapping、BTF、BRDF、以及基于 GPU 的渲染技术等。</p>\n<p>现在的渲染技术已经能够将各种物体，包括皮肤、树木、花草、水、烟雾、毛发等渲染得非常逼真。一些商业化软件（比如 Maya, Blender, Pov Ray 等）也提供了强大的真实感渲染功能，在计算机图形学研究论文中作图中要经常用到这些工具来渲染漂亮的展示图或结果图。</p>\n<p>然而，已知的渲染实现方法，仍无法实现复杂的视觉特效，离实时的高真实感渲染还有很大差距，比如完整地实现适于<a href=\"http://baike.baidu.com/view/2382.htm\">电影</a>渲染（高真实感、高分辨率）制作的 RenderMan 标准，以及其他各类基于物理真实感的实时渲染算法等。因此，如何充分利用 GPU 的计算特性，结合分布式的集群技术，从而来构造低功耗的渲染服务是发展趋势之一。</p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image012.gif\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image014.jpg\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image016.jpg\"></p>\n<p><img src=\"img/article/20210926-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/image018.jpg\"></p>\n<p><strong>3、 动画(Animation)</strong></p>\n<p>动画是采用连续播放静止图像的方法产生物体运动的效果。计算机动画借助于编程或动画制作软件生成一系列的景物画面，是计算机图形学的研究热点之一。研究方向包括：物理仿真(simulation)，人体动画，关节动画，运动动画，脚本动画，具有人的意识的虚拟角色的动画系统等。另外，高度物理真实感的动态模拟，包括对各种形变、水、气、云、烟雾、燃烧、爆炸、撕裂、老化等物理现象的真实模拟，也是动画领域的主要问题。这些技术是各类动态仿真应用的核心技术，可以极大地提高虚拟现实系统的沉浸感 （其中的本质是数值求解各种偏微分方程）。计算机动画的应用领域广泛，比如动画片制作，广告、 电影特技，训练模拟，游戏等。</p>\n<p>网上的一些 3D 动画的视频：</p>\n<p>Larva 虫虫: <a href=\"http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html\">http://v.youku.com/v_show/id_XMzAzMzkxMTY0.html</a></p>\n<p>The Killer Bean: <a href=\"http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html\">http://v.youku.com/v_show/id_XMjI5ODE2MTEy.html</a></p>\n<p>爱与孝: <a href=\"http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html\">http://v.youku.com/v_show/id_XNTU0OTUxNjUy.html</a></p>\n<p>房地产动画广告宣传片: <a href=\"http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html\">http://v.youku.com/v_show/id_XNTc1OTE4MDMy.html</a></p>\n<p><strong>4、 人机交互(Human–Computer Interaction, HCI)</strong></p>\n<p>人机交互（Human-Computer Interaction, 简写 HCI）是指人与计算机之间以一定的交互方式或交互界面，来完成确定任务的人与计算机之间的信息交换过程。简单来讲，就是人如何通过一定的交互方式告诉计算机来完成他所希望完成的任务。</p>\n<p>计算机图形学的顶级会议 ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”的缩写，缩写中只包含了 Graphics，而忽略了 Interactive Techniques，在长时间没有得到计算机图形学研究的重视。最近，包括在 SIGGRAPH 会议上，以及人机交互的顶级会议 SIGCHI 上，陆续出现了许多新兴的人机交互技术及研究论文。大家逐渐重视起来。</p>\n<p>在早期（上个世纪 60-70 年代），只有以键盘输入的字符界面；到了 80 年代，以 WIMP(窗口、图符、菜单、鼠标)为基础的图形用户界面(GUI)逐渐成为当今计算机用户界面的主流。</p>\n<p>近年来，以用户为中心的系统设计思想，增进人机交互的自然性，提高人机交互的效率是用户界面的主要研究方向。陆续提出了多通道用户界面的思想，它包括语言、姿势输入、头部跟踪、视觉跟踪、立体显示、三维交互技术、感觉反馈及自然语言界面等。</p>\n<p>事实上，人体的表面本身就是人机界面。人体的任何部分（姿势，手势，语言，眼睛，肌肉电波，脑波等）都可以成为人机对话的通道。比如 2010 年微软出的 Kinect 就是一种无需任何操纵杆的基于体感的人机界面，用户本身就是控制器。Kinect 在微软的 Xbox 游戏上取得了极大的成功，之后在其他方面也得到了很多的应用。</p>\n<p>特别是到了今年（2013 年），人机交互设备有了巨大的发展，各种自然的交互手段层出不穷，极大地丰富了用户与机器交互的体验，方便了用户的操作，轻松表达了用户的交互意图。可以说，</p>\n<p><strong>我们正处在图形与交互技术极速发展的浪尖！</strong></p>\n<p>以下是最近几年（特别是今年）出现的一些值得关注的新兴的人机交互设备：</p>\n<p>l Microsoft Kinect：<a href=\"http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html\">http://v.youku.com/v_show/id_XNTc2ODY0MTA4.html</a></p>\n<ol>\n<li><p> Kinect 由微软于 2010 年推出的对 XBOX360 体感外设，它不需要使用任何控制器，仅依靠相机捕捉三维空间中玩家的运动，同时它导入了即时动态捕捉、影像辨识、麦克风输入、语音辨识、社群互动等功能。Kinect 彻底颠覆了游戏的单一操作。使人机互动的理念更加彻底的展现出来。之后，基于 Kinect 的各种应用像雨后春笋般的冒出来，包括人机交互，手势识别，几何建模等。</p>\n</li>\n<li><p> 在 2013 年 5 月 28 日的 Xbox One 发布会上，微软展示了新一代 Kinect 2.0，新 Kinect 能感知的语音、手势和玩家感觉信息，将给玩家带来前所未有的互动性体验：</p>\n</li>\n</ol>\n<p><a href=\"http://v.youku.com/v_show/id_XNTIyODU0NDky.html\">http://v.youku.com/v_show/id_XNTIyODU0NDky.html</a></p>\n<p>l Leap Motion：<a href=\"http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html\">http://v.youku.com/v_show/id_XNTAwMzg0MTQw.html</a></p>\n<p>Leap Motion 为放在键盘和显示器之间的小小金属棒，就能让任何一位用户通过简单的手势完成人机交互。Leap Motion 的响应惊人的准确，对各种自然而简洁的手势都能识别。不必站起来或者摆动手臂，Leap Motion 是简单而毫不费力的交互方式。我们在 4 月份就预订了一台，到现在还未到货，估计要到下个月到货。到货后我们会对其进行评测。</p>\n<p>l MYO：<a href=\"http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html\">http://v.youku.com/v_show/id_XNTYzNzg3MDA0.html</a></p>\n<p>MYO 是一款能在用户挥动并指向屏幕时测量各种肌肉产生的电活动来完成交互的腕带。MYO 超越 Leap Motion 的一点是，MYO 对用户的位置没有限制。尽管 MYO 只听令于身体的一个部分（手臂），但是其应用的场合还是很多的。期望未来会有更多的听令于身体的其他部分的交互设备。</p>\n<p>l Google Glass：<a href=\"http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html\">http://v.youku.com/v_show/id_XNTYzNzk1NjIw.html</a></p>\n<p>Google Glass 为 Google 公司在 2012 的 I/O 开发者大会上正式公布的，在看起来普普通通的眼镜上配置强大的计算机和显示器。这款设备小巧而不显眼，可以在任何时间地点使用，即用户想要专注于周围环境时不会碍事。不过对其未来的发展各有说法，让我们拭目以待。</p>\n<p>l 3D Printer：这个就不用笔者详细说了，这两年太火了。正如上面所提到的观点，笔者觉得 3D 打印的出现带给了我们从事计算机图形学研究的工作者许多的机会。挑战和机会并存！我们应该要抓住这次机会！</p>\n<p>l 3Doodler：<a href=\"http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html\">http://v.youku.com/v_show/id_XNTE2MjM5NzUy.html</a></p>\n<p>3Doodler 是玩具和机器人公司 Wobble Works 开发的全球首款“3D 打印笔”，可以帮助人们在半空中创造出三维结构的模型。今后人们可以在三维空间中来“画图”交流和表达想法了。</p>\n<p>l Apple iWatch：<a href=\"http://v.youku.com/v_show/id_XNTIwODk0MzM2.html\">http://v.youku.com/v_show/id_XNTIwODk0MzM2.html</a></p>\n<p>iWatch 由苹果公司推出的一款智能手表。现在仍是概念产品，面世时间未定。其界面看看视频就知道有多酷。但是其技术上的实现笔者也没有完全想通，呵呵。</p>\n<p>除了上述介绍的外，最近还有其他很多新的人机交互类的电子科技产品，比如透明手机，可折叠的屏幕，具有气味和触感反馈的头盔等，就不一一介绍了。</p>\n<p>由此可见，以前在科幻电影里出现的“神器”逐渐被实现，计算机图形学及相关技术在其中发挥了重要的作用。同时，这些设备的出现，也带给了计算机图形学领域更多的探索和机会。</p>\n<p><strong>5、 其他内容</strong></p>\n<p>上述所提到的只是计算机图形学的主要的四个内容。事实上，与计算机图形学相关的学科还有很多，以下仅介绍几个最为相关的研究方向：</p>\n<p>l 虚拟现实(Virtual Reality)：利用计算机图形产生器，位置跟踪器，多功能传感器和控制器等有效地模拟实际场景和情形，从而能够使观察者产生一种真实的身临其境的感觉。虚拟现实技术主要研究用计算机模拟（构造）三维图形空间，并使用户能够自然地与该空间进行交互。对三维图形处理技术的要求特别高。简单的虚拟现实系统早在 70 年代便被应用于军事领域，训练驾驶员。80 年代后随着计算机软硬件技术的提高，它也得到重视并迅速发展。它已在航空航天、医学、教育、艺术、建筑等领域得到初步的应用。</p>\n<p>l 可视化(Visualization)：利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，并进行交互处理的理论、方法和技术。现已成为研究数据表示、数据处理、决策分析等一系列问题的综合技术。上面提到的虚拟现实技术也是以图形图像的可视化技术为依托的。在现在的大数据时代的背景下，可视化的内容除了传统的科学可视化外，现在还有信息可视化，可视分析等方面。</p>\n<p>l 可视媒体计算与处理(Visual Media Processing)：几何数据，被认为是继声音、图像、视频之后的新一代数字媒体，是计算机图形学的研究重点。最近几年，计算机图形学与图像视频处理技术相结合的研究与技术日益增多。正如笔者在上面所提及的，图像和视频的大数据处理能带给计算机图形学很多处理手段上的更新。另一方面，随着而计算机图形学技术，恰可以与这些图像处理，视觉方法相交叉融合，来直接地生成风格化的画面，实现基于图像三维建模，以及直接基于视频和图像数据来生成动画序列。当计算机图形学正向地图像生成方法和计算机视觉中逆向地从图像中恢复各种信息方法相结合，可以带来无可限量的想象空间，构造出很多视觉特效来，最终用于增强现实、数字地图、虚拟博物馆展示等多种应用中去。因此，在很多方面，计算机图形学与图像处理、视频处理、多媒体处理、计算机视觉等学科逐渐融合在一起，有成为一个更大的学科的趋势。</p>\n<p>l 医学图像处理(Medical Imaging)：随着医学成像技术的发展与进步，图像处理在医学研究与临床医学中的应用越来越广泛。与一般意义上的图像处理比较，医学图像处理有其特殊性和不同的侧重点。医学图像处理由生物医学成像(X 射线、CT、MRI)和生物医学图像处理两部分组成，在生命科学研究、医学诊断、临床治疗等方面起着重要的作用。医学图像分析中涉及的两个最为重要的内容为图像分割与图像配准。</p>\n<p>l 计算机艺术(Computational Arts)：计算机图形学的发展也提供给了艺术家发挥和实现想象的丰富的技术手段。计算机艺术的发展速度远远超出了人们的想象，在代表计算机图形研究最高水平的历届 SIGGRAPH 年会上，精彩的计算机艺术作品层出不穷。在计算机图形学领域，还有几个关于计算艺术方面的会议，包括非真实性图形学(Non-Photorealistic Graphics)和 Computational Aesthetics(计算美学)等。吸引了计算机工作者、艺术家、建筑师、设计师等方面的人员在一起，通过头脑风暴和交流讨论的方式进行一些有创意的技术研究。</p>\n<p><strong>三、 学习计算机图形学需要哪些基础？</strong></p>\n<p>计算机图形学是一门与很多学科都交叉的学科方向。因此，要学好计算机图形学和做好计算机图形学方面的研究，除了计算机图形学的基础知识以外，你还需要有其他方面的一些知识。当然你懂得越多当然会越好。</p>\n<p><strong>1、 数学</strong></p>\n<p>计算机图形学进入我国大概在上个世纪 70 年代末和 80 年代初，那时国内还没有计算机学科。于是，开始学习和研究计算机图形学的大部分都是搞数学的一些学者和教授。由此可见，计算机图形学是需要数学知识较多的一门计算机应用技术学科，在我国也是应用数学的一个重要分支（国内的很多高校和科研院所的数学专业都有计算机图形学方向）。</p>\n<p>计算机图形学里面用到的数学比较多，列举一些常用的，包括：微积分、线性代数、矩阵计算、微分几何、数值计算和分析、计算方法、偏微分方程、微分方程数值解、最优化、概率、统计、计算几何等。</p>\n<p>计算机图形学领域的一位优秀学者 Greg Turk 教授在 1997 年曾写过一篇“计算机图形学中的数学”(Mathematics for Computer Graphics)的帖子，详细可见：</p>\n<p><a href=\"http://www.cc.gatech.edu/~turk/math_gr.html\">http://www.cc.gatech.edu/~turk/math_gr.html</a></p>\n<p>其中文翻译版本可见：</p>\n<p><a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm\">http://staff.ustc.edu.cn/~lgliu/Resources/CG/Math_for_CG_Turk_CN.htm</a></p>\n<p>笔者在多年从事计算机图形学研究中对数学的体会是：“数学不是没有用，而是不够用！”。对数学的学习和应用将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解其中的数学思想和数学方法。</p>\n<p>另一方面，想成为一名计算机图形学的研究者也不必精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？以上提到的常用的数学课程你不必都要熟悉，许多研究工作者从不需要考虑其中提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！</p>\n<p>总之，关于计算机图形学与数学的关系，归纳起来就是以下几个原则：</p>\n<p>l 计算机图形学的研究需要用到较多的数学知识，有较好数学功底的学生从事计算机图形学有一定优势；</p>\n<p>l 即使没有学太多的数学也不要紧。数学的知识不需要都学会了再去做问题，在解决问题的过程中去学习数学是最快的学习方法。即，研究过程中若遇到什么数学知识再去学相关的知识，学习起来会更有兴趣，掌握起来会更快更扎实；</p>\n<p>l 学习数学要结合图形，即“数形结合”，需要有图形的想象能力；数学公式不重要，是“纸老虎”，重要的是背后的思想及其所表达的概念，公式只是它们的一个抽象表达；</p>\n<p>l 活到老，学到老。要不断学习新的知识和技术，使自己不断进步和增长功力，才是王道。</p>\n<p><strong>2、 编程</strong></p>\n<p>在计算机图形学中，大部分的想法都要通过实际例子来验证的，再好的理论也要拿实际例子来得到验证和应用。因此，利用编程语言来实现想法或算法是必须要有的能力。C/C++是计算机图形学最常用的编程语言。</p>\n<p>笔者要求学生必须掌握 C++编程语言和面向对象编程思想，这是大家通用的“语言”。网上的大部分的资源、类库、算法代码基本上都是 C++写的，因此，你若需要利用这些资源，必须掌握甚至精通 C++语言。</p>\n<p>关于计算机图形学所需要的编程能力的几点看法：</p>\n<p>l 从事计算机图形学和图像处理的研究需要有较强的编程能力，要对编程有极大的兴趣和热情；</p>\n<p>l 如果你对编程比较“感冒”或“厌恶”，则建议你不要选择计算机图形学方向；</p>\n<p>l 不太会编程不要紧，任何人都是从不会到会的！只要你对编程有兴趣，觉得编程“好玩”，您完全可以在很短的时间内极大地提高您的编程水平。笔者在长期的教学实验和科研过程中，摸索和发展出一套有效的方法，能够在最短的时间内，帮助学生（包括数学专业的学生）快速提高编程的能力。</p>\n<p><strong>3、 其他</strong></p>\n<p>l 英语基础要好，因为需要大量阅读英文文献和进行英文论文的写作；英文的听说能力也要好些，因为要跟国际学者交流讨论；</p>\n<p>l 计算机图形学中的很多算法是真实物理世界的模拟，因此，如果你要进行基于物理的建模和仿真，一些物理知识和理论也需要的，比如力学（动力学，运动学，流体力学）和光学等；</p>\n<p>l 其他学科的知识，根据具体研究的需要去学习即可，不必刻意去提前学多少。</p>\n<p><strong>4、 计算机图形学的教材</strong></p>\n<p>上面列举的只是在你从事计算机图形学的学习和研究中可能要用到的东西，不必所有的都学会才能开始计算机图形学的学习和研究。一门知识点不懂不要紧，重要的是要能尽快学习新知识的能力和速度！事实上，最好的学习方法就是在使用中学习。因此，计算机图形学的学习和研究提供了你学习其他相关知识的好的过程。</p>\n<p>现在市面上的计算机图形学的教材有很多，但是很多教材的内容仅仅是计算机图形学的基本知识，知识点也比较陈旧。不能指望通过一本或几本教材就能学会计算机图形学。计算机图形学的内容远比教材中或你想象中的内容多得多。正如笔者上面所述，计算机图形学作为一门技术科学，特别是在当前的互联网、移动互联网、大数据时代及第三次工业革命的时代背景下，最近几年的发展日新月异！务必要通过跟着老师做相关研究来了解计算机图形学最新的发展和趋势。除了阅读最新的最新的科研论文外，还需要不断关注信息科技及电子科技的一些前沿发展。要相信，计算机图形学是好玩的，是有用的，更是有未来的！充满热情和激情，才能做好计算机图形学方面的研究。</p>\n<p><strong>四、SIGGRAPH 简介</strong></p>\n<p>说到计算机图形学，不能不提 SIGGRAPH。</p>\n<p>ACM SIGGRAPH 是“ACM Special Interest Group on GRAPHics and Interactive Techniques”（<a href=\"http://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E4%BC%9A\">美国计算机协会</a>计算机图形专业组）的缩写，成立于 1967 年，致力于推广和发展计算机绘图和动画制作的软硬件技术。从 1974 年开始，ACM SIGGRAPH 每年都会举办一次年会（也称为 SIGGRAPH），至今年已经举办了 40 次。SIGGRAPH 是计算机图形学顶级年度会议，代表着世界级水平的研究，能在 SIGGRAPH 上发表论文是许多从事计算机图形学研究的工作者的梦想。</p>\n<p>SIGGRAPH 每年 7 月底或 8 月初在美国召开（2011 年在加拿大温哥华召开，是 SIGGRAPH 首次在美国以外的城市举行）。事实上，SIGGRAPH 是世界上影响最广、规模最大，同时也是最权威的一个集科学、艺术、商业于一身的 CG 展示、学术研讨会，参会人数众多，一般有 2–4 万人。绝大部分计算机图技术软硬件厂商每年都会将最新研究成果拿到 SIGGRAPH 年会上发布，大部分游戏的<a href=\"http://baike.baidu.com/view/217213.htm\">电脑动画</a>创作者也将他们本年度最杰出的艺术作品集中在 SIGGRAPH 上展示。因此，SIGGRAPH 在图形图像技术，计算机软硬件以及 CG 等方面都有着相当的影响力。</p>\n<p>从 2008 年开始，Siggraph 来到亚洲，每年冬天（11 或 12 月）在亚洲的一个城市（2008，新加坡；2009，日本<a href=\"http://baike.baidu.com/view/72581.htm\">横滨</a>；2010，韩国<a href=\"http://baike.baidu.com/view/4005.htm\">首尔</a>；2011，中国香港；2012，新加坡）召开，称为 SIGGRAPH Asia。今年的 Siggraph Asia 将在 2013 年 11 月 19-22 号于中国香港召开。</p>\n<p>与 SIGGRAPH 一样，发表者 SIGGRAPH Asia 上的研究论文也代表着计算机图形学领域的最前沿和最高水准，所有研究论文都发表在 ACM Transactions on Graphics 期刊上，这是计算机图形学领域唯一的一个 Top (I 区)的学术期刊。可以形象地将 SIGGRAPH 和 SIGGRAPH Asia 分别比喻为计算机图形学领域的“夏季奥运会”和“冬季奥运会”。</p>\n<p>在 SIGGRAPH 会议上，除了研究论文外，还有很多其他内容，比如课程、短文、海报、CG 企业展示、电子剧场、动画节、新型科技展示、艺术画廊、教育等，比你想象得要多得多。很多活动都是并行的，因此你需要每天提前计划好所参加的活动。视觉中国网站的“Siggraph 2007 会议报道”有详尽的关于 Siggraph 2007 年的报道：</p>\n<p><a href=\"http://static.chinavisual.com/storage/topics/39942/index.shtml\">http://static.chinavisual.com/storage/topics/39942/index.shtml</a></p>\n<p>虽然这是 6 年前的 Siggraph 介绍，但上述链接的内容仍然是对 SIGGRAPH 比较全面的介绍。其中有很多视频和材料，详细介绍了 Siggraph 盛会的情况，而且有对计算机图形学的历史发展的介绍。建议详细查看。</p>\n<p><strong>五、其他问题</strong></p>\n<p>1、 如何选择适合自己的工作（研究方向）？</p>\n<p>A: 就两点：兴趣 + 擅长！</p>\n<p>兴趣是第一位的，是否擅长需要尝试和不断学习成长！将学会将自己的天赋发挥到极致！</p>\n<p>2、 自己是否适合学习和从事计算机图形学的研究？</p>\n<p>A: 看看自己是否满足以下两个条件：</p>\n<ol>\n<li><p> 对计算机图形学或图像处理具有强烈的兴趣和激情；</p>\n</li>\n<li><p> 喜欢算法设计和编程。</p>\n</li>\n</ol>\n<p>若上述两个条件都满足（觉得好玩！），则可以尝试选择计算机图形学作为自己的研究方向。</p>\n<p>3、 从事研究工作需要哪些品质？</p>\n<p>A: 激情、好奇心、努力！</p>\n<p>4、 为何选择从事研究工作？</p>\n<p>A: <a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar\">http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/GCL-WhyResearch.rar</a></p>\n<p>5、 如何在研究生期间取得成功？</p>\n<p>A: <a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar\">http://staff.ustc.edu.cn/~lgliu/Resources/ForMyStudents/HowToSucceedAtGCL.rar</a></p>\n<p><strong>六、更多参考材料</strong></p>\n<p>l 有关更多地了解计算机图形的知识和内容，可搜索并参考 Internet 上的丰富的资源介绍，比如<a href=\"http://baike.baidu.com/view/13769.htm\">百度百科</a>，<a href=\"http://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6\">维基百科</a>等。本文的写作过程中也参考了网上的许多资源。</p>\n<p>l 国外和国内有很多有关《计算机图形学》的课程网站，可以通过查看相关视频和课件更多地了解计算机图形学的内容。</p>\n<p>l 国内外有很多从事计算机图形学研究的教授学者的网站，会列出他们所做的有关计算机图形学方面的研究，可以更为深入了解计算机图形学领域所研究的东西。</p>\n<p>l 与计算机其他学科一样，每年都有计算机图形学方面的很多会议。这些会议会有该领域的最新进展和研究工作，是了解计算机图形学发展及趋势的重要手段。在计算机图形学方面，可以通过以下链接来获得各个会议的信息<a href=\"http://kesen.realtimerendering.com/\">http://kesen.realtimerendering.com/</a> 建议加该链接为你的浏览器的标签。</p>\n<p>l Internet 上经常会有计算机图形学相关的科技信息，要有意识经常关注，随时了解该学科方向的动态、发展和未来。</p>\n<p>l 计算机图形学及相关学科在近些年来得到迅速的发展，特别是 2013 年出现的各种交互人机交互技术的出现，我们正处在技术极速发展的浪尖！计算机图形学前景诱人，形势逼人。相对于美国等西方国家，我国的计算机图形学相关产业还相对落后，但这正是留给我们这代人的机会！相信通过我们的努力，是可以逐渐缩短差距的，也带来了巨大的挑战和机会。</p>\n<p>l 最后，要相信，计算机图形学是很好玩的，是有用的，更是有未来的。“相信是成功的开始”。祝各位能够感受计算机图形的美妙，能够在计算机图形学的海洋中享受快乐和成功！J</p>\n<p>祝您健康、快乐、成功！</p>\n<p>刘利刚</p>\n<p>中国科学技术大学图形与几何计算实验室(<a href=\"http://gcl.ustc.edu.cn/\">http://gcl.ustc.edu.cn</a>)</p>\n<p>个人主页：<a href=\"http://staff.ustc.edu.cn/~lgliu\">http://staff.ustc.edu.cn/~lgliu</a></p>\n<p>电子邮箱：<a href=\"mailto:lgliu@ustc.edu.cn\">lgliu@ustc.edu.cn</a></p>\n<p>2013 年 8 月 8 日</p>\n<hr>\n<p>【2016 年 9 月 9 日添加】刘永进. 中国计算机图形学研究进展[J]. 科技导报, 2016, 34(14): 76-85. [<a href=\"http://www.kjdb.org/CN/10.3981/j.issn.1000-7857.2016.14.009\">link</a>] [<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201609_ProgressCG-China.pdf\">PDF, 5.1M</a>]</p>\n<p>【2018 年 8 月 16 日添加】AMiner. 计算机图形学研究报告. [<a href=\"https://www.aminer.cn/\">link</a>] [<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey.pdf\">PDF, 3.5M</a>][<a href=\"http://staff.ustc.edu.cn/~lgliu/Resources/CG/download/201808_Aminer-CGSurvey-PPT.pdf\">PPT, 2.3M</a>]</p>\n<p>【2020 年 7 月 14 日添加】GAMES：计算机图形学的在线学习和交流平台，其中有大量的课程、报告（均有 PPT 和录频等）。[<a href=\"http://games-cn.org/\">link</a>]</p>\n<p>计算机图形学基础课程推荐（含课程录频和 PPT 等）：</p>\n<ul>\n<li>GAMES 101（闫令琪）[<a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">link</a>]</li>\n<li>中国科学技术大学《计算机图形学》本科课程-2020 年（刘利刚）[<a href=\"http://staff.ustc.edu.cn/~lgliu/Courses/ComputerGraphics_2020_spring-summer/default.htm\">link</a>]</li>\n</ul>\n<hr>\n<p>版权所有@刘利刚</p>"},{"title":"mysql查询数据库内全部表名；查询表内全部字段名","date":"2022-04-13T13:15:13.000Z","reprint":false,"cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/mysql.png"],"_content":"\n# mysql 查询数据库内全部表名；查询表内全部字段名\n\n<!--more-->\n\n## 查询数据库内全部表名\n\n```sql\nSELECT\n\tTABLE_NAME\n\tFROM\n\tINFORMATION_SCHEMA.TABLES\nWHERE\n\tTABLE_TYPE = 'BASE TABLE'\n\tAND TABLE_SCHEMA = '库名'\n```\n\n## 查询表内全部字段名\n\n```sql\nSELECT\n\tCOLUMN_NAME\n\tFROM\n\tINFORMATION_SCHEMA.TABLES.COLUMNS\nWHERE\n\tTABLE_NAME = '表名'\n\tAND TABLE_SCHEMA = '库名'\n```\n","source":"_posts/20220413-mysql查询数据库内全部表名；查询表内全部字段名.md","raw":"---\ntitle: mysql查询数据库内全部表名；查询表内全部字段名\ndate: 2022-04-13 21:15:13\nreprint: false\ntags: -DB\ncategories: -mysql\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/mysql.png\n---\n\n# mysql 查询数据库内全部表名；查询表内全部字段名\n\n<!--more-->\n\n## 查询数据库内全部表名\n\n```sql\nSELECT\n\tTABLE_NAME\n\tFROM\n\tINFORMATION_SCHEMA.TABLES\nWHERE\n\tTABLE_TYPE = 'BASE TABLE'\n\tAND TABLE_SCHEMA = '库名'\n```\n\n## 查询表内全部字段名\n\n```sql\nSELECT\n\tCOLUMN_NAME\n\tFROM\n\tINFORMATION_SCHEMA.TABLES.COLUMNS\nWHERE\n\tTABLE_NAME = '表名'\n\tAND TABLE_SCHEMA = '库名'\n```\n","slug":"mysql查询数据库内全部表名；查询表内全部字段名","published":1,"updated":"2022-04-13T13:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x12000dy4w11q2f1db0","content":"<h1 id=\"mysql-查询数据库内全部表名；查询表内全部字段名\"><a href=\"#mysql-查询数据库内全部表名；查询表内全部字段名\" class=\"headerlink\" title=\"mysql 查询数据库内全部表名；查询表内全部字段名\"></a>mysql 查询数据库内全部表名；查询表内全部字段名</h1><span id=\"more\"></span>\n\n<h2 id=\"查询数据库内全部表名\"><a href=\"#查询数据库内全部表名\" class=\"headerlink\" title=\"查询数据库内全部表名\"></a>查询数据库内全部表名</h2><pre><code class=\"sql\">SELECT\n    TABLE_NAME\n    FROM\n    INFORMATION_SCHEMA.TABLES\nWHERE\n    TABLE_TYPE = &#39;BASE TABLE&#39;\n    AND TABLE_SCHEMA = &#39;库名&#39;\n</code></pre>\n<h2 id=\"查询表内全部字段名\"><a href=\"#查询表内全部字段名\" class=\"headerlink\" title=\"查询表内全部字段名\"></a>查询表内全部字段名</h2><pre><code class=\"sql\">SELECT\n    COLUMN_NAME\n    FROM\n    INFORMATION_SCHEMA.TABLES.COLUMNS\nWHERE\n    TABLE_NAME = &#39;表名&#39;\n    AND TABLE_SCHEMA = &#39;库名&#39;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"mysql-查询数据库内全部表名；查询表内全部字段名\"><a href=\"#mysql-查询数据库内全部表名；查询表内全部字段名\" class=\"headerlink\" title=\"mysql 查询数据库内全部表名；查询表内全部字段名\"></a>mysql 查询数据库内全部表名；查询表内全部字段名</h1>","more":"<h2 id=\"查询数据库内全部表名\"><a href=\"#查询数据库内全部表名\" class=\"headerlink\" title=\"查询数据库内全部表名\"></a>查询数据库内全部表名</h2><pre><code class=\"sql\">SELECT\n    TABLE_NAME\n    FROM\n    INFORMATION_SCHEMA.TABLES\nWHERE\n    TABLE_TYPE = &#39;BASE TABLE&#39;\n    AND TABLE_SCHEMA = &#39;库名&#39;\n</code></pre>\n<h2 id=\"查询表内全部字段名\"><a href=\"#查询表内全部字段名\" class=\"headerlink\" title=\"查询表内全部字段名\"></a>查询表内全部字段名</h2><pre><code class=\"sql\">SELECT\n    COLUMN_NAME\n    FROM\n    INFORMATION_SCHEMA.TABLES.COLUMNS\nWHERE\n    TABLE_NAME = &#39;表名&#39;\n    AND TABLE_SCHEMA = &#39;库名&#39;\n</code></pre>"},{"title":"Cesium中billboard广告牌使用PinBuilder创建的自定义样式地图图钉","date":"2021-08-08T07:16:31.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg","_content":"\n\n\n==============\n\n<!--more-->\n\n\n\n官方文档：\nhttp://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin\n\n1. HTMLCanvasElement.toDataURL()方法返回一个包含图片展示的 data URI （可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi）。\n2. 将生成的dataURI直接添加到billboard的image属性进行配置。\n3. 添加heightReference: Cesium.HeightReference.CLAMP_TO_GROUND属性，实现billboard贴地形。\n\n\n\n```js\n\tlet pinBuilder = new Cesium.PinBuilder();\n    let pinURI = pinBuilder.fromText(\"展示的内容\", Cesium.Color.GREEN, 48).toDataURL();\n    this.GLOBAL.viewer.entities.add({\n      name: name,\n      position: Cesium.Cartesian3.fromDegrees(lng, lat),\n      billboard: {\n        image: pinURI,\n        width: 64,\n        height: 64,\n        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND //广告牌贴地形\n      }\n    });\n```\n\n\n图一 官网示例的各种样式\n\n![](https://img-blog.csdnimg.cn/img_convert/3d5febef80be0aeb0eab37bf4bec7ecf.png#pic_center)","source":"_posts/Cesium中billboard广告牌使用PinBuilder创建的自定义样式地图图钉-20210808.md","raw":"---\ntitle: Cesium中billboard广告牌使用PinBuilder创建的自定义样式地图图钉\ndate: 2021-08-08 15:16:31\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Cesium.jpeg\ntags:\n- Cesium\ncategories:\n- Cesium\n---\n\n\n\n==============\n\n<!--more-->\n\n\n\n官方文档：\nhttp://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin\n\n1. HTMLCanvasElement.toDataURL()方法返回一个包含图片展示的 data URI （可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi）。\n2. 将生成的dataURI直接添加到billboard的image属性进行配置。\n3. 添加heightReference: Cesium.HeightReference.CLAMP_TO_GROUND属性，实现billboard贴地形。\n\n\n\n```js\n\tlet pinBuilder = new Cesium.PinBuilder();\n    let pinURI = pinBuilder.fromText(\"展示的内容\", Cesium.Color.GREEN, 48).toDataURL();\n    this.GLOBAL.viewer.entities.add({\n      name: name,\n      position: Cesium.Cartesian3.fromDegrees(lng, lat),\n      billboard: {\n        image: pinURI,\n        width: 64,\n        height: 64,\n        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND //广告牌贴地形\n      }\n    });\n```\n\n\n图一 官网示例的各种样式\n\n![](https://img-blog.csdnimg.cn/img_convert/3d5febef80be0aeb0eab37bf4bec7ecf.png#pic_center)","slug":"Cesium中billboard广告牌使用PinBuilder创建的自定义样式地图图钉-20210808","published":1,"updated":"2022-04-07T17:25:27.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x13000fy4w18irm0g5f","content":"<p>==============</p>\n<span id=\"more\"></span>\n\n\n\n<p>官方文档：<br><a href=\"http://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin\">http://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin</a></p>\n<ol>\n<li>HTMLCanvasElement.toDataURL()方法返回一个包含图片展示的 data URI （可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi）。</li>\n<li>将生成的dataURI直接添加到billboard的image属性进行配置。</li>\n<li>添加heightReference: Cesium.HeightReference.CLAMP_TO_GROUND属性，实现billboard贴地形。</li>\n</ol>\n<pre><code class=\"js\">    let pinBuilder = new Cesium.PinBuilder();\n    let pinURI = pinBuilder.fromText(&quot;展示的内容&quot;, Cesium.Color.GREEN, 48).toDataURL();\n    this.GLOBAL.viewer.entities.add(&#123;\n      name: name,\n      position: Cesium.Cartesian3.fromDegrees(lng, lat),\n      billboard: &#123;\n        image: pinURI,\n        width: 64,\n        height: 64,\n        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND //广告牌贴地形\n      &#125;\n    &#125;);\n</code></pre>\n<p>图一 官网示例的各种样式</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3d5febef80be0aeb0eab37bf4bec7ecf.png#pic_center\"></p>\n","site":{"data":{}},"excerpt":"<p>==============</p>","more":"<p>官方文档：<br><a href=\"http://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin\">http://cesium.xin/cesium/cn/Documentation1.72/PinBuilder.html?classFilter=pin</a></p>\n<ol>\n<li>HTMLCanvasElement.toDataURL()方法返回一个包含图片展示的 data URI （可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi）。</li>\n<li>将生成的dataURI直接添加到billboard的image属性进行配置。</li>\n<li>添加heightReference: Cesium.HeightReference.CLAMP_TO_GROUND属性，实现billboard贴地形。</li>\n</ol>\n<pre><code class=\"js\">    let pinBuilder = new Cesium.PinBuilder();\n    let pinURI = pinBuilder.fromText(&quot;展示的内容&quot;, Cesium.Color.GREEN, 48).toDataURL();\n    this.GLOBAL.viewer.entities.add(&#123;\n      name: name,\n      position: Cesium.Cartesian3.fromDegrees(lng, lat),\n      billboard: &#123;\n        image: pinURI,\n        width: 64,\n        height: 64,\n        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND //广告牌贴地形\n      &#125;\n    &#125;);\n</code></pre>\n<p>图一 官网示例的各种样式</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/3d5febef80be0aeb0eab37bf4bec7ecf.png#pic_center\"></p>"},{"title":"JAVA-IO流","date":"2021-04-08T16:53:58.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# IO 流\n\n<!-- more -->\n\n## 流的概念\n\n内存与存储设备之间传输数据的通道\n\n![image-20210409191717082](img/article/JAVA-IO流-20210417/image-20210409191717082.png)\n\n## 流的分类\n\n### 按方向【重点】\n\n1. 输入流：将<存储设备>中的内容读到<内存>中；\n\n2. 输出流：将<内存>中的内容写到<存储设备>中；\n\n   文件 ---------输入流-----------> 程序 ---------输出流----------->文件\n\n### 按单位\n\n1. 字节流：以字节流为单位，可以读写所有数据；\n2. 字符流：以字符为单位，只能读写文本数据；\n\n### 按功能\n\n1. 节点流：具有实际传输数据的读写功能；\n2. 过滤流：在节点流的基础之上增强功能；\n\n### 字节流\n\n#### 字节流的父类（抽象类）：\n\n1. InputStream 字节输入流\n\n   ```java\n   //InputStream 字节输入流\n   public int read(){}\n   public int read(byte[] b){}\n   public int read(byte[] b, int off, int len){}\n   ```\n\n2. OutStream 字节输出流\n\n   ```java\n   // OutputStream 字节输出流\n   public void write(int n){}\n   public void write(byte[] b){}\n   public void write(byte[] b, int off, int len){}\n   ```\n\n#### 文件字节流\n\n输入流：\n\n```java\n\t\t// 创建文件输出流对象\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-\tworkspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n```\n\n```java\n\n        // 单个字节读取文件\n        int data = 0;\n        while ((data=fis.read()) != -1) {\n            System.out.print((char) data);\n        }\n```\n\n```java\n\t\t// 指定读取个数，每次三个\n\t\tbyte[] buf = new byte[3];\n        int count = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count);\n\n        int count2 = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count2);\n```\n\n```java\n\t\t// 循环读取\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count=fis.read(buf))!=-1) {\n            System.out.println(new String(buf, 0, count));\n        }\n```\n\n```java\n\t\t//关闭\n\t\tfis.close();\n```\n\n输出流：\n\n```java\n\t\t//创建文件输出流对象;\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\bbb.txt\");\n```\n\n```java\n\t\t//写入文件\n        fos.write(97);\n        fos.write('b');\n        fos.write('c');\n```\n\n```java\n \t\t//写入字符串\n        String str = \"helloworld\";\n        fos.write(str.getBytes());\n```\n\n```java\n\t\tfos.close();\n```\n\n#### 图片复制案例\n\n```java\n\t\t//创建流\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.jpg\");\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ccc.jpg\");\n\n        ////边读边写\n        byte[] b = new byte[1024];\n        int count = 0;\n        while ((count = fis.read(b)) != -1) {\n            fos.write(b, 0, count);\n        }\n\n        //关闭\n        fis.close();\n        fos.close();\n```\n\n#### 字节缓冲流\n\n缓冲流：`BufferedInputStream/ BufferedOutputStream`\n\n提高 IO 效率，减少访问磁盘次数；\n\n数据存储在缓冲区中，flush 是将缓冲区的内容写入文件中，也可以直接 close\n\n```java\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n        int data = 0;\n        while ((data=bis.read())!=-1){\n            System.out.print((char) data);\n        }\n\n        //关闭\n        bis.close();\n        fis.close();\n```\n\n缓冲流读文件：\n\n```java\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n//        int data = 0;\n//        while ((data=bis.read())!=-1){\n//            System.out.print((char) data);\n//        }\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count = bis.read(buf))!=-1) {\n            System.out.print(new String(buf, 0, count));\n        }\n\n        //关闭\n        bis.close();\n        fis.close();\n```\n\n缓冲流写文件：\n\n```java\n\t\t//创建缓冲流对象\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ddd.txt\");\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n        //写入文件\n        for (int i = 0; i < 5; i++) {\n            bos.write(\"theworllllld\\n\".getBytes()); //写入缓冲区,缓冲区默认大小为8k\n            bos.flush(); // 刷新到硬盘\n        }\n\n        //关闭,bos.close();会自动调用 bos.flush(), 但异常中断的话会写入失败\n        bos.close();\n```\n\n### 对象流\n\n`ObjectOutputStream / ObjectInputStream`\n\n1. 增强了缓冲区功能\n2. 增强了读写 8 种基本数据类型和字符串的功能\n3. 增强了读写对象的功能\n   1. `readObject()` 从流中读取一个对象\n   2. `writeObject(Object obj)` 向流中写入一个对象\n\n使用流传输对象的过程称为序列化(写入)、反序列化(读取)\n\n#### 序列化\n\n```java\n\t\t// 1. 创建对象流\n        FileOutputStream fos = new \tFileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        // 2. 序列化（写入操作）\n        Student zhangsan = new Student(\"zs\", 20);\n        oos.writeObject(zhangsan);\n        // 3. 关闭\n        oos.close();\n```\n\n#### 反序列化\n\n```java\n\t\t// 1. 创建对象流\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        // 2. 读取文件（反序列化）\n        Student s = (Student)ois.readObject();\n        // 3. 关闭\n        ois.close();\n```\n\n#### 注意事项：\n\n1. 某个类要想序列化必须实现 Serializable 接口；\n2. 序列化类中对象属性要求实现 Serializable 接口；\n3. 序列化版本号 ID`例如 ：private static final long serialVersionUID = -8318741215394696905L;`，保证序列化的类和反序列化的类是同一个类；\n4. 使用 transient 修饰属性，这个属性就不能序列化；\n5. 静态属性不能序列化；\n6. 序列化多个对象，可以借助集合来实现；\n\n### 字符流\n\n```java\n// 传统字节流读取\n    public static void main(String[] args) throws Exception {\n            // 1. 创建FileInputStream对象\n            FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n            // 2. 读取\n            int data = 0;\n            while((data = fis.read()) != -1){\n                System.out.print(((char)data));\n            }\n            // 3. 关闭\n            fis.close();\n    }\n```\n\n#### 字符流的父类\n\n##### `reader` 字符输入流\n\n1. `public int read(){}`\n2. `public int read(char[] c){}`\n3. `public int read(char[] b, int off, int len){}`\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1. 创建FileReader 文件字符输入流\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        // 2. 读取\n        // 2.1 单个字符读取\n        int data = 0;\n        while((data = fr.read()) != -1){\n            System.out.print((char)data);// 读取一个字符\n        }\n\n        char[] buf = new char[2];// 字符缓冲区读取\n        int count = 0;\n        while((count = fr.read(buf)) != -1){\n            System.out.print(new String(buf, 0, count));\n        }\n\n        // 3. 关闭\n        fr.close();\n    }\n```\n\n##### `Writer` 字符输出流\n\n1. `public void write(int n){}`\n2. `public void write(String str){}`\n3. `public void write(char[] c){}`\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1. 创建FileWriter对象\n        FileWriter fw = new FileWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        // 2. 写入\n        for(int i = 0; i < 10; i ++){\n            fw.write(\"写入的内容\");\n            fw.flush();\n        }\n        // 3. 关闭\n        fw.close();\n        System.out.println(\"执行完毕\");\n    }\n```\n\n##### 案例（使用上述方法进行文本复制）\n\n不能复制图片或二进制文件，使用字节流可以复制任意文件\n\n```java\npublic static void main(String[] args) throws Exception{\n        // 1. 创建\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        FileWriter fw = new FileWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        // 2. 读写\n        int data = 0;\n        while((data = fr.read()) != -1){\n            fw.write(data);\n            fw.flush();\n        }\n        // 3. 关闭\n        fw.close();\n        fr.close();\n    }\n```\n\n#### 字符缓冲流\n\n`BufferedReader / BufferedWriter`\n\n高效读写、支持输入换行符、可一次写一行读一行;\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 创建缓冲流\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        BufferedReader br = new BufferedReader(fr);\n        // 读取\n        // 1. 第一种方式\n        char[] buf = new char[1024];\n        int count = 0;\n        while((count = br.read(buf)) != -1){\n            System.out.println(new String(buf, 0, count));\n        }\n        // 2. 第二种方式 一行一行读取\n        String line = null;\n        while((line = br.readLine()) != null){\n            System.out.println(line);\n        }\n\n        // 关闭\n        br.close();\n    }\n```\n\n#### PrintWriter\n\n1. 向文件中写入内容；\n2. 封装了`print() / println()` 方法 支持写入后换行；\n3. 支持数据原样打印；\n\n```java\npublic static void main(String[] args) throws FileNotFoundException {\n        // 1 创建打印流\n        PrintWriter pw = new PrintWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        // 2 打印\n        pw.println(12);\n        pw.println(true);\n        pw.println(3.14);\n        pw.println('a');\n        // 3 关闭\n        pw.close();\n    }\n```\n\n#### 转换流\n\n1. 桥转换流 `InputStreamReader / OutputStreamWriter`\n2. 可将字节流转换为字符流\n3. 可设置字符的编码方式\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1 创建InputStreamReader对象\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        InputStreamReader isr = new InputStreamReader(fis, \"utf-8\");\n        // 2 读取文件\n        int data = 0;\n        while((data = isr.read()) != -1){\n            System.out.print((char)data);\n        }\n        // 3 关闭\n        isr.close();\n    }\n```\n\n```java\n public static void main(String[] args) throws Exception {\n        // 1 创建OutputStreamReader对象\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        OutputStreamWriter osw = new OutputStreamWriter(fos, \"utf-8\");\n        // 2 写入\n        for (int i = 0; i < 10; i++) {\n            osw.write(\"写入内容\\n\");\n            osw.flush();\n        }\n        // 3 关闭\n        osw.close();\n\n    }\n```\n\n## File 类\n\n概念：代表物理盘符中的一个文件或者文件夹\n\n### 分隔符\n\n```java\n\t//分隔符\n    public static void separator() {\n        System.out.println(\"路径分隔符\" + File.pathSeparator);\n        System.out.println(\"名称分隔符\" + File.separator);\n    }\n```\n\n### 文件操作\n\n```java\n//文件操作\n    public static void fileOpen() throws Exception {\n        //创建文件\n        File file = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\file.txt\");\n        if (!file.exists()) {\n            boolean b = file.createNewFile();\n            System.out.println(\"创建结果\" + b);\n        }else {\n            System.out.println(\"文件已存在\");\n        }\n\n        //删除文件-直接删除\n//           System.out.println(file.delete());\n        //删除文件 jvm退出时删除\n//           file.deleteOnExit();\n//           Thread.sleep(5000);\n\n\n        //获取文件绝对路径\n        System.out.println(\"文件绝对路径:\" + file.getAbsolutePath());\n        //获取写的路径\n        System.out.println(file.getPath());\n        //获取文件名称\n        System.out.println(file.getName());\n        //获取父目录\n        System.out.println(file.getParent());\n        //获取文件长度\n        System.out.println(file.length());\n        //获取文件创建时间\n        System.out.println(new Date(file.lastModified()).toLocaleString());\n\n        //判断\n        //是否可写\n        //System.out.println(file.canWrite());  //linux支持\n        //是否可读\n        System.out.println(file.canRead());\n        //是否是文件\n        System.out.println(file.isFile());\n        //是否隐藏\n        System.out.println(file.isHidden());\n\n    }\n```\n\n### 文件夹操作\n\n```java\n//文件夹操作\npublic static void directoryOpe() throws Exception{\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc\");\n        System.out.println(dir.toString());\n        if (!dir.exists()) {\n            //创建单级目录\n//            dir.mkdir();\n            //创建多级目录\n            System.out.println(\"创建结果\" + dir.mkdirs());\n        }\n\n        //删除文件\n        //直接删除\n//        System.out.println(dir.delete()); //只能删除空目录\n        //使用jvm删除\n//        dir.deleteOnExit();\n//        Thread.sleep(3000);\n\n        //获取文件夹信息\n        //获取绝对路径\n        System.out.println(dir.getAbsolutePath());\n        //获取路径\n        System.out.println(dir.getPath());\n        //获取名称\n        System.out.println(dir.getName());\n        //获取父目录\n        System.out.println(dir.getParent());\n        //获取创建时间\n        System.out.println(new Date(dir.lastModified()).toLocaleString());\n\n        //判断\n        //是否是文件夹\n        System.out.println(dir.isDirectory());\n        //是否隐藏\n        System.out.println(dir.isHidden());\n\n        //遍历文件夹\n        File dir2 = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\");\n        String[] dirs = dir2.list();\n        //File[] dirs2 = dir2.listFiles();\n        for (String s : dirs) {\n            System.out.println(s);\n        }\n```\n\n### FileFilter\n\n```java\n// fileFilter接口使用，定制方法遍历\npublic static void main(String[] args) {\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc\");\n\n\n        File[] files = dir.listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                if (pathname.getName().endsWith(\".bin\")){\n                    return true;\n                }\n                return false;\n            }\n        });\n\n        for (File file : files) {\n            System.out.println(file.getName());\n        }\n\n    }\n```\n\n### 递归遍历文件夹\n\n遍历多级文件夹下的文件\n\n```java\npublic static void main(String[] args) {\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\");\n        listDir(dir);\n    }\npublic static void listDir(File dir) {\n\n        File[] files = dir.listFiles();\n        if (files != null && files.length>0) {\n            for (File file : files) {\n                if (file.isDirectory()){\n                    listDir(file);\n                }else {\n                    System.out.println(file.getAbsolutePath());\n                }\n            }\n        }\n    }\n```\n\n### 递归删除文件夹\n\n删除多级文件夹下的文件\n\n```java\npublic static void delDir(File dir) {\n\n        File[] files = dir.listFiles();\n        if (files != null && files.length>0) {\n            for (File file : files) {\n                if (file.isDirectory()){\n                    delDir(file);\n                }else {\n                    System.out.println(file.getAbsolutePath() + \"删除文件\" + file.delete());\n                }\n            }\n        }\n    }\n```\n","source":"_posts/JAVA-IO流-20210417.md","raw":"---\ntitle: JAVA-IO流\ndate: 2021-04-09 00:53:58\ntags:\n  - java基础\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# IO 流\n\n<!-- more -->\n\n## 流的概念\n\n内存与存储设备之间传输数据的通道\n\n![image-20210409191717082](img/article/JAVA-IO流-20210417/image-20210409191717082.png)\n\n## 流的分类\n\n### 按方向【重点】\n\n1. 输入流：将<存储设备>中的内容读到<内存>中；\n\n2. 输出流：将<内存>中的内容写到<存储设备>中；\n\n   文件 ---------输入流-----------> 程序 ---------输出流----------->文件\n\n### 按单位\n\n1. 字节流：以字节流为单位，可以读写所有数据；\n2. 字符流：以字符为单位，只能读写文本数据；\n\n### 按功能\n\n1. 节点流：具有实际传输数据的读写功能；\n2. 过滤流：在节点流的基础之上增强功能；\n\n### 字节流\n\n#### 字节流的父类（抽象类）：\n\n1. InputStream 字节输入流\n\n   ```java\n   //InputStream 字节输入流\n   public int read(){}\n   public int read(byte[] b){}\n   public int read(byte[] b, int off, int len){}\n   ```\n\n2. OutStream 字节输出流\n\n   ```java\n   // OutputStream 字节输出流\n   public void write(int n){}\n   public void write(byte[] b){}\n   public void write(byte[] b, int off, int len){}\n   ```\n\n#### 文件字节流\n\n输入流：\n\n```java\n\t\t// 创建文件输出流对象\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-\tworkspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n```\n\n```java\n\n        // 单个字节读取文件\n        int data = 0;\n        while ((data=fis.read()) != -1) {\n            System.out.print((char) data);\n        }\n```\n\n```java\n\t\t// 指定读取个数，每次三个\n\t\tbyte[] buf = new byte[3];\n        int count = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count);\n\n        int count2 = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count2);\n```\n\n```java\n\t\t// 循环读取\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count=fis.read(buf))!=-1) {\n            System.out.println(new String(buf, 0, count));\n        }\n```\n\n```java\n\t\t//关闭\n\t\tfis.close();\n```\n\n输出流：\n\n```java\n\t\t//创建文件输出流对象;\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\bbb.txt\");\n```\n\n```java\n\t\t//写入文件\n        fos.write(97);\n        fos.write('b');\n        fos.write('c');\n```\n\n```java\n \t\t//写入字符串\n        String str = \"helloworld\";\n        fos.write(str.getBytes());\n```\n\n```java\n\t\tfos.close();\n```\n\n#### 图片复制案例\n\n```java\n\t\t//创建流\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.jpg\");\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ccc.jpg\");\n\n        ////边读边写\n        byte[] b = new byte[1024];\n        int count = 0;\n        while ((count = fis.read(b)) != -1) {\n            fos.write(b, 0, count);\n        }\n\n        //关闭\n        fis.close();\n        fos.close();\n```\n\n#### 字节缓冲流\n\n缓冲流：`BufferedInputStream/ BufferedOutputStream`\n\n提高 IO 效率，减少访问磁盘次数；\n\n数据存储在缓冲区中，flush 是将缓冲区的内容写入文件中，也可以直接 close\n\n```java\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n        int data = 0;\n        while ((data=bis.read())!=-1){\n            System.out.print((char) data);\n        }\n\n        //关闭\n        bis.close();\n        fis.close();\n```\n\n缓冲流读文件：\n\n```java\n\t\tFileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n//        int data = 0;\n//        while ((data=bis.read())!=-1){\n//            System.out.print((char) data);\n//        }\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count = bis.read(buf))!=-1) {\n            System.out.print(new String(buf, 0, count));\n        }\n\n        //关闭\n        bis.close();\n        fis.close();\n```\n\n缓冲流写文件：\n\n```java\n\t\t//创建缓冲流对象\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ddd.txt\");\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n        //写入文件\n        for (int i = 0; i < 5; i++) {\n            bos.write(\"theworllllld\\n\".getBytes()); //写入缓冲区,缓冲区默认大小为8k\n            bos.flush(); // 刷新到硬盘\n        }\n\n        //关闭,bos.close();会自动调用 bos.flush(), 但异常中断的话会写入失败\n        bos.close();\n```\n\n### 对象流\n\n`ObjectOutputStream / ObjectInputStream`\n\n1. 增强了缓冲区功能\n2. 增强了读写 8 种基本数据类型和字符串的功能\n3. 增强了读写对象的功能\n   1. `readObject()` 从流中读取一个对象\n   2. `writeObject(Object obj)` 向流中写入一个对象\n\n使用流传输对象的过程称为序列化(写入)、反序列化(读取)\n\n#### 序列化\n\n```java\n\t\t// 1. 创建对象流\n        FileOutputStream fos = new \tFileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        // 2. 序列化（写入操作）\n        Student zhangsan = new Student(\"zs\", 20);\n        oos.writeObject(zhangsan);\n        // 3. 关闭\n        oos.close();\n```\n\n#### 反序列化\n\n```java\n\t\t// 1. 创建对象流\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        // 2. 读取文件（反序列化）\n        Student s = (Student)ois.readObject();\n        // 3. 关闭\n        ois.close();\n```\n\n#### 注意事项：\n\n1. 某个类要想序列化必须实现 Serializable 接口；\n2. 序列化类中对象属性要求实现 Serializable 接口；\n3. 序列化版本号 ID`例如 ：private static final long serialVersionUID = -8318741215394696905L;`，保证序列化的类和反序列化的类是同一个类；\n4. 使用 transient 修饰属性，这个属性就不能序列化；\n5. 静态属性不能序列化；\n6. 序列化多个对象，可以借助集合来实现；\n\n### 字符流\n\n```java\n// 传统字节流读取\n    public static void main(String[] args) throws Exception {\n            // 1. 创建FileInputStream对象\n            FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n            // 2. 读取\n            int data = 0;\n            while((data = fis.read()) != -1){\n                System.out.print(((char)data));\n            }\n            // 3. 关闭\n            fis.close();\n    }\n```\n\n#### 字符流的父类\n\n##### `reader` 字符输入流\n\n1. `public int read(){}`\n2. `public int read(char[] c){}`\n3. `public int read(char[] b, int off, int len){}`\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1. 创建FileReader 文件字符输入流\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        // 2. 读取\n        // 2.1 单个字符读取\n        int data = 0;\n        while((data = fr.read()) != -1){\n            System.out.print((char)data);// 读取一个字符\n        }\n\n        char[] buf = new char[2];// 字符缓冲区读取\n        int count = 0;\n        while((count = fr.read(buf)) != -1){\n            System.out.print(new String(buf, 0, count));\n        }\n\n        // 3. 关闭\n        fr.close();\n    }\n```\n\n##### `Writer` 字符输出流\n\n1. `public void write(int n){}`\n2. `public void write(String str){}`\n3. `public void write(char[] c){}`\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1. 创建FileWriter对象\n        FileWriter fw = new FileWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        // 2. 写入\n        for(int i = 0; i < 10; i ++){\n            fw.write(\"写入的内容\");\n            fw.flush();\n        }\n        // 3. 关闭\n        fw.close();\n        System.out.println(\"执行完毕\");\n    }\n```\n\n##### 案例（使用上述方法进行文本复制）\n\n不能复制图片或二进制文件，使用字节流可以复制任意文件\n\n```java\npublic static void main(String[] args) throws Exception{\n        // 1. 创建\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        FileWriter fw = new FileWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        // 2. 读写\n        int data = 0;\n        while((data = fr.read()) != -1){\n            fw.write(data);\n            fw.flush();\n        }\n        // 3. 关闭\n        fw.close();\n        fr.close();\n    }\n```\n\n#### 字符缓冲流\n\n`BufferedReader / BufferedWriter`\n\n高效读写、支持输入换行符、可一次写一行读一行;\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 创建缓冲流\n        FileReader fr = new FileReader(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt\");\n        BufferedReader br = new BufferedReader(fr);\n        // 读取\n        // 1. 第一种方式\n        char[] buf = new char[1024];\n        int count = 0;\n        while((count = br.read(buf)) != -1){\n            System.out.println(new String(buf, 0, count));\n        }\n        // 2. 第二种方式 一行一行读取\n        String line = null;\n        while((line = br.readLine()) != null){\n            System.out.println(line);\n        }\n\n        // 关闭\n        br.close();\n    }\n```\n\n#### PrintWriter\n\n1. 向文件中写入内容；\n2. 封装了`print() / println()` 方法 支持写入后换行；\n3. 支持数据原样打印；\n\n```java\npublic static void main(String[] args) throws FileNotFoundException {\n        // 1 创建打印流\n        PrintWriter pw = new PrintWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        // 2 打印\n        pw.println(12);\n        pw.println(true);\n        pw.println(3.14);\n        pw.println('a');\n        // 3 关闭\n        pw.close();\n    }\n```\n\n#### 转换流\n\n1. 桥转换流 `InputStreamReader / OutputStreamWriter`\n2. 可将字节流转换为字符流\n3. 可设置字符的编码方式\n\n```java\npublic static void main(String[] args) throws Exception {\n        // 1 创建InputStreamReader对象\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        InputStreamReader isr = new InputStreamReader(fis, \"utf-8\");\n        // 2 读取文件\n        int data = 0;\n        while((data = isr.read()) != -1){\n            System.out.print((char)data);\n        }\n        // 3 关闭\n        isr.close();\n    }\n```\n\n```java\n public static void main(String[] args) throws Exception {\n        // 1 创建OutputStreamReader对象\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt\");\n        OutputStreamWriter osw = new OutputStreamWriter(fos, \"utf-8\");\n        // 2 写入\n        for (int i = 0; i < 10; i++) {\n            osw.write(\"写入内容\\n\");\n            osw.flush();\n        }\n        // 3 关闭\n        osw.close();\n\n    }\n```\n\n## File 类\n\n概念：代表物理盘符中的一个文件或者文件夹\n\n### 分隔符\n\n```java\n\t//分隔符\n    public static void separator() {\n        System.out.println(\"路径分隔符\" + File.pathSeparator);\n        System.out.println(\"名称分隔符\" + File.separator);\n    }\n```\n\n### 文件操作\n\n```java\n//文件操作\n    public static void fileOpen() throws Exception {\n        //创建文件\n        File file = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\file.txt\");\n        if (!file.exists()) {\n            boolean b = file.createNewFile();\n            System.out.println(\"创建结果\" + b);\n        }else {\n            System.out.println(\"文件已存在\");\n        }\n\n        //删除文件-直接删除\n//           System.out.println(file.delete());\n        //删除文件 jvm退出时删除\n//           file.deleteOnExit();\n//           Thread.sleep(5000);\n\n\n        //获取文件绝对路径\n        System.out.println(\"文件绝对路径:\" + file.getAbsolutePath());\n        //获取写的路径\n        System.out.println(file.getPath());\n        //获取文件名称\n        System.out.println(file.getName());\n        //获取父目录\n        System.out.println(file.getParent());\n        //获取文件长度\n        System.out.println(file.length());\n        //获取文件创建时间\n        System.out.println(new Date(file.lastModified()).toLocaleString());\n\n        //判断\n        //是否可写\n        //System.out.println(file.canWrite());  //linux支持\n        //是否可读\n        System.out.println(file.canRead());\n        //是否是文件\n        System.out.println(file.isFile());\n        //是否隐藏\n        System.out.println(file.isHidden());\n\n    }\n```\n\n### 文件夹操作\n\n```java\n//文件夹操作\npublic static void directoryOpe() throws Exception{\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc\");\n        System.out.println(dir.toString());\n        if (!dir.exists()) {\n            //创建单级目录\n//            dir.mkdir();\n            //创建多级目录\n            System.out.println(\"创建结果\" + dir.mkdirs());\n        }\n\n        //删除文件\n        //直接删除\n//        System.out.println(dir.delete()); //只能删除空目录\n        //使用jvm删除\n//        dir.deleteOnExit();\n//        Thread.sleep(3000);\n\n        //获取文件夹信息\n        //获取绝对路径\n        System.out.println(dir.getAbsolutePath());\n        //获取路径\n        System.out.println(dir.getPath());\n        //获取名称\n        System.out.println(dir.getName());\n        //获取父目录\n        System.out.println(dir.getParent());\n        //获取创建时间\n        System.out.println(new Date(dir.lastModified()).toLocaleString());\n\n        //判断\n        //是否是文件夹\n        System.out.println(dir.isDirectory());\n        //是否隐藏\n        System.out.println(dir.isHidden());\n\n        //遍历文件夹\n        File dir2 = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\");\n        String[] dirs = dir2.list();\n        //File[] dirs2 = dir2.listFiles();\n        for (String s : dirs) {\n            System.out.println(s);\n        }\n```\n\n### FileFilter\n\n```java\n// fileFilter接口使用，定制方法遍历\npublic static void main(String[] args) {\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc\");\n\n\n        File[] files = dir.listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                if (pathname.getName().endsWith(\".bin\")){\n                    return true;\n                }\n                return false;\n            }\n        });\n\n        for (File file : files) {\n            System.out.println(file.getName());\n        }\n\n    }\n```\n\n### 递归遍历文件夹\n\n遍历多级文件夹下的文件\n\n```java\npublic static void main(String[] args) {\n        File dir = new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\");\n        listDir(dir);\n    }\npublic static void listDir(File dir) {\n\n        File[] files = dir.listFiles();\n        if (files != null && files.length>0) {\n            for (File file : files) {\n                if (file.isDirectory()){\n                    listDir(file);\n                }else {\n                    System.out.println(file.getAbsolutePath());\n                }\n            }\n        }\n    }\n```\n\n### 递归删除文件夹\n\n删除多级文件夹下的文件\n\n```java\npublic static void delDir(File dir) {\n\n        File[] files = dir.listFiles();\n        if (files != null && files.length>0) {\n            for (File file : files) {\n                if (file.isDirectory()){\n                    delDir(file);\n                }else {\n                    System.out.println(file.getAbsolutePath() + \"删除文件\" + file.delete());\n                }\n            }\n        }\n    }\n```\n","slug":"JAVA-IO流-20210417","published":1,"updated":"2022-06-14T04:09:00.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x14000iy4w1d7incwcj","content":"<h1 id=\"IO-流\"><a href=\"#IO-流\" class=\"headerlink\" title=\"IO 流\"></a>IO 流</h1><span id=\"more\"></span>\n\n<h2 id=\"流的概念\"><a href=\"#流的概念\" class=\"headerlink\" title=\"流的概念\"></a>流的概念</h2><p>内存与存储设备之间传输数据的通道</p>\n<p><img src=\"img/article/JAVA-IO%E6%B5%81-20210417/image-20210409191717082.png\" alt=\"image-20210409191717082\"></p>\n<h2 id=\"流的分类\"><a href=\"#流的分类\" class=\"headerlink\" title=\"流的分类\"></a>流的分类</h2><h3 id=\"按方向【重点】\"><a href=\"#按方向【重点】\" class=\"headerlink\" title=\"按方向【重点】\"></a>按方向【重点】</h3><ol>\n<li><p>输入流：将&lt;存储设备&gt;中的内容读到&lt;内存&gt;中；</p>\n</li>\n<li><p>输出流：将&lt;内存&gt;中的内容写到&lt;存储设备&gt;中；</p>\n<p>文件 ———输入流———–&gt; 程序 ———输出流———–&gt;文件</p>\n</li>\n</ol>\n<h3 id=\"按单位\"><a href=\"#按单位\" class=\"headerlink\" title=\"按单位\"></a>按单位</h3><ol>\n<li>字节流：以字节流为单位，可以读写所有数据；</li>\n<li>字符流：以字符为单位，只能读写文本数据；</li>\n</ol>\n<h3 id=\"按功能\"><a href=\"#按功能\" class=\"headerlink\" title=\"按功能\"></a>按功能</h3><ol>\n<li>节点流：具有实际传输数据的读写功能；</li>\n<li>过滤流：在节点流的基础之上增强功能；</li>\n</ol>\n<h3 id=\"字节流\"><a href=\"#字节流\" class=\"headerlink\" title=\"字节流\"></a>字节流</h3><h4 id=\"字节流的父类（抽象类）：\"><a href=\"#字节流的父类（抽象类）：\" class=\"headerlink\" title=\"字节流的父类（抽象类）：\"></a>字节流的父类（抽象类）：</h4><ol>\n<li><p>InputStream 字节输入流</p>\n<pre><code class=\"java\">//InputStream 字节输入流\npublic int read()&#123;&#125;\npublic int read(byte[] b)&#123;&#125;\npublic int read(byte[] b, int off, int len)&#123;&#125;\n</code></pre>\n</li>\n<li><p>OutStream 字节输出流</p>\n<pre><code class=\"java\">// OutputStream 字节输出流\npublic void write(int n)&#123;&#125;\npublic void write(byte[] b)&#123;&#125;\npublic void write(byte[] b, int off, int len)&#123;&#125;\n</code></pre>\n</li>\n</ol>\n<h4 id=\"文件字节流\"><a href=\"#文件字节流\" class=\"headerlink\" title=\"文件字节流\"></a>文件字节流</h4><p>输入流：</p>\n<pre><code class=\"java\">        // 创建文件输出流对象\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-    workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n</code></pre>\n<pre><code class=\"java\">\n        // 单个字节读取文件\n        int data = 0;\n        while ((data=fis.read()) != -1) &#123;\n            System.out.print((char) data);\n        &#125;\n</code></pre>\n<pre><code class=\"java\">        // 指定读取个数，每次三个\n        byte[] buf = new byte[3];\n        int count = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count);\n\n        int count2 = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count2);\n</code></pre>\n<pre><code class=\"java\">        // 循环读取\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count=fis.read(buf))!=-1) &#123;\n            System.out.println(new String(buf, 0, count));\n        &#125;\n</code></pre>\n<pre><code class=\"java\">        //关闭\n        fis.close();\n</code></pre>\n<p>输出流：</p>\n<pre><code class=\"java\">        //创建文件输出流对象;\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\bbb.txt&quot;);\n</code></pre>\n<pre><code class=\"java\">        //写入文件\n        fos.write(97);\n        fos.write(&#39;b&#39;);\n        fos.write(&#39;c&#39;);\n</code></pre>\n<pre><code class=\"java\">         //写入字符串\n        String str = &quot;helloworld&quot;;\n        fos.write(str.getBytes());\n</code></pre>\n<pre><code class=\"java\">        fos.close();\n</code></pre>\n<h4 id=\"图片复制案例\"><a href=\"#图片复制案例\" class=\"headerlink\" title=\"图片复制案例\"></a>图片复制案例</h4><pre><code class=\"java\">        //创建流\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.jpg&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ccc.jpg&quot;);\n\n        ////边读边写\n        byte[] b = new byte[1024];\n        int count = 0;\n        while ((count = fis.read(b)) != -1) &#123;\n            fos.write(b, 0, count);\n        &#125;\n\n        //关闭\n        fis.close();\n        fos.close();\n</code></pre>\n<h4 id=\"字节缓冲流\"><a href=\"#字节缓冲流\" class=\"headerlink\" title=\"字节缓冲流\"></a>字节缓冲流</h4><p>缓冲流：<code>BufferedInputStream/ BufferedOutputStream</code></p>\n<p>提高 IO 效率，减少访问磁盘次数；</p>\n<p>数据存储在缓冲区中，flush 是将缓冲区的内容写入文件中，也可以直接 close</p>\n<pre><code class=\"java\">        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n        int data = 0;\n        while ((data=bis.read())!=-1)&#123;\n            System.out.print((char) data);\n        &#125;\n\n        //关闭\n        bis.close();\n        fis.close();\n</code></pre>\n<p>缓冲流读文件：</p>\n<pre><code class=\"java\">        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n//        int data = 0;\n//        while ((data=bis.read())!=-1)&#123;\n//            System.out.print((char) data);\n//        &#125;\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count = bis.read(buf))!=-1) &#123;\n            System.out.print(new String(buf, 0, count));\n        &#125;\n\n        //关闭\n        bis.close();\n        fis.close();\n</code></pre>\n<p>缓冲流写文件：</p>\n<pre><code class=\"java\">        //创建缓冲流对象\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ddd.txt&quot;);\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n        //写入文件\n        for (int i = 0; i &lt; 5; i++) &#123;\n            bos.write(&quot;theworllllld\\n&quot;.getBytes()); //写入缓冲区,缓冲区默认大小为8k\n            bos.flush(); // 刷新到硬盘\n        &#125;\n\n        //关闭,bos.close();会自动调用 bos.flush(), 但异常中断的话会写入失败\n        bos.close();\n</code></pre>\n<h3 id=\"对象流\"><a href=\"#对象流\" class=\"headerlink\" title=\"对象流\"></a>对象流</h3><p><code>ObjectOutputStream / ObjectInputStream</code></p>\n<ol>\n<li>增强了缓冲区功能</li>\n<li>增强了读写 8 种基本数据类型和字符串的功能</li>\n<li>增强了读写对象的功能<ol>\n<li><code>readObject()</code> 从流中读取一个对象</li>\n<li><code>writeObject(Object obj)</code> 向流中写入一个对象</li>\n</ol>\n</li>\n</ol>\n<p>使用流传输对象的过程称为序列化(写入)、反序列化(读取)</p>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><pre><code class=\"java\">        // 1. 创建对象流\n        FileOutputStream fos = new     FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin&quot;);\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        // 2. 序列化（写入操作）\n        Student zhangsan = new Student(&quot;zs&quot;, 20);\n        oos.writeObject(zhangsan);\n        // 3. 关闭\n        oos.close();\n</code></pre>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><pre><code class=\"java\">        // 1. 创建对象流\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin&quot;);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        // 2. 读取文件（反序列化）\n        Student s = (Student)ois.readObject();\n        // 3. 关闭\n        ois.close();\n</code></pre>\n<h4 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>某个类要想序列化必须实现 Serializable 接口；</li>\n<li>序列化类中对象属性要求实现 Serializable 接口；</li>\n<li>序列化版本号 ID<code>例如 ：private static final long serialVersionUID = -8318741215394696905L;</code>，保证序列化的类和反序列化的类是同一个类；</li>\n<li>使用 transient 修饰属性，这个属性就不能序列化；</li>\n<li>静态属性不能序列化；</li>\n<li>序列化多个对象，可以借助集合来实现；</li>\n</ol>\n<h3 id=\"字符流\"><a href=\"#字符流\" class=\"headerlink\" title=\"字符流\"></a>字符流</h3><pre><code class=\"java\">// 传统字节流读取\n    public static void main(String[] args) throws Exception &#123;\n            // 1. 创建FileInputStream对象\n            FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n            // 2. 读取\n            int data = 0;\n            while((data = fis.read()) != -1)&#123;\n                System.out.print(((char)data));\n            &#125;\n            // 3. 关闭\n            fis.close();\n    &#125;\n</code></pre>\n<h4 id=\"字符流的父类\"><a href=\"#字符流的父类\" class=\"headerlink\" title=\"字符流的父类\"></a>字符流的父类</h4><h5 id=\"reader-字符输入流\"><a href=\"#reader-字符输入流\" class=\"headerlink\" title=\"reader 字符输入流\"></a><code>reader</code> 字符输入流</h5><ol>\n<li><code>public int read()&#123;&#125;</code></li>\n<li><code>public int read(char[] c)&#123;&#125;</code></li>\n<li><code>public int read(char[] b, int off, int len)&#123;&#125;</code></li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1. 创建FileReader 文件字符输入流\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        // 2. 读取\n        // 2.1 单个字符读取\n        int data = 0;\n        while((data = fr.read()) != -1)&#123;\n            System.out.print((char)data);// 读取一个字符\n        &#125;\n\n        char[] buf = new char[2];// 字符缓冲区读取\n        int count = 0;\n        while((count = fr.read(buf)) != -1)&#123;\n            System.out.print(new String(buf, 0, count));\n        &#125;\n\n        // 3. 关闭\n        fr.close();\n    &#125;\n</code></pre>\n<h5 id=\"Writer-字符输出流\"><a href=\"#Writer-字符输出流\" class=\"headerlink\" title=\"Writer 字符输出流\"></a><code>Writer</code> 字符输出流</h5><ol>\n<li><code>public void write(int n)&#123;&#125;</code></li>\n<li><code>public void write(String str)&#123;&#125;</code></li>\n<li><code>public void write(char[] c)&#123;&#125;</code></li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1. 创建FileWriter对象\n        FileWriter fw = new FileWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        // 2. 写入\n        for(int i = 0; i &lt; 10; i ++)&#123;\n            fw.write(&quot;写入的内容&quot;);\n            fw.flush();\n        &#125;\n        // 3. 关闭\n        fw.close();\n        System.out.println(&quot;执行完毕&quot;);\n    &#125;\n</code></pre>\n<h5 id=\"案例（使用上述方法进行文本复制）\"><a href=\"#案例（使用上述方法进行文本复制）\" class=\"headerlink\" title=\"案例（使用上述方法进行文本复制）\"></a>案例（使用上述方法进行文本复制）</h5><p>不能复制图片或二进制文件，使用字节流可以复制任意文件</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception&#123;\n        // 1. 创建\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        FileWriter fw = new FileWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        // 2. 读写\n        int data = 0;\n        while((data = fr.read()) != -1)&#123;\n            fw.write(data);\n            fw.flush();\n        &#125;\n        // 3. 关闭\n        fw.close();\n        fr.close();\n    &#125;\n</code></pre>\n<h4 id=\"字符缓冲流\"><a href=\"#字符缓冲流\" class=\"headerlink\" title=\"字符缓冲流\"></a>字符缓冲流</h4><p><code>BufferedReader / BufferedWriter</code></p>\n<p>高效读写、支持输入换行符、可一次写一行读一行;</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 创建缓冲流\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        BufferedReader br = new BufferedReader(fr);\n        // 读取\n        // 1. 第一种方式\n        char[] buf = new char[1024];\n        int count = 0;\n        while((count = br.read(buf)) != -1)&#123;\n            System.out.println(new String(buf, 0, count));\n        &#125;\n        // 2. 第二种方式 一行一行读取\n        String line = null;\n        while((line = br.readLine()) != null)&#123;\n            System.out.println(line);\n        &#125;\n\n        // 关闭\n        br.close();\n    &#125;\n</code></pre>\n<h4 id=\"PrintWriter\"><a href=\"#PrintWriter\" class=\"headerlink\" title=\"PrintWriter\"></a>PrintWriter</h4><ol>\n<li>向文件中写入内容；</li>\n<li>封装了<code>print() / println()</code> 方法 支持写入后换行；</li>\n<li>支持数据原样打印；</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws FileNotFoundException &#123;\n        // 1 创建打印流\n        PrintWriter pw = new PrintWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        // 2 打印\n        pw.println(12);\n        pw.println(true);\n        pw.println(3.14);\n        pw.println(&#39;a&#39;);\n        // 3 关闭\n        pw.close();\n    &#125;\n</code></pre>\n<h4 id=\"转换流\"><a href=\"#转换流\" class=\"headerlink\" title=\"转换流\"></a>转换流</h4><ol>\n<li>桥转换流 <code>InputStreamReader / OutputStreamWriter</code></li>\n<li>可将字节流转换为字符流</li>\n<li>可设置字符的编码方式</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1 创建InputStreamReader对象\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        InputStreamReader isr = new InputStreamReader(fis, &quot;utf-8&quot;);\n        // 2 读取文件\n        int data = 0;\n        while((data = isr.read()) != -1)&#123;\n            System.out.print((char)data);\n        &#125;\n        // 3 关闭\n        isr.close();\n    &#125;\n</code></pre>\n<pre><code class=\"java\"> public static void main(String[] args) throws Exception &#123;\n        // 1 创建OutputStreamReader对象\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;utf-8&quot;);\n        // 2 写入\n        for (int i = 0; i &lt; 10; i++) &#123;\n            osw.write(&quot;写入内容\\n&quot;);\n            osw.flush();\n        &#125;\n        // 3 关闭\n        osw.close();\n\n    &#125;\n</code></pre>\n<h2 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h2><p>概念：代表物理盘符中的一个文件或者文件夹</p>\n<h3 id=\"分隔符\"><a href=\"#分隔符\" class=\"headerlink\" title=\"分隔符\"></a>分隔符</h3><pre><code class=\"java\">    //分隔符\n    public static void separator() &#123;\n        System.out.println(&quot;路径分隔符&quot; + File.pathSeparator);\n        System.out.println(&quot;名称分隔符&quot; + File.separator);\n    &#125;\n</code></pre>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><pre><code class=\"java\">//文件操作\n    public static void fileOpen() throws Exception &#123;\n        //创建文件\n        File file = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\file.txt&quot;);\n        if (!file.exists()) &#123;\n            boolean b = file.createNewFile();\n            System.out.println(&quot;创建结果&quot; + b);\n        &#125;else &#123;\n            System.out.println(&quot;文件已存在&quot;);\n        &#125;\n\n        //删除文件-直接删除\n//           System.out.println(file.delete());\n        //删除文件 jvm退出时删除\n//           file.deleteOnExit();\n//           Thread.sleep(5000);\n\n\n        //获取文件绝对路径\n        System.out.println(&quot;文件绝对路径:&quot; + file.getAbsolutePath());\n        //获取写的路径\n        System.out.println(file.getPath());\n        //获取文件名称\n        System.out.println(file.getName());\n        //获取父目录\n        System.out.println(file.getParent());\n        //获取文件长度\n        System.out.println(file.length());\n        //获取文件创建时间\n        System.out.println(new Date(file.lastModified()).toLocaleString());\n\n        //判断\n        //是否可写\n        //System.out.println(file.canWrite());  //linux支持\n        //是否可读\n        System.out.println(file.canRead());\n        //是否是文件\n        System.out.println(file.isFile());\n        //是否隐藏\n        System.out.println(file.isHidden());\n\n    &#125;\n</code></pre>\n<h3 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h3><pre><code class=\"java\">//文件夹操作\npublic static void directoryOpe() throws Exception&#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc&quot;);\n        System.out.println(dir.toString());\n        if (!dir.exists()) &#123;\n            //创建单级目录\n//            dir.mkdir();\n            //创建多级目录\n            System.out.println(&quot;创建结果&quot; + dir.mkdirs());\n        &#125;\n\n        //删除文件\n        //直接删除\n//        System.out.println(dir.delete()); //只能删除空目录\n        //使用jvm删除\n//        dir.deleteOnExit();\n//        Thread.sleep(3000);\n\n        //获取文件夹信息\n        //获取绝对路径\n        System.out.println(dir.getAbsolutePath());\n        //获取路径\n        System.out.println(dir.getPath());\n        //获取名称\n        System.out.println(dir.getName());\n        //获取父目录\n        System.out.println(dir.getParent());\n        //获取创建时间\n        System.out.println(new Date(dir.lastModified()).toLocaleString());\n\n        //判断\n        //是否是文件夹\n        System.out.println(dir.isDirectory());\n        //是否隐藏\n        System.out.println(dir.isHidden());\n\n        //遍历文件夹\n        File dir2 = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file&quot;);\n        String[] dirs = dir2.list();\n        //File[] dirs2 = dir2.listFiles();\n        for (String s : dirs) &#123;\n            System.out.println(s);\n        &#125;\n</code></pre>\n<h3 id=\"FileFilter\"><a href=\"#FileFilter\" class=\"headerlink\" title=\"FileFilter\"></a>FileFilter</h3><pre><code class=\"java\">// fileFilter接口使用，定制方法遍历\npublic static void main(String[] args) &#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc&quot;);\n\n\n        File[] files = dir.listFiles(new FileFilter() &#123;\n            @Override\n            public boolean accept(File pathname) &#123;\n                if (pathname.getName().endsWith(&quot;.bin&quot;))&#123;\n                    return true;\n                &#125;\n                return false;\n            &#125;\n        &#125;);\n\n        for (File file : files) &#123;\n            System.out.println(file.getName());\n        &#125;\n\n    &#125;\n</code></pre>\n<h3 id=\"递归遍历文件夹\"><a href=\"#递归遍历文件夹\" class=\"headerlink\" title=\"递归遍历文件夹\"></a>递归遍历文件夹</h3><p>遍历多级文件夹下的文件</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa&quot;);\n        listDir(dir);\n    &#125;\npublic static void listDir(File dir) &#123;\n\n        File[] files = dir.listFiles();\n        if (files != null &amp;&amp; files.length&gt;0) &#123;\n            for (File file : files) &#123;\n                if (file.isDirectory())&#123;\n                    listDir(file);\n                &#125;else &#123;\n                    System.out.println(file.getAbsolutePath());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"递归删除文件夹\"><a href=\"#递归删除文件夹\" class=\"headerlink\" title=\"递归删除文件夹\"></a>递归删除文件夹</h3><p>删除多级文件夹下的文件</p>\n<pre><code class=\"java\">public static void delDir(File dir) &#123;\n\n        File[] files = dir.listFiles();\n        if (files != null &amp;&amp; files.length&gt;0) &#123;\n            for (File file : files) &#123;\n                if (file.isDirectory())&#123;\n                    delDir(file);\n                &#125;else &#123;\n                    System.out.println(file.getAbsolutePath() + &quot;删除文件&quot; + file.delete());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"IO-流\"><a href=\"#IO-流\" class=\"headerlink\" title=\"IO 流\"></a>IO 流</h1>","more":"<h2 id=\"流的概念\"><a href=\"#流的概念\" class=\"headerlink\" title=\"流的概念\"></a>流的概念</h2><p>内存与存储设备之间传输数据的通道</p>\n<p><img src=\"img/article/JAVA-IO%E6%B5%81-20210417/image-20210409191717082.png\" alt=\"image-20210409191717082\"></p>\n<h2 id=\"流的分类\"><a href=\"#流的分类\" class=\"headerlink\" title=\"流的分类\"></a>流的分类</h2><h3 id=\"按方向【重点】\"><a href=\"#按方向【重点】\" class=\"headerlink\" title=\"按方向【重点】\"></a>按方向【重点】</h3><ol>\n<li><p>输入流：将&lt;存储设备&gt;中的内容读到&lt;内存&gt;中；</p>\n</li>\n<li><p>输出流：将&lt;内存&gt;中的内容写到&lt;存储设备&gt;中；</p>\n<p>文件 ———输入流———–&gt; 程序 ———输出流———–&gt;文件</p>\n</li>\n</ol>\n<h3 id=\"按单位\"><a href=\"#按单位\" class=\"headerlink\" title=\"按单位\"></a>按单位</h3><ol>\n<li>字节流：以字节流为单位，可以读写所有数据；</li>\n<li>字符流：以字符为单位，只能读写文本数据；</li>\n</ol>\n<h3 id=\"按功能\"><a href=\"#按功能\" class=\"headerlink\" title=\"按功能\"></a>按功能</h3><ol>\n<li>节点流：具有实际传输数据的读写功能；</li>\n<li>过滤流：在节点流的基础之上增强功能；</li>\n</ol>\n<h3 id=\"字节流\"><a href=\"#字节流\" class=\"headerlink\" title=\"字节流\"></a>字节流</h3><h4 id=\"字节流的父类（抽象类）：\"><a href=\"#字节流的父类（抽象类）：\" class=\"headerlink\" title=\"字节流的父类（抽象类）：\"></a>字节流的父类（抽象类）：</h4><ol>\n<li><p>InputStream 字节输入流</p>\n<pre><code class=\"java\">//InputStream 字节输入流\npublic int read()&#123;&#125;\npublic int read(byte[] b)&#123;&#125;\npublic int read(byte[] b, int off, int len)&#123;&#125;\n</code></pre>\n</li>\n<li><p>OutStream 字节输出流</p>\n<pre><code class=\"java\">// OutputStream 字节输出流\npublic void write(int n)&#123;&#125;\npublic void write(byte[] b)&#123;&#125;\npublic void write(byte[] b, int off, int len)&#123;&#125;\n</code></pre>\n</li>\n</ol>\n<h4 id=\"文件字节流\"><a href=\"#文件字节流\" class=\"headerlink\" title=\"文件字节流\"></a>文件字节流</h4><p>输入流：</p>\n<pre><code class=\"java\">        // 创建文件输出流对象\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-    workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n</code></pre>\n<pre><code class=\"java\">\n        // 单个字节读取文件\n        int data = 0;\n        while ((data=fis.read()) != -1) &#123;\n            System.out.print((char) data);\n        &#125;\n</code></pre>\n<pre><code class=\"java\">        // 指定读取个数，每次三个\n        byte[] buf = new byte[3];\n        int count = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count);\n\n        int count2 = fis.read(buf);\n        System.out.println(new String(buf));\n        System.out.println(count2);\n</code></pre>\n<pre><code class=\"java\">        // 循环读取\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count=fis.read(buf))!=-1) &#123;\n            System.out.println(new String(buf, 0, count));\n        &#125;\n</code></pre>\n<pre><code class=\"java\">        //关闭\n        fis.close();\n</code></pre>\n<p>输出流：</p>\n<pre><code class=\"java\">        //创建文件输出流对象;\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\bbb.txt&quot;);\n</code></pre>\n<pre><code class=\"java\">        //写入文件\n        fos.write(97);\n        fos.write(&#39;b&#39;);\n        fos.write(&#39;c&#39;);\n</code></pre>\n<pre><code class=\"java\">         //写入字符串\n        String str = &quot;helloworld&quot;;\n        fos.write(str.getBytes());\n</code></pre>\n<pre><code class=\"java\">        fos.close();\n</code></pre>\n<h4 id=\"图片复制案例\"><a href=\"#图片复制案例\" class=\"headerlink\" title=\"图片复制案例\"></a>图片复制案例</h4><pre><code class=\"java\">        //创建流\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.jpg&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ccc.jpg&quot;);\n\n        ////边读边写\n        byte[] b = new byte[1024];\n        int count = 0;\n        while ((count = fis.read(b)) != -1) &#123;\n            fos.write(b, 0, count);\n        &#125;\n\n        //关闭\n        fis.close();\n        fos.close();\n</code></pre>\n<h4 id=\"字节缓冲流\"><a href=\"#字节缓冲流\" class=\"headerlink\" title=\"字节缓冲流\"></a>字节缓冲流</h4><p>缓冲流：<code>BufferedInputStream/ BufferedOutputStream</code></p>\n<p>提高 IO 效率，减少访问磁盘次数；</p>\n<p>数据存储在缓冲区中，flush 是将缓冲区的内容写入文件中，也可以直接 close</p>\n<pre><code class=\"java\">        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n        int data = 0;\n        while ((data=bis.read())!=-1)&#123;\n            System.out.print((char) data);\n        &#125;\n\n        //关闭\n        bis.close();\n        fis.close();\n</code></pre>\n<p>缓冲流读文件：</p>\n<pre><code class=\"java\">        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        //创建缓冲流对象\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //读取\n//        int data = 0;\n//        while ((data=bis.read())!=-1)&#123;\n//            System.out.print((char) data);\n//        &#125;\n        byte[] buf = new byte[1024];\n        int count = 0;\n        while ((count = bis.read(buf))!=-1) &#123;\n            System.out.print(new String(buf, 0, count));\n        &#125;\n\n        //关闭\n        bis.close();\n        fis.close();\n</code></pre>\n<p>缓冲流写文件：</p>\n<pre><code class=\"java\">        //创建缓冲流对象\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\ddd.txt&quot;);\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n        //写入文件\n        for (int i = 0; i &lt; 5; i++) &#123;\n            bos.write(&quot;theworllllld\\n&quot;.getBytes()); //写入缓冲区,缓冲区默认大小为8k\n            bos.flush(); // 刷新到硬盘\n        &#125;\n\n        //关闭,bos.close();会自动调用 bos.flush(), 但异常中断的话会写入失败\n        bos.close();\n</code></pre>\n<h3 id=\"对象流\"><a href=\"#对象流\" class=\"headerlink\" title=\"对象流\"></a>对象流</h3><p><code>ObjectOutputStream / ObjectInputStream</code></p>\n<ol>\n<li>增强了缓冲区功能</li>\n<li>增强了读写 8 种基本数据类型和字符串的功能</li>\n<li>增强了读写对象的功能<ol>\n<li><code>readObject()</code> 从流中读取一个对象</li>\n<li><code>writeObject(Object obj)</code> 向流中写入一个对象</li>\n</ol>\n</li>\n</ol>\n<p>使用流传输对象的过程称为序列化(写入)、反序列化(读取)</p>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><pre><code class=\"java\">        // 1. 创建对象流\n        FileOutputStream fos = new     FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin&quot;);\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        // 2. 序列化（写入操作）\n        Student zhangsan = new Student(&quot;zs&quot;, 20);\n        oos.writeObject(zhangsan);\n        // 3. 关闭\n        oos.close();\n</code></pre>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><pre><code class=\"java\">        // 1. 创建对象流\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\st.bin&quot;);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        // 2. 读取文件（反序列化）\n        Student s = (Student)ois.readObject();\n        // 3. 关闭\n        ois.close();\n</code></pre>\n<h4 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>某个类要想序列化必须实现 Serializable 接口；</li>\n<li>序列化类中对象属性要求实现 Serializable 接口；</li>\n<li>序列化版本号 ID<code>例如 ：private static final long serialVersionUID = -8318741215394696905L;</code>，保证序列化的类和反序列化的类是同一个类；</li>\n<li>使用 transient 修饰属性，这个属性就不能序列化；</li>\n<li>静态属性不能序列化；</li>\n<li>序列化多个对象，可以借助集合来实现；</li>\n</ol>\n<h3 id=\"字符流\"><a href=\"#字符流\" class=\"headerlink\" title=\"字符流\"></a>字符流</h3><pre><code class=\"java\">// 传统字节流读取\n    public static void main(String[] args) throws Exception &#123;\n            // 1. 创建FileInputStream对象\n            FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n            // 2. 读取\n            int data = 0;\n            while((data = fis.read()) != -1)&#123;\n                System.out.print(((char)data));\n            &#125;\n            // 3. 关闭\n            fis.close();\n    &#125;\n</code></pre>\n<h4 id=\"字符流的父类\"><a href=\"#字符流的父类\" class=\"headerlink\" title=\"字符流的父类\"></a>字符流的父类</h4><h5 id=\"reader-字符输入流\"><a href=\"#reader-字符输入流\" class=\"headerlink\" title=\"reader 字符输入流\"></a><code>reader</code> 字符输入流</h5><ol>\n<li><code>public int read()&#123;&#125;</code></li>\n<li><code>public int read(char[] c)&#123;&#125;</code></li>\n<li><code>public int read(char[] b, int off, int len)&#123;&#125;</code></li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1. 创建FileReader 文件字符输入流\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        // 2. 读取\n        // 2.1 单个字符读取\n        int data = 0;\n        while((data = fr.read()) != -1)&#123;\n            System.out.print((char)data);// 读取一个字符\n        &#125;\n\n        char[] buf = new char[2];// 字符缓冲区读取\n        int count = 0;\n        while((count = fr.read(buf)) != -1)&#123;\n            System.out.print(new String(buf, 0, count));\n        &#125;\n\n        // 3. 关闭\n        fr.close();\n    &#125;\n</code></pre>\n<h5 id=\"Writer-字符输出流\"><a href=\"#Writer-字符输出流\" class=\"headerlink\" title=\"Writer 字符输出流\"></a><code>Writer</code> 字符输出流</h5><ol>\n<li><code>public void write(int n)&#123;&#125;</code></li>\n<li><code>public void write(String str)&#123;&#125;</code></li>\n<li><code>public void write(char[] c)&#123;&#125;</code></li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1. 创建FileWriter对象\n        FileWriter fw = new FileWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        // 2. 写入\n        for(int i = 0; i &lt; 10; i ++)&#123;\n            fw.write(&quot;写入的内容&quot;);\n            fw.flush();\n        &#125;\n        // 3. 关闭\n        fw.close();\n        System.out.println(&quot;执行完毕&quot;);\n    &#125;\n</code></pre>\n<h5 id=\"案例（使用上述方法进行文本复制）\"><a href=\"#案例（使用上述方法进行文本复制）\" class=\"headerlink\" title=\"案例（使用上述方法进行文本复制）\"></a>案例（使用上述方法进行文本复制）</h5><p>不能复制图片或二进制文件，使用字节流可以复制任意文件</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception&#123;\n        // 1. 创建\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        FileWriter fw = new FileWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        // 2. 读写\n        int data = 0;\n        while((data = fr.read()) != -1)&#123;\n            fw.write(data);\n            fw.flush();\n        &#125;\n        // 3. 关闭\n        fw.close();\n        fr.close();\n    &#125;\n</code></pre>\n<h4 id=\"字符缓冲流\"><a href=\"#字符缓冲流\" class=\"headerlink\" title=\"字符缓冲流\"></a>字符缓冲流</h4><p><code>BufferedReader / BufferedWriter</code></p>\n<p>高效读写、支持输入换行符、可一次写一行读一行;</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 创建缓冲流\n        FileReader fr = new FileReader(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\aaa.txt&quot;);\n        BufferedReader br = new BufferedReader(fr);\n        // 读取\n        // 1. 第一种方式\n        char[] buf = new char[1024];\n        int count = 0;\n        while((count = br.read(buf)) != -1)&#123;\n            System.out.println(new String(buf, 0, count));\n        &#125;\n        // 2. 第二种方式 一行一行读取\n        String line = null;\n        while((line = br.readLine()) != null)&#123;\n            System.out.println(line);\n        &#125;\n\n        // 关闭\n        br.close();\n    &#125;\n</code></pre>\n<h4 id=\"PrintWriter\"><a href=\"#PrintWriter\" class=\"headerlink\" title=\"PrintWriter\"></a>PrintWriter</h4><ol>\n<li>向文件中写入内容；</li>\n<li>封装了<code>print() / println()</code> 方法 支持写入后换行；</li>\n<li>支持数据原样打印；</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws FileNotFoundException &#123;\n        // 1 创建打印流\n        PrintWriter pw = new PrintWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        // 2 打印\n        pw.println(12);\n        pw.println(true);\n        pw.println(3.14);\n        pw.println(&#39;a&#39;);\n        // 3 关闭\n        pw.close();\n    &#125;\n</code></pre>\n<h4 id=\"转换流\"><a href=\"#转换流\" class=\"headerlink\" title=\"转换流\"></a>转换流</h4><ol>\n<li>桥转换流 <code>InputStreamReader / OutputStreamWriter</code></li>\n<li>可将字节流转换为字符流</li>\n<li>可设置字符的编码方式</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        // 1 创建InputStreamReader对象\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        InputStreamReader isr = new InputStreamReader(fis, &quot;utf-8&quot;);\n        // 2 读取文件\n        int data = 0;\n        while((data = isr.read()) != -1)&#123;\n            System.out.print((char)data);\n        &#125;\n        // 3 关闭\n        isr.close();\n    &#125;\n</code></pre>\n<pre><code class=\"java\"> public static void main(String[] args) throws Exception &#123;\n        // 1 创建OutputStreamReader对象\n        FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\fff.txt&quot;);\n        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;utf-8&quot;);\n        // 2 写入\n        for (int i = 0; i &lt; 10; i++) &#123;\n            osw.write(&quot;写入内容\\n&quot;);\n            osw.flush();\n        &#125;\n        // 3 关闭\n        osw.close();\n\n    &#125;\n</code></pre>\n<h2 id=\"File-类\"><a href=\"#File-类\" class=\"headerlink\" title=\"File 类\"></a>File 类</h2><p>概念：代表物理盘符中的一个文件或者文件夹</p>\n<h3 id=\"分隔符\"><a href=\"#分隔符\" class=\"headerlink\" title=\"分隔符\"></a>分隔符</h3><pre><code class=\"java\">    //分隔符\n    public static void separator() &#123;\n        System.out.println(&quot;路径分隔符&quot; + File.pathSeparator);\n        System.out.println(&quot;名称分隔符&quot; + File.separator);\n    &#125;\n</code></pre>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><pre><code class=\"java\">//文件操作\n    public static void fileOpen() throws Exception &#123;\n        //创建文件\n        File file = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\file.txt&quot;);\n        if (!file.exists()) &#123;\n            boolean b = file.createNewFile();\n            System.out.println(&quot;创建结果&quot; + b);\n        &#125;else &#123;\n            System.out.println(&quot;文件已存在&quot;);\n        &#125;\n\n        //删除文件-直接删除\n//           System.out.println(file.delete());\n        //删除文件 jvm退出时删除\n//           file.deleteOnExit();\n//           Thread.sleep(5000);\n\n\n        //获取文件绝对路径\n        System.out.println(&quot;文件绝对路径:&quot; + file.getAbsolutePath());\n        //获取写的路径\n        System.out.println(file.getPath());\n        //获取文件名称\n        System.out.println(file.getName());\n        //获取父目录\n        System.out.println(file.getParent());\n        //获取文件长度\n        System.out.println(file.length());\n        //获取文件创建时间\n        System.out.println(new Date(file.lastModified()).toLocaleString());\n\n        //判断\n        //是否可写\n        //System.out.println(file.canWrite());  //linux支持\n        //是否可读\n        System.out.println(file.canRead());\n        //是否是文件\n        System.out.println(file.isFile());\n        //是否隐藏\n        System.out.println(file.isHidden());\n\n    &#125;\n</code></pre>\n<h3 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h3><pre><code class=\"java\">//文件夹操作\npublic static void directoryOpe() throws Exception&#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc&quot;);\n        System.out.println(dir.toString());\n        if (!dir.exists()) &#123;\n            //创建单级目录\n//            dir.mkdir();\n            //创建多级目录\n            System.out.println(&quot;创建结果&quot; + dir.mkdirs());\n        &#125;\n\n        //删除文件\n        //直接删除\n//        System.out.println(dir.delete()); //只能删除空目录\n        //使用jvm删除\n//        dir.deleteOnExit();\n//        Thread.sleep(3000);\n\n        //获取文件夹信息\n        //获取绝对路径\n        System.out.println(dir.getAbsolutePath());\n        //获取路径\n        System.out.println(dir.getPath());\n        //获取名称\n        System.out.println(dir.getName());\n        //获取父目录\n        System.out.println(dir.getParent());\n        //获取创建时间\n        System.out.println(new Date(dir.lastModified()).toLocaleString());\n\n        //判断\n        //是否是文件夹\n        System.out.println(dir.isDirectory());\n        //是否隐藏\n        System.out.println(dir.isHidden());\n\n        //遍历文件夹\n        File dir2 = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file&quot;);\n        String[] dirs = dir2.list();\n        //File[] dirs2 = dir2.listFiles();\n        for (String s : dirs) &#123;\n            System.out.println(s);\n        &#125;\n</code></pre>\n<h3 id=\"FileFilter\"><a href=\"#FileFilter\" class=\"headerlink\" title=\"FileFilter\"></a>FileFilter</h3><pre><code class=\"java\">// fileFilter接口使用，定制方法遍历\npublic static void main(String[] args) &#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa\\\\bbb\\\\ccc&quot;);\n\n\n        File[] files = dir.listFiles(new FileFilter() &#123;\n            @Override\n            public boolean accept(File pathname) &#123;\n                if (pathname.getName().endsWith(&quot;.bin&quot;))&#123;\n                    return true;\n                &#125;\n                return false;\n            &#125;\n        &#125;);\n\n        for (File file : files) &#123;\n            System.out.println(file.getName());\n        &#125;\n\n    &#125;\n</code></pre>\n<h3 id=\"递归遍历文件夹\"><a href=\"#递归遍历文件夹\" class=\"headerlink\" title=\"递归遍历文件夹\"></a>递归遍历文件夹</h3><p>遍历多级文件夹下的文件</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        File dir = new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\IO流\\\\src\\\\com\\\\file\\\\aaa&quot;);\n        listDir(dir);\n    &#125;\npublic static void listDir(File dir) &#123;\n\n        File[] files = dir.listFiles();\n        if (files != null &amp;&amp; files.length&gt;0) &#123;\n            for (File file : files) &#123;\n                if (file.isDirectory())&#123;\n                    listDir(file);\n                &#125;else &#123;\n                    System.out.println(file.getAbsolutePath());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"递归删除文件夹\"><a href=\"#递归删除文件夹\" class=\"headerlink\" title=\"递归删除文件夹\"></a>递归删除文件夹</h3><p>删除多级文件夹下的文件</p>\n<pre><code class=\"java\">public static void delDir(File dir) &#123;\n\n        File[] files = dir.listFiles();\n        if (files != null &amp;&amp; files.length&gt;0) &#123;\n            for (File file : files) &#123;\n                if (file.isDirectory())&#123;\n                    delDir(file);\n                &#125;else &#123;\n                    System.out.println(file.getAbsolutePath() + &quot;删除文件&quot; + file.delete());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>"},{"title":"JAVA-JVM基础","date":"2021-04-26T14:00:37.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# JVM 探究\n\n<!-- more -->\n\n## 常见面试问题\n\n- 请谈谈对 JVM 的理解？java8 虚拟机和之前的变化更新？\n- 什么是 OOM - OutOfMemory，什么是栈溢出 StackOverFlowError?怎么分析？\n- JVM 的常用调优参数有哪些?\n- 内存快照如何抓取，怎么分析 Dump 文件？\n- 谈谈 JVM 中，类加载器你的认识？\n\n1. jvm 的位置\n\n2. jvm 的体系结构\n\n3. 类加载器\n\n4. 双亲委派机制\n\n5. 沙箱安全机制\n\n6. Native\n\n7. PC 寄存器\n\n8. 方法区\n\n9. 栈\n\n10. 三种 JVM\n\n    java -version 查看 ：\n\n    ` Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)`\n\n11. 堆\n\n12. 新生区、老年区\n\n13. 永久区\n\n14. 堆内存调优\n\n15. GC\n\n    1. ​ 常用算法\n\n16. JMM\n\n## JVM 体系结构\n\n![JVM架构图](img/article/JAVA-JVM基础-20210426/20190216114129109.png)\n\n## 双亲委派机制\n\n1. 类加载器收到类加载的请求；\n2. 将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器；\n3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前加载器，否则抛出异常，通知子加载器进行加载；\n4. 重复上面步骤 3 次，仍然找不到，Class Not Found。\n\n### 以下为其他资料：\n\n你得先知道\n在介绍双亲委派机制的时候，不得不提 ClassLoader（类加载器）。说 ClassLoader 之前，我们得先了解下 Java 的基本知识。  \n Java 是运行在 Java 的虚拟机(JVM)中的，但是它是如何运行在 JVM 中了呢？我们在 IDE 中编写的 Java 源代码被编译器编译成.class 的字节码文件。然后由我们得 ClassLoader 负责将这些 class 文件给加载到 JVM 中去执行。  \n JVM 中提供了三层的 ClassLoader：\n\nBootstrap classLoader:主要负责加载核心的类库(java.lang.\\*等)，构造 ExtClassLoader 和 APPClassLoader。\n\nExtClassLoader：主要负责加载 jre/lib/ext 目录下的一些扩展的 jar。\n\nAppClassLoader：主要负责加载应用程序的主函数类\n\n那如果有一个我们写的 Hello.java 编译成的 Hello.class 文件，它是如何被加载到 JVM 中的呢？别着急，请继续往下看。\n\n双亲委派机制\n搜索“ClassLoader”,然后打开“java.lang”包下的 ClassLoader 类。然后将代码翻到 loadClass 方法：\n\n```java\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//              -----??-----\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n        // 首先，检查是否已经被类加载器加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            try {\n                // 存在父加载器，递归的交由父加载器\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    // 直到最上面的Bootstrap类加载器\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                c = findClass(name);\n            }\n        }\n        return c;\n}\n```\n\n其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：\n\n![20201217213314510](img/article/JAVA-JVM基础-20210426/20191108105314115.png)\n\n从上图中我们就更容易理解了，当一个 Hello.class 这样的文件要被加载时。不考虑我们自定义类加载器，首先会在 AppClassLoader 中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的 loadClass 方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达 Bootstrap classLoader 之前，都是在检查是否加载过，并不会选择自己去加载。直到 BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出 ClassNotFoundException。那么有人就有下面这种疑问了？\n\n为什么要设计这种机制\n这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被 Bootstrap classLoader 加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是 BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。\n\n总结了一张脑图如下：\n\n![2020121722082798](img/article/JAVA-JVM基础-20210426/2020121722082798.png)\n\n- 双亲委派模型是每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成加载，那么子类尝试自己加载。\n- 双亲委派机制可以避免加载子类自定义的 Object 类、String 类等一些跟 jdk 命名相同的类。使得加载的类都是同一个。这样才安全。\n\n当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。\n\n## 沙箱安全机制\n\njava 安全模型的核心就是 java 沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏，沙箱主要限制系统资源访问，那系统资源包括什么？CPU，内存，文件系统，网络。不同级别的沙箱对这些资源访问的限制也可以不一样。\n\n​ 所有的 java 程序运行都可以指定沙箱，可以定制安全策略。\n\n在 java 中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的代码远程在早期的 java 实现中，安全依赖于沙箱机制，如下图所示 JDK 1.0 安全模型：\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang1.png)\n\n在 java 1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制，如下图所示：\n\nJDK 1.2 安全模型\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang2.png)\n\n当前最新的安全机制实现，则引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain）,对应不一样的权限（Permission)，存在于不同域中的类文件就有了当前域的全部权限，如下图所示 最新的安全模型（jdk 1.6）\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang3.png)\n\n组成沙箱的基本组件：\n\n- 字节码校验器（bytecode verifier）：确保 java 类文件遵循 java 语言规范，这样可以帮助 java 程序实现内存保护，但并不是所有的类文件都会经过字节码校验，比如核心类；\n- 类装载器（class loader）：其中类装载器在 3 个方面对 java 沙箱起作用；\n  - 他防止恶意代码去干涉善意的代码；\n  - 他守护了被信任的类库边界；\n  - 它将代码归入保护域，确定了代码可以进行哪些操作。\n\n虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由 java 虚拟机为每一个类装载器维护的，他们互相之间甚至不可见。\n\n​ 类装载器采用的机制是双亲委派模式。\n\n1. 从最内层 JVM 自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；\n2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。\n3. 存取控制器 (access controller) : 存取控制器可以控制核心 API 对操作系统的存取权限, 而这个控制的策略设定,可以由用户指定。\n4. 安全管理器（security manger）：是核心 API 和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。\n5. 安全软件包（security package）：java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：\n   1. 安全提供者；\n   2. 消息摘要；\n   3. 数字签名； keytools\n   4. 加密；\n   5. 鉴别；\n\n## Native\n\n- native : 凡是带了 native 关键字的，说明 java 的作用域达不到了，会去调用底层 C 语言的库；\n- 会进入本地方法栈；\n- 调用本地方法接口 JNI；\n- JNI 作用：扩展 java 的使用，融合不同 java 语言为 java 所用！ 最初：C, C++；\n- java 诞生的时候 C, C++横行，想要立足，你需要有调用 C, C++ 的程序；\n- 它在内存区域中专门开辟了一块标记区域：Native Method Stack, 登记 Native 方法；\n- JAVA 程序驱动打印机，管理系统！掌握即可，在企业应用中较为少见；\n- 调用其他接口：Socket WebService http\n\n### Native Method Stack\n\n​ 他的具体做法是 Native Method Stack 中登记的 native 方法，在（Execution Engine）执行引擎执行的时候加载 Native Libraies。[本地库]\n\n## PC 寄存器\n\n程序计数器：Program Counter Register\n\n​ 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址，也即 将要执行的代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计；\n\n## 方法区\n\nMethod Area 方法区\n\n​ 方法区是被所有线程共享，所有字段和方法字节码、以及一些特殊方法，如构造函数，接口代码中也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间；\n\n​ 静态变量，常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关；\n\n方法区就存这些内容 static final Class 常量池\n\n## 栈：数据结构\n\n程序 = 数据结构 + 算法\n\n栈：先进后出，后进先出：类似桶\n\n队列：先进先出（FIFO:First Input First Output）\n\n为什么 main（）最先执行最后结束\n\n栈：栈内存，主管程序的运行，生命周期和线程同步；\n\n线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题；\n\n一旦线程结束，栈就 Over；\n\n栈 --- 存储的内容：8 大基本类型 + 对象引用 + 实例的方法；\n\n站运行原理：栈帧\n\n栈满了：StackOverflowError\n\n栈 + 堆 + 方法区\n\njava 对象实例化的过程 --- 百度\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426163943.png)\n\n## 走进 HotSpot 和堆\n\nHeap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。\n\n类加载器读取了类文件后，一般会把类，方法，常量，变量放入堆中，保存我们所有引用类型的真实对象；\n\n堆内存中还要细分为三个区域：\n\n- 新生区（伊甸园区） Young/New\n- 老年区 old\n- 永久区 Perm 1.8 取消了 永久区 perm ，变成了 元空间\n\nGC 垃圾回收，主要是在伊甸园区和养老区；\n\n​ 假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:java heap space\n\n在 JDK 8 以后，永久存储区改了个名字（元空间）；\n\n### 新生区\n\n- 类：诞生和成长的地方，甚至死亡；\n- 伊甸园，所有的对象都是在伊甸园区 new 出来的！\n- 幸存区 0 幸存区 1\n\n新生区 minor gc （轻 GC） 15 次还活着的，放入养老区，养老区满了时 full gc （重 GC）\n\n### 永久区\n\n这个区域常驻内存，用来存放 JDK 自身携带的 Class 对象，Interface 元数据，存储的是 JAVA 运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭 JVM 虚拟机就会释放这个区域的内存；\n\n- jdk1.6 之前：永久代，常量池在方法区；\n\n- jdk1.7： 永久代，但是慢慢地退化了，`去永久代`，常量池在堆中；\n\n- jdk1.8 之后：无永久代，常量池在元空间；\n\n元空间是在逻辑上存在的，不占用 jvm 内存，而是占用计算机内存；\n\nOOM 故障：\n\n- 尝试扩大堆内存；\n- 通过专业工具分析内存 ；\n\n在一个项目中突然出现了 OOM 故障，那么该如何排除，研究为什么出错；\n\n- 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler；\n- Debug 按行分析代码；\n\nMAT，Jprofiler 作用：\n\n- 分析 Dump 内存文件，快速定位内存泄漏；\n- 获得堆中的数据；\n- 获得大的对象;\n- ...........\n\n通过命令参数运行 jar 包 Jprofiler\n\n-Xms 设置初始化内存分配大小 1/164\n\n-Xmx 设置最大分配内存，默认 1/4\n\n-XX:+PrintGCDetails 打印 GC 垃圾回收信息\n\n-XX:+HeapDumpOnOutOfMemoryError //oom Dump\n\n-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError\n\n## GC: 垃圾回收\n\nGC 的作用区域只有堆、元空间、方法区；\n\njvm 再进行 GC 时，并不是对这三个区域统一回收，大部分时候，回收都是新生代：\n\n- 新生代\n- 幸存区\n- 老年区\n\nGC 两种类：轻 GC（普通的 GC），重 GC（全局 GC）\n\n题目：\n\n- JVM 的内存模型和分区-详细到每个分区做什么？\n- 堆里面的分区有哪些？Eden,form to, 老年区，说说他们的特点！\n- GC 的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器;\n- 轻 GC，重 GC 分别在什么时候发生；\n\n### 引用计数法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184103.png)\n\n### 复制算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426183040.png)\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426183748.png)\n\n- 好处：没有内存碎片；\n- 坏处：浪费了内存空间：多了一半空间永远是空 to，假设对象 100%存活（极端情况）\n\n复制算法最佳使用场景：对象存活度较低的时候；新生区；\n\n### 标记清除算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184359.png)\n\n优点：不需要额外空间；\n\n缺点：两次扫描，严重浪费时间，会产生内存碎片。\n\n### 标记清除压缩算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184621.png)\n\n多了一次扫描；\n\n一般会先多进行几次清除，内存碎片变多了，再进行压缩；\n\n### 总结\n\n内存效率：复制算法 > 标记清除算法 > 标记压缩算法；\n\n时间复杂度：复制算法 > 标记清除算法 > 标记压缩算法；\n\n内存整齐度：复制算法 = 标记压缩算法 > 标记清除算法；\n\n内存利用率：标记压缩算法 = 标记清除算法 > 复制算法；\n\n### 分代收集法\n\n年轻代：存活率低，复制算法；\n\n老年代：区域大，存活率高， 标记清除算法 + 标记压缩算法 混合实现\n\nJVM 调优就是调整 程序计数次数（默认 15），加大老年代空间等；\n\n上面仅仅为 **JVM 基础**\n","source":"_posts/JAVA-JVM基础-20210426.md","raw":"---\ntitle: JAVA-JVM基础\ndate: 2021-04-26 22:00:37\ntags:\n  - java基础\n  - 狂神说\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# JVM 探究\n\n<!-- more -->\n\n## 常见面试问题\n\n- 请谈谈对 JVM 的理解？java8 虚拟机和之前的变化更新？\n- 什么是 OOM - OutOfMemory，什么是栈溢出 StackOverFlowError?怎么分析？\n- JVM 的常用调优参数有哪些?\n- 内存快照如何抓取，怎么分析 Dump 文件？\n- 谈谈 JVM 中，类加载器你的认识？\n\n1. jvm 的位置\n\n2. jvm 的体系结构\n\n3. 类加载器\n\n4. 双亲委派机制\n\n5. 沙箱安全机制\n\n6. Native\n\n7. PC 寄存器\n\n8. 方法区\n\n9. 栈\n\n10. 三种 JVM\n\n    java -version 查看 ：\n\n    ` Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)`\n\n11. 堆\n\n12. 新生区、老年区\n\n13. 永久区\n\n14. 堆内存调优\n\n15. GC\n\n    1. ​ 常用算法\n\n16. JMM\n\n## JVM 体系结构\n\n![JVM架构图](img/article/JAVA-JVM基础-20210426/20190216114129109.png)\n\n## 双亲委派机制\n\n1. 类加载器收到类加载的请求；\n2. 将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器；\n3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前加载器，否则抛出异常，通知子加载器进行加载；\n4. 重复上面步骤 3 次，仍然找不到，Class Not Found。\n\n### 以下为其他资料：\n\n你得先知道\n在介绍双亲委派机制的时候，不得不提 ClassLoader（类加载器）。说 ClassLoader 之前，我们得先了解下 Java 的基本知识。  \n Java 是运行在 Java 的虚拟机(JVM)中的，但是它是如何运行在 JVM 中了呢？我们在 IDE 中编写的 Java 源代码被编译器编译成.class 的字节码文件。然后由我们得 ClassLoader 负责将这些 class 文件给加载到 JVM 中去执行。  \n JVM 中提供了三层的 ClassLoader：\n\nBootstrap classLoader:主要负责加载核心的类库(java.lang.\\*等)，构造 ExtClassLoader 和 APPClassLoader。\n\nExtClassLoader：主要负责加载 jre/lib/ext 目录下的一些扩展的 jar。\n\nAppClassLoader：主要负责加载应用程序的主函数类\n\n那如果有一个我们写的 Hello.java 编译成的 Hello.class 文件，它是如何被加载到 JVM 中的呢？别着急，请继续往下看。\n\n双亲委派机制\n搜索“ClassLoader”,然后打开“java.lang”包下的 ClassLoader 类。然后将代码翻到 loadClass 方法：\n\n```java\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//              -----??-----\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n        // 首先，检查是否已经被类加载器加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            try {\n                // 存在父加载器，递归的交由父加载器\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    // 直到最上面的Bootstrap类加载器\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                c = findClass(name);\n            }\n        }\n        return c;\n}\n```\n\n其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：\n\n![20201217213314510](img/article/JAVA-JVM基础-20210426/20191108105314115.png)\n\n从上图中我们就更容易理解了，当一个 Hello.class 这样的文件要被加载时。不考虑我们自定义类加载器，首先会在 AppClassLoader 中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的 loadClass 方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达 Bootstrap classLoader 之前，都是在检查是否加载过，并不会选择自己去加载。直到 BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出 ClassNotFoundException。那么有人就有下面这种疑问了？\n\n为什么要设计这种机制\n这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被 Bootstrap classLoader 加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是 BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。\n\n总结了一张脑图如下：\n\n![2020121722082798](img/article/JAVA-JVM基础-20210426/2020121722082798.png)\n\n- 双亲委派模型是每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成加载，那么子类尝试自己加载。\n- 双亲委派机制可以避免加载子类自定义的 Object 类、String 类等一些跟 jdk 命名相同的类。使得加载的类都是同一个。这样才安全。\n\n当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。\n\n## 沙箱安全机制\n\njava 安全模型的核心就是 java 沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏，沙箱主要限制系统资源访问，那系统资源包括什么？CPU，内存，文件系统，网络。不同级别的沙箱对这些资源访问的限制也可以不一样。\n\n​ 所有的 java 程序运行都可以指定沙箱，可以定制安全策略。\n\n在 java 中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的代码远程在早期的 java 实现中，安全依赖于沙箱机制，如下图所示 JDK 1.0 安全模型：\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang1.png)\n\n在 java 1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制，如下图所示：\n\nJDK 1.2 安全模型\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang2.png)\n\n当前最新的安全机制实现，则引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain）,对应不一样的权限（Permission)，存在于不同域中的类文件就有了当前域的全部权限，如下图所示 最新的安全模型（jdk 1.6）\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/shaxiang3.png)\n\n组成沙箱的基本组件：\n\n- 字节码校验器（bytecode verifier）：确保 java 类文件遵循 java 语言规范，这样可以帮助 java 程序实现内存保护，但并不是所有的类文件都会经过字节码校验，比如核心类；\n- 类装载器（class loader）：其中类装载器在 3 个方面对 java 沙箱起作用；\n  - 他防止恶意代码去干涉善意的代码；\n  - 他守护了被信任的类库边界；\n  - 它将代码归入保护域，确定了代码可以进行哪些操作。\n\n虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由 java 虚拟机为每一个类装载器维护的，他们互相之间甚至不可见。\n\n​ 类装载器采用的机制是双亲委派模式。\n\n1. 从最内层 JVM 自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；\n2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。\n3. 存取控制器 (access controller) : 存取控制器可以控制核心 API 对操作系统的存取权限, 而这个控制的策略设定,可以由用户指定。\n4. 安全管理器（security manger）：是核心 API 和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。\n5. 安全软件包（security package）：java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：\n   1. 安全提供者；\n   2. 消息摘要；\n   3. 数字签名； keytools\n   4. 加密；\n   5. 鉴别；\n\n## Native\n\n- native : 凡是带了 native 关键字的，说明 java 的作用域达不到了，会去调用底层 C 语言的库；\n- 会进入本地方法栈；\n- 调用本地方法接口 JNI；\n- JNI 作用：扩展 java 的使用，融合不同 java 语言为 java 所用！ 最初：C, C++；\n- java 诞生的时候 C, C++横行，想要立足，你需要有调用 C, C++ 的程序；\n- 它在内存区域中专门开辟了一块标记区域：Native Method Stack, 登记 Native 方法；\n- JAVA 程序驱动打印机，管理系统！掌握即可，在企业应用中较为少见；\n- 调用其他接口：Socket WebService http\n\n### Native Method Stack\n\n​ 他的具体做法是 Native Method Stack 中登记的 native 方法，在（Execution Engine）执行引擎执行的时候加载 Native Libraies。[本地库]\n\n## PC 寄存器\n\n程序计数器：Program Counter Register\n\n​ 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址，也即 将要执行的代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计；\n\n## 方法区\n\nMethod Area 方法区\n\n​ 方法区是被所有线程共享，所有字段和方法字节码、以及一些特殊方法，如构造函数，接口代码中也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间；\n\n​ 静态变量，常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关；\n\n方法区就存这些内容 static final Class 常量池\n\n## 栈：数据结构\n\n程序 = 数据结构 + 算法\n\n栈：先进后出，后进先出：类似桶\n\n队列：先进先出（FIFO:First Input First Output）\n\n为什么 main（）最先执行最后结束\n\n栈：栈内存，主管程序的运行，生命周期和线程同步；\n\n线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题；\n\n一旦线程结束，栈就 Over；\n\n栈 --- 存储的内容：8 大基本类型 + 对象引用 + 实例的方法；\n\n站运行原理：栈帧\n\n栈满了：StackOverflowError\n\n栈 + 堆 + 方法区\n\njava 对象实例化的过程 --- 百度\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426163943.png)\n\n## 走进 HotSpot 和堆\n\nHeap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。\n\n类加载器读取了类文件后，一般会把类，方法，常量，变量放入堆中，保存我们所有引用类型的真实对象；\n\n堆内存中还要细分为三个区域：\n\n- 新生区（伊甸园区） Young/New\n- 老年区 old\n- 永久区 Perm 1.8 取消了 永久区 perm ，变成了 元空间\n\nGC 垃圾回收，主要是在伊甸园区和养老区；\n\n​ 假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:java heap space\n\n在 JDK 8 以后，永久存储区改了个名字（元空间）；\n\n### 新生区\n\n- 类：诞生和成长的地方，甚至死亡；\n- 伊甸园，所有的对象都是在伊甸园区 new 出来的！\n- 幸存区 0 幸存区 1\n\n新生区 minor gc （轻 GC） 15 次还活着的，放入养老区，养老区满了时 full gc （重 GC）\n\n### 永久区\n\n这个区域常驻内存，用来存放 JDK 自身携带的 Class 对象，Interface 元数据，存储的是 JAVA 运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭 JVM 虚拟机就会释放这个区域的内存；\n\n- jdk1.6 之前：永久代，常量池在方法区；\n\n- jdk1.7： 永久代，但是慢慢地退化了，`去永久代`，常量池在堆中；\n\n- jdk1.8 之后：无永久代，常量池在元空间；\n\n元空间是在逻辑上存在的，不占用 jvm 内存，而是占用计算机内存；\n\nOOM 故障：\n\n- 尝试扩大堆内存；\n- 通过专业工具分析内存 ；\n\n在一个项目中突然出现了 OOM 故障，那么该如何排除，研究为什么出错；\n\n- 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler；\n- Debug 按行分析代码；\n\nMAT，Jprofiler 作用：\n\n- 分析 Dump 内存文件，快速定位内存泄漏；\n- 获得堆中的数据；\n- 获得大的对象;\n- ...........\n\n通过命令参数运行 jar 包 Jprofiler\n\n-Xms 设置初始化内存分配大小 1/164\n\n-Xmx 设置最大分配内存，默认 1/4\n\n-XX:+PrintGCDetails 打印 GC 垃圾回收信息\n\n-XX:+HeapDumpOnOutOfMemoryError //oom Dump\n\n-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError\n\n## GC: 垃圾回收\n\nGC 的作用区域只有堆、元空间、方法区；\n\njvm 再进行 GC 时，并不是对这三个区域统一回收，大部分时候，回收都是新生代：\n\n- 新生代\n- 幸存区\n- 老年区\n\nGC 两种类：轻 GC（普通的 GC），重 GC（全局 GC）\n\n题目：\n\n- JVM 的内存模型和分区-详细到每个分区做什么？\n- 堆里面的分区有哪些？Eden,form to, 老年区，说说他们的特点！\n- GC 的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器;\n- 轻 GC，重 GC 分别在什么时候发生；\n\n### 引用计数法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184103.png)\n\n### 复制算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426183040.png)\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426183748.png)\n\n- 好处：没有内存碎片；\n- 坏处：浪费了内存空间：多了一半空间永远是空 to，假设对象 100%存活（极端情况）\n\n复制算法最佳使用场景：对象存活度较低的时候；新生区；\n\n### 标记清除算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184359.png)\n\n优点：不需要额外空间；\n\n缺点：两次扫描，严重浪费时间，会产生内存碎片。\n\n### 标记清除压缩算法\n\n![shaxiang1](img/article/JAVA-JVM基础-20210426/20210426184621.png)\n\n多了一次扫描；\n\n一般会先多进行几次清除，内存碎片变多了，再进行压缩；\n\n### 总结\n\n内存效率：复制算法 > 标记清除算法 > 标记压缩算法；\n\n时间复杂度：复制算法 > 标记清除算法 > 标记压缩算法；\n\n内存整齐度：复制算法 = 标记压缩算法 > 标记清除算法；\n\n内存利用率：标记压缩算法 = 标记清除算法 > 复制算法；\n\n### 分代收集法\n\n年轻代：存活率低，复制算法；\n\n老年代：区域大，存活率高， 标记清除算法 + 标记压缩算法 混合实现\n\nJVM 调优就是调整 程序计数次数（默认 15），加大老年代空间等；\n\n上面仅仅为 **JVM 基础**\n","slug":"JAVA-JVM基础-20210426","published":1,"updated":"2022-06-14T04:09:00.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x15000ky4w154y1d9wh","content":"<h1 id=\"JVM-探究\"><a href=\"#JVM-探究\" class=\"headerlink\" title=\"JVM 探究\"></a>JVM 探究</h1><span id=\"more\"></span>\n\n<h2 id=\"常见面试问题\"><a href=\"#常见面试问题\" class=\"headerlink\" title=\"常见面试问题\"></a>常见面试问题</h2><ul>\n<li>请谈谈对 JVM 的理解？java8 虚拟机和之前的变化更新？</li>\n<li>什么是 OOM - OutOfMemory，什么是栈溢出 StackOverFlowError?怎么分析？</li>\n<li>JVM 的常用调优参数有哪些?</li>\n<li>内存快照如何抓取，怎么分析 Dump 文件？</li>\n<li>谈谈 JVM 中，类加载器你的认识？</li>\n</ul>\n<ol>\n<li><p>jvm 的位置</p>\n</li>\n<li><p>jvm 的体系结构</p>\n</li>\n<li><p>类加载器</p>\n</li>\n<li><p>双亲委派机制</p>\n</li>\n<li><p>沙箱安全机制</p>\n</li>\n<li><p>Native</p>\n</li>\n<li><p>PC 寄存器</p>\n</li>\n<li><p>方法区</p>\n</li>\n<li><p>栈</p>\n</li>\n<li><p>三种 JVM</p>\n<p>java -version 查看 ：</p>\n<p><code> Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</code></p>\n</li>\n<li><p>堆</p>\n</li>\n<li><p>新生区、老年区</p>\n</li>\n<li><p>永久区</p>\n</li>\n<li><p>堆内存调优</p>\n</li>\n<li><p>GC</p>\n<ol>\n<li>​ 常用算法</li>\n</ol>\n</li>\n<li><p>JMM</p>\n</li>\n</ol>\n<h2 id=\"JVM-体系结构\"><a href=\"#JVM-体系结构\" class=\"headerlink\" title=\"JVM 体系结构\"></a>JVM 体系结构</h2><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20190216114129109.png\" alt=\"JVM架构图\"></p>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><ol>\n<li>类加载器收到类加载的请求；</li>\n<li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器；</li>\n<li>启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前加载器，否则抛出异常，通知子加载器进行加载；</li>\n<li>重复上面步骤 3 次，仍然找不到，Class Not Found。</li>\n</ol>\n<h3 id=\"以下为其他资料：\"><a href=\"#以下为其他资料：\" class=\"headerlink\" title=\"以下为其他资料：\"></a>以下为其他资料：</h3><p>你得先知道<br>在介绍双亲委派机制的时候，不得不提 ClassLoader（类加载器）。说 ClassLoader 之前，我们得先了解下 Java 的基本知识。<br> Java 是运行在 Java 的虚拟机(JVM)中的，但是它是如何运行在 JVM 中了呢？我们在 IDE 中编写的 Java 源代码被编译器编译成.class 的字节码文件。然后由我们得 ClassLoader 负责将这些 class 文件给加载到 JVM 中去执行。<br> JVM 中提供了三层的 ClassLoader：</p>\n<p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造 ExtClassLoader 和 APPClassLoader。</p>\n<p>ExtClassLoader：主要负责加载 jre/lib/ext 目录下的一些扩展的 jar。</p>\n<p>AppClassLoader：主要负责加载应用程序的主函数类</p>\n<p>那如果有一个我们写的 Hello.java 编译成的 Hello.class 文件，它是如何被加载到 JVM 中的呢？别着急，请继续往下看。</p>\n<p>双亲委派机制<br>搜索“ClassLoader”,然后打开“java.lang”包下的 ClassLoader 类。然后将代码翻到 loadClass 方法：</p>\n<pre><code class=\"java\">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;\n    return loadClass(name, false);\n&#125;\n//              -----??-----\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n&#123;\n        // 首先，检查是否已经被类加载器加载过\n        Class&lt;?&gt; c = findLoadedClass(name);\n        if (c == null) &#123;\n            try &#123;\n                // 存在父加载器，递归的交由父加载器\n                if (parent != null) &#123;\n                    c = parent.loadClass(name, false);\n                &#125; else &#123;\n                    // 直到最上面的Bootstrap类加载器\n                    c = findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            &#125;\n\n            if (c == null) &#123;\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                c = findClass(name);\n            &#125;\n        &#125;\n        return c;\n&#125;\n</code></pre>\n<p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20191108105314115.png\" alt=\"20201217213314510\"></p>\n<p>从上图中我们就更容易理解了，当一个 Hello.class 这样的文件要被加载时。不考虑我们自定义类加载器，首先会在 AppClassLoader 中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的 loadClass 方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达 Bootstrap classLoader 之前，都是在检查是否加载过，并不会选择自己去加载。直到 BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出 ClassNotFoundException。那么有人就有下面这种疑问了？</p>\n<p>为什么要设计这种机制<br>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被 Bootstrap classLoader 加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是 BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p>\n<p>总结了一张脑图如下：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/2020121722082798.png\" alt=\"2020121722082798\"></p>\n<ul>\n<li>双亲委派模型是每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成加载，那么子类尝试自己加载。</li>\n<li>双亲委派机制可以避免加载子类自定义的 Object 类、String 类等一些跟 jdk 命名相同的类。使得加载的类都是同一个。这样才安全。</li>\n</ul>\n<p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。</p>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p>java 安全模型的核心就是 java 沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏，沙箱主要限制系统资源访问，那系统资源包括什么？CPU，内存，文件系统，网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>\n<p>​ 所有的 java 程序运行都可以指定沙箱，可以定制安全策略。</p>\n<p>在 java 中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的代码远程在早期的 java 实现中，安全依赖于沙箱机制，如下图所示 JDK 1.0 安全模型：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang1.png\" alt=\"shaxiang1\"></p>\n<p>在 java 1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制，如下图所示：</p>\n<p>JDK 1.2 安全模型</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang2.png\" alt=\"shaxiang1\"></p>\n<p>当前最新的安全机制实现，则引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain）,对应不一样的权限（Permission)，存在于不同域中的类文件就有了当前域的全部权限，如下图所示 最新的安全模型（jdk 1.6）</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang3.png\" alt=\"shaxiang1\"></p>\n<p>组成沙箱的基本组件：</p>\n<ul>\n<li>字节码校验器（bytecode verifier）：确保 java 类文件遵循 java 语言规范，这样可以帮助 java 程序实现内存保护，但并不是所有的类文件都会经过字节码校验，比如核心类；</li>\n<li>类装载器（class loader）：其中类装载器在 3 个方面对 java 沙箱起作用；<ul>\n<li>他防止恶意代码去干涉善意的代码；</li>\n<li>他守护了被信任的类库边界；</li>\n<li>它将代码归入保护域，确定了代码可以进行哪些操作。</li>\n</ul>\n</li>\n</ul>\n<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由 java 虚拟机为每一个类装载器维护的，他们互相之间甚至不可见。</p>\n<p>​ 类装载器采用的机制是双亲委派模式。</p>\n<ol>\n<li>从最内层 JVM 自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li>\n<li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>\n<li>存取控制器 (access controller) : 存取控制器可以控制核心 API 对操作系统的存取权限, 而这个控制的策略设定,可以由用户指定。</li>\n<li>安全管理器（security manger）：是核心 API 和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。</li>\n<li>安全软件包（security package）：java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ol>\n<li>安全提供者；</li>\n<li>消息摘要；</li>\n<li>数字签名； keytools</li>\n<li>加密；</li>\n<li>鉴别；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h2><ul>\n<li>native : 凡是带了 native 关键字的，说明 java 的作用域达不到了，会去调用底层 C 语言的库；</li>\n<li>会进入本地方法栈；</li>\n<li>调用本地方法接口 JNI；</li>\n<li>JNI 作用：扩展 java 的使用，融合不同 java 语言为 java 所用！ 最初：C, C++；</li>\n<li>java 诞生的时候 C, C++横行，想要立足，你需要有调用 C, C++ 的程序；</li>\n<li>它在内存区域中专门开辟了一块标记区域：Native Method Stack, 登记 Native 方法；</li>\n<li>JAVA 程序驱动打印机，管理系统！掌握即可，在企业应用中较为少见；</li>\n<li>调用其他接口：Socket WebService http</li>\n</ul>\n<h3 id=\"Native-Method-Stack\"><a href=\"#Native-Method-Stack\" class=\"headerlink\" title=\"Native Method Stack\"></a>Native Method Stack</h3><p>​ 他的具体做法是 Native Method Stack 中登记的 native 方法，在（Execution Engine）执行引擎执行的时候加载 Native Libraies。[本地库]</p>\n<h2 id=\"PC-寄存器\"><a href=\"#PC-寄存器\" class=\"headerlink\" title=\"PC 寄存器\"></a>PC 寄存器</h2><p>程序计数器：Program Counter Register</p>\n<p>​ 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址，也即 将要执行的代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计；</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>Method Area 方法区</p>\n<p>​ 方法区是被所有线程共享，所有字段和方法字节码、以及一些特殊方法，如构造函数，接口代码中也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间；</p>\n<p>​ 静态变量，常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关；</p>\n<p>方法区就存这些内容 static final Class 常量池</p>\n<h2 id=\"栈：数据结构\"><a href=\"#栈：数据结构\" class=\"headerlink\" title=\"栈：数据结构\"></a>栈：数据结构</h2><p>程序 = 数据结构 + 算法</p>\n<p>栈：先进后出，后进先出：类似桶</p>\n<p>队列：先进先出（FIFO:First Input First Output）</p>\n<p>为什么 main（）最先执行最后结束</p>\n<p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p>\n<p>线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题；</p>\n<p>一旦线程结束，栈就 Over；</p>\n<p>栈 — 存储的内容：8 大基本类型 + 对象引用 + 实例的方法；</p>\n<p>站运行原理：栈帧</p>\n<p>栈满了：StackOverflowError</p>\n<p>栈 + 堆 + 方法区</p>\n<p>java 对象实例化的过程 — 百度</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426163943.png\" alt=\"shaxiang1\"></p>\n<h2 id=\"走进-HotSpot-和堆\"><a href=\"#走进-HotSpot-和堆\" class=\"headerlink\" title=\"走进 HotSpot 和堆\"></a>走进 HotSpot 和堆</h2><p>Heap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。</p>\n<p>类加载器读取了类文件后，一般会把类，方法，常量，变量放入堆中，保存我们所有引用类型的真实对象；</p>\n<p>堆内存中还要细分为三个区域：</p>\n<ul>\n<li>新生区（伊甸园区） Young/New</li>\n<li>老年区 old</li>\n<li>永久区 Perm 1.8 取消了 永久区 perm ，变成了 元空间</li>\n</ul>\n<p>GC 垃圾回收，主要是在伊甸园区和养老区；</p>\n<p>​ 假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:java heap space</p>\n<p>在 JDK 8 以后，永久存储区改了个名字（元空间）；</p>\n<h3 id=\"新生区\"><a href=\"#新生区\" class=\"headerlink\" title=\"新生区\"></a>新生区</h3><ul>\n<li>类：诞生和成长的地方，甚至死亡；</li>\n<li>伊甸园，所有的对象都是在伊甸园区 new 出来的！</li>\n<li>幸存区 0 幸存区 1</li>\n</ul>\n<p>新生区 minor gc （轻 GC） 15 次还活着的，放入养老区，养老区满了时 full gc （重 GC）</p>\n<h3 id=\"永久区\"><a href=\"#永久区\" class=\"headerlink\" title=\"永久区\"></a>永久区</h3><p>这个区域常驻内存，用来存放 JDK 自身携带的 Class 对象，Interface 元数据，存储的是 JAVA 运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭 JVM 虚拟机就会释放这个区域的内存；</p>\n<ul>\n<li><p>jdk1.6 之前：永久代，常量池在方法区；</p>\n</li>\n<li><p>jdk1.7： 永久代，但是慢慢地退化了，<code>去永久代</code>，常量池在堆中；</p>\n</li>\n<li><p>jdk1.8 之后：无永久代，常量池在元空间；</p>\n</li>\n</ul>\n<p>元空间是在逻辑上存在的，不占用 jvm 内存，而是占用计算机内存；</p>\n<p>OOM 故障：</p>\n<ul>\n<li>尝试扩大堆内存；</li>\n<li>通过专业工具分析内存 ；</li>\n</ul>\n<p>在一个项目中突然出现了 OOM 故障，那么该如何排除，研究为什么出错；</p>\n<ul>\n<li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler；</li>\n<li>Debug 按行分析代码；</li>\n</ul>\n<p>MAT，Jprofiler 作用：</p>\n<ul>\n<li>分析 Dump 内存文件，快速定位内存泄漏；</li>\n<li>获得堆中的数据；</li>\n<li>获得大的对象;</li>\n<li>………..</li>\n</ul>\n<p>通过命令参数运行 jar 包 Jprofiler</p>\n<p>-Xms 设置初始化内存分配大小 1/164</p>\n<p>-Xmx 设置最大分配内存，默认 1/4</p>\n<p>-XX:+PrintGCDetails 打印 GC 垃圾回收信息</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError //oom Dump</p>\n<p>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</p>\n<h2 id=\"GC-垃圾回收\"><a href=\"#GC-垃圾回收\" class=\"headerlink\" title=\"GC: 垃圾回收\"></a>GC: 垃圾回收</h2><p>GC 的作用区域只有堆、元空间、方法区；</p>\n<p>jvm 再进行 GC 时，并不是对这三个区域统一回收，大部分时候，回收都是新生代：</p>\n<ul>\n<li>新生代</li>\n<li>幸存区</li>\n<li>老年区</li>\n</ul>\n<p>GC 两种类：轻 GC（普通的 GC），重 GC（全局 GC）</p>\n<p>题目：</p>\n<ul>\n<li>JVM 的内存模型和分区-详细到每个分区做什么？</li>\n<li>堆里面的分区有哪些？Eden,form to, 老年区，说说他们的特点！</li>\n<li>GC 的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器;</li>\n<li>轻 GC，重 GC 分别在什么时候发生；</li>\n</ul>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184103.png\" alt=\"shaxiang1\"></p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426183040.png\" alt=\"shaxiang1\"></p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426183748.png\" alt=\"shaxiang1\"></p>\n<ul>\n<li>好处：没有内存碎片；</li>\n<li>坏处：浪费了内存空间：多了一半空间永远是空 to，假设对象 100%存活（极端情况）</li>\n</ul>\n<p>复制算法最佳使用场景：对象存活度较低的时候；新生区；</p>\n<h3 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184359.png\" alt=\"shaxiang1\"></p>\n<p>优点：不需要额外空间；</p>\n<p>缺点：两次扫描，严重浪费时间，会产生内存碎片。</p>\n<h3 id=\"标记清除压缩算法\"><a href=\"#标记清除压缩算法\" class=\"headerlink\" title=\"标记清除压缩算法\"></a>标记清除压缩算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184621.png\" alt=\"shaxiang1\"></p>\n<p>多了一次扫描；</p>\n<p>一般会先多进行几次清除，内存碎片变多了，再进行压缩；</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法；</p>\n<p>时间复杂度：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法；</p>\n<p>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法；</p>\n<p>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法；</p>\n<h3 id=\"分代收集法\"><a href=\"#分代收集法\" class=\"headerlink\" title=\"分代收集法\"></a>分代收集法</h3><p>年轻代：存活率低，复制算法；</p>\n<p>老年代：区域大，存活率高， 标记清除算法 + 标记压缩算法 混合实现</p>\n<p>JVM 调优就是调整 程序计数次数（默认 15），加大老年代空间等；</p>\n<p>上面仅仅为 <strong>JVM 基础</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JVM-探究\"><a href=\"#JVM-探究\" class=\"headerlink\" title=\"JVM 探究\"></a>JVM 探究</h1>","more":"<h2 id=\"常见面试问题\"><a href=\"#常见面试问题\" class=\"headerlink\" title=\"常见面试问题\"></a>常见面试问题</h2><ul>\n<li>请谈谈对 JVM 的理解？java8 虚拟机和之前的变化更新？</li>\n<li>什么是 OOM - OutOfMemory，什么是栈溢出 StackOverFlowError?怎么分析？</li>\n<li>JVM 的常用调优参数有哪些?</li>\n<li>内存快照如何抓取，怎么分析 Dump 文件？</li>\n<li>谈谈 JVM 中，类加载器你的认识？</li>\n</ul>\n<ol>\n<li><p>jvm 的位置</p>\n</li>\n<li><p>jvm 的体系结构</p>\n</li>\n<li><p>类加载器</p>\n</li>\n<li><p>双亲委派机制</p>\n</li>\n<li><p>沙箱安全机制</p>\n</li>\n<li><p>Native</p>\n</li>\n<li><p>PC 寄存器</p>\n</li>\n<li><p>方法区</p>\n</li>\n<li><p>栈</p>\n</li>\n<li><p>三种 JVM</p>\n<p>java -version 查看 ：</p>\n<p><code> Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</code></p>\n</li>\n<li><p>堆</p>\n</li>\n<li><p>新生区、老年区</p>\n</li>\n<li><p>永久区</p>\n</li>\n<li><p>堆内存调优</p>\n</li>\n<li><p>GC</p>\n<ol>\n<li>​ 常用算法</li>\n</ol>\n</li>\n<li><p>JMM</p>\n</li>\n</ol>\n<h2 id=\"JVM-体系结构\"><a href=\"#JVM-体系结构\" class=\"headerlink\" title=\"JVM 体系结构\"></a>JVM 体系结构</h2><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20190216114129109.png\" alt=\"JVM架构图\"></p>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><ol>\n<li>类加载器收到类加载的请求；</li>\n<li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器；</li>\n<li>启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前加载器，否则抛出异常，通知子加载器进行加载；</li>\n<li>重复上面步骤 3 次，仍然找不到，Class Not Found。</li>\n</ol>\n<h3 id=\"以下为其他资料：\"><a href=\"#以下为其他资料：\" class=\"headerlink\" title=\"以下为其他资料：\"></a>以下为其他资料：</h3><p>你得先知道<br>在介绍双亲委派机制的时候，不得不提 ClassLoader（类加载器）。说 ClassLoader 之前，我们得先了解下 Java 的基本知识。<br> Java 是运行在 Java 的虚拟机(JVM)中的，但是它是如何运行在 JVM 中了呢？我们在 IDE 中编写的 Java 源代码被编译器编译成.class 的字节码文件。然后由我们得 ClassLoader 负责将这些 class 文件给加载到 JVM 中去执行。<br> JVM 中提供了三层的 ClassLoader：</p>\n<p>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造 ExtClassLoader 和 APPClassLoader。</p>\n<p>ExtClassLoader：主要负责加载 jre/lib/ext 目录下的一些扩展的 jar。</p>\n<p>AppClassLoader：主要负责加载应用程序的主函数类</p>\n<p>那如果有一个我们写的 Hello.java 编译成的 Hello.class 文件，它是如何被加载到 JVM 中的呢？别着急，请继续往下看。</p>\n<p>双亲委派机制<br>搜索“ClassLoader”,然后打开“java.lang”包下的 ClassLoader 类。然后将代码翻到 loadClass 方法：</p>\n<pre><code class=\"java\">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;\n    return loadClass(name, false);\n&#125;\n//              -----??-----\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n&#123;\n        // 首先，检查是否已经被类加载器加载过\n        Class&lt;?&gt; c = findLoadedClass(name);\n        if (c == null) &#123;\n            try &#123;\n                // 存在父加载器，递归的交由父加载器\n                if (parent != null) &#123;\n                    c = parent.loadClass(name, false);\n                &#125; else &#123;\n                    // 直到最上面的Bootstrap类加载器\n                    c = findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            &#125;\n\n            if (c == null) &#123;\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                c = findClass(name);\n            &#125;\n        &#125;\n        return c;\n&#125;\n</code></pre>\n<p>其实这段代码已经很好的解释了双亲委派机制，为了大家更容易理解，我做了一张图来描述一下上面这段代码的流程：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20191108105314115.png\" alt=\"20201217213314510\"></p>\n<p>从上图中我们就更容易理解了，当一个 Hello.class 这样的文件要被加载时。不考虑我们自定义类加载器，首先会在 AppClassLoader 中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的 loadClass 方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达 Bootstrap classLoader 之前，都是在检查是否加载过，并不会选择自己去加载。直到 BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出 ClassNotFoundException。那么有人就有下面这种疑问了？</p>\n<p>为什么要设计这种机制<br>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被 Bootstrap classLoader 加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是 BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p>\n<p>总结了一张脑图如下：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/2020121722082798.png\" alt=\"2020121722082798\"></p>\n<ul>\n<li>双亲委派模型是每次收到类加载请求时，先将请求委派给父类加载器完成，如果父类加载器无法完成加载，那么子类尝试自己加载。</li>\n<li>双亲委派机制可以避免加载子类自定义的 Object 类、String 类等一些跟 jdk 命名相同的类。使得加载的类都是同一个。这样才安全。</li>\n</ul>\n<p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。</p>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p>java 安全模型的核心就是 java 沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏，沙箱主要限制系统资源访问，那系统资源包括什么？CPU，内存，文件系统，网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>\n<p>​ 所有的 java 程序运行都可以指定沙箱，可以定制安全策略。</p>\n<p>在 java 中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信任的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的代码远程在早期的 java 实现中，安全依赖于沙箱机制，如下图所示 JDK 1.0 安全模型：</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang1.png\" alt=\"shaxiang1\"></p>\n<p>在 java 1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制，如下图所示：</p>\n<p>JDK 1.2 安全模型</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang2.png\" alt=\"shaxiang1\"></p>\n<p>当前最新的安全机制实现，则引入了域（Domain）的概念，虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain）,对应不一样的权限（Permission)，存在于不同域中的类文件就有了当前域的全部权限，如下图所示 最新的安全模型（jdk 1.6）</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/shaxiang3.png\" alt=\"shaxiang1\"></p>\n<p>组成沙箱的基本组件：</p>\n<ul>\n<li>字节码校验器（bytecode verifier）：确保 java 类文件遵循 java 语言规范，这样可以帮助 java 程序实现内存保护，但并不是所有的类文件都会经过字节码校验，比如核心类；</li>\n<li>类装载器（class loader）：其中类装载器在 3 个方面对 java 沙箱起作用；<ul>\n<li>他防止恶意代码去干涉善意的代码；</li>\n<li>他守护了被信任的类库边界；</li>\n<li>它将代码归入保护域，确定了代码可以进行哪些操作。</li>\n</ul>\n</li>\n</ul>\n<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由 java 虚拟机为每一个类装载器维护的，他们互相之间甚至不可见。</p>\n<p>​ 类装载器采用的机制是双亲委派模式。</p>\n<ol>\n<li>从最内层 JVM 自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li>\n<li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>\n<li>存取控制器 (access controller) : 存取控制器可以控制核心 API 对操作系统的存取权限, 而这个控制的策略设定,可以由用户指定。</li>\n<li>安全管理器（security manger）：是核心 API 和操作系统之间的主要接口，实现权限控制，比存取控制器优先级高。</li>\n<li>安全软件包（security package）：java.security 下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ol>\n<li>安全提供者；</li>\n<li>消息摘要；</li>\n<li>数字签名； keytools</li>\n<li>加密；</li>\n<li>鉴别；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h2><ul>\n<li>native : 凡是带了 native 关键字的，说明 java 的作用域达不到了，会去调用底层 C 语言的库；</li>\n<li>会进入本地方法栈；</li>\n<li>调用本地方法接口 JNI；</li>\n<li>JNI 作用：扩展 java 的使用，融合不同 java 语言为 java 所用！ 最初：C, C++；</li>\n<li>java 诞生的时候 C, C++横行，想要立足，你需要有调用 C, C++ 的程序；</li>\n<li>它在内存区域中专门开辟了一块标记区域：Native Method Stack, 登记 Native 方法；</li>\n<li>JAVA 程序驱动打印机，管理系统！掌握即可，在企业应用中较为少见；</li>\n<li>调用其他接口：Socket WebService http</li>\n</ul>\n<h3 id=\"Native-Method-Stack\"><a href=\"#Native-Method-Stack\" class=\"headerlink\" title=\"Native Method Stack\"></a>Native Method Stack</h3><p>​ 他的具体做法是 Native Method Stack 中登记的 native 方法，在（Execution Engine）执行引擎执行的时候加载 Native Libraies。[本地库]</p>\n<h2 id=\"PC-寄存器\"><a href=\"#PC-寄存器\" class=\"headerlink\" title=\"PC 寄存器\"></a>PC 寄存器</h2><p>程序计数器：Program Counter Register</p>\n<p>​ 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像一条指令的地址，也即 将要执行的代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计；</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>Method Area 方法区</p>\n<p>​ 方法区是被所有线程共享，所有字段和方法字节码、以及一些特殊方法，如构造函数，接口代码中也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间；</p>\n<p>​ 静态变量，常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关；</p>\n<p>方法区就存这些内容 static final Class 常量池</p>\n<h2 id=\"栈：数据结构\"><a href=\"#栈：数据结构\" class=\"headerlink\" title=\"栈：数据结构\"></a>栈：数据结构</h2><p>程序 = 数据结构 + 算法</p>\n<p>栈：先进后出，后进先出：类似桶</p>\n<p>队列：先进先出（FIFO:First Input First Output）</p>\n<p>为什么 main（）最先执行最后结束</p>\n<p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p>\n<p>线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题；</p>\n<p>一旦线程结束，栈就 Over；</p>\n<p>栈 — 存储的内容：8 大基本类型 + 对象引用 + 实例的方法；</p>\n<p>站运行原理：栈帧</p>\n<p>栈满了：StackOverflowError</p>\n<p>栈 + 堆 + 方法区</p>\n<p>java 对象实例化的过程 — 百度</p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426163943.png\" alt=\"shaxiang1\"></p>\n<h2 id=\"走进-HotSpot-和堆\"><a href=\"#走进-HotSpot-和堆\" class=\"headerlink\" title=\"走进 HotSpot 和堆\"></a>走进 HotSpot 和堆</h2><p>Heap, 一个 JVM 只有一个堆内存，堆内存的大小是可以调节的。</p>\n<p>类加载器读取了类文件后，一般会把类，方法，常量，变量放入堆中，保存我们所有引用类型的真实对象；</p>\n<p>堆内存中还要细分为三个区域：</p>\n<ul>\n<li>新生区（伊甸园区） Young/New</li>\n<li>老年区 old</li>\n<li>永久区 Perm 1.8 取消了 永久区 perm ，变成了 元空间</li>\n</ul>\n<p>GC 垃圾回收，主要是在伊甸园区和养老区；</p>\n<p>​ 假设内存满了，OOM，堆内存不够！java.lang.OutOfMemoryError:java heap space</p>\n<p>在 JDK 8 以后，永久存储区改了个名字（元空间）；</p>\n<h3 id=\"新生区\"><a href=\"#新生区\" class=\"headerlink\" title=\"新生区\"></a>新生区</h3><ul>\n<li>类：诞生和成长的地方，甚至死亡；</li>\n<li>伊甸园，所有的对象都是在伊甸园区 new 出来的！</li>\n<li>幸存区 0 幸存区 1</li>\n</ul>\n<p>新生区 minor gc （轻 GC） 15 次还活着的，放入养老区，养老区满了时 full gc （重 GC）</p>\n<h3 id=\"永久区\"><a href=\"#永久区\" class=\"headerlink\" title=\"永久区\"></a>永久区</h3><p>这个区域常驻内存，用来存放 JDK 自身携带的 Class 对象，Interface 元数据，存储的是 JAVA 运行时的一些环境或类信息，这个区域不存在垃圾回收！关闭 JVM 虚拟机就会释放这个区域的内存；</p>\n<ul>\n<li><p>jdk1.6 之前：永久代，常量池在方法区；</p>\n</li>\n<li><p>jdk1.7： 永久代，但是慢慢地退化了，<code>去永久代</code>，常量池在堆中；</p>\n</li>\n<li><p>jdk1.8 之后：无永久代，常量池在元空间；</p>\n</li>\n</ul>\n<p>元空间是在逻辑上存在的，不占用 jvm 内存，而是占用计算机内存；</p>\n<p>OOM 故障：</p>\n<ul>\n<li>尝试扩大堆内存；</li>\n<li>通过专业工具分析内存 ；</li>\n</ul>\n<p>在一个项目中突然出现了 OOM 故障，那么该如何排除，研究为什么出错；</p>\n<ul>\n<li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler；</li>\n<li>Debug 按行分析代码；</li>\n</ul>\n<p>MAT，Jprofiler 作用：</p>\n<ul>\n<li>分析 Dump 内存文件，快速定位内存泄漏；</li>\n<li>获得堆中的数据；</li>\n<li>获得大的对象;</li>\n<li>………..</li>\n</ul>\n<p>通过命令参数运行 jar 包 Jprofiler</p>\n<p>-Xms 设置初始化内存分配大小 1/164</p>\n<p>-Xmx 设置最大分配内存，默认 1/4</p>\n<p>-XX:+PrintGCDetails 打印 GC 垃圾回收信息</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError //oom Dump</p>\n<p>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</p>\n<h2 id=\"GC-垃圾回收\"><a href=\"#GC-垃圾回收\" class=\"headerlink\" title=\"GC: 垃圾回收\"></a>GC: 垃圾回收</h2><p>GC 的作用区域只有堆、元空间、方法区；</p>\n<p>jvm 再进行 GC 时，并不是对这三个区域统一回收，大部分时候，回收都是新生代：</p>\n<ul>\n<li>新生代</li>\n<li>幸存区</li>\n<li>老年区</li>\n</ul>\n<p>GC 两种类：轻 GC（普通的 GC），重 GC（全局 GC）</p>\n<p>题目：</p>\n<ul>\n<li>JVM 的内存模型和分区-详细到每个分区做什么？</li>\n<li>堆里面的分区有哪些？Eden,form to, 老年区，说说他们的特点！</li>\n<li>GC 的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器;</li>\n<li>轻 GC，重 GC 分别在什么时候发生；</li>\n</ul>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184103.png\" alt=\"shaxiang1\"></p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426183040.png\" alt=\"shaxiang1\"></p>\n<p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426183748.png\" alt=\"shaxiang1\"></p>\n<ul>\n<li>好处：没有内存碎片；</li>\n<li>坏处：浪费了内存空间：多了一半空间永远是空 to，假设对象 100%存活（极端情况）</li>\n</ul>\n<p>复制算法最佳使用场景：对象存活度较低的时候；新生区；</p>\n<h3 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184359.png\" alt=\"shaxiang1\"></p>\n<p>优点：不需要额外空间；</p>\n<p>缺点：两次扫描，严重浪费时间，会产生内存碎片。</p>\n<h3 id=\"标记清除压缩算法\"><a href=\"#标记清除压缩算法\" class=\"headerlink\" title=\"标记清除压缩算法\"></a>标记清除压缩算法</h3><p><img src=\"img/article/JAVA-JVM%E5%9F%BA%E7%A1%80-20210426/20210426184621.png\" alt=\"shaxiang1\"></p>\n<p>多了一次扫描；</p>\n<p>一般会先多进行几次清除，内存碎片变多了，再进行压缩；</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法；</p>\n<p>时间复杂度：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法；</p>\n<p>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法；</p>\n<p>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法；</p>\n<h3 id=\"分代收集法\"><a href=\"#分代收集法\" class=\"headerlink\" title=\"分代收集法\"></a>分代收集法</h3><p>年轻代：存活率低，复制算法；</p>\n<p>老年代：区域大，存活率高， 标记清除算法 + 标记压缩算法 混合实现</p>\n<p>JVM 调优就是调整 程序计数次数（默认 15），加大老年代空间等；</p>\n<p>上面仅仅为 <strong>JVM 基础</strong></p>"},{"title":"JAVA-MyBatis","date":"2021-05-02T17:40:46.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/MyBatis.png","_content":"\n# MyBatis\n\n<!--more-->\n\n## 简介\n\n- mybatis 是一个持久层框架；\n- 支持定制 SQL、存储过程以及高级映射；\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- Mybatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 java 的 POJO（Plain Old Java Objects，普通老式 java 对象）为数据库中的记录。\n\n## 什么是持久化？\n\n数据持久化\n\n- 持久化就是将程序的数据在持久状态和瞬间状态转化的过程；\n- 内存：断电即失；\n- 数据库（jdbc）, io 文件持久化。\n- 生活：冷藏、罐头；\n\n为什么需要持久化？\n\n- 有一些对象不能让丢掉；\n- 内存在系统中很珍贵；\n\n## 持久层\n\nDao 层、Service 层、Controller 层.......\n\n- 完成持久化工作的代码块；\n- 层界限十分明显。\n\n## 为什么需要 Mybatis？\n\n- 帮助程序员将数据存入到数据库中；\n- 方便；\n- 传统的 JDBC 代码太复杂了。简化。框架。自动化。\n- 不用 MyBatis 也可以。但 MyBatis 更容易上手。技术没有高低之分\n- 优点\n  - 简单易学\n  - 灵活\n  - sql 和代码的分离，提高了可维护性。\n  - 提供映射标签，支持对象与数据库的 orm 字段映射。\n  - 提供对象关系映射标签，支持对象关系组件维护。\n  - 提供 xml 标签，支持编写动态 sql。\n\n**最重要的一点：使用的人多！**\n\n## 第一个 MyBatis 程序 `mybatis-01`\n\n- 搭建环境\n\n```sql\nCREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user` (\n`id` INT(20) NOT NULL PRIMARY KEY,\n`name` VARCHAR(30) DEFAULT NULL,\n`pwd` VARCHAR(30) DEFAULT NULL\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\n\nINSERT INTO `user` (`id`,`name`,`pwd`) VALUES\n(1, '狂神', '123456'),\n(2, '李四', '123456'),\n(3, '张三', '123890')\n```\n\n- 新建项目(创建 maven 父子模块)\n\n  - 配置 mybatis 的核心配置文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <!DOCTYPE configuration\n            PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n            \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n    <configuration>\n        <environments default=\"development\">\n            <environment id=\"development\">\n                <transactionManager type=\"JDBC\"/>\n                <dataSource type=\"POOLED\">\n                    <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                    <property name=\"username\" value=\"root\"/>\n                    <property name=\"password\" value=\"123456\"/>\n                </dataSource>\n            </environment>\n        </environments>\n        <mappers>\n            <mapper resource=\"com/shan/dao/UserMapper.xml\"/>\n        </mappers>\n    </configuration>\n    ```\n\n  - 编写 mybatis 工具类\n\n    ```java\n    package com.shan.utils;\n\n    import org.apache.ibatis.io.Resources;\n    import org.apache.ibatis.session.SqlSession;\n    import org.apache.ibatis.session.SqlSessionFactory;\n    import org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n    import java.io.IOException;\n    import java.io.InputStream;\n\n    //sqlSessionFactory  -->  sqlSession\n    public class MybatisUtils {\n        private static SqlSessionFactory sqlSessionFactory;\n\n        static {\n            try {\n                //获取sqlSessionFactory对象\n                String resource = \"mybatis-config.xml\";\n                InputStream is = Resources.getResourceAsStream(resource);\n                sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        //既然有了sqlSessionFactory, 我们可以从中获取sqlSession实例\n        //SqlSession 完全包含了面向数据库执行 SQL 命令所需要的所有方法\n\n        public static SqlSession getSqlSession() {\n            return sqlSessionFactory.openSession();\n        }\n    }\n\n    ```\n\n- 编写实体类\n\n  - 实体类\n\n    ```java\n    package com.shan.pojo;\n\n    public class User {\n        private int id;\n        private String name;\n        private String pwd;\n        public User() {\n        }\n        public User(int id, String name, String pwd) {\n            this.id = id;\n            this.name = name;\n            this.pwd = pwd;\n        }\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getPwd() {\n            return pwd;\n        }\n        public void setPwd(String pwd) {\n            this.pwd = pwd;\n        }\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"id=\" + id +\n                    \", name='\" + name + '\\'' +\n                    \", pwd='\" + pwd + '\\'' +\n                    '}';\n        }\n    }\n    ```\n\n  - Dao 接口\n\n    ```java\n    package com.shan.dao;\n\n    import com.shan.pojo.User;\n\n    import java.util.List;\n\n    public interface UserDao {\n        List<User> getUserList();\n    }\n    ```\n\n  - 接口实现类由原本的 UserDaoOmpl 转变成一个 Mapper 配置文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <!DOCTYPE mapper\n            PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n            \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    <mapper namespace=\"com.shan.dao.UserDao\">\n        <select id=\"getUserList\" resultType=\"com.shan.pojo.User\">\n            select * from user\n        </select>\n    </mapper>\n    ```\n\n- 测试 (测试的包尽量一一对应)\n\n  - junit 测试\n\n    ```shell\n    # 错误1\n    org.apache.ibatis.binding.BindingException: Type interface com.xiaofan.dao.UserDao is not known to the MapperRegistry.\n\n    # 解决方案\n    <mappers>\n    \t<mapper resource=\"com/xiaofan/dao/UserMapper.xml\"/>\n    </mappers>\n\n    # 错误2\n    Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/xiaofan/dao/UserMapper.xml\n\n    # 解决方案\n        <build>\n            <resources>\n                <resource>\n                    <directory>src/main/resources</directory>\n                    <includes>\n                        <include>**/*.properties</include>\n                        <include>**/*.xml</include>\n                        <include>**/*.tld</include>\n                    </includes>\n                    <filtering>true</filtering>\n                </resource>\n                <resource>\n                    <directory>src/main/java</directory>\n                    <includes>\n                        <include>**/*.properties</include>\n                        <include>**/*.xml</include>\n                        <include>**/*.tld</include>\n                    </includes>\n                    <filtering>true</filtering>\n                </resource>\n            </resources>\n        </build>\n\n    ```\n\n可能遇到的问题：\n\n1. 配置文件没有注册\n2. 绑定接口错误\n3. 方法名不对\n4. 返回类型不对\n\n# CRUD\n\n## 1、namespace\n\nnamespace 中的包名要和 Dao/Mapper 接口的包名一致！\n\n## 2、select\n\n选择，查询语句；\n\n- id：就是对应的 nameSpace 中的方法名；\n- resultType：Sql 语句执行的返回值！\n- parameterType：参数类型\n\n## 增删改需要提交事务\n\n```java\nsqlSession.commit();\nsqlSession.close();\n```\n\n## 3、insert,update,delete\n\n```java\nint addUser(User user);\nint updUser(User user);\nint deleteUser(int id);\n```\n\n```java\n@Test\n    public void addUser(){\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.addUser(new User(5, \"haha\", \"123456\"));\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    @Test\n    public void updUser() {\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.updUser(new User(4, \"aa\", \"123456\"));\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    @Test\n    public void deleteUser() {\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.deleteUser(5);\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n```\n\n```xml\n<!--    对象中的属性可以直接取出来-->\n    <insert id=\"addUser\" parameterType=\"com.shan.pojo.User\">\n        insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd})\n    </insert>\n\n    <update id=\"updUser\" parameterType=\"com.shan.pojo.User\">\n        update mybatis.user set name=#{name}, pwd=#{pwd} where id=#{id}\n    </update>\n\n    <delete id=\"deleteUser\" parameterType=\"int\">\n        delete from mybatis.user where id=#{id}\n    </delete>\n```\n\n# 万能 Map\n\n假如我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用 Map 传入数据，而不是对象实体（User）\n\nmap 传递参数，直接在 sql 中取出 key 即可！ parameterType=\"map\"\n\n对象传递参数，直接在 sql 中取出对象的属性即可！\n\n只有一个基本类型参数的情况下，可以直接在 sql 中取到！\n\n多个参数用 map, 或者注解\n\n```java\n@Test\n    public void getUserByIdandName(){\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap<String, Object> objectMap = new HashMap<String, Object>();\n        objectMap.put(\"userid\", 7);\n        objectMap.put(\"username\", \"zz\");\n        User user = mapper.getUserByIdandName(objectMap);\n        System.out.println(user.toString());\n        sqlSession.close();\n    }\n```\n\n```xml\n<select id=\"getUserByIdandName\"  parameterType=\"map\" resultType=\"com.shan.pojo.User\">\n        select * from mybatis.user where id = #{userid} and name = #{username}\n    </select>\n```\n\n# 模糊查询\n\n不要让 java 传值拼接通配符`% _`，有 SQL 注入风险，比如传入`or 1=1`，恒定条件会导致全查出来；\n\nsql map 中使用通配符；\n\n```xml\n<select id=\"getUserLike\" parameterType=\"string\" resultType=\"com.shan.pojo.User\">\n        select * from mybatis.user where name like \"%\"#{key}\"%\"\n    </select>\n```\n\n# 配置之属性优化 mybatis-02\n\n## 核心配置文件\n\n- mybatis-config.xml\n- Mybatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n\n```\nconfiguration（配置）\n    properties（属性）\n    settings（设置）\n    typeAliases（类型别名）\n    typeHandlers（类型处理器）\n    objectFactory（对象工厂）\n    plugins（插件）\n    environments（环境配置）\n    \tenvironment（环境变量）\n    \t\ttransactionManager（事务管理器）\n    \t\tdataSource（数据源）\n    databaseIdProvider（数据库厂商标识）\n    mappers（映射器）\n\n```\n\n## 环境配置\n\nMybatis 可以配置成适应多种环境\n\n不过要记住，尽管可以配置多个环境，但每个 sqlsessionFactory 实例只能选择一种环境\n\n学会使用配置多套运行环境！------ `<environments default=\"development\">`\n\nMyBatis 默认的事务管理器就是 JDBC，连接池：POOLED\n\n## 属性（properties）\n\n我们可以通过 properties 属性来实现引用配置文件\n\n这些属性都是可外部配置且可动态替换的，既可以在典型的 java 属性文件中配置，也可通过 properties 元素的子元素来传递。 【db.properties】\n\ndb.properties\n\n```xml\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8\nusername=root\npassword=123456\n```\n\n在 mybatis-config.xml 中映入\n\n```xml\n<!--引入外部配置文件-->\n    <properties resource=\"db.properties\">\n    \t<property name=\"username\" value=\"root\"/>\n\t</properties>\n```\n\n- 可以直接引入外部配置文件\n\n- 可以在其中增加一些配置属性\n\n- 如果两个文件有同一个字段，优先使用 db.properties 外部配置文件的（先引入本文件属性，在引入外部文件属性，外部文件属性会覆盖本文件属性）\n\n## 类型别名\n\n- 类型别名是为 java 类型设置一个短的名字。\n- 存在的意义仅在于用来减少类完全限定名的冗余。\n\n```xml\n<!--类型别名-->\n    <typeAliases>\n        <typeAlias type=\"com.shan.pojo.User\" alias=\"User\"/>\n    </typeAliases>\n```\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：\n\n扫描实体类的包，他的默认别名就为这个类的类名，首字母小写！\n\n```xml\n\t<typeAliases>\n        <package name=\"com.shan.pojo\"/>\n    </typeAliases>\n```\n\n两种方法，在实体类比较少的时候，使用第一种方式。\n\n如果实体类身份多，建议使用第二种。\n\n第一种可以 DIY 别名，第二种则不行，如果非要改，需要在实体上增加注解。\n\n```java\n@Alias(value = \"hello\")\npublic class User {}\n```\n\n## 设置 Settings\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n\n![](img/article/JAVA-MyBatis-20210503/2020062316474822.png)\n\n## 其他配置\n\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins 插件\nmybatis-generator-core\nmybatis-plus\n通用 mapper\n\n## 映射器 mappers\n\nMapperRegistry：注册绑定我们的 Mapper 文件；\n\n方式一：【推荐使用】\n\n```xml\n<!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册-->\n<mappers>\n    <mapper resource=\"com/kuang/dao/UserMapper.xml\"/>\n</mappers>\n```\n\n方式二：使用 class 文件绑定注册\n\n```xml\n<!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册-->\n<mappers>\n    <mapper class=\"com.kuang.dao.UserMapper\"/>\n</mappers>\n```\n\n注意点：\n\n接口和他的 Mapper 配置文件必须同名\n接口和他的 Mapper 配置文件必须在同一个包下\n\n方式三：使用包扫描进行注入\n\n```xml\n<mappers>\n    <package name=\"com.kuang.dao\"/>\n</mappers>\n```\n\n## 作用域和生命周期\n\n![](img/article/JAVA-MyBatis-20210503/20200623164809990.png)\n\n声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n**SqlSessionFactoryBuilder:**\n\n一旦创建了 SqlSessionFactory，就不再需要它了\n局部变量\nSqlSessionFactory:\n\n说白了就可以想象为：数据库连接池\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。\n因此 SqlSessionFactory 的最佳作用域是应用作用域（ApplocationContext）。\n最简单的就是使用单例模式或静态单例模式。\nSqlSession：\n\n连接到连接池的一个请求\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n用完之后需要赶紧关闭，否则资源被占用！\n![](img/article/JAVA-MyBatis-20210503/20200623164833872.png)\n\n# 解决属性名和字段名不一致的问题\n\n### 问题\n\n数据库中的字段\n\n![](img/article/JAVA-MyBatis-20210503/20200623164845962.png)\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\n\n![](img/article/JAVA-MyBatis-20210503/20200623164853569.png)\n\n测试出现问题\n![](img/article/JAVA-MyBatis-20210503/20200623164901861.png)\n\n```xml\n// select * from user where id = #{id}\n// 类型处理器\n// select id,name,pwd from user where id = #{id}\n```\n\n解决方法：\n\n- 起别名\n\n```xml\n<select id=\"getUserById\" resultType=\"com.kuang.pojo.User\">\n    select id,name,pwd as password from USER where id = #{id}\n</select>\n```\n\n### resultMap\n\n结果集映射\n\nid name pwd\n\nid name password\n\n```xml\n<!--结果集映射-->\n<resultMap id=\"UserMap\" type=\"User\">\n    <!--column数据库中的字段，property实体类中的属性-->\n    <result column=\"id\" property=\"id\"></result>\n    <result column=\"name\" property=\"name\"></result>\n    <result column=\"pwd\" property=\"password\"></result>\n</resultMap>\n\n<select id=\"getUserList\" resultMap=\"UserMap\">\n    select * from USER\n</select>\n```\n\n- resultMap 元素是 MyBatis 中最重要最强大的元素。\n\n- ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。\n\n- ResultMap 的优秀之处——你完全可以不用显式地配置它们。\n\n  如果这个世界总是这么简单就好了。\n\n# 日志\n\n## 日志工厂\n\n如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！\n\n曾经：sout、debug\n\n现在：日志工厂\n\n![](img/article/JAVA-MyBatis-20210503/20200623164920502.png)\n\n- SLF4J\n- LOG4J 【掌握】\n- LOG4J2\n- JDK_LOGGING\n- COMMONS_LOGGING\n- STDOUT_LOGGING 【掌握】\n- NO_LOGGING\n\n在 MyBatis 中具体使用哪一个日志实现，在设置中设定\n\n**STDOUT_LOGGING**\n\n```xml\n<settings>\n    <!--标注的日志工厂-->\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n![](img/article/JAVA-MyBatis-20210503/2020062316493391.png)\n\n## Log4j\n\n什么是 Log4j？\n\nLog4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件；\n\n我们也可以控制每一条日志的输出格式；\n\n通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；\n\n最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n1. 先导入 log4j 的包\n\n```xml\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n2. log4j.properties\n\n```properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n​\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/rzp.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sq1.PreparedStatement=DEBUG\n```\n\n3. 配置 settings 为 log4j 实现\n4. 测试运行\n\n**Log4j 简单使用**\n\n1. 在要使用 Log4j 的类中，导入包 import org.apache.log4j.Logger; //注意要导对包\n2. 日志对象，参数为当前类的 class 对象\n\n```properties\nLogger logger = Logger.getLogger(UserDaoTest.class);\n```\n\n3. 日志级别\n\n```properties\nlogger.info(\"info: 测试log4j\");\nlogger.debug(\"debug: 测试log4j\");\nlogger.error(\"error:测试log4j\");\n```\n\n1. info\n2. debug\n3. error\n\n# 分页\n\n**思考：为什么分页？**\n\n- 减少数据的处理量\n\n## 使用 Limit 分页\n\n```sql\nSELECT * from user limit startIndex,pageSize   #[0,3)\n```\n\n**使用 MyBatis 实现分页，核心 SQL**\n\n1. 接口\n\n   ```java\n   //分页\n   List<User> getUserByLimit(Map<String,Integer> map);\n   ```\n\n2. Mapper.xml\n\n   ```xml\n   <!-- 结果集映射 -->\n       <resultMap id=\"UserMap\" type=\"User\"/>\n   <!--分页查询-->\n   <select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\">\n       select * from user limit #{startIndex},#{pageSize}\n   </select>\n   ```\n\n3. 测试\n\n   ```java\n       @Test\n       public void getUserByLimit(){\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           HashMap<String, Integer> map = new HashMap<String, Integer>();\n           map.put(\"startIndex\",1);\n           map.put(\"pageSize\",2);\n           List<User> list = mapper.getUserByLimit(map);\n           for (User user : list) {\n               System.out.println(user);\n           }\n       }\n   ```\n\n## RowBounds 分页\n\n不再使用 SQL 实现分页，不建议在开发中使用\n\n1. 接口\n\n   ```java\n   //分页2\n       List<User> getUserByRowBounds();\n   ```\n\n2. mapper.xml\n\n   ```xml\n   <!--分页查询2-->\n       <select id=\"getUserByRowBounds\" resultMap=\"UserMap\">\n           select * from mybatis.user\n       </select>\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n       public void getUserByRowBounds(){\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           //RowBounds实现\n           RowBounds rowBounds = new RowBounds(1, 2);\n           //通过Java代码层面实现分页\n           List<User> userList = sqlSession.selectList(\"com.shan.dao.UserMapper.getUserByRowBounds\", null, rowBounds);\n           for (User user : userList) {\n               System.out.println(user);\n           }\n           sqlSession.close();\n       }\n   ```\n\n## 分页插件\n\n![](img/article/JAVA-MyBatis-20210503/20200623164958936.png)\n\n# 使用注解开发\n\n## 面向接口开发\n\n**三个面向区别**\n\n- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；\n- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；\n- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；\n\n## 使用注解开发\n\n1. 注解在接口上实现\n\n   ```java\n   @Select(\"select * from user\")\n   List<User> getUsers();\n   ```\n\n2. 需要在核心配置文件中绑定接口\n\n   ```xml\n   <mappers>\n       <mapper class=\"com.kuang.dao.UserMapper\"/>\n   </mappers>\n   ```\n\n3. 测试\n\n本质：反射机制实现\n\n底层：动态代理\n\n![](img/article/JAVA-MyBatis-20210503/20200623165014965.png)\n\n**MyBatis 详细执行流程**\n\n![](img/article/JAVA-MyBatis-20210503/20200623165030775.png)\n\n## 注解 CURD\n\n```java\n//方法存在多个参数，所有的参数前面必须加上@Param(\"id\")注解\n@Delete(\"delete from user where id = ${uid}\")\nint deleteUser(@Param(\"uid\") int id);\n```\n\n**关于@Param( )注解**\n\n- 基本类型的参数或者 String 类型，需要加上\n- 引用类型不需要加\n- 如果只有一个基本类型的话，可以忽略，但是建议大家都加上\n- 我们在 SQL 中引用的就是我们这里的@Param()中设定的属性名\n\n**#{} 和 ${}**\n\n# Lombok\n\nLombok 项目是一个 Java 库，它会自动插入编辑器和构建工具中，Lombok 提供了一组有用的注释，用来消除 Java 类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。\n\n使用步骤：\n\n1. 在 IDEA 中安装 Lombok 插件; file--setting--plugin -- 搜索安装 lombok 插件\n\n2. 在项目中导入 lombok 的 jar 包\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.10</version>\n    <scope>provided</scope>\n</dependency>\n\n```\n\n3. 在程序上加注解\n\n```\n@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\n@Data //无参构造，get，set，tostring，hashcode，equals\n@Builder\n@SuperBuilder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@With\n@SneakyThrows\n@val\n```\n\n说明\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    private int id;\n    private String name;\n    private String password;\n}\n\n```\n\n# 多对一处理\n\n```sql\nCREATE TABLE `teacher` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师');\n\nCREATE TABLE `student` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           `tid` INT(10) DEFAULT NULL,\n                           PRIMARY KEY (`id`),\n                           KEY `fktid` (`tid`),\n                           CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, '小明', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, '小红', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, '小张', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, '小李', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, '小王', 1);\n\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n```\n\n多个学生一个老师；\n\n```sql\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n```\n\n# 一对多处理\n\n> 一个老师多个学生；\n>\n> 对于老师而言，就是一对多的关系；\n\n## 环境搭建\n\n**实体类**\n\n```java\n@Data\npublic class Student {\n    private int id;\n    private String name;\n    private int tid;\n}\n```\n\n```java\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n\n    //一个老师拥有多个学生\n    private List<Student> students;\n}\n```\n\n```java\n<!--按结果嵌套查询-->\n<select id=\"getTeacher\" resultMap=\"StudentTeacher\">\n    SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t\n    WHERE s.tid = t.id AND tid = #{tid}\n</select>\n<resultMap id=\"StudentTeacher\" type=\"Teacher\">\n    <result property=\"id\" column=\"tid\"/>\n    <result property=\"name\" column=\"tname\"/>\n    <!--复杂的属性，我们需要单独处理 对象：association 集合：collection\n    javaType=\"\"指定属性的类型！\n    集合中的泛型信息，我们使用ofType获取\n    -->\n    <collection property=\"students\" ofType=\"Student\">\n        <result property=\"id\" column=\"sid\"/>\n        <result property=\"name\" column=\"sname\"/>\n        <result property=\"tid\" column=\"tid\"/>\n    </collection>\n</resultMap>\n```\n\n### 小结\n\n1. 关联 - association 【多对一】\n2. 集合 - collection 【一对多】\n3. javaType & ofType\n   1. JavaType 用来指定实体类中的类型\n   2. ofType 用来指定映射到 List 或者集合中的 pojo 类型，泛型中的约束类型\n\n**注意点：**\n\n- 保证 SQL 的可读性，尽量保证通俗易懂\n\n- 注意一对多和多对一，属性名和字段的问题\n\n- 如果问题不好排查错误，可以使用日志，建议使用 Log4\n\n  面试高频\n\n  - Mysql 引擎\n  - InnoDB 底层原理\n  - 索引\n  - 索引优化\n  -\n\n# 动态 SQL\n\n什么是动态 SQL：动态 SQL 就是根据不同的条件生成不同的 SQL 语句\n\n所谓的动态 SQL，本质上还是 SQL 语句，只是我们可以在 SQL 层面，去执行一个逻辑代码\n\n动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\n\n## 搭建环境\n\n```sql\nCREATE TABLE `mybatis`.`blog`  (\n  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '博客id',\n  `title` varchar(30) NOT NULL COMMENT '博客标题',\n  `author` varchar(30) NOT NULL COMMENT '博客作者',\n  `create_time` datetime(0) NOT NULL COMMENT '创建时间',\n  `views` int(30) NOT NULL COMMENT '浏览量',\n  PRIMARY KEY (`id`)\n)\n```\n\n创建一个基础工程\n\n1. 导包\n2. 编写配置文件\n3. 编写实体类\n\n```java\n@Data\npublic class Blog {\n    private int id;\n    private String title;\n    private String author;\n\n    private Date createTime;// 属性名和字段名不一致\n    private int views;\n}\n```\n\n4. 编写实体类对应 Mapper 接口和 Mapper.xml 文件\n\n### IF\n\n```java\n<select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n    select * from blog\n    <where>\n        <if test=\"title!=null\">\n            and title = #{title}\n        </if>\n        <if test=\"author!=null\">\n            and author = #{author}\n        </if>\n    </where>\n</select>\n```\n\n### choose (when, otherwise)\n\n### trim、where、set\n\n### SQL 片段\n\n有的时候，我们可能会将一些功能的部分抽取出来，方便服用！\n\n1. 使用 SQL 标签抽取公共部分可\n\n   ```xml\n   <sql id=\"if-title-author\">\n       <if test=\"title!=null\">\n           title = #{title}\n       </if>\n       <if test=\"author!=null\">\n           and author = #{author}\n       </if>\n   </sql>\n   ```\n\n   2. 在需要使用的地方使用 Include 标签引用即可\n\n      ```xml\n      <select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n          select * from blog\n          <where>\n              <include refid=\"if-title-author\"></include>\n          </where>\n      </select>\n\n      ```\n\n注意事项：\n\n- 最好基于单标来定义 SQL 片段\n- 不要存在 where 标签\n\n**动态 SQL 就是在拼接 SQL 语句，我们只要保证 SQL 的正确性，按照 SQL 的格式，去排列组合就可以了**\n\n建议：\n\n- 先在 Mysql 中写出完整的 SQL，再对应的去修改成我们的动态 SQL 实现通用即可\n\n# 缓存\n\n## 简介\n\n查询 ： 连接数据库，耗资源\n\n一次查询的结果，给他暂存一个可以直接取到的地方 --> 内存：缓存\n\n我们再次查询的相同数据的时候，直接走缓存，不走数据库了\n\n1. 什么是缓存[Cache]？\n   1. 存在内存中的临时数据\n   2. 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题\n2. 为什么使用缓存？\n   1. 减少和数据库的交互次数，减少系统开销，提高系统效率\n3. 什么样的数据可以使用缓存？\n   1. 经常查询并且不经常改变的数据 【可以使用缓存】\n\n## MyBatis 缓存\n\n- MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。\n- MyBatis 系统中默认定义了两级缓存：**一级缓存**和**二级缓存**\n  - 默认情况下，只有一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）\n  - 二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。\n  - 为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。\n\n## 一级缓存\n\n- 一级缓存也叫本地缓存：SqlSession\n  - 与数据库同一次会话期间查询到的数据会放在本地缓存中\n  - 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库\n\n测试步骤：\n\n1. 开启日志\n\n2. 测试在一个 Session 中查询两次记录\n\n   ```java\n   @Test\n   public void test1() {\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           User user = mapper.getUserById(1);\n           System.out.println(user);\n\n           System.out.println(\"=====================================\");\n\n           User user2 =  mapper.getUserById(1);\n           System.out.println(user2 == user);\n       }\n   ```\n\n3. 查看日志输出\n\n   ![](img/article/JAVA-MyBatis-20210503/20200623165129955.png)\n\n**缓存失效的情况：**\n\n1. 查询不同的东西\n2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存\n3. 查询不同的 Mapper.xml\n4. 手动清理缓存\n\n```java\nsqlSession.clearCache();\n```\n\n## 二级缓存\n\n- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n- 基于 namespace 级别的缓存，一个名称空间，对应一个二级缓存\n- 工作机制\n  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中\n  - 如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中\n  - 新的会话查询信息，就可以从二级缓存中获取内容\n  - 不同的 mapper 查询出的数据会放在自己对应的缓存（map）中\n\n一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）\n\n- 二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。\n- 为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。\n-\n\n步骤：\n\n1. 开启全局缓存\n\n   ```xml\n   <!--显示的开启全局缓存-->\n   <setting name=\"cacheEnabled\" value=\"true\"/>\n   ```\n\n2. 在 Mapper.xml 中使用缓存\n\n   ```xml\n   <!--在当前Mapper.xml中使用二级缓存-->\n   <cache\n          eviction=\"FIFO\"  //first input first output\n          flushInterval=\"60000\"\n          size=\"512\"\n          readOnly=\"true\"/>\n   ```\n\n3. 测试\n\n   1. 问题：我们需要将实体类序列化，否则就会报错\n\n**小结：**\n\n- 只要开启了二级缓存，在同一个 Mapper 下就有效\n- 所有的数据都会放在一级缓存中\n- 只有当前会话提交，或者关闭的时候，才会提交到二级缓存中\n\n## 缓存原理\n\n![](img/article/JAVA-MyBatis-20210503/20200623165404113.png)\n\n**注意：**\n\n- 只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true”\n\n```xml\n    <select id=\"getUserById\" resultType=\"user\" useCache=\"true\">\n        select * from user where id = #{id}\n    </select>\n```\n\n## 自定义缓存-ehcache\n\nEhcache 是一种广泛使用的开源 Java 分布式缓存。主要面向通用缓存\n\n1. 导包\n\n   ```xml\n   <dependency>\n       <groupId>org.mybatis.caches</groupId>\n       <artifactId>mybatis-ehcache</artifactId>\n       <version>1.2.1</version>\n   </dependency>\n   ```\n\n2. 在 mapper 中指定使用我们的 ehcache 缓存实现\n\n   ```xml\n   <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n   ```\n\n3. resource/ehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\">\n    <!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     -->\n    <diskStore path=\"java.io.tmpdir/Tmp_EhCache\"/>\n    <!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     -->\n    <!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   -->\n    <defaultCache\n            eternal=\"false\"\n            maxElementsInMemory=\"10000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"259200\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n\n    <cache\n            name=\"cloud_user\"\n            eternal=\"false\"\n            maxElementsInMemory=\"5000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"1800\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n</ehcache>\n```\n\n4. MyCache.java 重写 其中方法\n\n```java\npackage com.shan.utils;\n\nimport org.apache.ibatis.cache.Cache;\n\nimport java.util.concurrent.locks.ReadWriteLock;\n\npublic class MyCache implements Cache {\n    public String getId() {\n        return null;\n    }\n\n    public void putObject(Object o, Object o1) {\n\n    }\n\n    public Object getObject(Object o) {\n        return null;\n    }\n\n    public Object removeObject(Object o) {\n        return null;\n    }\n\n    public void clear() {\n\n    }\n\n    public int getSize() {\n        return 0;\n    }\n\n    public ReadWriteLock getReadWriteLock() {\n        return null;\n    }\n}\n\n```\n\n现在一般用 Redis 做缓存！ <K, V>\n","source":"_posts/JAVA-MyBatis-20210503.md","raw":"---\ntitle: JAVA-MyBatis\ndate: 2021-05-03 01:40:46\ntags:\n  - 狂神说\ncategories:\n  - java\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/MyBatis.png\n---\n\n# MyBatis\n\n<!--more-->\n\n## 简介\n\n- mybatis 是一个持久层框架；\n- 支持定制 SQL、存储过程以及高级映射；\n- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。\n- Mybatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 java 的 POJO（Plain Old Java Objects，普通老式 java 对象）为数据库中的记录。\n\n## 什么是持久化？\n\n数据持久化\n\n- 持久化就是将程序的数据在持久状态和瞬间状态转化的过程；\n- 内存：断电即失；\n- 数据库（jdbc）, io 文件持久化。\n- 生活：冷藏、罐头；\n\n为什么需要持久化？\n\n- 有一些对象不能让丢掉；\n- 内存在系统中很珍贵；\n\n## 持久层\n\nDao 层、Service 层、Controller 层.......\n\n- 完成持久化工作的代码块；\n- 层界限十分明显。\n\n## 为什么需要 Mybatis？\n\n- 帮助程序员将数据存入到数据库中；\n- 方便；\n- 传统的 JDBC 代码太复杂了。简化。框架。自动化。\n- 不用 MyBatis 也可以。但 MyBatis 更容易上手。技术没有高低之分\n- 优点\n  - 简单易学\n  - 灵活\n  - sql 和代码的分离，提高了可维护性。\n  - 提供映射标签，支持对象与数据库的 orm 字段映射。\n  - 提供对象关系映射标签，支持对象关系组件维护。\n  - 提供 xml 标签，支持编写动态 sql。\n\n**最重要的一点：使用的人多！**\n\n## 第一个 MyBatis 程序 `mybatis-01`\n\n- 搭建环境\n\n```sql\nCREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user` (\n`id` INT(20) NOT NULL PRIMARY KEY,\n`name` VARCHAR(30) DEFAULT NULL,\n`pwd` VARCHAR(30) DEFAULT NULL\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\n\nINSERT INTO `user` (`id`,`name`,`pwd`) VALUES\n(1, '狂神', '123456'),\n(2, '李四', '123456'),\n(3, '张三', '123890')\n```\n\n- 新建项目(创建 maven 父子模块)\n\n  - 配置 mybatis 的核心配置文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <!DOCTYPE configuration\n            PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n            \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n    <configuration>\n        <environments default=\"development\">\n            <environment id=\"development\">\n                <transactionManager type=\"JDBC\"/>\n                <dataSource type=\"POOLED\">\n                    <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                    <property name=\"username\" value=\"root\"/>\n                    <property name=\"password\" value=\"123456\"/>\n                </dataSource>\n            </environment>\n        </environments>\n        <mappers>\n            <mapper resource=\"com/shan/dao/UserMapper.xml\"/>\n        </mappers>\n    </configuration>\n    ```\n\n  - 编写 mybatis 工具类\n\n    ```java\n    package com.shan.utils;\n\n    import org.apache.ibatis.io.Resources;\n    import org.apache.ibatis.session.SqlSession;\n    import org.apache.ibatis.session.SqlSessionFactory;\n    import org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\n    import java.io.IOException;\n    import java.io.InputStream;\n\n    //sqlSessionFactory  -->  sqlSession\n    public class MybatisUtils {\n        private static SqlSessionFactory sqlSessionFactory;\n\n        static {\n            try {\n                //获取sqlSessionFactory对象\n                String resource = \"mybatis-config.xml\";\n                InputStream is = Resources.getResourceAsStream(resource);\n                sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        //既然有了sqlSessionFactory, 我们可以从中获取sqlSession实例\n        //SqlSession 完全包含了面向数据库执行 SQL 命令所需要的所有方法\n\n        public static SqlSession getSqlSession() {\n            return sqlSessionFactory.openSession();\n        }\n    }\n\n    ```\n\n- 编写实体类\n\n  - 实体类\n\n    ```java\n    package com.shan.pojo;\n\n    public class User {\n        private int id;\n        private String name;\n        private String pwd;\n        public User() {\n        }\n        public User(int id, String name, String pwd) {\n            this.id = id;\n            this.name = name;\n            this.pwd = pwd;\n        }\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        public String getPwd() {\n            return pwd;\n        }\n        public void setPwd(String pwd) {\n            this.pwd = pwd;\n        }\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"id=\" + id +\n                    \", name='\" + name + '\\'' +\n                    \", pwd='\" + pwd + '\\'' +\n                    '}';\n        }\n    }\n    ```\n\n  - Dao 接口\n\n    ```java\n    package com.shan.dao;\n\n    import com.shan.pojo.User;\n\n    import java.util.List;\n\n    public interface UserDao {\n        List<User> getUserList();\n    }\n    ```\n\n  - 接口实现类由原本的 UserDaoOmpl 转变成一个 Mapper 配置文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <!DOCTYPE mapper\n            PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n            \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n    <mapper namespace=\"com.shan.dao.UserDao\">\n        <select id=\"getUserList\" resultType=\"com.shan.pojo.User\">\n            select * from user\n        </select>\n    </mapper>\n    ```\n\n- 测试 (测试的包尽量一一对应)\n\n  - junit 测试\n\n    ```shell\n    # 错误1\n    org.apache.ibatis.binding.BindingException: Type interface com.xiaofan.dao.UserDao is not known to the MapperRegistry.\n\n    # 解决方案\n    <mappers>\n    \t<mapper resource=\"com/xiaofan/dao/UserMapper.xml\"/>\n    </mappers>\n\n    # 错误2\n    Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/xiaofan/dao/UserMapper.xml\n\n    # 解决方案\n        <build>\n            <resources>\n                <resource>\n                    <directory>src/main/resources</directory>\n                    <includes>\n                        <include>**/*.properties</include>\n                        <include>**/*.xml</include>\n                        <include>**/*.tld</include>\n                    </includes>\n                    <filtering>true</filtering>\n                </resource>\n                <resource>\n                    <directory>src/main/java</directory>\n                    <includes>\n                        <include>**/*.properties</include>\n                        <include>**/*.xml</include>\n                        <include>**/*.tld</include>\n                    </includes>\n                    <filtering>true</filtering>\n                </resource>\n            </resources>\n        </build>\n\n    ```\n\n可能遇到的问题：\n\n1. 配置文件没有注册\n2. 绑定接口错误\n3. 方法名不对\n4. 返回类型不对\n\n# CRUD\n\n## 1、namespace\n\nnamespace 中的包名要和 Dao/Mapper 接口的包名一致！\n\n## 2、select\n\n选择，查询语句；\n\n- id：就是对应的 nameSpace 中的方法名；\n- resultType：Sql 语句执行的返回值！\n- parameterType：参数类型\n\n## 增删改需要提交事务\n\n```java\nsqlSession.commit();\nsqlSession.close();\n```\n\n## 3、insert,update,delete\n\n```java\nint addUser(User user);\nint updUser(User user);\nint deleteUser(int id);\n```\n\n```java\n@Test\n    public void addUser(){\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.addUser(new User(5, \"haha\", \"123456\"));\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    @Test\n    public void updUser() {\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.updUser(new User(4, \"aa\", \"123456\"));\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    @Test\n    public void deleteUser() {\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.deleteUser(5);\n        if (res!=0){\n            System.out.println(\"success\");\n        }\n        sqlSession.commit();\n        sqlSession.close();\n    }\n```\n\n```xml\n<!--    对象中的属性可以直接取出来-->\n    <insert id=\"addUser\" parameterType=\"com.shan.pojo.User\">\n        insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd})\n    </insert>\n\n    <update id=\"updUser\" parameterType=\"com.shan.pojo.User\">\n        update mybatis.user set name=#{name}, pwd=#{pwd} where id=#{id}\n    </update>\n\n    <delete id=\"deleteUser\" parameterType=\"int\">\n        delete from mybatis.user where id=#{id}\n    </delete>\n```\n\n# 万能 Map\n\n假如我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用 Map 传入数据，而不是对象实体（User）\n\nmap 传递参数，直接在 sql 中取出 key 即可！ parameterType=\"map\"\n\n对象传递参数，直接在 sql 中取出对象的属性即可！\n\n只有一个基本类型参数的情况下，可以直接在 sql 中取到！\n\n多个参数用 map, 或者注解\n\n```java\n@Test\n    public void getUserByIdandName(){\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap<String, Object> objectMap = new HashMap<String, Object>();\n        objectMap.put(\"userid\", 7);\n        objectMap.put(\"username\", \"zz\");\n        User user = mapper.getUserByIdandName(objectMap);\n        System.out.println(user.toString());\n        sqlSession.close();\n    }\n```\n\n```xml\n<select id=\"getUserByIdandName\"  parameterType=\"map\" resultType=\"com.shan.pojo.User\">\n        select * from mybatis.user where id = #{userid} and name = #{username}\n    </select>\n```\n\n# 模糊查询\n\n不要让 java 传值拼接通配符`% _`，有 SQL 注入风险，比如传入`or 1=1`，恒定条件会导致全查出来；\n\nsql map 中使用通配符；\n\n```xml\n<select id=\"getUserLike\" parameterType=\"string\" resultType=\"com.shan.pojo.User\">\n        select * from mybatis.user where name like \"%\"#{key}\"%\"\n    </select>\n```\n\n# 配置之属性优化 mybatis-02\n\n## 核心配置文件\n\n- mybatis-config.xml\n- Mybatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。\n\n```\nconfiguration（配置）\n    properties（属性）\n    settings（设置）\n    typeAliases（类型别名）\n    typeHandlers（类型处理器）\n    objectFactory（对象工厂）\n    plugins（插件）\n    environments（环境配置）\n    \tenvironment（环境变量）\n    \t\ttransactionManager（事务管理器）\n    \t\tdataSource（数据源）\n    databaseIdProvider（数据库厂商标识）\n    mappers（映射器）\n\n```\n\n## 环境配置\n\nMybatis 可以配置成适应多种环境\n\n不过要记住，尽管可以配置多个环境，但每个 sqlsessionFactory 实例只能选择一种环境\n\n学会使用配置多套运行环境！------ `<environments default=\"development\">`\n\nMyBatis 默认的事务管理器就是 JDBC，连接池：POOLED\n\n## 属性（properties）\n\n我们可以通过 properties 属性来实现引用配置文件\n\n这些属性都是可外部配置且可动态替换的，既可以在典型的 java 属性文件中配置，也可通过 properties 元素的子元素来传递。 【db.properties】\n\ndb.properties\n\n```xml\ndriver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8\nusername=root\npassword=123456\n```\n\n在 mybatis-config.xml 中映入\n\n```xml\n<!--引入外部配置文件-->\n    <properties resource=\"db.properties\">\n    \t<property name=\"username\" value=\"root\"/>\n\t</properties>\n```\n\n- 可以直接引入外部配置文件\n\n- 可以在其中增加一些配置属性\n\n- 如果两个文件有同一个字段，优先使用 db.properties 外部配置文件的（先引入本文件属性，在引入外部文件属性，外部文件属性会覆盖本文件属性）\n\n## 类型别名\n\n- 类型别名是为 java 类型设置一个短的名字。\n- 存在的意义仅在于用来减少类完全限定名的冗余。\n\n```xml\n<!--类型别名-->\n    <typeAliases>\n        <typeAlias type=\"com.shan.pojo.User\" alias=\"User\"/>\n    </typeAliases>\n```\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：\n\n扫描实体类的包，他的默认别名就为这个类的类名，首字母小写！\n\n```xml\n\t<typeAliases>\n        <package name=\"com.shan.pojo\"/>\n    </typeAliases>\n```\n\n两种方法，在实体类比较少的时候，使用第一种方式。\n\n如果实体类身份多，建议使用第二种。\n\n第一种可以 DIY 别名，第二种则不行，如果非要改，需要在实体上增加注解。\n\n```java\n@Alias(value = \"hello\")\npublic class User {}\n```\n\n## 设置 Settings\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。\n\n![](img/article/JAVA-MyBatis-20210503/2020062316474822.png)\n\n## 其他配置\n\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins 插件\nmybatis-generator-core\nmybatis-plus\n通用 mapper\n\n## 映射器 mappers\n\nMapperRegistry：注册绑定我们的 Mapper 文件；\n\n方式一：【推荐使用】\n\n```xml\n<!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册-->\n<mappers>\n    <mapper resource=\"com/kuang/dao/UserMapper.xml\"/>\n</mappers>\n```\n\n方式二：使用 class 文件绑定注册\n\n```xml\n<!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册-->\n<mappers>\n    <mapper class=\"com.kuang.dao.UserMapper\"/>\n</mappers>\n```\n\n注意点：\n\n接口和他的 Mapper 配置文件必须同名\n接口和他的 Mapper 配置文件必须在同一个包下\n\n方式三：使用包扫描进行注入\n\n```xml\n<mappers>\n    <package name=\"com.kuang.dao\"/>\n</mappers>\n```\n\n## 作用域和生命周期\n\n![](img/article/JAVA-MyBatis-20210503/20200623164809990.png)\n\n声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n**SqlSessionFactoryBuilder:**\n\n一旦创建了 SqlSessionFactory，就不再需要它了\n局部变量\nSqlSessionFactory:\n\n说白了就可以想象为：数据库连接池\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。\n因此 SqlSessionFactory 的最佳作用域是应用作用域（ApplocationContext）。\n最简单的就是使用单例模式或静态单例模式。\nSqlSession：\n\n连接到连接池的一个请求\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n用完之后需要赶紧关闭，否则资源被占用！\n![](img/article/JAVA-MyBatis-20210503/20200623164833872.png)\n\n# 解决属性名和字段名不一致的问题\n\n### 问题\n\n数据库中的字段\n\n![](img/article/JAVA-MyBatis-20210503/20200623164845962.png)\n\n新建一个项目，拷贝之前的，测试实体类字段不一致的情况\n\n![](img/article/JAVA-MyBatis-20210503/20200623164853569.png)\n\n测试出现问题\n![](img/article/JAVA-MyBatis-20210503/20200623164901861.png)\n\n```xml\n// select * from user where id = #{id}\n// 类型处理器\n// select id,name,pwd from user where id = #{id}\n```\n\n解决方法：\n\n- 起别名\n\n```xml\n<select id=\"getUserById\" resultType=\"com.kuang.pojo.User\">\n    select id,name,pwd as password from USER where id = #{id}\n</select>\n```\n\n### resultMap\n\n结果集映射\n\nid name pwd\n\nid name password\n\n```xml\n<!--结果集映射-->\n<resultMap id=\"UserMap\" type=\"User\">\n    <!--column数据库中的字段，property实体类中的属性-->\n    <result column=\"id\" property=\"id\"></result>\n    <result column=\"name\" property=\"name\"></result>\n    <result column=\"pwd\" property=\"password\"></result>\n</resultMap>\n\n<select id=\"getUserList\" resultMap=\"UserMap\">\n    select * from USER\n</select>\n```\n\n- resultMap 元素是 MyBatis 中最重要最强大的元素。\n\n- ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。\n\n- ResultMap 的优秀之处——你完全可以不用显式地配置它们。\n\n  如果这个世界总是这么简单就好了。\n\n# 日志\n\n## 日志工厂\n\n如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！\n\n曾经：sout、debug\n\n现在：日志工厂\n\n![](img/article/JAVA-MyBatis-20210503/20200623164920502.png)\n\n- SLF4J\n- LOG4J 【掌握】\n- LOG4J2\n- JDK_LOGGING\n- COMMONS_LOGGING\n- STDOUT_LOGGING 【掌握】\n- NO_LOGGING\n\n在 MyBatis 中具体使用哪一个日志实现，在设置中设定\n\n**STDOUT_LOGGING**\n\n```xml\n<settings>\n    <!--标注的日志工厂-->\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n![](img/article/JAVA-MyBatis-20210503/2020062316493391.png)\n\n## Log4j\n\n什么是 Log4j？\n\nLog4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件；\n\n我们也可以控制每一条日志的输出格式；\n\n通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；\n\n最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n1. 先导入 log4j 的包\n\n```xml\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n2. log4j.properties\n\n```properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n​\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/rzp.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sq1.PreparedStatement=DEBUG\n```\n\n3. 配置 settings 为 log4j 实现\n4. 测试运行\n\n**Log4j 简单使用**\n\n1. 在要使用 Log4j 的类中，导入包 import org.apache.log4j.Logger; //注意要导对包\n2. 日志对象，参数为当前类的 class 对象\n\n```properties\nLogger logger = Logger.getLogger(UserDaoTest.class);\n```\n\n3. 日志级别\n\n```properties\nlogger.info(\"info: 测试log4j\");\nlogger.debug(\"debug: 测试log4j\");\nlogger.error(\"error:测试log4j\");\n```\n\n1. info\n2. debug\n3. error\n\n# 分页\n\n**思考：为什么分页？**\n\n- 减少数据的处理量\n\n## 使用 Limit 分页\n\n```sql\nSELECT * from user limit startIndex,pageSize   #[0,3)\n```\n\n**使用 MyBatis 实现分页，核心 SQL**\n\n1. 接口\n\n   ```java\n   //分页\n   List<User> getUserByLimit(Map<String,Integer> map);\n   ```\n\n2. Mapper.xml\n\n   ```xml\n   <!-- 结果集映射 -->\n       <resultMap id=\"UserMap\" type=\"User\"/>\n   <!--分页查询-->\n   <select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\">\n       select * from user limit #{startIndex},#{pageSize}\n   </select>\n   ```\n\n3. 测试\n\n   ```java\n       @Test\n       public void getUserByLimit(){\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           HashMap<String, Integer> map = new HashMap<String, Integer>();\n           map.put(\"startIndex\",1);\n           map.put(\"pageSize\",2);\n           List<User> list = mapper.getUserByLimit(map);\n           for (User user : list) {\n               System.out.println(user);\n           }\n       }\n   ```\n\n## RowBounds 分页\n\n不再使用 SQL 实现分页，不建议在开发中使用\n\n1. 接口\n\n   ```java\n   //分页2\n       List<User> getUserByRowBounds();\n   ```\n\n2. mapper.xml\n\n   ```xml\n   <!--分页查询2-->\n       <select id=\"getUserByRowBounds\" resultMap=\"UserMap\">\n           select * from mybatis.user\n       </select>\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n       public void getUserByRowBounds(){\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           //RowBounds实现\n           RowBounds rowBounds = new RowBounds(1, 2);\n           //通过Java代码层面实现分页\n           List<User> userList = sqlSession.selectList(\"com.shan.dao.UserMapper.getUserByRowBounds\", null, rowBounds);\n           for (User user : userList) {\n               System.out.println(user);\n           }\n           sqlSession.close();\n       }\n   ```\n\n## 分页插件\n\n![](img/article/JAVA-MyBatis-20210503/20200623164958936.png)\n\n# 使用注解开发\n\n## 面向接口开发\n\n**三个面向区别**\n\n- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；\n- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；\n- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；\n\n## 使用注解开发\n\n1. 注解在接口上实现\n\n   ```java\n   @Select(\"select * from user\")\n   List<User> getUsers();\n   ```\n\n2. 需要在核心配置文件中绑定接口\n\n   ```xml\n   <mappers>\n       <mapper class=\"com.kuang.dao.UserMapper\"/>\n   </mappers>\n   ```\n\n3. 测试\n\n本质：反射机制实现\n\n底层：动态代理\n\n![](img/article/JAVA-MyBatis-20210503/20200623165014965.png)\n\n**MyBatis 详细执行流程**\n\n![](img/article/JAVA-MyBatis-20210503/20200623165030775.png)\n\n## 注解 CURD\n\n```java\n//方法存在多个参数，所有的参数前面必须加上@Param(\"id\")注解\n@Delete(\"delete from user where id = ${uid}\")\nint deleteUser(@Param(\"uid\") int id);\n```\n\n**关于@Param( )注解**\n\n- 基本类型的参数或者 String 类型，需要加上\n- 引用类型不需要加\n- 如果只有一个基本类型的话，可以忽略，但是建议大家都加上\n- 我们在 SQL 中引用的就是我们这里的@Param()中设定的属性名\n\n**#{} 和 ${}**\n\n# Lombok\n\nLombok 项目是一个 Java 库，它会自动插入编辑器和构建工具中，Lombok 提供了一组有用的注释，用来消除 Java 类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。\n\n使用步骤：\n\n1. 在 IDEA 中安装 Lombok 插件; file--setting--plugin -- 搜索安装 lombok 插件\n\n2. 在项目中导入 lombok 的 jar 包\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.10</version>\n    <scope>provided</scope>\n</dependency>\n\n```\n\n3. 在程序上加注解\n\n```\n@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\n@Data //无参构造，get，set，tostring，hashcode，equals\n@Builder\n@SuperBuilder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@With\n@SneakyThrows\n@val\n```\n\n说明\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    private int id;\n    private String name;\n    private String password;\n}\n\n```\n\n# 多对一处理\n\n```sql\nCREATE TABLE `teacher` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师');\n\nCREATE TABLE `student` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           `tid` INT(10) DEFAULT NULL,\n                           PRIMARY KEY (`id`),\n                           KEY `fktid` (`tid`),\n                           CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, '小明', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, '小红', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, '小张', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, '小李', 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, '小王', 1);\n\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n```\n\n多个学生一个老师；\n\n```sql\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n```\n\n# 一对多处理\n\n> 一个老师多个学生；\n>\n> 对于老师而言，就是一对多的关系；\n\n## 环境搭建\n\n**实体类**\n\n```java\n@Data\npublic class Student {\n    private int id;\n    private String name;\n    private int tid;\n}\n```\n\n```java\n@Data\npublic class Teacher {\n    private int id;\n    private String name;\n\n    //一个老师拥有多个学生\n    private List<Student> students;\n}\n```\n\n```java\n<!--按结果嵌套查询-->\n<select id=\"getTeacher\" resultMap=\"StudentTeacher\">\n    SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t\n    WHERE s.tid = t.id AND tid = #{tid}\n</select>\n<resultMap id=\"StudentTeacher\" type=\"Teacher\">\n    <result property=\"id\" column=\"tid\"/>\n    <result property=\"name\" column=\"tname\"/>\n    <!--复杂的属性，我们需要单独处理 对象：association 集合：collection\n    javaType=\"\"指定属性的类型！\n    集合中的泛型信息，我们使用ofType获取\n    -->\n    <collection property=\"students\" ofType=\"Student\">\n        <result property=\"id\" column=\"sid\"/>\n        <result property=\"name\" column=\"sname\"/>\n        <result property=\"tid\" column=\"tid\"/>\n    </collection>\n</resultMap>\n```\n\n### 小结\n\n1. 关联 - association 【多对一】\n2. 集合 - collection 【一对多】\n3. javaType & ofType\n   1. JavaType 用来指定实体类中的类型\n   2. ofType 用来指定映射到 List 或者集合中的 pojo 类型，泛型中的约束类型\n\n**注意点：**\n\n- 保证 SQL 的可读性，尽量保证通俗易懂\n\n- 注意一对多和多对一，属性名和字段的问题\n\n- 如果问题不好排查错误，可以使用日志，建议使用 Log4\n\n  面试高频\n\n  - Mysql 引擎\n  - InnoDB 底层原理\n  - 索引\n  - 索引优化\n  -\n\n# 动态 SQL\n\n什么是动态 SQL：动态 SQL 就是根据不同的条件生成不同的 SQL 语句\n\n所谓的动态 SQL，本质上还是 SQL 语句，只是我们可以在 SQL 层面，去执行一个逻辑代码\n\n动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\n\n## 搭建环境\n\n```sql\nCREATE TABLE `mybatis`.`blog`  (\n  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '博客id',\n  `title` varchar(30) NOT NULL COMMENT '博客标题',\n  `author` varchar(30) NOT NULL COMMENT '博客作者',\n  `create_time` datetime(0) NOT NULL COMMENT '创建时间',\n  `views` int(30) NOT NULL COMMENT '浏览量',\n  PRIMARY KEY (`id`)\n)\n```\n\n创建一个基础工程\n\n1. 导包\n2. 编写配置文件\n3. 编写实体类\n\n```java\n@Data\npublic class Blog {\n    private int id;\n    private String title;\n    private String author;\n\n    private Date createTime;// 属性名和字段名不一致\n    private int views;\n}\n```\n\n4. 编写实体类对应 Mapper 接口和 Mapper.xml 文件\n\n### IF\n\n```java\n<select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n    select * from blog\n    <where>\n        <if test=\"title!=null\">\n            and title = #{title}\n        </if>\n        <if test=\"author!=null\">\n            and author = #{author}\n        </if>\n    </where>\n</select>\n```\n\n### choose (when, otherwise)\n\n### trim、where、set\n\n### SQL 片段\n\n有的时候，我们可能会将一些功能的部分抽取出来，方便服用！\n\n1. 使用 SQL 标签抽取公共部分可\n\n   ```xml\n   <sql id=\"if-title-author\">\n       <if test=\"title!=null\">\n           title = #{title}\n       </if>\n       <if test=\"author!=null\">\n           and author = #{author}\n       </if>\n   </sql>\n   ```\n\n   2. 在需要使用的地方使用 Include 标签引用即可\n\n      ```xml\n      <select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\">\n          select * from blog\n          <where>\n              <include refid=\"if-title-author\"></include>\n          </where>\n      </select>\n\n      ```\n\n注意事项：\n\n- 最好基于单标来定义 SQL 片段\n- 不要存在 where 标签\n\n**动态 SQL 就是在拼接 SQL 语句，我们只要保证 SQL 的正确性，按照 SQL 的格式，去排列组合就可以了**\n\n建议：\n\n- 先在 Mysql 中写出完整的 SQL，再对应的去修改成我们的动态 SQL 实现通用即可\n\n# 缓存\n\n## 简介\n\n查询 ： 连接数据库，耗资源\n\n一次查询的结果，给他暂存一个可以直接取到的地方 --> 内存：缓存\n\n我们再次查询的相同数据的时候，直接走缓存，不走数据库了\n\n1. 什么是缓存[Cache]？\n   1. 存在内存中的临时数据\n   2. 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题\n2. 为什么使用缓存？\n   1. 减少和数据库的交互次数，减少系统开销，提高系统效率\n3. 什么样的数据可以使用缓存？\n   1. 经常查询并且不经常改变的数据 【可以使用缓存】\n\n## MyBatis 缓存\n\n- MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。\n- MyBatis 系统中默认定义了两级缓存：**一级缓存**和**二级缓存**\n  - 默认情况下，只有一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）\n  - 二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。\n  - 为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。\n\n## 一级缓存\n\n- 一级缓存也叫本地缓存：SqlSession\n  - 与数据库同一次会话期间查询到的数据会放在本地缓存中\n  - 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库\n\n测试步骤：\n\n1. 开启日志\n\n2. 测试在一个 Session 中查询两次记录\n\n   ```java\n   @Test\n   public void test1() {\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           User user = mapper.getUserById(1);\n           System.out.println(user);\n\n           System.out.println(\"=====================================\");\n\n           User user2 =  mapper.getUserById(1);\n           System.out.println(user2 == user);\n       }\n   ```\n\n3. 查看日志输出\n\n   ![](img/article/JAVA-MyBatis-20210503/20200623165129955.png)\n\n**缓存失效的情况：**\n\n1. 查询不同的东西\n2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存\n3. 查询不同的 Mapper.xml\n4. 手动清理缓存\n\n```java\nsqlSession.clearCache();\n```\n\n## 二级缓存\n\n- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n- 基于 namespace 级别的缓存，一个名称空间，对应一个二级缓存\n- 工作机制\n  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中\n  - 如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中\n  - 新的会话查询信息，就可以从二级缓存中获取内容\n  - 不同的 mapper 查询出的数据会放在自己对应的缓存（map）中\n\n一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）\n\n- 二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。\n- 为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。\n-\n\n步骤：\n\n1. 开启全局缓存\n\n   ```xml\n   <!--显示的开启全局缓存-->\n   <setting name=\"cacheEnabled\" value=\"true\"/>\n   ```\n\n2. 在 Mapper.xml 中使用缓存\n\n   ```xml\n   <!--在当前Mapper.xml中使用二级缓存-->\n   <cache\n          eviction=\"FIFO\"  //first input first output\n          flushInterval=\"60000\"\n          size=\"512\"\n          readOnly=\"true\"/>\n   ```\n\n3. 测试\n\n   1. 问题：我们需要将实体类序列化，否则就会报错\n\n**小结：**\n\n- 只要开启了二级缓存，在同一个 Mapper 下就有效\n- 所有的数据都会放在一级缓存中\n- 只有当前会话提交，或者关闭的时候，才会提交到二级缓存中\n\n## 缓存原理\n\n![](img/article/JAVA-MyBatis-20210503/20200623165404113.png)\n\n**注意：**\n\n- 只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true”\n\n```xml\n    <select id=\"getUserById\" resultType=\"user\" useCache=\"true\">\n        select * from user where id = #{id}\n    </select>\n```\n\n## 自定义缓存-ehcache\n\nEhcache 是一种广泛使用的开源 Java 分布式缓存。主要面向通用缓存\n\n1. 导包\n\n   ```xml\n   <dependency>\n       <groupId>org.mybatis.caches</groupId>\n       <artifactId>mybatis-ehcache</artifactId>\n       <version>1.2.1</version>\n   </dependency>\n   ```\n\n2. 在 mapper 中指定使用我们的 ehcache 缓存实现\n\n   ```xml\n   <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n   ```\n\n3. resource/ehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\">\n    <!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     -->\n    <diskStore path=\"java.io.tmpdir/Tmp_EhCache\"/>\n    <!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     -->\n    <!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   -->\n    <defaultCache\n            eternal=\"false\"\n            maxElementsInMemory=\"10000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"259200\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n\n    <cache\n            name=\"cloud_user\"\n            eternal=\"false\"\n            maxElementsInMemory=\"5000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"1800\"\n            memoryStoreEvictionPolicy=\"LRU\"/>\n</ehcache>\n```\n\n4. MyCache.java 重写 其中方法\n\n```java\npackage com.shan.utils;\n\nimport org.apache.ibatis.cache.Cache;\n\nimport java.util.concurrent.locks.ReadWriteLock;\n\npublic class MyCache implements Cache {\n    public String getId() {\n        return null;\n    }\n\n    public void putObject(Object o, Object o1) {\n\n    }\n\n    public Object getObject(Object o) {\n        return null;\n    }\n\n    public Object removeObject(Object o) {\n        return null;\n    }\n\n    public void clear() {\n\n    }\n\n    public int getSize() {\n        return 0;\n    }\n\n    public ReadWriteLock getReadWriteLock() {\n        return null;\n    }\n}\n\n```\n\n现在一般用 Redis 做缓存！ <K, V>\n","slug":"JAVA-MyBatis-20210503","published":1,"updated":"2022-06-14T04:09:00.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x17000oy4w1eynfbct4","content":"<h1 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h1><span id=\"more\"></span>\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>mybatis 是一个持久层框架；</li>\n<li>支持定制 SQL、存储过程以及高级映射；</li>\n<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>\n<li>Mybatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 java 的 POJO（Plain Old Java Objects，普通老式 java 对象）为数据库中的记录。</li>\n</ul>\n<h2 id=\"什么是持久化？\"><a href=\"#什么是持久化？\" class=\"headerlink\" title=\"什么是持久化？\"></a>什么是持久化？</h2><p>数据持久化</p>\n<ul>\n<li>持久化就是将程序的数据在持久状态和瞬间状态转化的过程；</li>\n<li>内存：断电即失；</li>\n<li>数据库（jdbc）, io 文件持久化。</li>\n<li>生活：冷藏、罐头；</li>\n</ul>\n<p>为什么需要持久化？</p>\n<ul>\n<li>有一些对象不能让丢掉；</li>\n<li>内存在系统中很珍贵；</li>\n</ul>\n<h2 id=\"持久层\"><a href=\"#持久层\" class=\"headerlink\" title=\"持久层\"></a>持久层</h2><p>Dao 层、Service 层、Controller 层…….</p>\n<ul>\n<li>完成持久化工作的代码块；</li>\n<li>层界限十分明显。</li>\n</ul>\n<h2 id=\"为什么需要-Mybatis？\"><a href=\"#为什么需要-Mybatis？\" class=\"headerlink\" title=\"为什么需要 Mybatis？\"></a>为什么需要 Mybatis？</h2><ul>\n<li>帮助程序员将数据存入到数据库中；</li>\n<li>方便；</li>\n<li>传统的 JDBC 代码太复杂了。简化。框架。自动化。</li>\n<li>不用 MyBatis 也可以。但 MyBatis 更容易上手。技术没有高低之分</li>\n<li>优点<ul>\n<li>简单易学</li>\n<li>灵活</li>\n<li>sql 和代码的分离，提高了可维护性。</li>\n<li>提供映射标签，支持对象与数据库的 orm 字段映射。</li>\n<li>提供对象关系映射标签，支持对象关系组件维护。</li>\n<li>提供 xml 标签，支持编写动态 sql。</li>\n</ul>\n</li>\n</ul>\n<p><strong>最重要的一点：使用的人多！</strong></p>\n<h2 id=\"第一个-MyBatis-程序-mybatis-01\"><a href=\"#第一个-MyBatis-程序-mybatis-01\" class=\"headerlink\" title=\"第一个 MyBatis 程序 mybatis-01\"></a>第一个 MyBatis 程序 <code>mybatis-01</code></h2><ul>\n<li>搭建环境</li>\n</ul>\n<pre><code class=\"sql\">CREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user` (\n`id` INT(20) NOT NULL PRIMARY KEY,\n`name` VARCHAR(30) DEFAULT NULL,\n`pwd` VARCHAR(30) DEFAULT NULL\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\n\nINSERT INTO `user` (`id`,`name`,`pwd`) VALUES\n(1, &#39;狂神&#39;, &#39;123456&#39;),\n(2, &#39;李四&#39;, &#39;123456&#39;),\n(3, &#39;张三&#39;, &#39;123890&#39;)\n</code></pre>\n<ul>\n<li><p>新建项目(创建 maven 父子模块)</p>\n<ul>\n<li><p>配置 mybatis 的核心配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/shan/dao/UserMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n</li>\n<li><p>编写 mybatis 工具类</p>\n<pre><code class=\"java\">package com.shan.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n//sqlSessionFactory  --&gt;  sqlSession\npublic class MybatisUtils &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        try &#123;\n            //获取sqlSessionFactory对象\n            String resource = &quot;mybatis-config.xml&quot;;\n            InputStream is = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    //既然有了sqlSessionFactory, 我们可以从中获取sqlSession实例\n    //SqlSession 完全包含了面向数据库执行 SQL 命令所需要的所有方法\n\n    public static SqlSession getSqlSession() &#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>编写实体类</p>\n<ul>\n<li><p>实体类</p>\n<pre><code class=\"java\">package com.shan.pojo;\n\npublic class User &#123;\n    private int id;\n    private String name;\n    private String pwd;\n    public User() &#123;\n    &#125;\n    public User(int id, String name, String pwd) &#123;\n        this.id = id;\n        this.name = name;\n        this.pwd = pwd;\n    &#125;\n    public int getId() &#123;\n        return id;\n    &#125;\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getPwd() &#123;\n        return pwd;\n    &#125;\n    public void setPwd(String pwd) &#123;\n        this.pwd = pwd;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, pwd=&#39;&quot; + pwd + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>Dao 接口</p>\n<pre><code class=\"java\">package com.shan.dao;\n\nimport com.shan.pojo.User;\n\nimport java.util.List;\n\npublic interface UserDao &#123;\n    List&lt;User&gt; getUserList();\n&#125;\n</code></pre>\n</li>\n<li><p>接口实现类由原本的 UserDaoOmpl 转变成一个 Mapper 配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.shan.dao.UserDao&quot;&gt;\n    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from user\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>测试 (测试的包尽量一一对应)</p>\n<ul>\n<li><p>junit 测试</p>\n<pre><code class=\"shell\"># 错误1\norg.apache.ibatis.binding.BindingException: Type interface com.xiaofan.dao.UserDao is not known to the MapperRegistry.\n\n# 解决方案\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/xiaofan/dao/UserMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n\n# 错误2\nCause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/xiaofan/dao/UserMapper.xml\n\n# 解决方案\n    &lt;build&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.properties&lt;/include&gt;\n                    &lt;include&gt;**/*.xml&lt;/include&gt;\n                    &lt;include&gt;**/*.tld&lt;/include&gt;\n                &lt;/includes&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.properties&lt;/include&gt;\n                    &lt;include&gt;**/*.xml&lt;/include&gt;\n                    &lt;include&gt;**/*.tld&lt;/include&gt;\n                &lt;/includes&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>可能遇到的问题：</p>\n<ol>\n<li>配置文件没有注册</li>\n<li>绑定接口错误</li>\n<li>方法名不对</li>\n<li>返回类型不对</li>\n</ol>\n<h1 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h1><h2 id=\"1、namespace\"><a href=\"#1、namespace\" class=\"headerlink\" title=\"1、namespace\"></a>1、namespace</h2><p>namespace 中的包名要和 Dao/Mapper 接口的包名一致！</p>\n<h2 id=\"2、select\"><a href=\"#2、select\" class=\"headerlink\" title=\"2、select\"></a>2、select</h2><p>选择，查询语句；</p>\n<ul>\n<li>id：就是对应的 nameSpace 中的方法名；</li>\n<li>resultType：Sql 语句执行的返回值！</li>\n<li>parameterType：参数类型</li>\n</ul>\n<h2 id=\"增删改需要提交事务\"><a href=\"#增删改需要提交事务\" class=\"headerlink\" title=\"增删改需要提交事务\"></a>增删改需要提交事务</h2><pre><code class=\"java\">sqlSession.commit();\nsqlSession.close();\n</code></pre>\n<h2 id=\"3、insert-update-delete\"><a href=\"#3、insert-update-delete\" class=\"headerlink\" title=\"3、insert,update,delete\"></a>3、insert,update,delete</h2><pre><code class=\"java\">int addUser(User user);\nint updUser(User user);\nint deleteUser(int id);\n</code></pre>\n<pre><code class=\"java\">@Test\n    public void addUser()&#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.addUser(new User(5, &quot;haha&quot;, &quot;123456&quot;));\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n\n    @Test\n    public void updUser() &#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.updUser(new User(4, &quot;aa&quot;, &quot;123456&quot;));\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n\n    @Test\n    public void deleteUser() &#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.deleteUser(5);\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;!--    对象中的属性可以直接取出来--&gt;\n    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.shan.pojo.User&quot;&gt;\n        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\n    &lt;/insert&gt;\n\n    &lt;update id=&quot;updUser&quot; parameterType=&quot;com.shan.pojo.User&quot;&gt;\n        update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125;\n    &lt;/update&gt;\n\n    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;\n        delete from mybatis.user where id=#&#123;id&#125;\n    &lt;/delete&gt;\n</code></pre>\n<h1 id=\"万能-Map\"><a href=\"#万能-Map\" class=\"headerlink\" title=\"万能 Map\"></a>万能 Map</h1><p>假如我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用 Map 传入数据，而不是对象实体（User）</p>\n<p>map 传递参数，直接在 sql 中取出 key 即可！ parameterType=”map”</p>\n<p>对象传递参数，直接在 sql 中取出对象的属性即可！</p>\n<p>只有一个基本类型参数的情况下，可以直接在 sql 中取到！</p>\n<p>多个参数用 map, 或者注解</p>\n<pre><code class=\"java\">@Test\n    public void getUserByIdandName()&#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();\n        objectMap.put(&quot;userid&quot;, 7);\n        objectMap.put(&quot;username&quot;, &quot;zz&quot;);\n        User user = mapper.getUserByIdandName(objectMap);\n        System.out.println(user.toString());\n        sqlSession.close();\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserByIdandName&quot;  parameterType=&quot;map&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from mybatis.user where id = #&#123;userid&#125; and name = #&#123;username&#125;\n    &lt;/select&gt;\n</code></pre>\n<h1 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h1><p>不要让 java 传值拼接通配符<code>% _</code>，有 SQL 注入风险，比如传入<code>or 1=1</code>，恒定条件会导致全查出来；</p>\n<p>sql map 中使用通配符；</p>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserLike&quot; parameterType=&quot;string&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from mybatis.user where name like &quot;%&quot;#&#123;key&#125;&quot;%&quot;\n    &lt;/select&gt;\n</code></pre>\n<h1 id=\"配置之属性优化-mybatis-02\"><a href=\"#配置之属性优化-mybatis-02\" class=\"headerlink\" title=\"配置之属性优化 mybatis-02\"></a>配置之属性优化 mybatis-02</h1><h2 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a>核心配置文件</h2><ul>\n<li>mybatis-config.xml</li>\n<li>Mybatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>\n</ul>\n<pre><code>configuration（配置）\n    properties（属性）\n    settings（设置）\n    typeAliases（类型别名）\n    typeHandlers（类型处理器）\n    objectFactory（对象工厂）\n    plugins（插件）\n    environments（环境配置）\n        environment（环境变量）\n            transactionManager（事务管理器）\n            dataSource（数据源）\n    databaseIdProvider（数据库厂商标识）\n    mappers（映射器）\n</code></pre>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>Mybatis 可以配置成适应多种环境</p>\n<p>不过要记住，尽管可以配置多个环境，但每个 sqlsessionFactory 实例只能选择一种环境</p>\n<p>学会使用配置多套运行环境！—— <code>&lt;environments default=&quot;development&quot;&gt;</code></p>\n<p>MyBatis 默认的事务管理器就是 JDBC，连接池：POOLED</p>\n<h2 id=\"属性（properties）\"><a href=\"#属性（properties）\" class=\"headerlink\" title=\"属性（properties）\"></a>属性（properties）</h2><p>我们可以通过 properties 属性来实现引用配置文件</p>\n<p>这些属性都是可外部配置且可动态替换的，既可以在典型的 java 属性文件中配置，也可通过 properties 元素的子元素来传递。 【db.properties】</p>\n<p>db.properties</p>\n<pre><code class=\"xml\">driver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\nusername=root\npassword=123456\n</code></pre>\n<p>在 mybatis-config.xml 中映入</p>\n<pre><code class=\"xml\">&lt;!--引入外部配置文件--&gt;\n    &lt;properties resource=&quot;db.properties&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n    &lt;/properties&gt;\n</code></pre>\n<ul>\n<li><p>可以直接引入外部配置文件</p>\n</li>\n<li><p>可以在其中增加一些配置属性</p>\n</li>\n<li><p>如果两个文件有同一个字段，优先使用 db.properties 外部配置文件的（先引入本文件属性，在引入外部文件属性，外部文件属性会覆盖本文件属性）</p>\n</li>\n</ul>\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><ul>\n<li>类型别名是为 java 类型设置一个短的名字。</li>\n<li>存在的意义仅在于用来减少类完全限定名的冗余。</li>\n</ul>\n<pre><code class=\"xml\">&lt;!--类型别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias type=&quot;com.shan.pojo.User&quot; alias=&quot;User&quot;/&gt;\n    &lt;/typeAliases&gt;\n</code></pre>\n<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>\n<p>扫描实体类的包，他的默认别名就为这个类的类名，首字母小写！</p>\n<pre><code class=\"xml\">    &lt;typeAliases&gt;\n        &lt;package name=&quot;com.shan.pojo&quot;/&gt;\n    &lt;/typeAliases&gt;\n</code></pre>\n<p>两种方法，在实体类比较少的时候，使用第一种方式。</p>\n<p>如果实体类身份多，建议使用第二种。</p>\n<p>第一种可以 DIY 别名，第二种则不行，如果非要改，需要在实体上增加注解。</p>\n<pre><code class=\"java\">@Alias(value = &quot;hello&quot;)\npublic class User &#123;&#125;\n</code></pre>\n<h2 id=\"设置-Settings\"><a href=\"#设置-Settings\" class=\"headerlink\" title=\"设置 Settings\"></a>设置 Settings</h2><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/2020062316474822.png\"></p>\n<h2 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h2><p>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins 插件<br>mybatis-generator-core<br>mybatis-plus<br>通用 mapper</p>\n<h2 id=\"映射器-mappers\"><a href=\"#映射器-mappers\" class=\"headerlink\" title=\"映射器 mappers\"></a>映射器 mappers</h2><p>MapperRegistry：注册绑定我们的 Mapper 文件；</p>\n<p>方式一：【推荐使用】</p>\n<pre><code class=\"xml\">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>方式二：使用 class 文件绑定注册</p>\n<pre><code class=\"xml\">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>注意点：</p>\n<p>接口和他的 Mapper 配置文件必须同名<br>接口和他的 Mapper 配置文件必须在同一个包下</p>\n<p>方式三：使用包扫描进行注入</p>\n<pre><code class=\"xml\">&lt;mappers&gt;\n    &lt;package name=&quot;com.kuang.dao&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<h2 id=\"作用域和生命周期\"><a href=\"#作用域和生命周期\" class=\"headerlink\" title=\"作用域和生命周期\"></a>作用域和生命周期</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164809990.png\"></p>\n<p>声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>\n<p><strong>SqlSessionFactoryBuilder:</strong></p>\n<p>一旦创建了 SqlSessionFactory，就不再需要它了<br>局部变量<br>SqlSessionFactory:</p>\n<p>说白了就可以想象为：数据库连接池<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。<br>因此 SqlSessionFactory 的最佳作用域是应用作用域（ApplocationContext）。<br>最简单的就是使用单例模式或静态单例模式。<br>SqlSession：</p>\n<p>连接到连接池的一个请求<br>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。<br>用完之后需要赶紧关闭，否则资源被占用！<br><img src=\"img/article/JAVA-MyBatis-20210503/20200623164833872.png\"></p>\n<h1 id=\"解决属性名和字段名不一致的问题\"><a href=\"#解决属性名和字段名不一致的问题\" class=\"headerlink\" title=\"解决属性名和字段名不一致的问题\"></a>解决属性名和字段名不一致的问题</h1><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>数据库中的字段</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164845962.png\"></p>\n<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164853569.png\"></p>\n<p>测试出现问题<br><img src=\"img/article/JAVA-MyBatis-20210503/20200623164901861.png\"></p>\n<pre><code class=\"xml\">// select * from user where id = #&#123;id&#125;\n// 类型处理器\n// select id,name,pwd from user where id = #&#123;id&#125;\n</code></pre>\n<p>解决方法：</p>\n<ul>\n<li>起别名</li>\n</ul>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;\n    select id,name,pwd as password from USER where id = #&#123;id&#125;\n&lt;/select&gt;\n</code></pre>\n<h3 id=\"resultMap\"><a href=\"#resultMap\" class=\"headerlink\" title=\"resultMap\"></a>resultMap</h3><p>结果集映射</p>\n<p>id name pwd</p>\n<p>id name password</p>\n<pre><code class=\"xml\">&lt;!--结果集映射--&gt;\n&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;\n    &lt;!--column数据库中的字段，property实体类中的属性--&gt;\n    &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt;\n    &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;\n    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt;\n&lt;/resultMap&gt;\n\n&lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt;\n    select * from USER\n&lt;/select&gt;\n</code></pre>\n<ul>\n<li><p>resultMap 元素是 MyBatis 中最重要最强大的元素。</p>\n</li>\n<li><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>\n</li>\n<li><p>ResultMap 的优秀之处——你完全可以不用显式地配置它们。</p>\n<p>如果这个世界总是这么简单就好了。</p>\n</li>\n</ul>\n<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h1><h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！</p>\n<p>曾经：sout、debug</p>\n<p>现在：日志工厂</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164920502.png\"></p>\n<ul>\n<li>SLF4J</li>\n<li>LOG4J 【掌握】</li>\n<li>LOG4J2</li>\n<li>JDK_LOGGING</li>\n<li>COMMONS_LOGGING</li>\n<li>STDOUT_LOGGING 【掌握】</li>\n<li>NO_LOGGING</li>\n</ul>\n<p>在 MyBatis 中具体使用哪一个日志实现，在设置中设定</p>\n<p><strong>STDOUT_LOGGING</strong></p>\n<pre><code class=\"xml\">&lt;settings&gt;\n    &lt;!--标注的日志工厂--&gt;\n    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/2020062316493391.png\"></p>\n<h2 id=\"Log4j\"><a href=\"#Log4j\" class=\"headerlink\" title=\"Log4j\"></a>Log4j</h2><p>什么是 Log4j？</p>\n<p>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件；</p>\n<p>我们也可以控制每一条日志的输出格式；</p>\n<p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；</p>\n<p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<ol>\n<li>先导入 log4j 的包</li>\n</ol>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<pre><code class=\"properties\">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n​\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/rzp.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sq1.PreparedStatement=DEBUG\n</code></pre>\n<ol start=\"3\">\n<li>配置 settings 为 log4j 实现</li>\n<li>测试运行</li>\n</ol>\n<p><strong>Log4j 简单使用</strong></p>\n<ol>\n<li>在要使用 Log4j 的类中，导入包 import org.apache.log4j.Logger; //注意要导对包</li>\n<li>日志对象，参数为当前类的 class 对象</li>\n</ol>\n<pre><code class=\"properties\">Logger logger = Logger.getLogger(UserDaoTest.class);\n</code></pre>\n<ol start=\"3\">\n<li>日志级别</li>\n</ol>\n<pre><code class=\"properties\">logger.info(&quot;info: 测试log4j&quot;);\nlogger.debug(&quot;debug: 测试log4j&quot;);\nlogger.error(&quot;error:测试log4j&quot;);\n</code></pre>\n<ol>\n<li>info</li>\n<li>debug</li>\n<li>error</li>\n</ol>\n<h1 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h1><p><strong>思考：为什么分页？</strong></p>\n<ul>\n<li>减少数据的处理量</li>\n</ul>\n<h2 id=\"使用-Limit-分页\"><a href=\"#使用-Limit-分页\" class=\"headerlink\" title=\"使用 Limit 分页\"></a>使用 Limit 分页</h2><pre><code class=\"sql\">SELECT * from user limit startIndex,pageSize   #[0,3)\n</code></pre>\n<p><strong>使用 MyBatis 实现分页，核心 SQL</strong></p>\n<ol>\n<li><p>接口</p>\n<pre><code class=\"java\">//分页\nList&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n</code></pre>\n</li>\n<li><p>Mapper.xml</p>\n<pre><code class=\"xml\">&lt;!-- 结果集映射 --&gt;\n    &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;/&gt;\n&lt;!--分页查询--&gt;\n&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;\n    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;\n&lt;/select&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">    @Test\n    public void getUserByLimit()&#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n        map.put(&quot;startIndex&quot;,1);\n        map.put(&quot;pageSize&quot;,2);\n        List&lt;User&gt; list = mapper.getUserByLimit(map);\n        for (User user : list) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"RowBounds-分页\"><a href=\"#RowBounds-分页\" class=\"headerlink\" title=\"RowBounds 分页\"></a>RowBounds 分页</h2><p>不再使用 SQL 实现分页，不建议在开发中使用</p>\n<ol>\n<li><p>接口</p>\n<pre><code class=\"java\">//分页2\n    List&lt;User&gt; getUserByRowBounds();\n</code></pre>\n</li>\n<li><p>mapper.xml</p>\n<pre><code class=\"xml\">&lt;!--分页查询2--&gt;\n    &lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt;\n        select * from mybatis.user\n    &lt;/select&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">@Test\n    public void getUserByRowBounds()&#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        //RowBounds实现\n        RowBounds rowBounds = new RowBounds(1, 2);\n        //通过Java代码层面实现分页\n        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.shan.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds);\n        for (User user : userList) &#123;\n            System.out.println(user);\n        &#125;\n        sqlSession.close();\n    &#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"分页插件\"><a href=\"#分页插件\" class=\"headerlink\" title=\"分页插件\"></a>分页插件</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164958936.png\"></p>\n<h1 id=\"使用注解开发\"><a href=\"#使用注解开发\" class=\"headerlink\" title=\"使用注解开发\"></a>使用注解开发</h1><h2 id=\"面向接口开发\"><a href=\"#面向接口开发\" class=\"headerlink\" title=\"面向接口开发\"></a>面向接口开发</h2><p><strong>三个面向区别</strong></p>\n<ul>\n<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；</li>\n<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；</li>\n<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；</li>\n</ul>\n<h2 id=\"使用注解开发-1\"><a href=\"#使用注解开发-1\" class=\"headerlink\" title=\"使用注解开发\"></a>使用注解开发</h2><ol>\n<li><p>注解在接口上实现</p>\n<pre><code class=\"java\">@Select(&quot;select * from user&quot;)\nList&lt;User&gt; getUsers();\n</code></pre>\n</li>\n<li><p>需要在核心配置文件中绑定接口</p>\n<pre><code class=\"xml\">&lt;mappers&gt;\n    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n<p>本质：反射机制实现</p>\n<p>底层：动态代理</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165014965.png\"></p>\n<p><strong>MyBatis 详细执行流程</strong></p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165030775.png\"></p>\n<h2 id=\"注解-CURD\"><a href=\"#注解-CURD\" class=\"headerlink\" title=\"注解 CURD\"></a>注解 CURD</h2><pre><code class=\"java\">//方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解\n@Delete(&quot;delete from user where id = $&#123;uid&#125;&quot;)\nint deleteUser(@Param(&quot;uid&quot;) int id);\n</code></pre>\n<p><strong>关于@Param( )注解</strong></p>\n<ul>\n<li>基本类型的参数或者 String 类型，需要加上</li>\n<li>引用类型不需要加</li>\n<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上</li>\n<li>我们在 SQL 中引用的就是我们这里的@Param()中设定的属性名</li>\n</ul>\n<p><strong>#{} 和 ${}</strong></p>\n<h1 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h1><p>Lombok 项目是一个 Java 库，它会自动插入编辑器和构建工具中，Lombok 提供了一组有用的注释，用来消除 Java 类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。</p>\n<p>使用步骤：</p>\n<ol>\n<li><p>在 IDEA 中安装 Lombok 插件; file–setting–plugin – 搜索安装 lombok 插件</p>\n</li>\n<li><p>在项目中导入 lombok 的 jar 包</p>\n</li>\n</ol>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;version&gt;1.18.10&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"3\">\n<li>在程序上加注解</li>\n</ol>\n<pre><code>@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\n@Data //无参构造，get，set，tostring，hashcode，equals\n@Builder\n@SuperBuilder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@With\n@SneakyThrows\n@val\n</code></pre>\n<p>说明</p>\n<pre><code class=\"java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private int id;\n    private String name;\n    private String password;\n&#125;\n</code></pre>\n<h1 id=\"多对一处理\"><a href=\"#多对一处理\" class=\"headerlink\" title=\"多对一处理\"></a>多对一处理</h1><pre><code class=\"sql\">CREATE TABLE `teacher` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);\n\nCREATE TABLE `student` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           `tid` INT(10) DEFAULT NULL,\n                           PRIMARY KEY (`id`),\n                           KEY `fktid` (`tid`),\n                           CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, &#39;小明&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, &#39;小红&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, &#39;小张&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, &#39;小李&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, &#39;小王&#39;, 1);\n\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n</code></pre>\n<p>多个学生一个老师；</p>\n<pre><code class=\"sql\">alter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n</code></pre>\n<h1 id=\"一对多处理\"><a href=\"#一对多处理\" class=\"headerlink\" title=\"一对多处理\"></a>一对多处理</h1><blockquote>\n<p>一个老师多个学生；</p>\n<p>对于老师而言，就是一对多的关系；</p>\n</blockquote>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p><strong>实体类</strong></p>\n<pre><code class=\"java\">@Data\npublic class Student &#123;\n    private int id;\n    private String name;\n    private int tid;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Data\npublic class Teacher &#123;\n    private int id;\n    private String name;\n\n    //一个老师拥有多个学生\n    private List&lt;Student&gt; students;\n&#125;\n</code></pre>\n<pre><code class=\"java\">&lt;!--按结果嵌套查询--&gt;\n&lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt;\n    SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t\n    WHERE s.tid = t.id AND tid = #&#123;tid&#125;\n&lt;/select&gt;\n&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt;\n    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;\n    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;\n    &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection\n    javaType=&quot;&quot;指定属性的类型！\n    集合中的泛型信息，我们使用ofType获取\n    --&gt;\n    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;\n        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;\n        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;\n        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n</code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li>关联 - association 【多对一】</li>\n<li>集合 - collection 【一对多】</li>\n<li>javaType &amp; ofType<ol>\n<li>JavaType 用来指定实体类中的类型</li>\n<li>ofType 用来指定映射到 List 或者集合中的 pojo 类型，泛型中的约束类型</li>\n</ol>\n</li>\n</ol>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><p>保证 SQL 的可读性，尽量保证通俗易懂</p>\n</li>\n<li><p>注意一对多和多对一，属性名和字段的问题</p>\n</li>\n<li><p>如果问题不好排查错误，可以使用日志，建议使用 Log4</p>\n<p>面试高频</p>\n<ul>\n<li>Mysql 引擎</li>\n<li>InnoDB 底层原理</li>\n<li>索引</li>\n<li>索引优化</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"动态-SQL\"><a href=\"#动态-SQL\" class=\"headerlink\" title=\"动态 SQL\"></a>动态 SQL</h1><p>什么是动态 SQL：动态 SQL 就是根据不同的条件生成不同的 SQL 语句</p>\n<p>所谓的动态 SQL，本质上还是 SQL 语句，只是我们可以在 SQL 层面，去执行一个逻辑代码</p>\n<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>\n<h2 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h2><pre><code class=\"sql\">CREATE TABLE `mybatis`.`blog`  (\n  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#39;博客id&#39;,\n  `title` varchar(30) NOT NULL COMMENT &#39;博客标题&#39;,\n  `author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,\n  `create_time` datetime(0) NOT NULL COMMENT &#39;创建时间&#39;,\n  `views` int(30) NOT NULL COMMENT &#39;浏览量&#39;,\n  PRIMARY KEY (`id`)\n)\n</code></pre>\n<p>创建一个基础工程</p>\n<ol>\n<li>导包</li>\n<li>编写配置文件</li>\n<li>编写实体类</li>\n</ol>\n<pre><code class=\"java\">@Data\npublic class Blog &#123;\n    private int id;\n    private String title;\n    private String author;\n\n    private Date createTime;// 属性名和字段名不一致\n    private int views;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>编写实体类对应 Mapper 接口和 Mapper.xml 文件</li>\n</ol>\n<h3 id=\"IF\"><a href=\"#IF\" class=\"headerlink\" title=\"IF\"></a>IF</h3><pre><code class=\"java\">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;if test=&quot;title!=null&quot;&gt;\n            and title = #&#123;title&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;author!=null&quot;&gt;\n            and author = #&#123;author&#125;\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h3 id=\"choose-when-otherwise\"><a href=\"#choose-when-otherwise\" class=\"headerlink\" title=\"choose (when, otherwise)\"></a>choose (when, otherwise)</h3><h3 id=\"trim、where、set\"><a href=\"#trim、where、set\" class=\"headerlink\" title=\"trim、where、set\"></a>trim、where、set</h3><h3 id=\"SQL-片段\"><a href=\"#SQL-片段\" class=\"headerlink\" title=\"SQL 片段\"></a>SQL 片段</h3><p>有的时候，我们可能会将一些功能的部分抽取出来，方便服用！</p>\n<ol>\n<li><p>使用 SQL 标签抽取公共部分可</p>\n<pre><code class=\"xml\">&lt;sql id=&quot;if-title-author&quot;&gt;\n    &lt;if test=&quot;title!=null&quot;&gt;\n        title = #&#123;title&#125;\n    &lt;/if&gt;\n    &lt;if test=&quot;author!=null&quot;&gt;\n        and author = #&#123;author&#125;\n    &lt;/if&gt;\n&lt;/sql&gt;\n</code></pre>\n<ol start=\"2\">\n<li><p>在需要使用的地方使用 Include 标签引用即可</p>\n<pre><code class=\"xml\">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意事项：</p>\n<ul>\n<li>最好基于单标来定义 SQL 片段</li>\n<li>不要存在 where 标签</li>\n</ul>\n<p><strong>动态 SQL 就是在拼接 SQL 语句，我们只要保证 SQL 的正确性，按照 SQL 的格式，去排列组合就可以了</strong></p>\n<p>建议：</p>\n<ul>\n<li>先在 Mysql 中写出完整的 SQL，再对应的去修改成我们的动态 SQL 实现通用即可</li>\n</ul>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>查询 ： 连接数据库，耗资源</p>\n<p>一次查询的结果，给他暂存一个可以直接取到的地方 –&gt; 内存：缓存</p>\n<p>我们再次查询的相同数据的时候，直接走缓存，不走数据库了</p>\n<ol>\n<li>什么是缓存[Cache]？<ol>\n<li>存在内存中的临时数据</li>\n<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>\n</ol>\n</li>\n<li>为什么使用缓存？<ol>\n<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>\n</ol>\n</li>\n<li>什么样的数据可以使用缓存？<ol>\n<li>经常查询并且不经常改变的数据 【可以使用缓存】</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"MyBatis-缓存\"><a href=\"#MyBatis-缓存\" class=\"headerlink\" title=\"MyBatis 缓存\"></a>MyBatis 缓存</h2><ul>\n<li>MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。</li>\n<li>MyBatis 系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>\n<li>默认情况下，只有一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）</li>\n<li>二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。</li>\n<li>为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><ul>\n<li>一级缓存也叫本地缓存：SqlSession<ul>\n<li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li>\n<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>\n</ul>\n</li>\n</ul>\n<p>测试步骤：</p>\n<ol>\n<li><p>开启日志</p>\n</li>\n<li><p>测试在一个 Session 中查询两次记录</p>\n<pre><code class=\"java\">@Test\npublic void test1() &#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = mapper.getUserById(1);\n        System.out.println(user);\n\n        System.out.println(&quot;=====================================&quot;);\n\n        User user2 =  mapper.getUserById(1);\n        System.out.println(user2 == user);\n    &#125;\n</code></pre>\n</li>\n<li><p>查看日志输出</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165129955.png\"></p>\n</li>\n</ol>\n<p><strong>缓存失效的情况：</strong></p>\n<ol>\n<li>查询不同的东西</li>\n<li>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</li>\n<li>查询不同的 Mapper.xml</li>\n<li>手动清理缓存</li>\n</ol>\n<pre><code class=\"java\">sqlSession.clearCache();\n</code></pre>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><ul>\n<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>\n<li>基于 namespace 级别的缓存，一个名称空间，对应一个二级缓存</li>\n<li>工作机制<ul>\n<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>\n<li>如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li>\n<li>新的会话查询信息，就可以从二级缓存中获取内容</li>\n<li>不同的 mapper 查询出的数据会放在自己对应的缓存（map）中</li>\n</ul>\n</li>\n</ul>\n<p>一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）</p>\n<ul>\n<li>二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。</li>\n<li>为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。</li>\n<li></li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li><p>开启全局缓存</p>\n<pre><code class=\"xml\">&lt;!--显示的开启全局缓存--&gt;\n&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n</code></pre>\n</li>\n<li><p>在 Mapper.xml 中使用缓存</p>\n<pre><code class=\"xml\">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;\n&lt;cache\n       eviction=&quot;FIFO&quot;  //first input first output\n       flushInterval=&quot;60000&quot;\n       size=&quot;512&quot;\n       readOnly=&quot;true&quot;/&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<ol>\n<li>问题：我们需要将实体类序列化，否则就会报错</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结：</strong></p>\n<ul>\n<li>只要开启了二级缓存，在同一个 Mapper 下就有效</li>\n<li>所有的数据都会放在一级缓存中</li>\n<li>只有当前会话提交，或者关闭的时候，才会提交到二级缓存中</li>\n</ul>\n<h2 id=\"缓存原理\"><a href=\"#缓存原理\" class=\"headerlink\" title=\"缓存原理\"></a>缓存原理</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165404113.png\"></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true”</li>\n</ul>\n<pre><code class=\"xml\">    &lt;select id=&quot;getUserById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;\n        select * from user where id = #&#123;id&#125;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"自定义缓存-ehcache\"><a href=\"#自定义缓存-ehcache\" class=\"headerlink\" title=\"自定义缓存-ehcache\"></a>自定义缓存-ehcache</h2><p>Ehcache 是一种广泛使用的开源 Java 分布式缓存。主要面向通用缓存</p>\n<ol>\n<li><p>导包</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;1.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n</li>\n<li><p>在 mapper 中指定使用我们的 ehcache 缓存实现</p>\n<pre><code class=\"xml\">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n</code></pre>\n</li>\n<li><p>resource/ehcache.xml</p>\n</li>\n</ol>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;\n         updateCheck=&quot;false&quot;&gt;\n    &lt;!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     --&gt;\n    &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt;\n    &lt;!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     --&gt;\n    &lt;!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   --&gt;\n    &lt;defaultCache\n            eternal=&quot;false&quot;\n            maxElementsInMemory=&quot;10000&quot;\n            overflowToDisk=&quot;false&quot;\n            diskPersistent=&quot;false&quot;\n            timeToIdleSeconds=&quot;1800&quot;\n            timeToLiveSeconds=&quot;259200&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;\n\n    &lt;cache\n            name=&quot;cloud_user&quot;\n            eternal=&quot;false&quot;\n            maxElementsInMemory=&quot;5000&quot;\n            overflowToDisk=&quot;false&quot;\n            diskPersistent=&quot;false&quot;\n            timeToIdleSeconds=&quot;1800&quot;\n            timeToLiveSeconds=&quot;1800&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;\n&lt;/ehcache&gt;\n</code></pre>\n<ol start=\"4\">\n<li>MyCache.java 重写 其中方法</li>\n</ol>\n<pre><code class=\"java\">package com.shan.utils;\n\nimport org.apache.ibatis.cache.Cache;\n\nimport java.util.concurrent.locks.ReadWriteLock;\n\npublic class MyCache implements Cache &#123;\n    public String getId() &#123;\n        return null;\n    &#125;\n\n    public void putObject(Object o, Object o1) &#123;\n\n    &#125;\n\n    public Object getObject(Object o) &#123;\n        return null;\n    &#125;\n\n    public Object removeObject(Object o) &#123;\n        return null;\n    &#125;\n\n    public void clear() &#123;\n\n    &#125;\n\n    public int getSize() &#123;\n        return 0;\n    &#125;\n\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<p>现在一般用 Redis 做缓存！ &lt;K, V&gt;</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h1>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>mybatis 是一个持久层框架；</li>\n<li>支持定制 SQL、存储过程以及高级映射；</li>\n<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>\n<li>Mybatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 java 的 POJO（Plain Old Java Objects，普通老式 java 对象）为数据库中的记录。</li>\n</ul>\n<h2 id=\"什么是持久化？\"><a href=\"#什么是持久化？\" class=\"headerlink\" title=\"什么是持久化？\"></a>什么是持久化？</h2><p>数据持久化</p>\n<ul>\n<li>持久化就是将程序的数据在持久状态和瞬间状态转化的过程；</li>\n<li>内存：断电即失；</li>\n<li>数据库（jdbc）, io 文件持久化。</li>\n<li>生活：冷藏、罐头；</li>\n</ul>\n<p>为什么需要持久化？</p>\n<ul>\n<li>有一些对象不能让丢掉；</li>\n<li>内存在系统中很珍贵；</li>\n</ul>\n<h2 id=\"持久层\"><a href=\"#持久层\" class=\"headerlink\" title=\"持久层\"></a>持久层</h2><p>Dao 层、Service 层、Controller 层…….</p>\n<ul>\n<li>完成持久化工作的代码块；</li>\n<li>层界限十分明显。</li>\n</ul>\n<h2 id=\"为什么需要-Mybatis？\"><a href=\"#为什么需要-Mybatis？\" class=\"headerlink\" title=\"为什么需要 Mybatis？\"></a>为什么需要 Mybatis？</h2><ul>\n<li>帮助程序员将数据存入到数据库中；</li>\n<li>方便；</li>\n<li>传统的 JDBC 代码太复杂了。简化。框架。自动化。</li>\n<li>不用 MyBatis 也可以。但 MyBatis 更容易上手。技术没有高低之分</li>\n<li>优点<ul>\n<li>简单易学</li>\n<li>灵活</li>\n<li>sql 和代码的分离，提高了可维护性。</li>\n<li>提供映射标签，支持对象与数据库的 orm 字段映射。</li>\n<li>提供对象关系映射标签，支持对象关系组件维护。</li>\n<li>提供 xml 标签，支持编写动态 sql。</li>\n</ul>\n</li>\n</ul>\n<p><strong>最重要的一点：使用的人多！</strong></p>\n<h2 id=\"第一个-MyBatis-程序-mybatis-01\"><a href=\"#第一个-MyBatis-程序-mybatis-01\" class=\"headerlink\" title=\"第一个 MyBatis 程序 mybatis-01\"></a>第一个 MyBatis 程序 <code>mybatis-01</code></h2><ul>\n<li>搭建环境</li>\n</ul>\n<pre><code class=\"sql\">CREATE DATABASE `mybatis`;\n\nUSE `mybatis`;\n\nCREATE TABLE `user` (\n`id` INT(20) NOT NULL PRIMARY KEY,\n`name` VARCHAR(30) DEFAULT NULL,\n`pwd` VARCHAR(30) DEFAULT NULL\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\n\nINSERT INTO `user` (`id`,`name`,`pwd`) VALUES\n(1, &#39;狂神&#39;, &#39;123456&#39;),\n(2, &#39;李四&#39;, &#39;123456&#39;),\n(3, &#39;张三&#39;, &#39;123890&#39;)\n</code></pre>\n<ul>\n<li><p>新建项目(创建 maven 父子模块)</p>\n<ul>\n<li><p>配置 mybatis 的核心配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/shan/dao/UserMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n</li>\n<li><p>编写 mybatis 工具类</p>\n<pre><code class=\"java\">package com.shan.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n//sqlSessionFactory  --&gt;  sqlSession\npublic class MybatisUtils &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        try &#123;\n            //获取sqlSessionFactory对象\n            String resource = &quot;mybatis-config.xml&quot;;\n            InputStream is = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    //既然有了sqlSessionFactory, 我们可以从中获取sqlSession实例\n    //SqlSession 完全包含了面向数据库执行 SQL 命令所需要的所有方法\n\n    public static SqlSession getSqlSession() &#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>编写实体类</p>\n<ul>\n<li><p>实体类</p>\n<pre><code class=\"java\">package com.shan.pojo;\n\npublic class User &#123;\n    private int id;\n    private String name;\n    private String pwd;\n    public User() &#123;\n    &#125;\n    public User(int id, String name, String pwd) &#123;\n        this.id = id;\n        this.name = name;\n        this.pwd = pwd;\n    &#125;\n    public int getId() &#123;\n        return id;\n    &#125;\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getPwd() &#123;\n        return pwd;\n    &#125;\n    public void setPwd(String pwd) &#123;\n        this.pwd = pwd;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, pwd=&#39;&quot; + pwd + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>Dao 接口</p>\n<pre><code class=\"java\">package com.shan.dao;\n\nimport com.shan.pojo.User;\n\nimport java.util.List;\n\npublic interface UserDao &#123;\n    List&lt;User&gt; getUserList();\n&#125;\n</code></pre>\n</li>\n<li><p>接口实现类由原本的 UserDaoOmpl 转变成一个 Mapper 配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.shan.dao.UserDao&quot;&gt;\n    &lt;select id=&quot;getUserList&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from user\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>测试 (测试的包尽量一一对应)</p>\n<ul>\n<li><p>junit 测试</p>\n<pre><code class=\"shell\"># 错误1\norg.apache.ibatis.binding.BindingException: Type interface com.xiaofan.dao.UserDao is not known to the MapperRegistry.\n\n# 解决方案\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/xiaofan/dao/UserMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n\n# 错误2\nCause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/xiaofan/dao/UserMapper.xml\n\n# 解决方案\n    &lt;build&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.properties&lt;/include&gt;\n                    &lt;include&gt;**/*.xml&lt;/include&gt;\n                    &lt;include&gt;**/*.tld&lt;/include&gt;\n                &lt;/includes&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.properties&lt;/include&gt;\n                    &lt;include&gt;**/*.xml&lt;/include&gt;\n                    &lt;include&gt;**/*.tld&lt;/include&gt;\n                &lt;/includes&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>可能遇到的问题：</p>\n<ol>\n<li>配置文件没有注册</li>\n<li>绑定接口错误</li>\n<li>方法名不对</li>\n<li>返回类型不对</li>\n</ol>\n<h1 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h1><h2 id=\"1、namespace\"><a href=\"#1、namespace\" class=\"headerlink\" title=\"1、namespace\"></a>1、namespace</h2><p>namespace 中的包名要和 Dao/Mapper 接口的包名一致！</p>\n<h2 id=\"2、select\"><a href=\"#2、select\" class=\"headerlink\" title=\"2、select\"></a>2、select</h2><p>选择，查询语句；</p>\n<ul>\n<li>id：就是对应的 nameSpace 中的方法名；</li>\n<li>resultType：Sql 语句执行的返回值！</li>\n<li>parameterType：参数类型</li>\n</ul>\n<h2 id=\"增删改需要提交事务\"><a href=\"#增删改需要提交事务\" class=\"headerlink\" title=\"增删改需要提交事务\"></a>增删改需要提交事务</h2><pre><code class=\"java\">sqlSession.commit();\nsqlSession.close();\n</code></pre>\n<h2 id=\"3、insert-update-delete\"><a href=\"#3、insert-update-delete\" class=\"headerlink\" title=\"3、insert,update,delete\"></a>3、insert,update,delete</h2><pre><code class=\"java\">int addUser(User user);\nint updUser(User user);\nint deleteUser(int id);\n</code></pre>\n<pre><code class=\"java\">@Test\n    public void addUser()&#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.addUser(new User(5, &quot;haha&quot;, &quot;123456&quot;));\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n\n    @Test\n    public void updUser() &#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.updUser(new User(4, &quot;aa&quot;, &quot;123456&quot;));\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n\n    @Test\n    public void deleteUser() &#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        int res = mapper.deleteUser(5);\n        if (res!=0)&#123;\n            System.out.println(&quot;success&quot;);\n        &#125;\n        sqlSession.commit();\n        sqlSession.close();\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;!--    对象中的属性可以直接取出来--&gt;\n    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.shan.pojo.User&quot;&gt;\n        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\n    &lt;/insert&gt;\n\n    &lt;update id=&quot;updUser&quot; parameterType=&quot;com.shan.pojo.User&quot;&gt;\n        update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125;\n    &lt;/update&gt;\n\n    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;\n        delete from mybatis.user where id=#&#123;id&#125;\n    &lt;/delete&gt;\n</code></pre>\n<h1 id=\"万能-Map\"><a href=\"#万能-Map\" class=\"headerlink\" title=\"万能 Map\"></a>万能 Map</h1><p>假如我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用 Map 传入数据，而不是对象实体（User）</p>\n<p>map 传递参数，直接在 sql 中取出 key 即可！ parameterType=”map”</p>\n<p>对象传递参数，直接在 sql 中取出对象的属性即可！</p>\n<p>只有一个基本类型参数的情况下，可以直接在 sql 中取到！</p>\n<p>多个参数用 map, 或者注解</p>\n<pre><code class=\"java\">@Test\n    public void getUserByIdandName()&#123;\n        //获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap&lt;String, Object&gt; objectMap = new HashMap&lt;String, Object&gt;();\n        objectMap.put(&quot;userid&quot;, 7);\n        objectMap.put(&quot;username&quot;, &quot;zz&quot;);\n        User user = mapper.getUserByIdandName(objectMap);\n        System.out.println(user.toString());\n        sqlSession.close();\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserByIdandName&quot;  parameterType=&quot;map&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from mybatis.user where id = #&#123;userid&#125; and name = #&#123;username&#125;\n    &lt;/select&gt;\n</code></pre>\n<h1 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h1><p>不要让 java 传值拼接通配符<code>% _</code>，有 SQL 注入风险，比如传入<code>or 1=1</code>，恒定条件会导致全查出来；</p>\n<p>sql map 中使用通配符；</p>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserLike&quot; parameterType=&quot;string&quot; resultType=&quot;com.shan.pojo.User&quot;&gt;\n        select * from mybatis.user where name like &quot;%&quot;#&#123;key&#125;&quot;%&quot;\n    &lt;/select&gt;\n</code></pre>\n<h1 id=\"配置之属性优化-mybatis-02\"><a href=\"#配置之属性优化-mybatis-02\" class=\"headerlink\" title=\"配置之属性优化 mybatis-02\"></a>配置之属性优化 mybatis-02</h1><h2 id=\"核心配置文件\"><a href=\"#核心配置文件\" class=\"headerlink\" title=\"核心配置文件\"></a>核心配置文件</h2><ul>\n<li>mybatis-config.xml</li>\n<li>Mybatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li>\n</ul>\n<pre><code>configuration（配置）\n    properties（属性）\n    settings（设置）\n    typeAliases（类型别名）\n    typeHandlers（类型处理器）\n    objectFactory（对象工厂）\n    plugins（插件）\n    environments（环境配置）\n        environment（环境变量）\n            transactionManager（事务管理器）\n            dataSource（数据源）\n    databaseIdProvider（数据库厂商标识）\n    mappers（映射器）\n</code></pre>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>Mybatis 可以配置成适应多种环境</p>\n<p>不过要记住，尽管可以配置多个环境，但每个 sqlsessionFactory 实例只能选择一种环境</p>\n<p>学会使用配置多套运行环境！—— <code>&lt;environments default=&quot;development&quot;&gt;</code></p>\n<p>MyBatis 默认的事务管理器就是 JDBC，连接池：POOLED</p>\n<h2 id=\"属性（properties）\"><a href=\"#属性（properties）\" class=\"headerlink\" title=\"属性（properties）\"></a>属性（properties）</h2><p>我们可以通过 properties 属性来实现引用配置文件</p>\n<p>这些属性都是可外部配置且可动态替换的，既可以在典型的 java 属性文件中配置，也可通过 properties 元素的子元素来传递。 【db.properties】</p>\n<p>db.properties</p>\n<pre><code class=\"xml\">driver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\nusername=root\npassword=123456\n</code></pre>\n<p>在 mybatis-config.xml 中映入</p>\n<pre><code class=\"xml\">&lt;!--引入外部配置文件--&gt;\n    &lt;properties resource=&quot;db.properties&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n    &lt;/properties&gt;\n</code></pre>\n<ul>\n<li><p>可以直接引入外部配置文件</p>\n</li>\n<li><p>可以在其中增加一些配置属性</p>\n</li>\n<li><p>如果两个文件有同一个字段，优先使用 db.properties 外部配置文件的（先引入本文件属性，在引入外部文件属性，外部文件属性会覆盖本文件属性）</p>\n</li>\n</ul>\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><ul>\n<li>类型别名是为 java 类型设置一个短的名字。</li>\n<li>存在的意义仅在于用来减少类完全限定名的冗余。</li>\n</ul>\n<pre><code class=\"xml\">&lt;!--类型别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias type=&quot;com.shan.pojo.User&quot; alias=&quot;User&quot;/&gt;\n    &lt;/typeAliases&gt;\n</code></pre>\n<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>\n<p>扫描实体类的包，他的默认别名就为这个类的类名，首字母小写！</p>\n<pre><code class=\"xml\">    &lt;typeAliases&gt;\n        &lt;package name=&quot;com.shan.pojo&quot;/&gt;\n    &lt;/typeAliases&gt;\n</code></pre>\n<p>两种方法，在实体类比较少的时候，使用第一种方式。</p>\n<p>如果实体类身份多，建议使用第二种。</p>\n<p>第一种可以 DIY 别名，第二种则不行，如果非要改，需要在实体上增加注解。</p>\n<pre><code class=\"java\">@Alias(value = &quot;hello&quot;)\npublic class User &#123;&#125;\n</code></pre>\n<h2 id=\"设置-Settings\"><a href=\"#设置-Settings\" class=\"headerlink\" title=\"设置 Settings\"></a>设置 Settings</h2><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/2020062316474822.png\"></p>\n<h2 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h2><p>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins 插件<br>mybatis-generator-core<br>mybatis-plus<br>通用 mapper</p>\n<h2 id=\"映射器-mappers\"><a href=\"#映射器-mappers\" class=\"headerlink\" title=\"映射器 mappers\"></a>映射器 mappers</h2><p>MapperRegistry：注册绑定我们的 Mapper 文件；</p>\n<p>方式一：【推荐使用】</p>\n<pre><code class=\"xml\">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>方式二：使用 class 文件绑定注册</p>\n<pre><code class=\"xml\">&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>注意点：</p>\n<p>接口和他的 Mapper 配置文件必须同名<br>接口和他的 Mapper 配置文件必须在同一个包下</p>\n<p>方式三：使用包扫描进行注入</p>\n<pre><code class=\"xml\">&lt;mappers&gt;\n    &lt;package name=&quot;com.kuang.dao&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<h2 id=\"作用域和生命周期\"><a href=\"#作用域和生命周期\" class=\"headerlink\" title=\"作用域和生命周期\"></a>作用域和生命周期</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164809990.png\"></p>\n<p>声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>\n<p><strong>SqlSessionFactoryBuilder:</strong></p>\n<p>一旦创建了 SqlSessionFactory，就不再需要它了<br>局部变量<br>SqlSessionFactory:</p>\n<p>说白了就可以想象为：数据库连接池<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。<br>因此 SqlSessionFactory 的最佳作用域是应用作用域（ApplocationContext）。<br>最简单的就是使用单例模式或静态单例模式。<br>SqlSession：</p>\n<p>连接到连接池的一个请求<br>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。<br>用完之后需要赶紧关闭，否则资源被占用！<br><img src=\"img/article/JAVA-MyBatis-20210503/20200623164833872.png\"></p>\n<h1 id=\"解决属性名和字段名不一致的问题\"><a href=\"#解决属性名和字段名不一致的问题\" class=\"headerlink\" title=\"解决属性名和字段名不一致的问题\"></a>解决属性名和字段名不一致的问题</h1><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>数据库中的字段</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164845962.png\"></p>\n<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164853569.png\"></p>\n<p>测试出现问题<br><img src=\"img/article/JAVA-MyBatis-20210503/20200623164901861.png\"></p>\n<pre><code class=\"xml\">// select * from user where id = #&#123;id&#125;\n// 类型处理器\n// select id,name,pwd from user where id = #&#123;id&#125;\n</code></pre>\n<p>解决方法：</p>\n<ul>\n<li>起别名</li>\n</ul>\n<pre><code class=\"xml\">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;\n    select id,name,pwd as password from USER where id = #&#123;id&#125;\n&lt;/select&gt;\n</code></pre>\n<h3 id=\"resultMap\"><a href=\"#resultMap\" class=\"headerlink\" title=\"resultMap\"></a>resultMap</h3><p>结果集映射</p>\n<p>id name pwd</p>\n<p>id name password</p>\n<pre><code class=\"xml\">&lt;!--结果集映射--&gt;\n&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;\n    &lt;!--column数据库中的字段，property实体类中的属性--&gt;\n    &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt;\n    &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;\n    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt;\n&lt;/resultMap&gt;\n\n&lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt;\n    select * from USER\n&lt;/select&gt;\n</code></pre>\n<ul>\n<li><p>resultMap 元素是 MyBatis 中最重要最强大的元素。</p>\n</li>\n<li><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>\n</li>\n<li><p>ResultMap 的优秀之处——你完全可以不用显式地配置它们。</p>\n<p>如果这个世界总是这么简单就好了。</p>\n</li>\n</ul>\n<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h1><h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！</p>\n<p>曾经：sout、debug</p>\n<p>现在：日志工厂</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164920502.png\"></p>\n<ul>\n<li>SLF4J</li>\n<li>LOG4J 【掌握】</li>\n<li>LOG4J2</li>\n<li>JDK_LOGGING</li>\n<li>COMMONS_LOGGING</li>\n<li>STDOUT_LOGGING 【掌握】</li>\n<li>NO_LOGGING</li>\n</ul>\n<p>在 MyBatis 中具体使用哪一个日志实现，在设置中设定</p>\n<p><strong>STDOUT_LOGGING</strong></p>\n<pre><code class=\"xml\">&lt;settings&gt;\n    &lt;!--标注的日志工厂--&gt;\n    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/2020062316493391.png\"></p>\n<h2 id=\"Log4j\"><a href=\"#Log4j\" class=\"headerlink\" title=\"Log4j\"></a>Log4j</h2><p>什么是 Log4j？</p>\n<p>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件；</p>\n<p>我们也可以控制每一条日志的输出格式；</p>\n<p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；</p>\n<p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<ol>\n<li>先导入 log4j 的包</li>\n</ol>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<pre><code class=\"properties\">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n​\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/rzp.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sq1.PreparedStatement=DEBUG\n</code></pre>\n<ol start=\"3\">\n<li>配置 settings 为 log4j 实现</li>\n<li>测试运行</li>\n</ol>\n<p><strong>Log4j 简单使用</strong></p>\n<ol>\n<li>在要使用 Log4j 的类中，导入包 import org.apache.log4j.Logger; //注意要导对包</li>\n<li>日志对象，参数为当前类的 class 对象</li>\n</ol>\n<pre><code class=\"properties\">Logger logger = Logger.getLogger(UserDaoTest.class);\n</code></pre>\n<ol start=\"3\">\n<li>日志级别</li>\n</ol>\n<pre><code class=\"properties\">logger.info(&quot;info: 测试log4j&quot;);\nlogger.debug(&quot;debug: 测试log4j&quot;);\nlogger.error(&quot;error:测试log4j&quot;);\n</code></pre>\n<ol>\n<li>info</li>\n<li>debug</li>\n<li>error</li>\n</ol>\n<h1 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h1><p><strong>思考：为什么分页？</strong></p>\n<ul>\n<li>减少数据的处理量</li>\n</ul>\n<h2 id=\"使用-Limit-分页\"><a href=\"#使用-Limit-分页\" class=\"headerlink\" title=\"使用 Limit 分页\"></a>使用 Limit 分页</h2><pre><code class=\"sql\">SELECT * from user limit startIndex,pageSize   #[0,3)\n</code></pre>\n<p><strong>使用 MyBatis 实现分页，核心 SQL</strong></p>\n<ol>\n<li><p>接口</p>\n<pre><code class=\"java\">//分页\nList&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n</code></pre>\n</li>\n<li><p>Mapper.xml</p>\n<pre><code class=\"xml\">&lt;!-- 结果集映射 --&gt;\n    &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;/&gt;\n&lt;!--分页查询--&gt;\n&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;\n    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;\n&lt;/select&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">    @Test\n    public void getUserByLimit()&#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n        map.put(&quot;startIndex&quot;,1);\n        map.put(&quot;pageSize&quot;,2);\n        List&lt;User&gt; list = mapper.getUserByLimit(map);\n        for (User user : list) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"RowBounds-分页\"><a href=\"#RowBounds-分页\" class=\"headerlink\" title=\"RowBounds 分页\"></a>RowBounds 分页</h2><p>不再使用 SQL 实现分页，不建议在开发中使用</p>\n<ol>\n<li><p>接口</p>\n<pre><code class=\"java\">//分页2\n    List&lt;User&gt; getUserByRowBounds();\n</code></pre>\n</li>\n<li><p>mapper.xml</p>\n<pre><code class=\"xml\">&lt;!--分页查询2--&gt;\n    &lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt;\n        select * from mybatis.user\n    &lt;/select&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">@Test\n    public void getUserByRowBounds()&#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        //RowBounds实现\n        RowBounds rowBounds = new RowBounds(1, 2);\n        //通过Java代码层面实现分页\n        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.shan.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds);\n        for (User user : userList) &#123;\n            System.out.println(user);\n        &#125;\n        sqlSession.close();\n    &#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"分页插件\"><a href=\"#分页插件\" class=\"headerlink\" title=\"分页插件\"></a>分页插件</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623164958936.png\"></p>\n<h1 id=\"使用注解开发\"><a href=\"#使用注解开发\" class=\"headerlink\" title=\"使用注解开发\"></a>使用注解开发</h1><h2 id=\"面向接口开发\"><a href=\"#面向接口开发\" class=\"headerlink\" title=\"面向接口开发\"></a>面向接口开发</h2><p><strong>三个面向区别</strong></p>\n<ul>\n<li>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；</li>\n<li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；</li>\n<li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；</li>\n</ul>\n<h2 id=\"使用注解开发-1\"><a href=\"#使用注解开发-1\" class=\"headerlink\" title=\"使用注解开发\"></a>使用注解开发</h2><ol>\n<li><p>注解在接口上实现</p>\n<pre><code class=\"java\">@Select(&quot;select * from user&quot;)\nList&lt;User&gt; getUsers();\n</code></pre>\n</li>\n<li><p>需要在核心配置文件中绑定接口</p>\n<pre><code class=\"xml\">&lt;mappers&gt;\n    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n<p>本质：反射机制实现</p>\n<p>底层：动态代理</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165014965.png\"></p>\n<p><strong>MyBatis 详细执行流程</strong></p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165030775.png\"></p>\n<h2 id=\"注解-CURD\"><a href=\"#注解-CURD\" class=\"headerlink\" title=\"注解 CURD\"></a>注解 CURD</h2><pre><code class=\"java\">//方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解\n@Delete(&quot;delete from user where id = $&#123;uid&#125;&quot;)\nint deleteUser(@Param(&quot;uid&quot;) int id);\n</code></pre>\n<p><strong>关于@Param( )注解</strong></p>\n<ul>\n<li>基本类型的参数或者 String 类型，需要加上</li>\n<li>引用类型不需要加</li>\n<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上</li>\n<li>我们在 SQL 中引用的就是我们这里的@Param()中设定的属性名</li>\n</ul>\n<p><strong>#{} 和 ${}</strong></p>\n<h1 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h1><p>Lombok 项目是一个 Java 库，它会自动插入编辑器和构建工具中，Lombok 提供了一组有用的注释，用来消除 Java 类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的 Java 类。</p>\n<p>使用步骤：</p>\n<ol>\n<li><p>在 IDEA 中安装 Lombok 插件; file–setting–plugin – 搜索安装 lombok 插件</p>\n</li>\n<li><p>在项目中导入 lombok 的 jar 包</p>\n</li>\n</ol>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;version&gt;1.18.10&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"3\">\n<li>在程序上加注解</li>\n</ol>\n<pre><code>@Getter and @Setter\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\n@Data //无参构造，get，set，tostring，hashcode，equals\n@Builder\n@SuperBuilder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@With\n@SneakyThrows\n@val\n</code></pre>\n<p>说明</p>\n<pre><code class=\"java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private int id;\n    private String name;\n    private String password;\n&#125;\n</code></pre>\n<h1 id=\"多对一处理\"><a href=\"#多对一处理\" class=\"headerlink\" title=\"多对一处理\"></a>多对一处理</h1><pre><code class=\"sql\">CREATE TABLE `teacher` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           PRIMARY KEY (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO teacher(`id`, `name`) VALUES (1, &#39;秦老师&#39;);\n\nCREATE TABLE `student` (\n                           `id` INT(10) NOT NULL,\n                           `name` VARCHAR(30) DEFAULT NULL,\n                           `tid` INT(10) DEFAULT NULL,\n                           PRIMARY KEY (`id`),\n                           KEY `fktid` (`tid`),\n                           CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, &#39;小明&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, &#39;小红&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, &#39;小张&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, &#39;小李&#39;, 1);\nINSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, &#39;小王&#39;, 1);\n\nalter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n</code></pre>\n<p>多个学生一个老师；</p>\n<pre><code class=\"sql\">alter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id)\n</code></pre>\n<h1 id=\"一对多处理\"><a href=\"#一对多处理\" class=\"headerlink\" title=\"一对多处理\"></a>一对多处理</h1><blockquote>\n<p>一个老师多个学生；</p>\n<p>对于老师而言，就是一对多的关系；</p>\n</blockquote>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p><strong>实体类</strong></p>\n<pre><code class=\"java\">@Data\npublic class Student &#123;\n    private int id;\n    private String name;\n    private int tid;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Data\npublic class Teacher &#123;\n    private int id;\n    private String name;\n\n    //一个老师拥有多个学生\n    private List&lt;Student&gt; students;\n&#125;\n</code></pre>\n<pre><code class=\"java\">&lt;!--按结果嵌套查询--&gt;\n&lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt;\n    SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t\n    WHERE s.tid = t.id AND tid = #&#123;tid&#125;\n&lt;/select&gt;\n&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt;\n    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;\n    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;\n    &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection\n    javaType=&quot;&quot;指定属性的类型！\n    集合中的泛型信息，我们使用ofType获取\n    --&gt;\n    &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;\n        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;\n        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;\n        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n</code></pre>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li>关联 - association 【多对一】</li>\n<li>集合 - collection 【一对多】</li>\n<li>javaType &amp; ofType<ol>\n<li>JavaType 用来指定实体类中的类型</li>\n<li>ofType 用来指定映射到 List 或者集合中的 pojo 类型，泛型中的约束类型</li>\n</ol>\n</li>\n</ol>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><p>保证 SQL 的可读性，尽量保证通俗易懂</p>\n</li>\n<li><p>注意一对多和多对一，属性名和字段的问题</p>\n</li>\n<li><p>如果问题不好排查错误，可以使用日志，建议使用 Log4</p>\n<p>面试高频</p>\n<ul>\n<li>Mysql 引擎</li>\n<li>InnoDB 底层原理</li>\n<li>索引</li>\n<li>索引优化</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"动态-SQL\"><a href=\"#动态-SQL\" class=\"headerlink\" title=\"动态 SQL\"></a>动态 SQL</h1><p>什么是动态 SQL：动态 SQL 就是根据不同的条件生成不同的 SQL 语句</p>\n<p>所谓的动态 SQL，本质上还是 SQL 语句，只是我们可以在 SQL 层面，去执行一个逻辑代码</p>\n<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>\n<h2 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h2><pre><code class=\"sql\">CREATE TABLE `mybatis`.`blog`  (\n  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#39;博客id&#39;,\n  `title` varchar(30) NOT NULL COMMENT &#39;博客标题&#39;,\n  `author` varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,\n  `create_time` datetime(0) NOT NULL COMMENT &#39;创建时间&#39;,\n  `views` int(30) NOT NULL COMMENT &#39;浏览量&#39;,\n  PRIMARY KEY (`id`)\n)\n</code></pre>\n<p>创建一个基础工程</p>\n<ol>\n<li>导包</li>\n<li>编写配置文件</li>\n<li>编写实体类</li>\n</ol>\n<pre><code class=\"java\">@Data\npublic class Blog &#123;\n    private int id;\n    private String title;\n    private String author;\n\n    private Date createTime;// 属性名和字段名不一致\n    private int views;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>编写实体类对应 Mapper 接口和 Mapper.xml 文件</li>\n</ol>\n<h3 id=\"IF\"><a href=\"#IF\" class=\"headerlink\" title=\"IF\"></a>IF</h3><pre><code class=\"java\">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;if test=&quot;title!=null&quot;&gt;\n            and title = #&#123;title&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;author!=null&quot;&gt;\n            and author = #&#123;author&#125;\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h3 id=\"choose-when-otherwise\"><a href=\"#choose-when-otherwise\" class=\"headerlink\" title=\"choose (when, otherwise)\"></a>choose (when, otherwise)</h3><h3 id=\"trim、where、set\"><a href=\"#trim、where、set\" class=\"headerlink\" title=\"trim、where、set\"></a>trim、where、set</h3><h3 id=\"SQL-片段\"><a href=\"#SQL-片段\" class=\"headerlink\" title=\"SQL 片段\"></a>SQL 片段</h3><p>有的时候，我们可能会将一些功能的部分抽取出来，方便服用！</p>\n<ol>\n<li><p>使用 SQL 标签抽取公共部分可</p>\n<pre><code class=\"xml\">&lt;sql id=&quot;if-title-author&quot;&gt;\n    &lt;if test=&quot;title!=null&quot;&gt;\n        title = #&#123;title&#125;\n    &lt;/if&gt;\n    &lt;if test=&quot;author!=null&quot;&gt;\n        and author = #&#123;author&#125;\n    &lt;/if&gt;\n&lt;/sql&gt;\n</code></pre>\n<ol start=\"2\">\n<li><p>在需要使用的地方使用 Include 标签引用即可</p>\n<pre><code class=\"xml\">&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意事项：</p>\n<ul>\n<li>最好基于单标来定义 SQL 片段</li>\n<li>不要存在 where 标签</li>\n</ul>\n<p><strong>动态 SQL 就是在拼接 SQL 语句，我们只要保证 SQL 的正确性，按照 SQL 的格式，去排列组合就可以了</strong></p>\n<p>建议：</p>\n<ul>\n<li>先在 Mysql 中写出完整的 SQL，再对应的去修改成我们的动态 SQL 实现通用即可</li>\n</ul>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>查询 ： 连接数据库，耗资源</p>\n<p>一次查询的结果，给他暂存一个可以直接取到的地方 –&gt; 内存：缓存</p>\n<p>我们再次查询的相同数据的时候，直接走缓存，不走数据库了</p>\n<ol>\n<li>什么是缓存[Cache]？<ol>\n<li>存在内存中的临时数据</li>\n<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>\n</ol>\n</li>\n<li>为什么使用缓存？<ol>\n<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>\n</ol>\n</li>\n<li>什么样的数据可以使用缓存？<ol>\n<li>经常查询并且不经常改变的数据 【可以使用缓存】</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"MyBatis-缓存\"><a href=\"#MyBatis-缓存\" class=\"headerlink\" title=\"MyBatis 缓存\"></a>MyBatis 缓存</h2><ul>\n<li>MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。</li>\n<li>MyBatis 系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>\n<li>默认情况下，只有一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）</li>\n<li>二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。</li>\n<li>为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><ul>\n<li>一级缓存也叫本地缓存：SqlSession<ul>\n<li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li>\n<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li>\n</ul>\n</li>\n</ul>\n<p>测试步骤：</p>\n<ol>\n<li><p>开启日志</p>\n</li>\n<li><p>测试在一个 Session 中查询两次记录</p>\n<pre><code class=\"java\">@Test\npublic void test1() &#123;\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = mapper.getUserById(1);\n        System.out.println(user);\n\n        System.out.println(&quot;=====================================&quot;);\n\n        User user2 =  mapper.getUserById(1);\n        System.out.println(user2 == user);\n    &#125;\n</code></pre>\n</li>\n<li><p>查看日志输出</p>\n<p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165129955.png\"></p>\n</li>\n</ol>\n<p><strong>缓存失效的情况：</strong></p>\n<ol>\n<li>查询不同的东西</li>\n<li>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</li>\n<li>查询不同的 Mapper.xml</li>\n<li>手动清理缓存</li>\n</ol>\n<pre><code class=\"java\">sqlSession.clearCache();\n</code></pre>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><ul>\n<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>\n<li>基于 namespace 级别的缓存，一个名称空间，对应一个二级缓存</li>\n<li>工作机制<ul>\n<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>\n<li>如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li>\n<li>新的会话查询信息，就可以从二级缓存中获取内容</li>\n<li>不同的 mapper 查询出的数据会放在自己对应的缓存（map）中</li>\n</ul>\n</li>\n</ul>\n<p>一级缓存开启（SqlSession 级别的缓存，也称为本地缓存）</p>\n<ul>\n<li>二级缓存需要手动开启和配置，他是基于 namespace 级别的缓存。</li>\n<li>为了提高可扩展性，MyBatis 定义了缓存接口 Cache。我们可以通过实现 Cache 接口来定义二级缓存。</li>\n<li></li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li><p>开启全局缓存</p>\n<pre><code class=\"xml\">&lt;!--显示的开启全局缓存--&gt;\n&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n</code></pre>\n</li>\n<li><p>在 Mapper.xml 中使用缓存</p>\n<pre><code class=\"xml\">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;\n&lt;cache\n       eviction=&quot;FIFO&quot;  //first input first output\n       flushInterval=&quot;60000&quot;\n       size=&quot;512&quot;\n       readOnly=&quot;true&quot;/&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<ol>\n<li>问题：我们需要将实体类序列化，否则就会报错</li>\n</ol>\n</li>\n</ol>\n<p><strong>小结：</strong></p>\n<ul>\n<li>只要开启了二级缓存，在同一个 Mapper 下就有效</li>\n<li>所有的数据都会放在一级缓存中</li>\n<li>只有当前会话提交，或者关闭的时候，才会提交到二级缓存中</li>\n</ul>\n<h2 id=\"缓存原理\"><a href=\"#缓存原理\" class=\"headerlink\" title=\"缓存原理\"></a>缓存原理</h2><p><img src=\"img/article/JAVA-MyBatis-20210503/20200623165404113.png\"></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>只有查询才有缓存，根据数据是否需要缓存（修改是否频繁选择是否开启）useCache=“true”</li>\n</ul>\n<pre><code class=\"xml\">    &lt;select id=&quot;getUserById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;\n        select * from user where id = #&#123;id&#125;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"自定义缓存-ehcache\"><a href=\"#自定义缓存-ehcache\" class=\"headerlink\" title=\"自定义缓存-ehcache\"></a>自定义缓存-ehcache</h2><p>Ehcache 是一种广泛使用的开源 Java 分布式缓存。主要面向通用缓存</p>\n<ol>\n<li><p>导包</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;1.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n</li>\n<li><p>在 mapper 中指定使用我们的 ehcache 缓存实现</p>\n<pre><code class=\"xml\">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n</code></pre>\n</li>\n<li><p>resource/ehcache.xml</p>\n</li>\n</ol>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;\n         updateCheck=&quot;false&quot;&gt;\n    &lt;!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     --&gt;\n    &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt;\n    &lt;!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     --&gt;\n    &lt;!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统当机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   --&gt;\n    &lt;defaultCache\n            eternal=&quot;false&quot;\n            maxElementsInMemory=&quot;10000&quot;\n            overflowToDisk=&quot;false&quot;\n            diskPersistent=&quot;false&quot;\n            timeToIdleSeconds=&quot;1800&quot;\n            timeToLiveSeconds=&quot;259200&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;\n\n    &lt;cache\n            name=&quot;cloud_user&quot;\n            eternal=&quot;false&quot;\n            maxElementsInMemory=&quot;5000&quot;\n            overflowToDisk=&quot;false&quot;\n            diskPersistent=&quot;false&quot;\n            timeToIdleSeconds=&quot;1800&quot;\n            timeToLiveSeconds=&quot;1800&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;\n&lt;/ehcache&gt;\n</code></pre>\n<ol start=\"4\">\n<li>MyCache.java 重写 其中方法</li>\n</ol>\n<pre><code class=\"java\">package com.shan.utils;\n\nimport org.apache.ibatis.cache.Cache;\n\nimport java.util.concurrent.locks.ReadWriteLock;\n\npublic class MyCache implements Cache &#123;\n    public String getId() &#123;\n        return null;\n    &#125;\n\n    public void putObject(Object o, Object o1) &#123;\n\n    &#125;\n\n    public Object getObject(Object o) &#123;\n        return null;\n    &#125;\n\n    public Object removeObject(Object o) &#123;\n        return null;\n    &#125;\n\n    public void clear() &#123;\n\n    &#125;\n\n    public int getSize() &#123;\n        return 0;\n    &#125;\n\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<p>现在一般用 Redis 做缓存！ &lt;K, V&gt;</p>"},{"title":"JAVA-Spring5","date":"2021-05-03T15:00:02.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Spring.png"],"_content":"\n# Spring5\n\n<!--more-->\n\n## 简介\n\n春天 —>给软件行业带来了春天\n2002 年，Rod Jahnson 首次推出了 Spring 框架雏形 interface21 框架。\n2004 年 3 月 24 日，Spring 框架以 interface21 框架为基础，经过重新设计，发布了 1.0 正式版。\nRod Johnson 的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring 理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n官方下载地址 ： https://repo.spring.io/libs-release-local/org/springframework/spring/\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n\n```\n\n## 优点\n\n- Spring 是一个开源免费的框架 (容器)！\n- Spring 是一个轻量级的框架 , 非侵入式的\n- **控制反转 IoC , 面向切面 Aop**\n- 对事务的支持 , 对框架整合的支持\n\n**Spring 是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。**\n\n## 组成\n\nSpring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .\n\n![](img/article/JAVA-Spring5-20210503/20200628180016435.png)\n\n![](img/article/JAVA-Spring5-20210503/20200628180025728.png)\n\n- 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n- Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n- Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP 的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。\n- Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n- Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n- Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n- Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n## 拓展\n\n![](img/article/JAVA-Spring5-20210503/20200628180035980.png)\n\n- Spring Boot\n  - 一个快速开发的脚手架\n  - 基于 SpringBoot 可以快速的开发单个微服务\n- Spring Cloud\n  - Spring Cloud 是基于 SpringBoot 实现的\n\n# IOC 理论推导\n\n1. UserDao 接口\n\n```java\npublic interface UserDao {\n   void getUser();\n}\n```\n\n2. UserDaoImpl 实现类\n\n```java\npublic class UserDaoImpl implements UserDao {\n   @Override\n   public void getUser() {\n       System.out.println(\"获取用户数据\");\n  }\n}\n```\n\n3. UserService 业务接口\n\n```java\npublic interface UserService {\n   void getUser();\n}\n```\n\n4. UserServiceImpl 业务实现类\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao = new UserDaoImpl();\n\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n5. 测试一下\n\n```java\n@Test\npublic void test(){\n   UserService service = new UserServiceImpl();\n   service.getUser();\n}\n```\n\n把 Userdao 的实现类增加一个 .\n\n```java\npublic class UserDaoMySqlImpl implements UserDao {\n   @Override\n   public void getUser() {\n       System.out.println(\"MySql获取用户数据\");\n  }\n}\n```\n\n紧接着我们要去使用 MySql 的话 , 我们就需要去 service 实现类里面修改对应的实现\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao = new UserDaoMySqlImpl();\n\n   @Override\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n**代码量十分大，修改一次的成本十分昂贵！**\n\n我们使用一个 Set 接口实现，已经发生了革命性的变化！\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao;\n\t// 利用set实现\n   public void setUserDao(UserDao userDao) {\n       this.userDao = userDao;\n  }\n\n   @Override\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n- 之前，程序是主动创建对象，控制权在程序员手上！\n- 使用了 set 注入后，程序不再具有主动性，而是变成了被动的接受对象！\n\n这种思想，从本质上解决了问题，我们程序员不用再去管对象的创建了。系统的耦合性大大降低，可以专注在业务的实现上！这是 IOC 的原型！\n\n## IOC 本质\n\n控制反转 IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n\n![](img/article/JAVA-Spring5-20210503/20200628180055895.png)\n\n采用 XML 方式配置 Bean 的时候，Bean 的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean 的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n\n**控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入（Dependency Injection,DI）。**\n\n# HelloSpring\n\nbeans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n    <!--使用spring创建对象，在spring中这些都称为bean-->\n    <bean id=\"hello\" class=\"com.shan.pojo.Hello\">\n        <property name=\"str\" value=\"Spring\"/>\n    </bean>\n\n</beans>\n```\n\npojo.hello.java\n\n```java\npackage com.shan.pojo;\n\npublic class Hello {\n    private String str;\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n\n    @Override\n    public String toString() {\n        return \"Hello{\" +\n                \"str='\" + str + '\\'' +\n                '}';\n    }\n}\n```\n\ntest\n\n```java\n@Test\n    public void test01(){\n        //获取spring的上下文对象\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        // 我们的对象现在都在spring管理了,我们要使用，直接去里面取出来就可以！\n        Hello hello =(Hello) context.getBean(\"hello\");\n        System.out.println(hello);\n    }\n```\n\n# IOC 创建对象的方式\n\n1. 使用无参构造创建对象，默认！\n\n2. 假设我们要使用有参构造创建对象。\n\n   1. 下标赋值\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg index=\"0\" value=\"7500000\"/>\n          <constructor-arg index=\"1\" value=\"42\"/>\n      </bean>\n      ```\n\n   2. 构造参数类型\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg type=\"int\" value=\"7500000\"/>\n          <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n      </bean>\n      ```\n\n   3. 构造参数名\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg name=\"years\" value=\"7500000\"/>\n          <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n      </bean>\n      ```\n\n总结：在配置文件加载的时候，容器中管理的对象就已经初始化了\n\n# Spring 配置\n\n## 别名\n\n```xml\n<!--设置别名：在获取Bean的时候可以使用别名获取-->\n<alias name=\"userT\" alias=\"userNew\"/>\n```\n\n## Bean 的配置\n\n```xml\n<!--bean就是java对象,由Spring创建和管理-->\n\n<!--\n   id : bean的标识符,要唯一,如果没有配置id,name就是默认标识符\n   如果配置id,又配置了name,那么name是别名\n   name可以设置多个别名,可以用逗号,分号,空格隔开\n   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;\n\n   class : bean的全限定名=包名+类名\n-->\n<bean id=\"hello\" name=\"hello2 h2,h3;h4\" class=\"com.kuang.pojo.Hello\">\n   <property name=\"name\" value=\"Spring\"/>\n</bean>\n```\n\n## import\n\n这个 import,一般用于团队开发使用，他可以将多个配置文件，导入合并为一个；\n\n假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的 bean 中，我们可以利用 import 将所有人的 beans.xml 合并为一个总的！\n\napplicationContext.xml\n\n```xml\n<import resource=\"{path}/beans.xml\"/>\n```\n\n# 依赖注入 (DI)\n\n## 构造器注入\n\n前面已经说过了\n\n## Set 方式注入 【重点】\n\n- 依赖注入：Set 注入\n  - 依赖：bean 对象的创建依赖于容器\n  - 注入：bean 对象中的所有属性，由容器来注入\n\n1. 模拟环境搭建\n\n2. 两个实体类\n\n   ```java\n   @Data\n   public class Student {\n\n       private String name;\n       private Address address;\n       private String[] books;\n       private List<String> hobbys;\n       private Map<String,String> card;\n       private Set<String> games;\n       private String wife;\n       private Properties info;\n   }\n   ```\n\n   ```java\n   @Data\n   public class Address {\n       private String address;\n   }\n   ```\n\n3. 配置 applicationContext.xml\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n       <bean id=\"address\" class=\"com.kuang.pojo.Address\">\n           <property name=\"address\" value=\"NJUPT9\"/>\n       </bean>\n       <bean id=\"student\" class=\"com.kuang.pojo.Student\">\n           <!--第一种，普通值注入，value-->\n           <property name=\"name\" value=\"狂神\"/>\n\n           <!--第二种,Bean注入-->\n           <property name=\"address\" ref=\"address\"/>\n\n           <!--数组-->\n           <property name=\"books\">\n               <array>\n                   <value>红楼</value>\n                   <value>三国</value>\n               </array>\n           </property>\n\n           <!--List-->\n           <property name=\"hobbys\">\n               <list>\n                   <value>music</value>\n                   <value>swimming</value>\n                   <value>coding</value>\n               </list>\n           </property>\n\n           <!--Map-->\n           <property name=\"card\">\n               <map>\n                   <entry key=\"身份证\" value=\"12312121212\"/>\n                   <entry key=\"银行卡\" value=\"678112121111000\"/>\n               </map>\n           </property>\n\n           <!--Set-->\n           <property name=\"games\">\n               <set>\n                   <value>CF</value>\n                   <value>LOL</value>\n                   <value>GTA</value>\n               </set>\n           </property>\n\n           <!--null-->\n           <property name=\"wife\">\n               <null/>\n           </property>\n\n           <!--Properties-->\n           <property name=\"info\">\n               <props>\n                   <prop key=\"学号\">20190526</prop>\n                   <prop key=\"username\">root</prop>\n                   <prop key=\"password\">root</prop>\n               </props>\n           </property>\n       </bean>\n   </beans>\n   ```\n\n4. 测试\n\n   ```java\n   public class MyTest {\n       public static void main(String[] args) {\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n           Student student = (Student) context.getBean(\"student\");\n           System.out.println(student);\n       }\n   }\n   ```\n\n## 拓展方式注入\n\n我们可以使用 p 命名空间和 c 命名空间进行注入\n\n官方解释：\n\n![](img/article/JAVA-Spring5-20210503/20200628180116257.png)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--p命名空间注入，可以直接注入属性的值：property-->\n    <bean id=\"user\" class=\"com.kuang.pojo.User\" p:name=\"狂神\" p:age=\"18\"/>\n\n    <!--c命名空间注入，通过构造器注入：construt-args-->\n    <bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\"/>\n\n</beans>\n```\n\n**注意点：p 命名和 c 命名空间不能直接使用，需要导入 xml 约束！**\n\n```xml\nxmlns:p=\"http://www.springframework.org/schema/p\"\nxmlns:c=\"http://www.springframework.org/schema/c\"\n```\n\n## Bean 的作用域\n\n![](img/article/JAVA-Spring5-20210503/20200628180128654.png)\n\n1. 单例模式（Spring 默认机制）\n\n```xml\n<bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\" scope=\"singleton\"/>\n```\n\n2. 原型模式：每次从容器中 get 的时候，都会产生一个新对象\n\n```xml\n<bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\" scope=\"prototype\"/>\n```\n\n3. 其余的 request、session、application 这些只能在 web 开发中使用到\n\n# Bean 的自动装配\n\n- 自动装配是 Spring 满足 bean 依赖的一种方式\n- Spring 会在上下文中自动寻找，并自动给 bean 装配属性\n\n在 Spring 中有三种装配的方式\n\n1. 在 xml 中显示的配置\n2. 在 java 中显示的配置\n3. 隐式的自动装配 bean 【重要】\n\n## 测试\n\n环境搭建：一个人有两个宠物\n\n## byName 自定装配\n\n```xml\n<bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/>\n<bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/>\n\n\t<!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n    -->\n<bean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byName\">\n    <property name=\"name\" value=\"狂神\"/>\n</bean>\n```\n\n## byTpye 自动装配\n\n```xml\n\t<!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n        byType : 会自动在容器上下文中查找，和自己对象属性类型相同的bean\n    -->\n<bean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byType\">\n    <property name=\"name\" value=\"狂神\"/>\n</bean>\n```\n\n**小结：**\n\n- byName 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致\n- byType 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属性的类型一致\n\n## 使用注解实现自动装配\n\njdk1.5 支持的注解，Spring2.5 就支持注解了！\n\n要使用注解须知：\n\n1. 导入约束\n2. 配置注解的支持 <context:annotation-config/>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n### @Autowired\n\n直接在属性上使用即可，也可以在 set 方法上使用\n\n使用 Autowired 我们可以不用编写 set 方法了，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byName\n\n科普：\n\n```\n@Nullable\t字段标记了这个注解，说明这个字段可以为null;\n```\n\n```java\npublic @interface Autowired {\n    boolean required() default true;\n}\n```\n\n测试代码：\n\n```java\npublic class People {\n    //如果显示定义了Autowired的required属性为false，说明这个对象可以为Null,否则不允许为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n}\n```\n\n如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【**@Autowired**】完成的时候，我们可以使用**@Qualifier(value = “xxx”)**去配合@Autowire 的使用，指定一个唯一的 bean 对象注入！\n\n```java\npublic class People {\n\n    @Autowired\n    @Qualifier(value = \"cat2\")\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n}\n```\n\n### @Resource\n\n```java\npublic class People {\n\n    @Resource( name = \"cat3\")\n    private Cat cat;\n    @Resource\n    private Dog dog;\n    private String name;\n}\n```\n\n小结：\n\n@Resource 和@Autowired 的区别：\n\n都是用来自动转配的，都可以放在属性字段上\n@Autowired 是通过 byType 的方式实现，而且必须要求这个对象存在！【常用】\n@Resource 默认通过 byName 的方式实现，如果找不到名字，则通过 byType 实现！如果两个都找不到的情况下，就报错！【常用】\n执行顺序不同: @Autowired 通过 byType 的方式实现。@Resource 默认通过 byName 的方式实现。\n\n原理实现：通过反射机制来实现访问，所以不需要写 set 方法\n\n可以配合@qualifier 来指定一个唯一的 bean 对象注入\n\n@Nullable 如果某个字段标记了这个注解后，说明这个字段可以为 null\n\n@Autowired 里面有个参数 required 可以为 false，说明这个字段可以为 null，否则不允许为空\n\n@Resource 注解 也可以实现和@autowired 一样的功能\n\n注意：@Resource 注解是 Java 自带的注解\n\n使用注解开发\n\n注解说明\n\n@Component：组件，放在类上，说明这个类被 Spring 管理了就是 Bean\n\n衍生的注解\n\ndao 层 @Repository\n\nservice 层 @Service\n\ncontroller 层 @Controller\n\n@Value 可以用来注入属性 可以在 setXXX()方法上直接注入值\n\n@Scope 作用域注解 里面可以有 prototype 和 singleton\n\nxml 与注解：\n\nxml 更加万能，适用于任何场合！\n\n注解 不是自己的类使用不了 维护相对复杂\n\nxml 与注解最佳实践\n\n1.xml 用来管理 bean\n\n2.注解只负责完成属性的注入\n\n3.在使用的过程，想让注解生效，必须开启对注解的支持\n\n```xml\n<context:component-scan base-package=\"com.shan.pojo\"/>\n<context:annotation-config/>\n```\n\n# Java 类实现 Spring 配置\n\n```java\n@Configuration\n@ComponentScan(\"pojo\")\n//这个类也会被注入到Spring容器中，其本质就是一个@Component\n//@Configuration代表这是一个配置类，用于替代beans.xml\npublic class LewisConfig {\n    @Bean\n    //注册一个bean，相当于xml里的一个bean标签\n    //方法的名字相当于bean标签的id值\n\t//方法的返回类型相当于bean标签的class属性值\n    public User getUser(){\n        return new User();\n    }\n}\n```\n\n使用下面的代码来获得 Spring 容器，同样用 getBean 方法来获得容器中的对象\n\n```java\nApplicationContext context = new AnnotationConfigApplicationContext(LewisConfig.class);\n```\n\n# 面向切面编程 AOP（重点）\n\n- 横切关注点：横跨多个模块的方法或功能，待加入到业务层实现功能扩充，如日志功能\n- 切面（aspect）：横切关注点被模块化的特殊对象，是一个类，即下文中的 afterLog 类\n- 通知（advice）：切面必须完成的工作，即类中的一个方法\n- 目标（target）：被通知对象，下文中的 UserServiceImpl 类的对象\n- 代理（proxy）：向目标对象加入通知创建的新对象\n- 切入点（pointcut）：切面通知执行的“地点”的定义\n- 连接点（jointpoint）：与切入点匹配的执行点\n\n## Spring API 接口实现\n\n在保持 service 层代码不变的基础上，通过 AOP 新增一些其他的功能。\n\n```java\n//UserService接口\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n}\n//UserServiceImpl实现类\npublic class UserServiceImpl implements UserService{\n    public void add() {\n        System.out.println(\"增加了一个用户\");\n    }\n\n    public void delete() {\n        System.out.println(\"删除了一个用户\");\n    }\n\n    public void update() {\n        System.out.println(\"修改了一个用户\");\n    }\n\n    public void select() {\n        System.out.println(\"查询了一个用户\");\n    }\n}\n//afterLog\npublic class afterLog  implements AfterReturningAdvice {\n    public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable {\n        System.out.println(\"执行了\"+method.getName()+\"方法，返回的结果为\"+returnValue);\n    }\n}\n//beforeLog\npublic class beforeLog implements MethodBeforeAdvice {\n    public void before(Method method, Object[] objects, Object target) throws Throwable {\n        System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\");\n    }\n}\n```\n\nxml 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n\">\n<!--    注册bean-->\n    <bean id=\"userService\" class=\"com.lewis.service.UserServiceImpl\"/>\n    <bean id=\"afterLog\" class=\"com.lewis.log.afterLog\"/>\n    <bean id=\"beforeLog\" class=\"com.lewis.log.beforeLog\"/>\n\n    <aop:config>\n        <aop:pointcut id=\"pointcup\" expression=\"execution(* com.lewis.service.UserServiceImpl.*(..))\"/>\n        <aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcup\"/>\n        <aop:advisor advice-ref=\"beforeLog\" pointcut-ref=\"pointcup\"/>\n    </aop:config>\n</beans>\n```\n\n## 自定义实现 AOP（主要是切面定义）推荐使用\n\n自定义接口类\n\n```java\npublic class DiyPointCut {\n    public void before(){\n        System.out.println(\"===========方法执行前================\");\n    }\n    public void after(){\n        System.out.println(\"===========方法执行后================\");\n    }\n}\n```\n\n配置文件\n\n```xml\n<bean id=\"diy\" class=\"diy.DiyPointCut\"/>\n<aop:config>\n    <!--切面：一个类-->\n    <aop:aspect ref=\"diy\">\n    <!--切入点-->\n        <aop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/>\n    <!--通知-->\n        <aop:after method=\"after\" pointcut-ref=\"point\"/>\n        <aop:before method=\"before\" pointcut-ref=\"point\"/>\n    </aop:aspect>\n</aop:config>\n```\n\n## 使用注解实现 AOP\n\n在类上使用`@Aspect`，表明这个类是一个切面；在方法上使用`@Before,@After`等实现通知\n\n```xml\n<bean id=\"annotationPointCut\" class=\"service.UserServiceImpl\"/>\n<!--开启注解支持-->\n<aop:aspectj-autoproxy/>\n```\n\n```java\n@Aspect\npublic class AnnotationPointCut {\n    @Before(\"execution(* service.UserServiceImpl.*(..))\")\n    public void before(){\n        System.out.println(\"===========方法执行前===========\");\n    }\n    @After(\"execution(* service.UserServiceImpl.*(..))\")\n    public void after(){\n        System.out.println(\"===========方法执行后===========\");\n    }\n     @Around(\"execution(* service.UserServiceImpl.*(..))\")\n    public void around(){\n        System.out.println(\"===========环绕后===========\");\n    }\n}\n```\n","source":"_posts/JAVA-Spring5-20210503.md","raw":"---\ntitle: JAVA-Spring5\ndate: 2021-05-03 23:00:02\ntags:\n  - java基础\n  - spring\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/Spring.png\n---\n\n# Spring5\n\n<!--more-->\n\n## 简介\n\n春天 —>给软件行业带来了春天\n2002 年，Rod Jahnson 首次推出了 Spring 框架雏形 interface21 框架。\n2004 年 3 月 24 日，Spring 框架以 interface21 框架为基础，经过重新设计，发布了 1.0 正式版。\nRod Johnson 的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring 理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n官方下载地址 ： https://repo.spring.io/libs-release-local/org/springframework/spring/\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n\n```\n\n## 优点\n\n- Spring 是一个开源免费的框架 (容器)！\n- Spring 是一个轻量级的框架 , 非侵入式的\n- **控制反转 IoC , 面向切面 Aop**\n- 对事务的支持 , 对框架整合的支持\n\n**Spring 是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。**\n\n## 组成\n\nSpring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .\n\n![](img/article/JAVA-Spring5-20210503/20200628180016435.png)\n\n![](img/article/JAVA-Spring5-20210503/20200628180025728.png)\n\n- 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n- Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n- Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP 的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。\n- Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n- Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n- Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n- Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n## 拓展\n\n![](img/article/JAVA-Spring5-20210503/20200628180035980.png)\n\n- Spring Boot\n  - 一个快速开发的脚手架\n  - 基于 SpringBoot 可以快速的开发单个微服务\n- Spring Cloud\n  - Spring Cloud 是基于 SpringBoot 实现的\n\n# IOC 理论推导\n\n1. UserDao 接口\n\n```java\npublic interface UserDao {\n   void getUser();\n}\n```\n\n2. UserDaoImpl 实现类\n\n```java\npublic class UserDaoImpl implements UserDao {\n   @Override\n   public void getUser() {\n       System.out.println(\"获取用户数据\");\n  }\n}\n```\n\n3. UserService 业务接口\n\n```java\npublic interface UserService {\n   void getUser();\n}\n```\n\n4. UserServiceImpl 业务实现类\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao = new UserDaoImpl();\n\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n5. 测试一下\n\n```java\n@Test\npublic void test(){\n   UserService service = new UserServiceImpl();\n   service.getUser();\n}\n```\n\n把 Userdao 的实现类增加一个 .\n\n```java\npublic class UserDaoMySqlImpl implements UserDao {\n   @Override\n   public void getUser() {\n       System.out.println(\"MySql获取用户数据\");\n  }\n}\n```\n\n紧接着我们要去使用 MySql 的话 , 我们就需要去 service 实现类里面修改对应的实现\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao = new UserDaoMySqlImpl();\n\n   @Override\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n**代码量十分大，修改一次的成本十分昂贵！**\n\n我们使用一个 Set 接口实现，已经发生了革命性的变化！\n\n```java\npublic class UserServiceImpl implements UserService {\n   private UserDao userDao;\n\t// 利用set实现\n   public void setUserDao(UserDao userDao) {\n       this.userDao = userDao;\n  }\n\n   @Override\n   public void getUser() {\n       userDao.getUser();\n  }\n}\n```\n\n- 之前，程序是主动创建对象，控制权在程序员手上！\n- 使用了 set 注入后，程序不再具有主动性，而是变成了被动的接受对象！\n\n这种思想，从本质上解决了问题，我们程序员不用再去管对象的创建了。系统的耦合性大大降低，可以专注在业务的实现上！这是 IOC 的原型！\n\n## IOC 本质\n\n控制反转 IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n\n![](img/article/JAVA-Spring5-20210503/20200628180055895.png)\n\n采用 XML 方式配置 Bean 的时候，Bean 的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean 的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n\n**控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入（Dependency Injection,DI）。**\n\n# HelloSpring\n\nbeans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n    <!--使用spring创建对象，在spring中这些都称为bean-->\n    <bean id=\"hello\" class=\"com.shan.pojo.Hello\">\n        <property name=\"str\" value=\"Spring\"/>\n    </bean>\n\n</beans>\n```\n\npojo.hello.java\n\n```java\npackage com.shan.pojo;\n\npublic class Hello {\n    private String str;\n\n    public String getStr() {\n        return str;\n    }\n\n    public void setStr(String str) {\n        this.str = str;\n    }\n\n    @Override\n    public String toString() {\n        return \"Hello{\" +\n                \"str='\" + str + '\\'' +\n                '}';\n    }\n}\n```\n\ntest\n\n```java\n@Test\n    public void test01(){\n        //获取spring的上下文对象\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        // 我们的对象现在都在spring管理了,我们要使用，直接去里面取出来就可以！\n        Hello hello =(Hello) context.getBean(\"hello\");\n        System.out.println(hello);\n    }\n```\n\n# IOC 创建对象的方式\n\n1. 使用无参构造创建对象，默认！\n\n2. 假设我们要使用有参构造创建对象。\n\n   1. 下标赋值\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg index=\"0\" value=\"7500000\"/>\n          <constructor-arg index=\"1\" value=\"42\"/>\n      </bean>\n      ```\n\n   2. 构造参数类型\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg type=\"int\" value=\"7500000\"/>\n          <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n      </bean>\n      ```\n\n   3. 构造参数名\n\n      ```xml\n      <bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n          <constructor-arg name=\"years\" value=\"7500000\"/>\n          <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n      </bean>\n      ```\n\n总结：在配置文件加载的时候，容器中管理的对象就已经初始化了\n\n# Spring 配置\n\n## 别名\n\n```xml\n<!--设置别名：在获取Bean的时候可以使用别名获取-->\n<alias name=\"userT\" alias=\"userNew\"/>\n```\n\n## Bean 的配置\n\n```xml\n<!--bean就是java对象,由Spring创建和管理-->\n\n<!--\n   id : bean的标识符,要唯一,如果没有配置id,name就是默认标识符\n   如果配置id,又配置了name,那么name是别名\n   name可以设置多个别名,可以用逗号,分号,空格隔开\n   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;\n\n   class : bean的全限定名=包名+类名\n-->\n<bean id=\"hello\" name=\"hello2 h2,h3;h4\" class=\"com.kuang.pojo.Hello\">\n   <property name=\"name\" value=\"Spring\"/>\n</bean>\n```\n\n## import\n\n这个 import,一般用于团队开发使用，他可以将多个配置文件，导入合并为一个；\n\n假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的 bean 中，我们可以利用 import 将所有人的 beans.xml 合并为一个总的！\n\napplicationContext.xml\n\n```xml\n<import resource=\"{path}/beans.xml\"/>\n```\n\n# 依赖注入 (DI)\n\n## 构造器注入\n\n前面已经说过了\n\n## Set 方式注入 【重点】\n\n- 依赖注入：Set 注入\n  - 依赖：bean 对象的创建依赖于容器\n  - 注入：bean 对象中的所有属性，由容器来注入\n\n1. 模拟环境搭建\n\n2. 两个实体类\n\n   ```java\n   @Data\n   public class Student {\n\n       private String name;\n       private Address address;\n       private String[] books;\n       private List<String> hobbys;\n       private Map<String,String> card;\n       private Set<String> games;\n       private String wife;\n       private Properties info;\n   }\n   ```\n\n   ```java\n   @Data\n   public class Address {\n       private String address;\n   }\n   ```\n\n3. 配置 applicationContext.xml\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n       <bean id=\"address\" class=\"com.kuang.pojo.Address\">\n           <property name=\"address\" value=\"NJUPT9\"/>\n       </bean>\n       <bean id=\"student\" class=\"com.kuang.pojo.Student\">\n           <!--第一种，普通值注入，value-->\n           <property name=\"name\" value=\"狂神\"/>\n\n           <!--第二种,Bean注入-->\n           <property name=\"address\" ref=\"address\"/>\n\n           <!--数组-->\n           <property name=\"books\">\n               <array>\n                   <value>红楼</value>\n                   <value>三国</value>\n               </array>\n           </property>\n\n           <!--List-->\n           <property name=\"hobbys\">\n               <list>\n                   <value>music</value>\n                   <value>swimming</value>\n                   <value>coding</value>\n               </list>\n           </property>\n\n           <!--Map-->\n           <property name=\"card\">\n               <map>\n                   <entry key=\"身份证\" value=\"12312121212\"/>\n                   <entry key=\"银行卡\" value=\"678112121111000\"/>\n               </map>\n           </property>\n\n           <!--Set-->\n           <property name=\"games\">\n               <set>\n                   <value>CF</value>\n                   <value>LOL</value>\n                   <value>GTA</value>\n               </set>\n           </property>\n\n           <!--null-->\n           <property name=\"wife\">\n               <null/>\n           </property>\n\n           <!--Properties-->\n           <property name=\"info\">\n               <props>\n                   <prop key=\"学号\">20190526</prop>\n                   <prop key=\"username\">root</prop>\n                   <prop key=\"password\">root</prop>\n               </props>\n           </property>\n       </bean>\n   </beans>\n   ```\n\n4. 测试\n\n   ```java\n   public class MyTest {\n       public static void main(String[] args) {\n           ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n           Student student = (Student) context.getBean(\"student\");\n           System.out.println(student);\n       }\n   }\n   ```\n\n## 拓展方式注入\n\n我们可以使用 p 命名空间和 c 命名空间进行注入\n\n官方解释：\n\n![](img/article/JAVA-Spring5-20210503/20200628180116257.png)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--p命名空间注入，可以直接注入属性的值：property-->\n    <bean id=\"user\" class=\"com.kuang.pojo.User\" p:name=\"狂神\" p:age=\"18\"/>\n\n    <!--c命名空间注入，通过构造器注入：construt-args-->\n    <bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\"/>\n\n</beans>\n```\n\n**注意点：p 命名和 c 命名空间不能直接使用，需要导入 xml 约束！**\n\n```xml\nxmlns:p=\"http://www.springframework.org/schema/p\"\nxmlns:c=\"http://www.springframework.org/schema/c\"\n```\n\n## Bean 的作用域\n\n![](img/article/JAVA-Spring5-20210503/20200628180128654.png)\n\n1. 单例模式（Spring 默认机制）\n\n```xml\n<bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\" scope=\"singleton\"/>\n```\n\n2. 原型模式：每次从容器中 get 的时候，都会产生一个新对象\n\n```xml\n<bean id=\"user2\" class=\"com.kuang.pojo.User\" c:name=\"狂神2\" c:age=\"11\" scope=\"prototype\"/>\n```\n\n3. 其余的 request、session、application 这些只能在 web 开发中使用到\n\n# Bean 的自动装配\n\n- 自动装配是 Spring 满足 bean 依赖的一种方式\n- Spring 会在上下文中自动寻找，并自动给 bean 装配属性\n\n在 Spring 中有三种装配的方式\n\n1. 在 xml 中显示的配置\n2. 在 java 中显示的配置\n3. 隐式的自动装配 bean 【重要】\n\n## 测试\n\n环境搭建：一个人有两个宠物\n\n## byName 自定装配\n\n```xml\n<bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/>\n<bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/>\n\n\t<!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n    -->\n<bean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byName\">\n    <property name=\"name\" value=\"狂神\"/>\n</bean>\n```\n\n## byTpye 自动装配\n\n```xml\n\t<!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n        byType : 会自动在容器上下文中查找，和自己对象属性类型相同的bean\n    -->\n<bean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byType\">\n    <property name=\"name\" value=\"狂神\"/>\n</bean>\n```\n\n**小结：**\n\n- byName 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致\n- byType 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属性的类型一致\n\n## 使用注解实现自动装配\n\njdk1.5 支持的注解，Spring2.5 就支持注解了！\n\n要使用注解须知：\n\n1. 导入约束\n2. 配置注解的支持 <context:annotation-config/>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n### @Autowired\n\n直接在属性上使用即可，也可以在 set 方法上使用\n\n使用 Autowired 我们可以不用编写 set 方法了，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byName\n\n科普：\n\n```\n@Nullable\t字段标记了这个注解，说明这个字段可以为null;\n```\n\n```java\npublic @interface Autowired {\n    boolean required() default true;\n}\n```\n\n测试代码：\n\n```java\npublic class People {\n    //如果显示定义了Autowired的required属性为false，说明这个对象可以为Null,否则不允许为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n}\n```\n\n如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【**@Autowired**】完成的时候，我们可以使用**@Qualifier(value = “xxx”)**去配合@Autowire 的使用，指定一个唯一的 bean 对象注入！\n\n```java\npublic class People {\n\n    @Autowired\n    @Qualifier(value = \"cat2\")\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n}\n```\n\n### @Resource\n\n```java\npublic class People {\n\n    @Resource( name = \"cat3\")\n    private Cat cat;\n    @Resource\n    private Dog dog;\n    private String name;\n}\n```\n\n小结：\n\n@Resource 和@Autowired 的区别：\n\n都是用来自动转配的，都可以放在属性字段上\n@Autowired 是通过 byType 的方式实现，而且必须要求这个对象存在！【常用】\n@Resource 默认通过 byName 的方式实现，如果找不到名字，则通过 byType 实现！如果两个都找不到的情况下，就报错！【常用】\n执行顺序不同: @Autowired 通过 byType 的方式实现。@Resource 默认通过 byName 的方式实现。\n\n原理实现：通过反射机制来实现访问，所以不需要写 set 方法\n\n可以配合@qualifier 来指定一个唯一的 bean 对象注入\n\n@Nullable 如果某个字段标记了这个注解后，说明这个字段可以为 null\n\n@Autowired 里面有个参数 required 可以为 false，说明这个字段可以为 null，否则不允许为空\n\n@Resource 注解 也可以实现和@autowired 一样的功能\n\n注意：@Resource 注解是 Java 自带的注解\n\n使用注解开发\n\n注解说明\n\n@Component：组件，放在类上，说明这个类被 Spring 管理了就是 Bean\n\n衍生的注解\n\ndao 层 @Repository\n\nservice 层 @Service\n\ncontroller 层 @Controller\n\n@Value 可以用来注入属性 可以在 setXXX()方法上直接注入值\n\n@Scope 作用域注解 里面可以有 prototype 和 singleton\n\nxml 与注解：\n\nxml 更加万能，适用于任何场合！\n\n注解 不是自己的类使用不了 维护相对复杂\n\nxml 与注解最佳实践\n\n1.xml 用来管理 bean\n\n2.注解只负责完成属性的注入\n\n3.在使用的过程，想让注解生效，必须开启对注解的支持\n\n```xml\n<context:component-scan base-package=\"com.shan.pojo\"/>\n<context:annotation-config/>\n```\n\n# Java 类实现 Spring 配置\n\n```java\n@Configuration\n@ComponentScan(\"pojo\")\n//这个类也会被注入到Spring容器中，其本质就是一个@Component\n//@Configuration代表这是一个配置类，用于替代beans.xml\npublic class LewisConfig {\n    @Bean\n    //注册一个bean，相当于xml里的一个bean标签\n    //方法的名字相当于bean标签的id值\n\t//方法的返回类型相当于bean标签的class属性值\n    public User getUser(){\n        return new User();\n    }\n}\n```\n\n使用下面的代码来获得 Spring 容器，同样用 getBean 方法来获得容器中的对象\n\n```java\nApplicationContext context = new AnnotationConfigApplicationContext(LewisConfig.class);\n```\n\n# 面向切面编程 AOP（重点）\n\n- 横切关注点：横跨多个模块的方法或功能，待加入到业务层实现功能扩充，如日志功能\n- 切面（aspect）：横切关注点被模块化的特殊对象，是一个类，即下文中的 afterLog 类\n- 通知（advice）：切面必须完成的工作，即类中的一个方法\n- 目标（target）：被通知对象，下文中的 UserServiceImpl 类的对象\n- 代理（proxy）：向目标对象加入通知创建的新对象\n- 切入点（pointcut）：切面通知执行的“地点”的定义\n- 连接点（jointpoint）：与切入点匹配的执行点\n\n## Spring API 接口实现\n\n在保持 service 层代码不变的基础上，通过 AOP 新增一些其他的功能。\n\n```java\n//UserService接口\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n}\n//UserServiceImpl实现类\npublic class UserServiceImpl implements UserService{\n    public void add() {\n        System.out.println(\"增加了一个用户\");\n    }\n\n    public void delete() {\n        System.out.println(\"删除了一个用户\");\n    }\n\n    public void update() {\n        System.out.println(\"修改了一个用户\");\n    }\n\n    public void select() {\n        System.out.println(\"查询了一个用户\");\n    }\n}\n//afterLog\npublic class afterLog  implements AfterReturningAdvice {\n    public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable {\n        System.out.println(\"执行了\"+method.getName()+\"方法，返回的结果为\"+returnValue);\n    }\n}\n//beforeLog\npublic class beforeLog implements MethodBeforeAdvice {\n    public void before(Method method, Object[] objects, Object target) throws Throwable {\n        System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\");\n    }\n}\n```\n\nxml 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n\">\n<!--    注册bean-->\n    <bean id=\"userService\" class=\"com.lewis.service.UserServiceImpl\"/>\n    <bean id=\"afterLog\" class=\"com.lewis.log.afterLog\"/>\n    <bean id=\"beforeLog\" class=\"com.lewis.log.beforeLog\"/>\n\n    <aop:config>\n        <aop:pointcut id=\"pointcup\" expression=\"execution(* com.lewis.service.UserServiceImpl.*(..))\"/>\n        <aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcup\"/>\n        <aop:advisor advice-ref=\"beforeLog\" pointcut-ref=\"pointcup\"/>\n    </aop:config>\n</beans>\n```\n\n## 自定义实现 AOP（主要是切面定义）推荐使用\n\n自定义接口类\n\n```java\npublic class DiyPointCut {\n    public void before(){\n        System.out.println(\"===========方法执行前================\");\n    }\n    public void after(){\n        System.out.println(\"===========方法执行后================\");\n    }\n}\n```\n\n配置文件\n\n```xml\n<bean id=\"diy\" class=\"diy.DiyPointCut\"/>\n<aop:config>\n    <!--切面：一个类-->\n    <aop:aspect ref=\"diy\">\n    <!--切入点-->\n        <aop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/>\n    <!--通知-->\n        <aop:after method=\"after\" pointcut-ref=\"point\"/>\n        <aop:before method=\"before\" pointcut-ref=\"point\"/>\n    </aop:aspect>\n</aop:config>\n```\n\n## 使用注解实现 AOP\n\n在类上使用`@Aspect`，表明这个类是一个切面；在方法上使用`@Before,@After`等实现通知\n\n```xml\n<bean id=\"annotationPointCut\" class=\"service.UserServiceImpl\"/>\n<!--开启注解支持-->\n<aop:aspectj-autoproxy/>\n```\n\n```java\n@Aspect\npublic class AnnotationPointCut {\n    @Before(\"execution(* service.UserServiceImpl.*(..))\")\n    public void before(){\n        System.out.println(\"===========方法执行前===========\");\n    }\n    @After(\"execution(* service.UserServiceImpl.*(..))\")\n    public void after(){\n        System.out.println(\"===========方法执行后===========\");\n    }\n     @Around(\"execution(* service.UserServiceImpl.*(..))\")\n    public void around(){\n        System.out.println(\"===========环绕后===========\");\n    }\n}\n```\n","slug":"JAVA-Spring5-20210503","published":1,"updated":"2022-06-14T04:09:00.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x18000ry4w15o537x8m","content":"<h1 id=\"Spring5\"><a href=\"#Spring5\" class=\"headerlink\" title=\"Spring5\"></a>Spring5</h1><span id=\"more\"></span>\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>春天 —&gt;给软件行业带来了春天<br>2002 年，Rod Jahnson 首次推出了 Spring 框架雏形 interface21 框架。<br>2004 年 3 月 24 日，Spring 框架以 interface21 框架为基础，经过重新设计，发布了 1.0 正式版。<br>Rod Johnson 的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。<br>Spring 理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术<br>官方下载地址 ： <a href=\"https://repo.spring.io/libs-release-local/org/springframework/spring/\">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p>\n<pre><code class=\"xml\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>Spring 是一个开源免费的框架 (容器)！</li>\n<li>Spring 是一个轻量级的框架 , 非侵入式的</li>\n<li><strong>控制反转 IoC , 面向切面 Aop</strong></li>\n<li>对事务的支持 , 对框架整合的支持</li>\n</ul>\n<p><strong>Spring 是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180016435.png\"></p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180025728.png\"></p>\n<ul>\n<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>\n<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>\n<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP 的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>\n<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>\n<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>\n<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>\n<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p><img src=\"img/article/JAVA-Spring5-20210503/20200628180035980.png\"></p>\n<ul>\n<li>Spring Boot<ul>\n<li>一个快速开发的脚手架</li>\n<li>基于 SpringBoot 可以快速的开发单个微服务</li>\n</ul>\n</li>\n<li>Spring Cloud<ul>\n<li>Spring Cloud 是基于 SpringBoot 实现的</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"IOC-理论推导\"><a href=\"#IOC-理论推导\" class=\"headerlink\" title=\"IOC 理论推导\"></a>IOC 理论推导</h1><ol>\n<li>UserDao 接口</li>\n</ol>\n<pre><code class=\"java\">public interface UserDao &#123;\n   void getUser();\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>UserDaoImpl 实现类</li>\n</ol>\n<pre><code class=\"java\">public class UserDaoImpl implements UserDao &#123;\n   @Override\n   public void getUser() &#123;\n       System.out.println(&quot;获取用户数据&quot;);\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>UserService 业务接口</li>\n</ol>\n<pre><code class=\"java\">public interface UserService &#123;\n   void getUser();\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>UserServiceImpl 业务实现类</li>\n</ol>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao = new UserDaoImpl();\n\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>测试一下</li>\n</ol>\n<pre><code class=\"java\">@Test\npublic void test()&#123;\n   UserService service = new UserServiceImpl();\n   service.getUser();\n&#125;\n</code></pre>\n<p>把 Userdao 的实现类增加一个 .</p>\n<pre><code class=\"java\">public class UserDaoMySqlImpl implements UserDao &#123;\n   @Override\n   public void getUser() &#123;\n       System.out.println(&quot;MySql获取用户数据&quot;);\n  &#125;\n&#125;\n</code></pre>\n<p>紧接着我们要去使用 MySql 的话 , 我们就需要去 service 实现类里面修改对应的实现</p>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao = new UserDaoMySqlImpl();\n\n   @Override\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<p><strong>代码量十分大，修改一次的成本十分昂贵！</strong></p>\n<p>我们使用一个 Set 接口实现，已经发生了革命性的变化！</p>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao;\n    // 利用set实现\n   public void setUserDao(UserDao userDao) &#123;\n       this.userDao = userDao;\n  &#125;\n\n   @Override\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li>之前，程序是主动创建对象，控制权在程序员手上！</li>\n<li>使用了 set 注入后，程序不再具有主动性，而是变成了被动的接受对象！</li>\n</ul>\n<p>这种思想，从本质上解决了问题，我们程序员不用再去管对象的创建了。系统的耦合性大大降低，可以专注在业务的实现上！这是 IOC 的原型！</p>\n<h2 id=\"IOC-本质\"><a href=\"#IOC-本质\" class=\"headerlink\" title=\"IOC 本质\"></a>IOC 本质</h2><p>控制反转 IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180055895.png\"></p>\n<p>采用 XML 方式配置 Bean 的时候，Bean 的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean 的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>\n<p><strong>控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>\n<h1 id=\"HelloSpring\"><a href=\"#HelloSpring\" class=\"headerlink\" title=\"HelloSpring\"></a>HelloSpring</h1><p>beans.xml</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;\n\n    &lt;!--使用spring创建对象，在spring中这些都称为bean--&gt;\n    &lt;bean id=&quot;hello&quot; class=&quot;com.shan.pojo.Hello&quot;&gt;\n        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>pojo.hello.java</p>\n<pre><code class=\"java\">package com.shan.pojo;\n\npublic class Hello &#123;\n    private String str;\n\n    public String getStr() &#123;\n        return str;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str = str;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hello&#123;&quot; +\n                &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>test</p>\n<pre><code class=\"java\">@Test\n    public void test01()&#123;\n        //获取spring的上下文对象\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        // 我们的对象现在都在spring管理了,我们要使用，直接去里面取出来就可以！\n        Hello hello =(Hello) context.getBean(&quot;hello&quot;);\n        System.out.println(hello);\n    &#125;\n</code></pre>\n<h1 id=\"IOC-创建对象的方式\"><a href=\"#IOC-创建对象的方式\" class=\"headerlink\" title=\"IOC 创建对象的方式\"></a>IOC 创建对象的方式</h1><ol>\n<li><p>使用无参构造创建对象，默认！</p>\n</li>\n<li><p>假设我们要使用有参构造创建对象。</p>\n<ol>\n<li><p>下标赋值</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li><p>构造参数类型</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li><p>构造参数名</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了</p>\n<h1 id=\"Spring-配置\"><a href=\"#Spring-配置\" class=\"headerlink\" title=\"Spring 配置\"></a>Spring 配置</h1><h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><pre><code class=\"xml\">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;\n&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;\n</code></pre>\n<h2 id=\"Bean-的配置\"><a href=\"#Bean-的配置\" class=\"headerlink\" title=\"Bean 的配置\"></a>Bean 的配置</h2><pre><code class=\"xml\">&lt;!--bean就是java对象,由Spring创建和管理--&gt;\n\n&lt;!--\n   id : bean的标识符,要唯一,如果没有配置id,name就是默认标识符\n   如果配置id,又配置了name,那么name是别名\n   name可以设置多个别名,可以用逗号,分号,空格隔开\n   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;\n\n   class : bean的全限定名=包名+类名\n--&gt;\n&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;\n   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>这个 import,一般用于团队开发使用，他可以将多个配置文件，导入合并为一个；</p>\n<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的 bean 中，我们可以利用 import 将所有人的 beans.xml 合并为一个总的！</p>\n<p>applicationContext.xml</p>\n<pre><code class=\"xml\">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;\n</code></pre>\n<h1 id=\"依赖注入-DI\"><a href=\"#依赖注入-DI\" class=\"headerlink\" title=\"依赖注入 (DI)\"></a>依赖注入 (DI)</h1><h2 id=\"构造器注入\"><a href=\"#构造器注入\" class=\"headerlink\" title=\"构造器注入\"></a>构造器注入</h2><p>前面已经说过了</p>\n<h2 id=\"Set-方式注入-【重点】\"><a href=\"#Set-方式注入-【重点】\" class=\"headerlink\" title=\"Set 方式注入 【重点】\"></a>Set 方式注入 【重点】</h2><ul>\n<li>依赖注入：Set 注入<ul>\n<li>依赖：bean 对象的创建依赖于容器</li>\n<li>注入：bean 对象中的所有属性，由容器来注入</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>模拟环境搭建</p>\n</li>\n<li><p>两个实体类</p>\n<pre><code class=\"java\">@Data\npublic class Student &#123;\n\n    private String name;\n    private Address address;\n    private String[] books;\n    private List&lt;String&gt; hobbys;\n    private Map&lt;String,String&gt; card;\n    private Set&lt;String&gt; games;\n    private String wife;\n    private Properties info;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Data\npublic class Address &#123;\n    private String address;\n&#125;\n</code></pre>\n</li>\n<li><p>配置 applicationContext.xml</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;\n        &lt;property name=&quot;address&quot; value=&quot;NJUPT9&quot;/&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n        &lt;!--第一种，普通值注入，value--&gt;\n        &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n\n        &lt;!--第二种,Bean注入--&gt;\n        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;\n\n        &lt;!--数组--&gt;\n        &lt;property name=&quot;books&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;红楼&lt;/value&gt;\n                &lt;value&gt;三国&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n\n        &lt;!--List--&gt;\n        &lt;property name=&quot;hobbys&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;music&lt;/value&gt;\n                &lt;value&gt;swimming&lt;/value&gt;\n                &lt;value&gt;coding&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n\n        &lt;!--Map--&gt;\n        &lt;property name=&quot;card&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;身份证&quot; value=&quot;12312121212&quot;/&gt;\n                &lt;entry key=&quot;银行卡&quot; value=&quot;678112121111000&quot;/&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n\n        &lt;!--Set--&gt;\n        &lt;property name=&quot;games&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;CF&lt;/value&gt;\n                &lt;value&gt;LOL&lt;/value&gt;\n                &lt;value&gt;GTA&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n\n        &lt;!--null--&gt;\n        &lt;property name=&quot;wife&quot;&gt;\n            &lt;null/&gt;\n        &lt;/property&gt;\n\n        &lt;!--Properties--&gt;\n        &lt;property name=&quot;info&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;学号&quot;&gt;20190526&lt;/prop&gt;\n                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;\n                &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">public class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        Student student = (Student) context.getBean(&quot;student&quot;);\n        System.out.println(student);\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"拓展方式注入\"><a href=\"#拓展方式注入\" class=\"headerlink\" title=\"拓展方式注入\"></a>拓展方式注入</h2><p>我们可以使用 p 命名空间和 c 命名空间进行注入</p>\n<p>官方解释：</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180116257.png\"></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;\n\n    &lt;!--c命名空间注入，通过构造器注入：construt-args--&gt;\n    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot;/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p><strong>注意点：p 命名和 c 命名空间不能直接使用，需要导入 xml 约束！</strong></p>\n<pre><code class=\"xml\">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\nxmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n</code></pre>\n<h2 id=\"Bean-的作用域\"><a href=\"#Bean-的作用域\" class=\"headerlink\" title=\"Bean 的作用域\"></a>Bean 的作用域</h2><p><img src=\"img/article/JAVA-Spring5-20210503/20200628180128654.png\"></p>\n<ol>\n<li>单例模式（Spring 默认机制）</li>\n</ol>\n<pre><code class=\"xml\">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot; scope=&quot;singleton&quot;/&gt;\n</code></pre>\n<ol start=\"2\">\n<li>原型模式：每次从容器中 get 的时候，都会产生一个新对象</li>\n</ol>\n<pre><code class=\"xml\">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot; scope=&quot;prototype&quot;/&gt;\n</code></pre>\n<ol start=\"3\">\n<li>其余的 request、session、application 这些只能在 web 开发中使用到</li>\n</ol>\n<h1 id=\"Bean-的自动装配\"><a href=\"#Bean-的自动装配\" class=\"headerlink\" title=\"Bean 的自动装配\"></a>Bean 的自动装配</h1><ul>\n<li>自动装配是 Spring 满足 bean 依赖的一种方式</li>\n<li>Spring 会在上下文中自动寻找，并自动给 bean 装配属性</li>\n</ul>\n<p>在 Spring 中有三种装配的方式</p>\n<ol>\n<li>在 xml 中显示的配置</li>\n<li>在 java 中显示的配置</li>\n<li>隐式的自动装配 bean 【重要】</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>环境搭建：一个人有两个宠物</p>\n<h2 id=\"byName-自定装配\"><a href=\"#byName-自定装配\" class=\"headerlink\" title=\"byName 自定装配\"></a>byName 自定装配</h2><pre><code class=\"xml\">&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;\n\n    &lt;!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n    --&gt;\n&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<h2 id=\"byTpye-自动装配\"><a href=\"#byTpye-自动装配\" class=\"headerlink\" title=\"byTpye 自动装配\"></a>byTpye 自动装配</h2><pre><code class=\"xml\">    &lt;!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n        byType : 会自动在容器上下文中查找，和自己对象属性类型相同的bean\n    --&gt;\n&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p><strong>小结：</strong></p>\n<ul>\n<li>byName 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致</li>\n<li>byType 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属性的类型一致</li>\n</ul>\n<h2 id=\"使用注解实现自动装配\"><a href=\"#使用注解实现自动装配\" class=\"headerlink\" title=\"使用注解实现自动装配\"></a>使用注解实现自动装配</h2><p>jdk1.5 支持的注解，Spring2.5 就支持注解了！</p>\n<p>要使用注解须知：</p>\n<ol>\n<li>导入约束</li>\n<li>配置注解的支持 <a href=\"context:annotation-config/\">context:annotation-config/</a></li>\n</ol>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"Autowired\"><a href=\"#Autowired\" class=\"headerlink\" title=\"@Autowired\"></a>@Autowired</h3><p>直接在属性上使用即可，也可以在 set 方法上使用</p>\n<p>使用 Autowired 我们可以不用编写 set 方法了，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byName</p>\n<p>科普：</p>\n<pre><code>@Nullable    字段标记了这个注解，说明这个字段可以为null;\n</code></pre>\n<pre><code class=\"java\">public @interface Autowired &#123;\n    boolean required() default true;\n&#125;\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class People &#123;\n    //如果显示定义了Autowired的required属性为false，说明这个对象可以为Null,否则不允许为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<p>如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【**@Autowired<strong>】完成的时候，我们可以使用</strong>@Qualifier(value = “xxx”)**去配合@Autowire 的使用，指定一个唯一的 bean 对象注入！</p>\n<pre><code class=\"java\">public class People &#123;\n\n    @Autowired\n    @Qualifier(value = &quot;cat2&quot;)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"@Resource\"></a>@Resource</h3><pre><code class=\"java\">public class People &#123;\n\n    @Resource( name = &quot;cat3&quot;)\n    private Cat cat;\n    @Resource\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<p>小结：</p>\n<p>@Resource 和@Autowired 的区别：</p>\n<p>都是用来自动转配的，都可以放在属性字段上<br>@Autowired 是通过 byType 的方式实现，而且必须要求这个对象存在！【常用】<br>@Resource 默认通过 byName 的方式实现，如果找不到名字，则通过 byType 实现！如果两个都找不到的情况下，就报错！【常用】<br>执行顺序不同: @Autowired 通过 byType 的方式实现。@Resource 默认通过 byName 的方式实现。</p>\n<p>原理实现：通过反射机制来实现访问，所以不需要写 set 方法</p>\n<p>可以配合@qualifier 来指定一个唯一的 bean 对象注入</p>\n<p>@Nullable 如果某个字段标记了这个注解后，说明这个字段可以为 null</p>\n<p>@Autowired 里面有个参数 required 可以为 false，说明这个字段可以为 null，否则不允许为空</p>\n<p>@Resource 注解 也可以实现和@autowired 一样的功能</p>\n<p>注意：@Resource 注解是 Java 自带的注解</p>\n<p>使用注解开发</p>\n<p>注解说明</p>\n<p>@Component：组件，放在类上，说明这个类被 Spring 管理了就是 Bean</p>\n<p>衍生的注解</p>\n<p>dao 层 @Repository</p>\n<p>service 层 @Service</p>\n<p>controller 层 @Controller</p>\n<p>@Value 可以用来注入属性 可以在 setXXX()方法上直接注入值</p>\n<p>@Scope 作用域注解 里面可以有 prototype 和 singleton</p>\n<p>xml 与注解：</p>\n<p>xml 更加万能，适用于任何场合！</p>\n<p>注解 不是自己的类使用不了 维护相对复杂</p>\n<p>xml 与注解最佳实践</p>\n<p>1.xml 用来管理 bean</p>\n<p>2.注解只负责完成属性的注入</p>\n<p>3.在使用的过程，想让注解生效，必须开启对注解的支持</p>\n<pre><code class=\"xml\">&lt;context:component-scan base-package=&quot;com.shan.pojo&quot;/&gt;\n&lt;context:annotation-config/&gt;\n</code></pre>\n<h1 id=\"Java-类实现-Spring-配置\"><a href=\"#Java-类实现-Spring-配置\" class=\"headerlink\" title=\"Java 类实现 Spring 配置\"></a>Java 类实现 Spring 配置</h1><pre><code class=\"java\">@Configuration\n@ComponentScan(&quot;pojo&quot;)\n//这个类也会被注入到Spring容器中，其本质就是一个@Component\n//@Configuration代表这是一个配置类，用于替代beans.xml\npublic class LewisConfig &#123;\n    @Bean\n    //注册一个bean，相当于xml里的一个bean标签\n    //方法的名字相当于bean标签的id值\n    //方法的返回类型相当于bean标签的class属性值\n    public User getUser()&#123;\n        return new User();\n    &#125;\n&#125;\n</code></pre>\n<p>使用下面的代码来获得 Spring 容器，同样用 getBean 方法来获得容器中的对象</p>\n<pre><code class=\"java\">ApplicationContext context = new AnnotationConfigApplicationContext(LewisConfig.class);\n</code></pre>\n<h1 id=\"面向切面编程-AOP（重点）\"><a href=\"#面向切面编程-AOP（重点）\" class=\"headerlink\" title=\"面向切面编程 AOP（重点）\"></a>面向切面编程 AOP（重点）</h1><ul>\n<li>横切关注点：横跨多个模块的方法或功能，待加入到业务层实现功能扩充，如日志功能</li>\n<li>切面（aspect）：横切关注点被模块化的特殊对象，是一个类，即下文中的 afterLog 类</li>\n<li>通知（advice）：切面必须完成的工作，即类中的一个方法</li>\n<li>目标（target）：被通知对象，下文中的 UserServiceImpl 类的对象</li>\n<li>代理（proxy）：向目标对象加入通知创建的新对象</li>\n<li>切入点（pointcut）：切面通知执行的“地点”的定义</li>\n<li>连接点（jointpoint）：与切入点匹配的执行点</li>\n</ul>\n<h2 id=\"Spring-API-接口实现\"><a href=\"#Spring-API-接口实现\" class=\"headerlink\" title=\"Spring API 接口实现\"></a>Spring API 接口实现</h2><p>在保持 service 层代码不变的基础上，通过 AOP 新增一些其他的功能。</p>\n<pre><code class=\"java\">//UserService接口\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n&#125;\n//UserServiceImpl实现类\npublic class UserServiceImpl implements UserService&#123;\n    public void add() &#123;\n        System.out.println(&quot;增加了一个用户&quot;);\n    &#125;\n\n    public void delete() &#123;\n        System.out.println(&quot;删除了一个用户&quot;);\n    &#125;\n\n    public void update() &#123;\n        System.out.println(&quot;修改了一个用户&quot;);\n    &#125;\n\n    public void select() &#123;\n        System.out.println(&quot;查询了一个用户&quot;);\n    &#125;\n&#125;\n//afterLog\npublic class afterLog  implements AfterReturningAdvice &#123;\n    public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable &#123;\n        System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回的结果为&quot;+returnValue);\n    &#125;\n&#125;\n//beforeLog\npublic class beforeLog implements MethodBeforeAdvice &#123;\n    public void before(Method method, Object[] objects, Object target) throws Throwable &#123;\n        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>xml 配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n&quot;&gt;\n&lt;!--    注册bean--&gt;\n    &lt;bean id=&quot;userService&quot; class=&quot;com.lewis.service.UserServiceImpl&quot;/&gt;\n    &lt;bean id=&quot;afterLog&quot; class=&quot;com.lewis.log.afterLog&quot;/&gt;\n    &lt;bean id=&quot;beforeLog&quot; class=&quot;com.lewis.log.beforeLog&quot;/&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id=&quot;pointcup&quot; expression=&quot;execution(* com.lewis.service.UserServiceImpl.*(..))&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcup&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcup&quot;/&gt;\n    &lt;/aop:config&gt;\n&lt;/beans&gt;\n</code></pre>\n<h2 id=\"自定义实现-AOP（主要是切面定义）推荐使用\"><a href=\"#自定义实现-AOP（主要是切面定义）推荐使用\" class=\"headerlink\" title=\"自定义实现 AOP（主要是切面定义）推荐使用\"></a>自定义实现 AOP（主要是切面定义）推荐使用</h2><p>自定义接口类</p>\n<pre><code class=\"java\">public class DiyPointCut &#123;\n    public void before()&#123;\n        System.out.println(&quot;===========方法执行前================&quot;);\n    &#125;\n    public void after()&#123;\n        System.out.println(&quot;===========方法执行后================&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>配置文件</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointCut&quot;/&gt;\n&lt;aop:config&gt;\n    &lt;!--切面：一个类--&gt;\n    &lt;aop:aspect ref=&quot;diy&quot;&gt;\n    &lt;!--切入点--&gt;\n        &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;\n    &lt;!--通知--&gt;\n        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;\n        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<h2 id=\"使用注解实现-AOP\"><a href=\"#使用注解实现-AOP\" class=\"headerlink\" title=\"使用注解实现 AOP\"></a>使用注解实现 AOP</h2><p>在类上使用<code>@Aspect</code>，表明这个类是一个切面；在方法上使用<code>@Before,@After</code>等实现通知</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;annotationPointCut&quot; class=&quot;service.UserServiceImpl&quot;/&gt;\n&lt;!--开启注解支持--&gt;\n&lt;aop:aspectj-autoproxy/&gt;\n</code></pre>\n<pre><code class=\"java\">@Aspect\npublic class AnnotationPointCut &#123;\n    @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void before()&#123;\n        System.out.println(&quot;===========方法执行前===========&quot;);\n    &#125;\n    @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void after()&#123;\n        System.out.println(&quot;===========方法执行后===========&quot;);\n    &#125;\n     @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void around()&#123;\n        System.out.println(&quot;===========环绕后===========&quot;);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"Spring5\"><a href=\"#Spring5\" class=\"headerlink\" title=\"Spring5\"></a>Spring5</h1>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>春天 —&gt;给软件行业带来了春天<br>2002 年，Rod Jahnson 首次推出了 Spring 框架雏形 interface21 框架。<br>2004 年 3 月 24 日，Spring 框架以 interface21 框架为基础，经过重新设计，发布了 1.0 正式版。<br>Rod Johnson 的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。<br>Spring 理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术<br>官方下载地址 ： <a href=\"https://repo.spring.io/libs-release-local/org/springframework/spring/\">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p>\n<pre><code class=\"xml\">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>Spring 是一个开源免费的框架 (容器)！</li>\n<li>Spring 是一个轻量级的框架 , 非侵入式的</li>\n<li><strong>控制反转 IoC , 面向切面 Aop</strong></li>\n<li>对事务的支持 , 对框架整合的支持</li>\n</ul>\n<p><strong>Spring 是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong></p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180016435.png\"></p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180025728.png\"></p>\n<ul>\n<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>\n<li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>\n<li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP 的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>\n<li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>\n<li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>\n<li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>\n<li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p><img src=\"img/article/JAVA-Spring5-20210503/20200628180035980.png\"></p>\n<ul>\n<li>Spring Boot<ul>\n<li>一个快速开发的脚手架</li>\n<li>基于 SpringBoot 可以快速的开发单个微服务</li>\n</ul>\n</li>\n<li>Spring Cloud<ul>\n<li>Spring Cloud 是基于 SpringBoot 实现的</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"IOC-理论推导\"><a href=\"#IOC-理论推导\" class=\"headerlink\" title=\"IOC 理论推导\"></a>IOC 理论推导</h1><ol>\n<li>UserDao 接口</li>\n</ol>\n<pre><code class=\"java\">public interface UserDao &#123;\n   void getUser();\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>UserDaoImpl 实现类</li>\n</ol>\n<pre><code class=\"java\">public class UserDaoImpl implements UserDao &#123;\n   @Override\n   public void getUser() &#123;\n       System.out.println(&quot;获取用户数据&quot;);\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>UserService 业务接口</li>\n</ol>\n<pre><code class=\"java\">public interface UserService &#123;\n   void getUser();\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>UserServiceImpl 业务实现类</li>\n</ol>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao = new UserDaoImpl();\n\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>测试一下</li>\n</ol>\n<pre><code class=\"java\">@Test\npublic void test()&#123;\n   UserService service = new UserServiceImpl();\n   service.getUser();\n&#125;\n</code></pre>\n<p>把 Userdao 的实现类增加一个 .</p>\n<pre><code class=\"java\">public class UserDaoMySqlImpl implements UserDao &#123;\n   @Override\n   public void getUser() &#123;\n       System.out.println(&quot;MySql获取用户数据&quot;);\n  &#125;\n&#125;\n</code></pre>\n<p>紧接着我们要去使用 MySql 的话 , 我们就需要去 service 实现类里面修改对应的实现</p>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao = new UserDaoMySqlImpl();\n\n   @Override\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<p><strong>代码量十分大，修改一次的成本十分昂贵！</strong></p>\n<p>我们使用一个 Set 接口实现，已经发生了革命性的变化！</p>\n<pre><code class=\"java\">public class UserServiceImpl implements UserService &#123;\n   private UserDao userDao;\n    // 利用set实现\n   public void setUserDao(UserDao userDao) &#123;\n       this.userDao = userDao;\n  &#125;\n\n   @Override\n   public void getUser() &#123;\n       userDao.getUser();\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li>之前，程序是主动创建对象，控制权在程序员手上！</li>\n<li>使用了 set 注入后，程序不再具有主动性，而是变成了被动的接受对象！</li>\n</ul>\n<p>这种思想，从本质上解决了问题，我们程序员不用再去管对象的创建了。系统的耦合性大大降低，可以专注在业务的实现上！这是 IOC 的原型！</p>\n<h2 id=\"IOC-本质\"><a href=\"#IOC-本质\" class=\"headerlink\" title=\"IOC 本质\"></a>IOC 本质</h2><p>控制反转 IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180055895.png\"></p>\n<p>采用 XML 方式配置 Bean 的时候，Bean 的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean 的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>\n<p><strong>控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>\n<h1 id=\"HelloSpring\"><a href=\"#HelloSpring\" class=\"headerlink\" title=\"HelloSpring\"></a>HelloSpring</h1><p>beans.xml</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;\n\n    &lt;!--使用spring创建对象，在spring中这些都称为bean--&gt;\n    &lt;bean id=&quot;hello&quot; class=&quot;com.shan.pojo.Hello&quot;&gt;\n        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>pojo.hello.java</p>\n<pre><code class=\"java\">package com.shan.pojo;\n\npublic class Hello &#123;\n    private String str;\n\n    public String getStr() &#123;\n        return str;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str = str;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hello&#123;&quot; +\n                &quot;str=&#39;&quot; + str + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>test</p>\n<pre><code class=\"java\">@Test\n    public void test01()&#123;\n        //获取spring的上下文对象\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        // 我们的对象现在都在spring管理了,我们要使用，直接去里面取出来就可以！\n        Hello hello =(Hello) context.getBean(&quot;hello&quot;);\n        System.out.println(hello);\n    &#125;\n</code></pre>\n<h1 id=\"IOC-创建对象的方式\"><a href=\"#IOC-创建对象的方式\" class=\"headerlink\" title=\"IOC 创建对象的方式\"></a>IOC 创建对象的方式</h1><ol>\n<li><p>使用无参构造创建对象，默认！</p>\n</li>\n<li><p>假设我们要使用有参构造创建对象。</p>\n<ol>\n<li><p>下标赋值</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li><p>构造参数类型</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n<li><p>构造参数名</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;\n    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;\n    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了</p>\n<h1 id=\"Spring-配置\"><a href=\"#Spring-配置\" class=\"headerlink\" title=\"Spring 配置\"></a>Spring 配置</h1><h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><pre><code class=\"xml\">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;\n&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;\n</code></pre>\n<h2 id=\"Bean-的配置\"><a href=\"#Bean-的配置\" class=\"headerlink\" title=\"Bean 的配置\"></a>Bean 的配置</h2><pre><code class=\"xml\">&lt;!--bean就是java对象,由Spring创建和管理--&gt;\n\n&lt;!--\n   id : bean的标识符,要唯一,如果没有配置id,name就是默认标识符\n   如果配置id,又配置了name,那么name是别名\n   name可以设置多个别名,可以用逗号,分号,空格隔开\n   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;\n\n   class : bean的全限定名=包名+类名\n--&gt;\n&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;\n   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>这个 import,一般用于团队开发使用，他可以将多个配置文件，导入合并为一个；</p>\n<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的 bean 中，我们可以利用 import 将所有人的 beans.xml 合并为一个总的！</p>\n<p>applicationContext.xml</p>\n<pre><code class=\"xml\">&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;\n</code></pre>\n<h1 id=\"依赖注入-DI\"><a href=\"#依赖注入-DI\" class=\"headerlink\" title=\"依赖注入 (DI)\"></a>依赖注入 (DI)</h1><h2 id=\"构造器注入\"><a href=\"#构造器注入\" class=\"headerlink\" title=\"构造器注入\"></a>构造器注入</h2><p>前面已经说过了</p>\n<h2 id=\"Set-方式注入-【重点】\"><a href=\"#Set-方式注入-【重点】\" class=\"headerlink\" title=\"Set 方式注入 【重点】\"></a>Set 方式注入 【重点】</h2><ul>\n<li>依赖注入：Set 注入<ul>\n<li>依赖：bean 对象的创建依赖于容器</li>\n<li>注入：bean 对象中的所有属性，由容器来注入</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>模拟环境搭建</p>\n</li>\n<li><p>两个实体类</p>\n<pre><code class=\"java\">@Data\npublic class Student &#123;\n\n    private String name;\n    private Address address;\n    private String[] books;\n    private List&lt;String&gt; hobbys;\n    private Map&lt;String,String&gt; card;\n    private Set&lt;String&gt; games;\n    private String wife;\n    private Properties info;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Data\npublic class Address &#123;\n    private String address;\n&#125;\n</code></pre>\n</li>\n<li><p>配置 applicationContext.xml</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;\n        &lt;property name=&quot;address&quot; value=&quot;NJUPT9&quot;/&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;\n        &lt;!--第一种，普通值注入，value--&gt;\n        &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n\n        &lt;!--第二种,Bean注入--&gt;\n        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;\n\n        &lt;!--数组--&gt;\n        &lt;property name=&quot;books&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;红楼&lt;/value&gt;\n                &lt;value&gt;三国&lt;/value&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n\n        &lt;!--List--&gt;\n        &lt;property name=&quot;hobbys&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;music&lt;/value&gt;\n                &lt;value&gt;swimming&lt;/value&gt;\n                &lt;value&gt;coding&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n\n        &lt;!--Map--&gt;\n        &lt;property name=&quot;card&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;身份证&quot; value=&quot;12312121212&quot;/&gt;\n                &lt;entry key=&quot;银行卡&quot; value=&quot;678112121111000&quot;/&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n\n        &lt;!--Set--&gt;\n        &lt;property name=&quot;games&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;CF&lt;/value&gt;\n                &lt;value&gt;LOL&lt;/value&gt;\n                &lt;value&gt;GTA&lt;/value&gt;\n            &lt;/set&gt;\n        &lt;/property&gt;\n\n        &lt;!--null--&gt;\n        &lt;property name=&quot;wife&quot;&gt;\n            &lt;null/&gt;\n        &lt;/property&gt;\n\n        &lt;!--Properties--&gt;\n        &lt;property name=&quot;info&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key=&quot;学号&quot;&gt;20190526&lt;/prop&gt;\n                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;\n                &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt;\n            &lt;/props&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">public class MyTest &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        Student student = (Student) context.getBean(&quot;student&quot;);\n        System.out.println(student);\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"拓展方式注入\"><a href=\"#拓展方式注入\" class=\"headerlink\" title=\"拓展方式注入\"></a>拓展方式注入</h2><p>我们可以使用 p 命名空间和 c 命名空间进行注入</p>\n<p>官方解释：</p>\n<p><img src=\"img/article/JAVA-Spring5-20210503/20200628180116257.png\"></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt;\n\n    &lt;!--c命名空间注入，通过构造器注入：construt-args--&gt;\n    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot;/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p><strong>注意点：p 命名和 c 命名空间不能直接使用，需要导入 xml 约束！</strong></p>\n<pre><code class=\"xml\">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\nxmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n</code></pre>\n<h2 id=\"Bean-的作用域\"><a href=\"#Bean-的作用域\" class=\"headerlink\" title=\"Bean 的作用域\"></a>Bean 的作用域</h2><p><img src=\"img/article/JAVA-Spring5-20210503/20200628180128654.png\"></p>\n<ol>\n<li>单例模式（Spring 默认机制）</li>\n</ol>\n<pre><code class=\"xml\">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot; scope=&quot;singleton&quot;/&gt;\n</code></pre>\n<ol start=\"2\">\n<li>原型模式：每次从容器中 get 的时候，都会产生一个新对象</li>\n</ol>\n<pre><code class=\"xml\">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神2&quot; c:age=&quot;11&quot; scope=&quot;prototype&quot;/&gt;\n</code></pre>\n<ol start=\"3\">\n<li>其余的 request、session、application 这些只能在 web 开发中使用到</li>\n</ol>\n<h1 id=\"Bean-的自动装配\"><a href=\"#Bean-的自动装配\" class=\"headerlink\" title=\"Bean 的自动装配\"></a>Bean 的自动装配</h1><ul>\n<li>自动装配是 Spring 满足 bean 依赖的一种方式</li>\n<li>Spring 会在上下文中自动寻找，并自动给 bean 装配属性</li>\n</ul>\n<p>在 Spring 中有三种装配的方式</p>\n<ol>\n<li>在 xml 中显示的配置</li>\n<li>在 java 中显示的配置</li>\n<li>隐式的自动装配 bean 【重要】</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>环境搭建：一个人有两个宠物</p>\n<h2 id=\"byName-自定装配\"><a href=\"#byName-自定装配\" class=\"headerlink\" title=\"byName 自定装配\"></a>byName 自定装配</h2><pre><code class=\"xml\">&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;\n\n    &lt;!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n    --&gt;\n&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<h2 id=\"byTpye-自动装配\"><a href=\"#byTpye-自动装配\" class=\"headerlink\" title=\"byTpye 自动装配\"></a>byTpye 自动装配</h2><pre><code class=\"xml\">    &lt;!--\n        byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean_id\n        byType : 会自动在容器上下文中查找，和自己对象属性类型相同的bean\n    --&gt;\n&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;\n    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p><strong>小结：</strong></p>\n<ul>\n<li>byName 的时候，需要保证所有 bean 的 id 唯一，并且这个 bean 需要和自动注入的属性的 set 方法的值一致</li>\n<li>byType 的时候，需要保证所有 bean 的 class 唯一，并且这个 bean 需要和自动注入的属性的类型一致</li>\n</ul>\n<h2 id=\"使用注解实现自动装配\"><a href=\"#使用注解实现自动装配\" class=\"headerlink\" title=\"使用注解实现自动装配\"></a>使用注解实现自动装配</h2><p>jdk1.5 支持的注解，Spring2.5 就支持注解了！</p>\n<p>要使用注解须知：</p>\n<ol>\n<li>导入约束</li>\n<li>配置注解的支持 <a href=\"context:annotation-config/\">context:annotation-config/</a></li>\n</ol>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"Autowired\"><a href=\"#Autowired\" class=\"headerlink\" title=\"@Autowired\"></a>@Autowired</h3><p>直接在属性上使用即可，也可以在 set 方法上使用</p>\n<p>使用 Autowired 我们可以不用编写 set 方法了，前提是你这个自动装配的属性在 IOC（Spring）容器中存在，且符合名字 byName</p>\n<p>科普：</p>\n<pre><code>@Nullable    字段标记了这个注解，说明这个字段可以为null;\n</code></pre>\n<pre><code class=\"java\">public @interface Autowired &#123;\n    boolean required() default true;\n&#125;\n</code></pre>\n<p>测试代码：</p>\n<pre><code class=\"java\">public class People &#123;\n    //如果显示定义了Autowired的required属性为false，说明这个对象可以为Null,否则不允许为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<p>如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【**@Autowired<strong>】完成的时候，我们可以使用</strong>@Qualifier(value = “xxx”)**去配合@Autowire 的使用，指定一个唯一的 bean 对象注入！</p>\n<pre><code class=\"java\">public class People &#123;\n\n    @Autowired\n    @Qualifier(value = &quot;cat2&quot;)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"@Resource\"></a>@Resource</h3><pre><code class=\"java\">public class People &#123;\n\n    @Resource( name = &quot;cat3&quot;)\n    private Cat cat;\n    @Resource\n    private Dog dog;\n    private String name;\n&#125;\n</code></pre>\n<p>小结：</p>\n<p>@Resource 和@Autowired 的区别：</p>\n<p>都是用来自动转配的，都可以放在属性字段上<br>@Autowired 是通过 byType 的方式实现，而且必须要求这个对象存在！【常用】<br>@Resource 默认通过 byName 的方式实现，如果找不到名字，则通过 byType 实现！如果两个都找不到的情况下，就报错！【常用】<br>执行顺序不同: @Autowired 通过 byType 的方式实现。@Resource 默认通过 byName 的方式实现。</p>\n<p>原理实现：通过反射机制来实现访问，所以不需要写 set 方法</p>\n<p>可以配合@qualifier 来指定一个唯一的 bean 对象注入</p>\n<p>@Nullable 如果某个字段标记了这个注解后，说明这个字段可以为 null</p>\n<p>@Autowired 里面有个参数 required 可以为 false，说明这个字段可以为 null，否则不允许为空</p>\n<p>@Resource 注解 也可以实现和@autowired 一样的功能</p>\n<p>注意：@Resource 注解是 Java 自带的注解</p>\n<p>使用注解开发</p>\n<p>注解说明</p>\n<p>@Component：组件，放在类上，说明这个类被 Spring 管理了就是 Bean</p>\n<p>衍生的注解</p>\n<p>dao 层 @Repository</p>\n<p>service 层 @Service</p>\n<p>controller 层 @Controller</p>\n<p>@Value 可以用来注入属性 可以在 setXXX()方法上直接注入值</p>\n<p>@Scope 作用域注解 里面可以有 prototype 和 singleton</p>\n<p>xml 与注解：</p>\n<p>xml 更加万能，适用于任何场合！</p>\n<p>注解 不是自己的类使用不了 维护相对复杂</p>\n<p>xml 与注解最佳实践</p>\n<p>1.xml 用来管理 bean</p>\n<p>2.注解只负责完成属性的注入</p>\n<p>3.在使用的过程，想让注解生效，必须开启对注解的支持</p>\n<pre><code class=\"xml\">&lt;context:component-scan base-package=&quot;com.shan.pojo&quot;/&gt;\n&lt;context:annotation-config/&gt;\n</code></pre>\n<h1 id=\"Java-类实现-Spring-配置\"><a href=\"#Java-类实现-Spring-配置\" class=\"headerlink\" title=\"Java 类实现 Spring 配置\"></a>Java 类实现 Spring 配置</h1><pre><code class=\"java\">@Configuration\n@ComponentScan(&quot;pojo&quot;)\n//这个类也会被注入到Spring容器中，其本质就是一个@Component\n//@Configuration代表这是一个配置类，用于替代beans.xml\npublic class LewisConfig &#123;\n    @Bean\n    //注册一个bean，相当于xml里的一个bean标签\n    //方法的名字相当于bean标签的id值\n    //方法的返回类型相当于bean标签的class属性值\n    public User getUser()&#123;\n        return new User();\n    &#125;\n&#125;\n</code></pre>\n<p>使用下面的代码来获得 Spring 容器，同样用 getBean 方法来获得容器中的对象</p>\n<pre><code class=\"java\">ApplicationContext context = new AnnotationConfigApplicationContext(LewisConfig.class);\n</code></pre>\n<h1 id=\"面向切面编程-AOP（重点）\"><a href=\"#面向切面编程-AOP（重点）\" class=\"headerlink\" title=\"面向切面编程 AOP（重点）\"></a>面向切面编程 AOP（重点）</h1><ul>\n<li>横切关注点：横跨多个模块的方法或功能，待加入到业务层实现功能扩充，如日志功能</li>\n<li>切面（aspect）：横切关注点被模块化的特殊对象，是一个类，即下文中的 afterLog 类</li>\n<li>通知（advice）：切面必须完成的工作，即类中的一个方法</li>\n<li>目标（target）：被通知对象，下文中的 UserServiceImpl 类的对象</li>\n<li>代理（proxy）：向目标对象加入通知创建的新对象</li>\n<li>切入点（pointcut）：切面通知执行的“地点”的定义</li>\n<li>连接点（jointpoint）：与切入点匹配的执行点</li>\n</ul>\n<h2 id=\"Spring-API-接口实现\"><a href=\"#Spring-API-接口实现\" class=\"headerlink\" title=\"Spring API 接口实现\"></a>Spring API 接口实现</h2><p>在保持 service 层代码不变的基础上，通过 AOP 新增一些其他的功能。</p>\n<pre><code class=\"java\">//UserService接口\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n&#125;\n//UserServiceImpl实现类\npublic class UserServiceImpl implements UserService&#123;\n    public void add() &#123;\n        System.out.println(&quot;增加了一个用户&quot;);\n    &#125;\n\n    public void delete() &#123;\n        System.out.println(&quot;删除了一个用户&quot;);\n    &#125;\n\n    public void update() &#123;\n        System.out.println(&quot;修改了一个用户&quot;);\n    &#125;\n\n    public void select() &#123;\n        System.out.println(&quot;查询了一个用户&quot;);\n    &#125;\n&#125;\n//afterLog\npublic class afterLog  implements AfterReturningAdvice &#123;\n    public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable &#123;\n        System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回的结果为&quot;+returnValue);\n    &#125;\n&#125;\n//beforeLog\npublic class beforeLog implements MethodBeforeAdvice &#123;\n    public void before(Method method, Object[] objects, Object target) throws Throwable &#123;\n        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>xml 配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n&quot;&gt;\n&lt;!--    注册bean--&gt;\n    &lt;bean id=&quot;userService&quot; class=&quot;com.lewis.service.UserServiceImpl&quot;/&gt;\n    &lt;bean id=&quot;afterLog&quot; class=&quot;com.lewis.log.afterLog&quot;/&gt;\n    &lt;bean id=&quot;beforeLog&quot; class=&quot;com.lewis.log.beforeLog&quot;/&gt;\n\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id=&quot;pointcup&quot; expression=&quot;execution(* com.lewis.service.UserServiceImpl.*(..))&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcup&quot;/&gt;\n        &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcup&quot;/&gt;\n    &lt;/aop:config&gt;\n&lt;/beans&gt;\n</code></pre>\n<h2 id=\"自定义实现-AOP（主要是切面定义）推荐使用\"><a href=\"#自定义实现-AOP（主要是切面定义）推荐使用\" class=\"headerlink\" title=\"自定义实现 AOP（主要是切面定义）推荐使用\"></a>自定义实现 AOP（主要是切面定义）推荐使用</h2><p>自定义接口类</p>\n<pre><code class=\"java\">public class DiyPointCut &#123;\n    public void before()&#123;\n        System.out.println(&quot;===========方法执行前================&quot;);\n    &#125;\n    public void after()&#123;\n        System.out.println(&quot;===========方法执行后================&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>配置文件</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointCut&quot;/&gt;\n&lt;aop:config&gt;\n    &lt;!--切面：一个类--&gt;\n    &lt;aop:aspect ref=&quot;diy&quot;&gt;\n    &lt;!--切入点--&gt;\n        &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;\n    &lt;!--通知--&gt;\n        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;\n        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n</code></pre>\n<h2 id=\"使用注解实现-AOP\"><a href=\"#使用注解实现-AOP\" class=\"headerlink\" title=\"使用注解实现 AOP\"></a>使用注解实现 AOP</h2><p>在类上使用<code>@Aspect</code>，表明这个类是一个切面；在方法上使用<code>@Before,@After</code>等实现通知</p>\n<pre><code class=\"xml\">&lt;bean id=&quot;annotationPointCut&quot; class=&quot;service.UserServiceImpl&quot;/&gt;\n&lt;!--开启注解支持--&gt;\n&lt;aop:aspectj-autoproxy/&gt;\n</code></pre>\n<pre><code class=\"java\">@Aspect\npublic class AnnotationPointCut &#123;\n    @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void before()&#123;\n        System.out.println(&quot;===========方法执行前===========&quot;);\n    &#125;\n    @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void after()&#123;\n        System.out.println(&quot;===========方法执行后===========&quot;);\n    &#125;\n     @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;)\n    public void around()&#123;\n        System.out.println(&quot;===========环绕后===========&quot;);\n    &#125;\n&#125;\n</code></pre>"},{"title":"JAVA_javaweb","date":"2021-04-30T15:48:28.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# 基本概念\n\n<!--more-->\n\n## 前言\n\nweb 开发：\n\n- web，网页的意思，www.baidu.com\n- 静态 web\n  - html,css\n  - 提供给所有人看的数据始终不会发生变化！\n  - 技术栈：servlet / JSP，ASP，PHP\n\n在 java 中，动态 web 资源开发的技术统称为 JavaWeb\n\n## web 应用程序\n\nweb 应用程序：可以提供浏览器访问的程序；\n\n- a.html、b.html ..... 多个 web 资源，这些 web 资源可以被外界访问，对外界提供服务；\n- 你们能访问到的任何一个页面或者资源，都存在于这个世界上的某一角落的计算机上。\n- URL\n- 这个统一的 web 资源会被放在同一个文件夹下，web 应用程序-->Tomcat: 服务器\n- 一个 web 应用由多部分组成（静态 web，动态 web）\n  - html，css，js\n  - jsp，servlet\n  - java 程序\n  - jar 包\n  - 配置文件（properties）\n\nweb 应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n## 静态 web\n\n- _.html_ 这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n![](img/article/JAVA-javaweb-20210430/20210428131402.png)\n\n- 静态 web 存在的缺点\n  - web 页面无法动态更新，所有用户看到都是同一个页面\n    - 轮播图，点击特效；伪动态\n    - javaScript （实际开发中，它用的最多）\n    - VBScript\n  - 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n## 动态 web\n\n页面会动态展示：“web 的页面展示的效果因人而异”；\n\n![](img/article/JAVA-javaweb-20210430/20210428131746.png)\n\n缺点：\n\n- 加入服务器的动态 web 资源出现了错误，我们需要重新编写我们的后台程序，重新发布；\n  - 停机维护\n\n优点：\n\n- Web 页面可以动态刷新，所有用户看到的都不是同一个页面\n- 他可以与数据库交互（数据持久化：注册，商品信息，用户信息........）\n\n![](img/article/JAVA-javaweb-20210430/20210428132115.png)\n\n# Web 服务器\n\nASP:\n\n- 微软：国内最早流行的就是 ASP；\n- 在 HTML 中嵌入了 VB 的脚本，ASP + COM；\n- 在 ASP 开发中，基本一个页面都有几千行的代码业务，页面极其混乱\n- 维护成本高！\n- C#\n- LLS\n\n```asp\n<h1>\n    <h1><h1>\n        <h1>\n            <h1>\n                <h1>\n        <h1>\n            <%\n            System.out.println(\"hello\")\n                %>\n            <h1>\n                <h1>\n    <h1><h1>\n<h1>\n```\n\nphp :\n\n- php 开发速度很快，功能很强大，跨平台，代码简单（70%，WordPress）\n- 无法承载大访问量的情况（局限性）\n\nJSP/Servlet\n\nB/S: 浏览和服务器\n\nC/S: 客户端和服务器\n\n- sun 公司主推的 B/S 架构\n- 基于 java 语言的（所有的大公司，或者一些开源的组件，都是用 java 写的）\n- 可以承载三高问题带来的影响；\n- 语法像 ASP， ASP--->JSP，加强市场强度；\n\n......\n\n## web 服务器\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些影响信息；\n\n### IIS\n\n微软的；ASP..., windows 中自带的\n\n### Tomcat\n\n面向百度编程；\n\nTomcat 是 Apache 软件基金会（Apache Software Foundation） 的 Jakarta 项目中的一个核心项目，最新的 Servlet 和 JSP 规范总是能在 Tomcat 中的到体现，因为 Tomcat 技术先进，性能稳定，而且免费，因而深受 java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 web 应用服务器。\n\nTomcat 服务器是一个免费的开放源代码 web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 jsp 程序的首选。对于一个 java 初学 web 的人来说，它是最佳的选择。\n\nTomcat 实际上运行 JSP 页面和 servlet。Tomcat 最新版本为 9.0。\n\n# Tomcat\n\n## Tomcat 启动和配置\n\n文件夹作用：\n\n![](img/article/JAVA-javaweb-20210430/20210428133849.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428133859.png)\n\n可以配置启动的端口号\n\n- tomcat 的默认端口号为：8080\n- mysql: 3306\n- http: 80\n- https: 443\n\n```xml\n<Connector URIEncoding=\"UTF-8\" connectionTimeout=\"20000\"\n           port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" useBodyEncodingForURI=\"true\"/>\n```\n\n可以配置主机的名称\n\n- 默认的主机名为：localhost->127.0.0.1\n- 默认网站应用存放的位置为：webapps\n\n```xml\n<Host appBase=\"webapps\" autoDeploy=\"true\" name=\"localhost\" unpackWARs=\"true\">\n```\n\n**高难度面试题**：\n\n请你谈谈网站是如何进行访问的！\n\n1. 输入一个域名: 回车\n\n2. 检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts 配置文件下有没有这个域名映射：\n\n   1. 有：直接返回对应的 IP 地址，这个地址中，有我们需要访问的 web 程序，可以直接访问\n\n      ```powershell\n      192.30.255.112 github.com\n      ```\n\n   2. 没有：去 DNS 服务器找，找到的话就返回，找不到就返回找不到：\n\n   ![](img/article/JAVA-javaweb-20210430/20210428135406.png)\n\n## 发布一个网站\n\n将自己写的网站，放到服务器（Tomcat）中指定的 Web 应用的文件夹（Wevapps）\n\n网站该有的结构\n\n```\n--webapps：Tomcat服务器的web目录\n\t-ROOT\n    -kuangstudy：网站的目录名\n    \t-WEB-INF\n    \t\t-classes：java程序\n    \t\t-lib：web应用所依赖的jar包\n    \t\t-web.xml：网站配置文件\n    \t-index.html 默认的首页\n    \t-static\n    \t\t-css\n    \t\t\t-style.css\n    \t\t-js\n    \t\t-img\n    \t-......\n```\n\n# HTTP\n\n## 什么是 HTTP\n\nHTTP（超文本传输协议）是一个简单的请求-响应协议，他通常运行在 TCP 之上。\n\n- 文本：html，字符串，~......\n- 超文本：图片，音乐，视频，定位，地图..........\n- 默认端口：80\n\nHTTPS：安全的\n\n- 默认端口：443\n\n## 两个时代\n\n- http1.0\n  - HTTP/1.0：客户端可以与 web 服务器连接后，只能获得一个 web 资源，断开连接\n- http2.0\n  - HTTP/1.1：客户端可以与 web 服务器连接后，可以获得多个 web 资源\n\n## HTTP 请求\n\n- 客户端---发送请求（Request）--- 服务器\n\n百度：\n\n```java\nRequest URL:https://www.baidu.com/ 请求地址\nRequest Method:GET     get方法/post方法\nStatus Code:200 OK     状态码：200\nRemote （远程） Address：14.215.177.39:443\n```\n\n```java\nAccpet:text/html\nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN, zh; q=0.9 语言\nCache-Control:max-age=0\nConnection:keep-alive\n```\n\n### 请求行\n\n- 请求行中的请求方式：get\n\n- 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT......\n  - get: 请求能够携带的参数比较少，大小有限制，会在浏览器的 URL 地址栏显示数据内容，不安全，但高效；\n  - post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的 URL 地址栏显示数据内容，安全，但不高效；\n\n### 消息头\n\n```java\nAccpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\n```\n\n## HTTP 响应\n\n- 服务器---响应---客户端\n\n百度\n\n```xml\nCache-control:private  缓存控制\nConnection：Keep-Alive  连接\nContent-Encoding: gzip  编码\nContent-Type:text/html  类型\n```\n\n### 响应体\n\n```java\nAccpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\nRefresh: 告诉客户端，多久刷新一次；\nLocation: 让网页重新定位；\n```\n\n### 响应状态码\n\n200：请求响应成功\n\n3xx：请求重定向\n\n4xx：找不到资源\n\n​ 资源不存在；\n\n5xx：服务器代码错误 500 502：网关错误\n\n常见面试题：\n\n当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么?\n\n1. 域名解析\n2. 发起 TCP 的三次握手\n3. 建立起 TCP 连接后发起 http 请求\n4. 服务器响应 http 请求，浏览器得到 html 代码\n5. 浏览器解析 html 代码，并请求 html 代码中的资源（css JavaScript 图片）\n6. 浏览器对页面进行渲染呈现\n7. 详细请参考:https://www.cnblogs.com/wupeixuan/p/8747918.html\n\n# Maven\n\n为什么学习这个技术?\n\n1. 在 javaweb 开发中, 需要使用大量的 jar 包,我们手动去导入;\n\n2. 如何能让一个东西自动帮我导入和配置这个 jar 包。\n\n   由此,maven 诞生了。\n\n## maven--项目架构管理工具\n\n我们目前用来就是方便导入 jar 包的！\n\nMaven 的核心思想，**约定大于配置**\n\n- 有约束，不要去违反。\n\nMaven 会规定好你该如何去编写我们的 java 代码，必须要按照这个规范来。\n\n## 下载，安装，配置环境变量，配置国内镜像，配置本地仓库--略\n\n## 在 IDEA 中使用 Maven\n\n创建 maven 项目\n\n![](img/article/JAVA-javaweb-20210430/20210428162308.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428162631.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428162806.png)\n\n## 创建一个普通的 maven 项目\n\n不选模板创建\n\n一个干净的 maven 项目\n\n![](img/article/JAVA-javaweb-20210430/20210428170220.png)\n\nwebapp 文件夹只有在 web 应用下才会有！\n\n## 标记文件夹目录\n\n![](img/article/JAVA-javaweb-20210430/20210428170647.png)\n\n方法二\n\n![](img/article/JAVA-javaweb-20210430/20210428171043.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428171331.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428172011.png)\n\n## pom 文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.kuang</groupId>\n  <artifactId>javaweb-01-maven</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <!-- package 项目的打包方式\n   jar: java应用\n   war: javaWeb应用\n   -->\n  <packaging>war</packaging>\n\n  <name>javaweb-01-maven Maven Webapp</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <!-- 配置 -->\n  <properties>\n    <!-- 项目的默认构建编码 -->\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <!-- 编码版本 -->\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <!-- 项目依赖 -->\n  <dependencies>\n    <!-- 具体依赖的jar包配置文件 -->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n  </dependencies>\n\n  <!-- 项目构建用的东西 -->\n  <build>\n    <finalName>javaweb-01-maven</finalName>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n```\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.kuang</groupId>\n    <artifactId>javaweb-01-maven02</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <!-- maven的高级之处在于，他会帮你导入这个jar包所依赖的其他jar包 -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.11</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n## maven 无法导出或者生效的问题\n\nmaven 由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n\n在 build 中配置 resources 节点，来防止我们资源导出失败的问题\n\n```xml\n<build>\n    .......\n      <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <!--打包时该路径下过滤掉的-->\n            <excludes>\n                <exclude>**/*.properties</exclude>\n                <exclude>**/*.xml</exclude>\n             </excludes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <!--打包时该路径下留下的，其他过滤掉-->\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n    ......\n</build>\n```\n\n## maven 默认 web 项目中的 web.xml 版本问题\n\n去 tomcat\\webapps\\ROOT\\WEB-INF\\web.xml 中复制，这里的是 tomcat 9.0 版本中的\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n  version=\"4.0\"\n  metadata-complete=\"true\">\n\n\n</web-app>\n```\n\n# Serverlet\n\n## servlet 简介\n\n- serverlet 就是 sun 公司开发动态 web 的一门技术；\n- sun 公司在这些 API 中提供一个接口叫做：Servlet，如果你想开发一个 servlet 程序，只需要完成两个小步骤：\n  - 编写一个类，实现 servlet 接口。\n  - 把开发好的 java 类部署到 web 服务器中。\n\n**把实现了 Servlet 接口的 java 程序叫做，servlet**\n\n## HelloServlet\n\nServlet 接口在 sun 公司有两个默认的实现类：HttpServlet GenericServlet\n\n1. 构建一个普通 maven 项目，删掉其中的 src 目录，以后我们的学习就在这个项目里面建立 Moudel；这个空的工程就是 Maven 主工程；\n\n2. 关于 maven 父子工程的理解：\n\n   - 父项目中会有\n\n   ```xml\n   <modules>\n           <module>servlet-01</module>\n   </modules>\n   ```\n\n   - 子项目会有\n\n   ```xml\n   <parent>\n           <artifactId>javaweb-servlet</artifactId>\n           <groupId>com.kuang</groupId>\n           <version>1.0-SNAPSHOT</version>\n   </parent>\n   ```\n\n   父项目中的 java 子项目可以直接使用\n\n   ```java\n   son extends father\n   ```\n\n3. Maven 环境优化\n\n   1. 修改`web.xml`为最新的\n   2. 将 maven 的结构搭建完整\n\n4. 编写一个 Servlet 程序\n\n   1. 编写一个普通类\n   2. 实现 Servlet 接口\n   3. 由于 get 或者 post 只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n\n   ```java\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   import java.io.PrintWriter;\n\n   public class HelloServlet extends HttpServlet {\n       //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n       @Override\n       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n           PrintWriter writer = resp.getWriter(); //响应流\n           writer.print(\"hello servlet\");\n       }\n       @Override\n       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n           super.doPost(req, resp);\n       }\n   }\n   ```\n\n5. 编写 servlet 的映射\n\n   为什么需要映射，我们写的是 java 程序，但是要通过浏览器访问，而浏览器需要连接 Web 服务器，所以我们需要在 Web 服务器中注册我们写的 servlet，还需要给他一个浏览器能够访问到的路径；\n\n6. 配置 tomcat\n\n7. 启动测试\n\n## Servlet 原理\n\n![](img/article/JAVA-javaweb-20210430/20210428201314.png)\n\n## Mapping 问题\n\n1. 一个 servlet 可以指定一个映射路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n   </servlet-mapping>\n   ```\n\n2. 一个 servlet 可以指定对个映射路径\n\n   ```xml\n   <!--注册servlet-->\n       <servlet>\n           <servlet-name>hello</servlet-name>\n           <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n       </servlet>\n\n       <!--servlet的请求路径-->\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello1</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello2</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello3</url-pattern>\n       </servlet-mapping>\n   ```\n\n3. 一个 servlet 可以指定通用映射路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello/*</url-pattern>\n   </servlet-mapping>\n   ```\n\n4. 默认请求路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/*</url-pattern>\n   </servlet-mapping>\n   ```\n\n5. 指定一些后缀或者前缀等等......\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>*.do</url-pattern>\n   </servlet-mapping>\n   可以自定义\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>*.shan</url-pattern>\n   </servlet-mapping>\n   ```\n\n6. 优先级问题\n\n   指定了固定的映射路径优先级最高，如果找不到就会走默认的处理请求\n\n   ```xml\n       <servlet>\n           <servlet-name>errorServlet</servlet-name>\n           <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>\n       </servlet>\n\n       <servlet-mapping>\n           <servlet-name>errorServlet</servlet-name>\n           <url-pattern>/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n一般都是一对一\n\n## ServletContext\n\nweb 容器在启动的时候，它会为每个 web 程序都创建一个对应的 ServletContext 对象，他代表了当前的 Web 应用：\n\n- 共享容器\n\n  我在这个 servlet 中保存的数据，可以在另外一个 servlet 中拿到；（context.setAttribute(); context.getAttribute(); ）\n\n  ![](img/article/JAVA-javaweb-20210430/20210428230921.png)\n\n  ```java\n  @Override\n      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n          ServletContext context = this.getServletContext();\n          //this.getInitParameter();  //初始化参数\n          //this.getServletConfig();  //servlet配置\n          //this.getServletContext(); //servlet上下文\n          resp.setContentType(\"text/html;charset=utf-8\");\n          String username = \"秦疆\";\n          context.setAttribute(\"username\", username);\n      }\n  ```\n\n  ```java\n  @Override\n      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n          ServletContext context = this.getServletContext();\n          String username = (String) context.getAttribute(\"username\");\n          resp.setContentType(\"text/html;charset=utf-8\");\n          resp.getWriter().print(\"名字\"+username);\n      }\n  ```\n\n  ```xml\n  <servlet>\n          <servlet-name>hello</servlet-name>\n          <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n      </servlet>\n      <servlet-mapping>\n          <servlet-name>hello</servlet-name>\n          <url-pattern>/hello</url-pattern>\n      </servlet-mapping>\n\n      <servlet>\n          <servlet-name>getc</servlet-name>\n          <servlet-class>com.kuang.servlet.GetServlet</servlet-class>\n      </servlet>\n      <servlet-mapping>\n          <servlet-name>getc</servlet-name>\n          <url-pattern>/getc</url-pattern>\n  </servlet-mapping>\n  ```\n\n## 请求转发\n\n```java\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ServletContext context = this.getServletContext();\n        System.out.println(\"servlet\");\n       // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/servlet03\"); //请求转发的路径\n      //  requestDispatcher.forward(req,resp); //调用foward实现请求转发\n\n    context.getRequestDispatcher(\"/servlet03\").forward(req,resp); //同上两行，调用foward实现请求转发\n    }\n```\n\n## 读取资源文件\n\nProperties\n\n- 在 java 目录下新建 properties\n- 在 resource 目录下新建 properties\n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为 classpath\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=utf-8\");\n        InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\");\n        Properties prop = new Properties();\n        prop.load(is);\n        String username = prop.getProperty(\"username\");\n        String password = prop.getProperty(\"password\");\n\n        resp.getWriter().print(username+\":\"+password);\n    }\n```\n\n访问测试都可 OK；\n\n## HttpServletResponse\n\nweb 服务器接收到客户端的 HTTP 请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest 对象。代表相应的一个 HttpServletResponse；\n\n- 我们如果要获取客户端请求过来的参数；找 HttpServletRequest；\n- 如果要给客户响应一些信息；找 HttpServletResponse；\n\n### 简单分类\n\n#### 负责向浏览器发送数据的办法\n\n```java\nServletOutputStream getOutputStream() throw IOException;\nPrintWriter getWriter() throws IOException;\n```\n\n#### 负责向浏览器发送响应头的方法\n\n```java\n(ServletResponse)\nvoid setCharacterEncoding(String charset);\nvoid setContentLength(int len);\nvoid setContentLengthLong(long len);\nvoid setContentType(String type);\n(HttpServletResponse)\nvoid setDateHeader(String name, long date);\nvoid addDateHeader(String name, long date);\nvoid setHeader(String name, String value);\nvoid addHeader(String name, String value);\nvoid setIntHeader(String name, int value);\nvoid addIntHeader(String name, int value);\n```\n\n#### 响应的状态码\n\n404.....................\n\n#### 常见应用\n\n1. 向浏览器输出消息（前面内容）\n2. 下载文件\n   1. 要获取下载文件的路径\n   2. 下载的文件名是什么\n   3. 设置想办法让浏览器能够支持下载我们需要的东西\n   4. 获取下载文件的输入流\n   5. 创建缓冲区\n   6. 获取 OutputStream 对象\n   7. 将 FileOutputStream 流写入到 buffer 缓冲区\n   8. 使用 OutputStream 将缓冲区中的数据输出到客户端！\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1. 要获取下载文件的路径\n        String realPath = \"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\javaweb-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png\";\n        System.out.println(\"下载文件的路径：\"+realPath);\n        //2. 下载的文件名是什么\n        String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1);\n        //3. 设置想办法让浏览器能够支持下载我们需要的东西\n        resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+URLEncoder.encode(fileName, \"utf-8\"));\n        //4. 获取下载文件的输入流\n        FileInputStream fileInputStream = new FileInputStream(realPath);\n        //5. 创建缓冲区\n        int len = 0;\n        byte[] buffer = new byte[1024];\n        //6. 获取OutputStream对象\n\n        ServletOutputStream outputStream = resp.getOutputStream();\n        //7. 将FileOutputStream流写入到buffer缓冲区\n        //8. 使用OutputStream将缓冲区中的数据输出到客户端！\n        while ((len=fileInputStream.read(buffer))>0){\n            outputStream.write(buffer,0,len);\n        }\n        fileInputStream.close();\n        outputStream.close();\n    }\n```\n\n#### 验证码\n\n验证码怎么来的？\n\n- 前端实现\n- 后端实现、需要用到 java 的图片类，生产一个图片\n\n```java\npublic class ImageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //如何让浏览器5秒自动刷新一次\n        resp.setHeader(\"refresh\",\"3\");\n\n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //的到图片\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n        //告诉浏览器这个请求用图片的方式打开\n        resp.setContentType(\"image/jpeg\");\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader(\"expires\",-1);\n        resp.setHeader(\"Cache-Control\",\"no-cache\");\n        resp.setHeader(\"Pragma\",\"no-cache\");\n        //把图片写给浏览器\n        ImageIO.write(image,\"jpg\", resp.getOutputStream());\n    }\n\n    private String makeNum() {\n        Random random = new Random();\n        String num = random.nextInt(9999999)+\"\";\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < 7-num.length(); i++) {\n            sb.append(\"0\");\n        }\n        num = sb.toString() + num;\n        return num;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n\n```\n\n#### 实现重定向\n\nB 一个 Web 资源收到客户端 A 请求后，B 会通知 A 客户端去访问另外一个 Web 资源 C，这个过程叫做重定向；\n\n常见场景：\n\n- 用户登录\n\n```java\nresp.sendRedirect(\"/index.jsp\");\n```\n\n```java\nresp.setHeader(\"Location\",\"/r/img\");\n        resp.setStatus(302);\n```\n\n面试题：\n\n重定向和转发的区别？\n\n相同点\n\n- 页面都会实现跳转\n\n不同点\n\n- 请求转发的时候，url 不会产生变化 307\n- 重定向的时候，URL 地址会发生变化 302\n\n## HttpServletRequest\n\n```java\n@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.setCharacterEncoding(\"utf-8\");\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String[] hobbys = req.getParameterValues(\"hobby\");\n\n        System.out.println(username);\n        System.out.println(password);\n        System.out.println(Arrays.toString(hobbys));\n\n        //通过请求转发\n        req.getRequestDispatcher(\"./success.jsp\").forward(req, resp);\n    }\n```\n\n# Cookie、Session\n\n## 会话\n\n**概念**：用户打开一个浏览器，点击了很多超链接，访问了很多 Web 资源，关闭浏览器，这个过程称之为会话；\n\n**有状态会话**：\n\n一个网站，怎么证明你来过？\n\n客户端 服务端\n\n1. 服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookies\n2. 服务端登记你来过了，下次你来的时候我来匹配你；session\n\n## 保存会话的两种技术\n\ncookie\n\n- 客户端技术（响应，请求）\n\nsession\n\n- 服务端技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据放在 session 中！\n\n常见场景：网站登陆之后，下次不用登陆了，第二次访问直接就登上了！\n\n## Cookie\n\n1. 从请求中拿到 cookie 信息。\n2. 服务器响应给客户端 cookie。\n\n各种常用方法：\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //服务器，告诉你，你来的时间，把这个时间封装成一个信件，你下次带来，我就知道你来了\n        //解决中文乱码\n        resp.setContentType(\"text/html\");\n        req.setCharacterEncoding(\"utf-8\");\n        resp.setCharacterEncoding(\"utf-8\");\n\n        PrintWriter out = resp.getWriter();\n\n        //Cookie，服务器端从客户端获取时\n        Cookie[] cookies = req.getCookies();  //这里返回数组，说明cookies可能存在多个\n        //判断Cookies是否存在\n        if (cookies!=null) {\n            //如果cookies存在\n            out.write(\"你上一次访问的时间是：\");\n\n            for (int i = 0; i < cookies.length; i++) {\n                Cookie cookie = cookies[i];\n                //获取cookie的值 cookie.getValue();\n                if (cookie.getName().equals(\"LastLoginTime\")) {\n                    //获取cookie的名字\n                    long l = Long.parseLong(cookie.getValue());\n                    Date date = new Date(l);\n                    out.print(date.toLocaleString());\n                }\n\n            }\n        }else {\n            out.write(\"这是你第一次访问本站\");\n        }\n        // 服务器给客户端响应一个cookie\n        Cookie cookie = new Cookie(\"LastLoginTime\", System.currentTimeMillis()+\"\");\n\n        //设置cookie有效期，关闭浏览器不会删除cookie\n        cookie.setMaxAge(24*60*60);\n        //响应给客户端一个cookie，可以多个\n        /*\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        */\n        resp.addCookie(cookie);\n    }\n```\n\ncookie：一般会保存在本地的用户目录下 appdata:\n\n一个网站的 cookie 是否存在上限！**细节问题**\n\n- 一个 cookie 只能保存一个信息；\n- 一个 web 站点/域名可以给浏览器发送多个 cookie，最多存放 20 个；\n- 所有 cookie 总大小不超出 4kb;\n- 浏览器总共能储存 300 个 cookie；\n- 具体情况根据浏览器不同会有不同限制；\n\n删除 cookie：\n\n- 不设置有效期，关闭浏览器，自动失效；\n- 设置有效期时间为 0；\n\nPS：解码的一个方法\n\n```java\nURLDecoder.decode(String s, \"UTF-8\");\n```\n\n## Session (重点)\n\n什么是 Session：\n\n- 服务器会给每一个用户（浏览器）创建一个 session 对象；\n- 一个 session 独占一个浏览器，只要浏览器没有关闭，这个 session 就存在；\n- 用户登录之后，整个网站他都可以访问！-->保存用户信息，保存购物车的信息......\n\nSession 和 cookie 的区别：\n\n- Cookie 是把用户的数据写给用户的浏览器，浏览器保存（可以保存）；\n- Session 把用户的数据写到用户独占 session 中，服务器端保存；（减少服务器资源的浪费）\n- Session 对象由服务创建；\n\n使用场景：\n\n- 保存一个登录用户的信息；\n- 购物车信息；\n- 在整个网站中经常会使用的数据，我们将它保存在 session 中；\n\n使用 Session:\n\n```java\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //解决中文乱码\n        resp.setContentType(\"text/html；charset=utf-8\");\n        req.setCharacterEncoding(\"utf-8\");\n        resp.setCharacterEncoding(\"utf-8\");\n\n        //得到session\n        HttpSession session = req.getSession();\n        //给session中存东西\n        session.setAttribute(\"name\", new Person(\"秦疆\", 1));\n        //获取sessionID\n        String id = session.getId();\n        //判断session是否是新创建的\n        if (session.isNew()) {\n            resp.getWriter().write(\"session创建成功，ID\"+id);\n        } else {\n            resp.getWriter().write(\"session已经在服务器中存在，ID\"+id);\n        }\n    }\n```\n\n```java\n//得到session\nHttpSession session = req.getSession();\n//给session中存东西\nPerson person = (Person) session.getAttribute(\"name\");\nresp.getWriter().write(person.toString());\n```\n\n```java\n//移除session\nHttpSession session = req.getSession();\nsession.removeAttribute(\"name\");\n```\n\n```java\n  <!--设置session失效时间-->\n  <session-config>\n    <!--15分钟后失效，timeout以分钟为单位-->\n    <session-timeout>15</session-timeout>\n  </session-config>\n```\n\n# javaBean\n\n实体类\n\njavaBean 有特定的写法：\n\n- 必须要有一个无参构造；\n- 属性必须私有化；\n- 必须有对应的 get/set 方法；\n\n一般用来和数据库的字段做映射 ORM；\n\nORM 对象关系映射\n\n- 表->类\n- 字段->属性\n- 行记录->对象\n\n**people 表**\n\n| id  | name      | age | address |\n| --- | --------- | --- | ------- |\n| 1   | 秦疆 1 号 | 3   | 西安    |\n| 2   | 秦疆 2 号 | 18  | 西安    |\n| 3   | 秦疆 3 号 | 100 | 西安    |\n\n# MVC 三层架构\n\n什么是 MVC：model，view，controller 模型，视图，控制器\n\n![](img/article/JAVA-javaweb-20210430/20210430181656.png)\n\n用户直接访问控制层，控制层就可以直接操作数据库：\n\n```java\nservlet --CURD --->数据库\n弊端：程序十分臃肿，不利于维护\nservlet的代码中；处理请求、响应、视图跳转、处理JDBC，处理业务代码，处理逻辑代码\n\n架构：没有什么是加了一层解决不了的......\n```\n\nModel\n\n- 业务处理：业务逻辑（service）\n- 数据持久层：CURD （Dao）\n\nView\n\n- 展示数据\n- 提供链接发起 servlet 请求（a，form，img.......）\n\nController (Servlet)\n\n- 接收用户的请求：（req：请求参数、Session 信息......）\n- 交给业务层处理对应的代码\n- 控制视图的跳转\n\n```java\n登录 ---接受用户的请求 --- 处理用户的请求（获取用户登录的参数，username，password） --- 交给业务层处理登录业务（判断用户名密码是否正确：事务）--- Dao层查询用户名和密码是否正确 --- 数据库\n```\n\n# Filter\n\nFIlter：过滤器，用来过滤网站数据；\n\n- 处理中文乱码\n- 登录验证\n\n![](img/article/JAVA-javaweb-20210430/20210430200702.png)\n\n## Filter 开发步骤\n\n1. 导包\n\n2. 编写过滤器\n\n   ```java\n   package com.kuang.filter;\n\n   import javax.servlet.*;\n   import java.io.IOException;\n\n   public class CharacterEncodingFilter implements Filter {\n       //初始化\n       public void init(FilterConfig filterConfig) throws ServletException {\n           System.out.println(\"CharacterEncodingFilter初始化\");\n       }\n\n       //  chain（链）\n       /*\n       过滤中的所有代码，在过滤特定请求的时候都会执行\n       必须要让过滤器继续通行  chain.doFilter(request,response);\n        */\n       public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n           request.setCharacterEncoding(\"utf-8\");\n           response.setCharacterEncoding(\"utf-8\");\n           response.setContentType(\"text/html;charset=utf-8\");\n           System.out.println(\"CharacterEncodingFilter执行前......\");\n           chain.doFilter(request,response);//让请求继续走，如果不写，程序会被这里拦截\n           System.out.println(\"CharacterEncodingFilter执行后......\");\n       }\n\n       //销毁\n       public void destroy() {\n           System.out.println(\"CharacterEncodingFilter销毁\");\n       }\n   }\n\n   ```\n\n3. 在 web.xml 中配置 Filter\n\n   ```java\n       <filter>\n           <filter-name>characterEncodingFilter</filter-name>\n           <filter-class>com.kuang.filter.CharacterEncodingFilter</filter-class>\n       </filter>\n\n       <filter-mapping>\n           <filter-name>characterEncodingFilter</filter-name>\n           <!--此访问路径（不是项目路径）下的任何请求，都会经过这个过滤器-->\n           <url-pattern>/servlet/*</url-pattern>\n       </filter-mapping>\n   ```\n\n4. **Filter 链**\n\n   ​ 在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称为一个 Filter 链。\n\n   ​ web 服务器根据 Filter 在 web.xml 中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第二个 filter，如果没有，则调用目标资源。\n\n# 监听器\n\n监听登录人数\n\n```java\npackage com.kuang.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\npublic class OnlineCountListener implements HttpSessionListener {\n    //创建session监听，看你的一举一动\n    //一旦创建session就会触发一次这个事践\n    public void sessionCreated(HttpSessionEvent se) {\n        ServletContext ctx = se.getSession().getServletContext();\n        Integer onlineCount = (Integer) ctx.getAttribute(\"OnlineCount\");\n        if (onlineCount==null) {\n            onlineCount = 1;\n        }else {\n            int count = onlineCount;\n            onlineCount = count + 1;\n        }\n        ctx.setAttribute(\"onlineCount\", onlineCount);\n    }\n    //销毁session监听\n    public void sessionDestroyed(HttpSessionEvent se) {\n\n    }\n}\n\n```\n\n```java\n<listener>\n    <listener-class>com.kuang.listener.OnlineCountListener</listener-class>\n</listener>\n<session-config>\n    <session-timeout>1</session-timeout>\n</session-config>\n```\n\n# 过滤器监听器常见应用\n\n用户登录后才能进入主页！用户注销后就不能进入主页了！\n\n1. 用户登录之后，向 session 中放入用户的数据；\n2. 进入主页的时候要判断用户是否已经登录；下面：在过滤器中实现；\n\n```java\npackage com.kuang.filter;\n\nimport com.kuang.utils.Constant;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SysFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) resp;\n\n        if (request.getSession().getAttribute(Constant.USER_SESSION)==null){\n            response.sendRedirect(\"/sys/Error.jsp\");\n        }\n\n        chain.doFilter(req,resp);\n    }\n    public void destroy() {\n    }\n}\n```\n\n# Junit 测试\n\n`@Test`注解\n\n只能在单元测试代码中使用\n","source":"_posts/JAVA-javaweb-20210430.md","raw":"---\ntitle: JAVA_javaweb\ndate: 2021-04-30 23:48:28\ntags:\n  - java基础\n  - 狂神说\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# 基本概念\n\n<!--more-->\n\n## 前言\n\nweb 开发：\n\n- web，网页的意思，www.baidu.com\n- 静态 web\n  - html,css\n  - 提供给所有人看的数据始终不会发生变化！\n  - 技术栈：servlet / JSP，ASP，PHP\n\n在 java 中，动态 web 资源开发的技术统称为 JavaWeb\n\n## web 应用程序\n\nweb 应用程序：可以提供浏览器访问的程序；\n\n- a.html、b.html ..... 多个 web 资源，这些 web 资源可以被外界访问，对外界提供服务；\n- 你们能访问到的任何一个页面或者资源，都存在于这个世界上的某一角落的计算机上。\n- URL\n- 这个统一的 web 资源会被放在同一个文件夹下，web 应用程序-->Tomcat: 服务器\n- 一个 web 应用由多部分组成（静态 web，动态 web）\n  - html，css，js\n  - jsp，servlet\n  - java 程序\n  - jar 包\n  - 配置文件（properties）\n\nweb 应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n## 静态 web\n\n- _.html_ 这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n![](img/article/JAVA-javaweb-20210430/20210428131402.png)\n\n- 静态 web 存在的缺点\n  - web 页面无法动态更新，所有用户看到都是同一个页面\n    - 轮播图，点击特效；伪动态\n    - javaScript （实际开发中，它用的最多）\n    - VBScript\n  - 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n## 动态 web\n\n页面会动态展示：“web 的页面展示的效果因人而异”；\n\n![](img/article/JAVA-javaweb-20210430/20210428131746.png)\n\n缺点：\n\n- 加入服务器的动态 web 资源出现了错误，我们需要重新编写我们的后台程序，重新发布；\n  - 停机维护\n\n优点：\n\n- Web 页面可以动态刷新，所有用户看到的都不是同一个页面\n- 他可以与数据库交互（数据持久化：注册，商品信息，用户信息........）\n\n![](img/article/JAVA-javaweb-20210430/20210428132115.png)\n\n# Web 服务器\n\nASP:\n\n- 微软：国内最早流行的就是 ASP；\n- 在 HTML 中嵌入了 VB 的脚本，ASP + COM；\n- 在 ASP 开发中，基本一个页面都有几千行的代码业务，页面极其混乱\n- 维护成本高！\n- C#\n- LLS\n\n```asp\n<h1>\n    <h1><h1>\n        <h1>\n            <h1>\n                <h1>\n        <h1>\n            <%\n            System.out.println(\"hello\")\n                %>\n            <h1>\n                <h1>\n    <h1><h1>\n<h1>\n```\n\nphp :\n\n- php 开发速度很快，功能很强大，跨平台，代码简单（70%，WordPress）\n- 无法承载大访问量的情况（局限性）\n\nJSP/Servlet\n\nB/S: 浏览和服务器\n\nC/S: 客户端和服务器\n\n- sun 公司主推的 B/S 架构\n- 基于 java 语言的（所有的大公司，或者一些开源的组件，都是用 java 写的）\n- 可以承载三高问题带来的影响；\n- 语法像 ASP， ASP--->JSP，加强市场强度；\n\n......\n\n## web 服务器\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些影响信息；\n\n### IIS\n\n微软的；ASP..., windows 中自带的\n\n### Tomcat\n\n面向百度编程；\n\nTomcat 是 Apache 软件基金会（Apache Software Foundation） 的 Jakarta 项目中的一个核心项目，最新的 Servlet 和 JSP 规范总是能在 Tomcat 中的到体现，因为 Tomcat 技术先进，性能稳定，而且免费，因而深受 java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 web 应用服务器。\n\nTomcat 服务器是一个免费的开放源代码 web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 jsp 程序的首选。对于一个 java 初学 web 的人来说，它是最佳的选择。\n\nTomcat 实际上运行 JSP 页面和 servlet。Tomcat 最新版本为 9.0。\n\n# Tomcat\n\n## Tomcat 启动和配置\n\n文件夹作用：\n\n![](img/article/JAVA-javaweb-20210430/20210428133849.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428133859.png)\n\n可以配置启动的端口号\n\n- tomcat 的默认端口号为：8080\n- mysql: 3306\n- http: 80\n- https: 443\n\n```xml\n<Connector URIEncoding=\"UTF-8\" connectionTimeout=\"20000\"\n           port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" useBodyEncodingForURI=\"true\"/>\n```\n\n可以配置主机的名称\n\n- 默认的主机名为：localhost->127.0.0.1\n- 默认网站应用存放的位置为：webapps\n\n```xml\n<Host appBase=\"webapps\" autoDeploy=\"true\" name=\"localhost\" unpackWARs=\"true\">\n```\n\n**高难度面试题**：\n\n请你谈谈网站是如何进行访问的！\n\n1. 输入一个域名: 回车\n\n2. 检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts 配置文件下有没有这个域名映射：\n\n   1. 有：直接返回对应的 IP 地址，这个地址中，有我们需要访问的 web 程序，可以直接访问\n\n      ```powershell\n      192.30.255.112 github.com\n      ```\n\n   2. 没有：去 DNS 服务器找，找到的话就返回，找不到就返回找不到：\n\n   ![](img/article/JAVA-javaweb-20210430/20210428135406.png)\n\n## 发布一个网站\n\n将自己写的网站，放到服务器（Tomcat）中指定的 Web 应用的文件夹（Wevapps）\n\n网站该有的结构\n\n```\n--webapps：Tomcat服务器的web目录\n\t-ROOT\n    -kuangstudy：网站的目录名\n    \t-WEB-INF\n    \t\t-classes：java程序\n    \t\t-lib：web应用所依赖的jar包\n    \t\t-web.xml：网站配置文件\n    \t-index.html 默认的首页\n    \t-static\n    \t\t-css\n    \t\t\t-style.css\n    \t\t-js\n    \t\t-img\n    \t-......\n```\n\n# HTTP\n\n## 什么是 HTTP\n\nHTTP（超文本传输协议）是一个简单的请求-响应协议，他通常运行在 TCP 之上。\n\n- 文本：html，字符串，~......\n- 超文本：图片，音乐，视频，定位，地图..........\n- 默认端口：80\n\nHTTPS：安全的\n\n- 默认端口：443\n\n## 两个时代\n\n- http1.0\n  - HTTP/1.0：客户端可以与 web 服务器连接后，只能获得一个 web 资源，断开连接\n- http2.0\n  - HTTP/1.1：客户端可以与 web 服务器连接后，可以获得多个 web 资源\n\n## HTTP 请求\n\n- 客户端---发送请求（Request）--- 服务器\n\n百度：\n\n```java\nRequest URL:https://www.baidu.com/ 请求地址\nRequest Method:GET     get方法/post方法\nStatus Code:200 OK     状态码：200\nRemote （远程） Address：14.215.177.39:443\n```\n\n```java\nAccpet:text/html\nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN, zh; q=0.9 语言\nCache-Control:max-age=0\nConnection:keep-alive\n```\n\n### 请求行\n\n- 请求行中的请求方式：get\n\n- 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT......\n  - get: 请求能够携带的参数比较少，大小有限制，会在浏览器的 URL 地址栏显示数据内容，不安全，但高效；\n  - post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的 URL 地址栏显示数据内容，安全，但不高效；\n\n### 消息头\n\n```java\nAccpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\n```\n\n## HTTP 响应\n\n- 服务器---响应---客户端\n\n百度\n\n```xml\nCache-control:private  缓存控制\nConnection：Keep-Alive  连接\nContent-Encoding: gzip  编码\nContent-Type:text/html  类型\n```\n\n### 响应体\n\n```java\nAccpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\nRefresh: 告诉客户端，多久刷新一次；\nLocation: 让网页重新定位；\n```\n\n### 响应状态码\n\n200：请求响应成功\n\n3xx：请求重定向\n\n4xx：找不到资源\n\n​ 资源不存在；\n\n5xx：服务器代码错误 500 502：网关错误\n\n常见面试题：\n\n当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么?\n\n1. 域名解析\n2. 发起 TCP 的三次握手\n3. 建立起 TCP 连接后发起 http 请求\n4. 服务器响应 http 请求，浏览器得到 html 代码\n5. 浏览器解析 html 代码，并请求 html 代码中的资源（css JavaScript 图片）\n6. 浏览器对页面进行渲染呈现\n7. 详细请参考:https://www.cnblogs.com/wupeixuan/p/8747918.html\n\n# Maven\n\n为什么学习这个技术?\n\n1. 在 javaweb 开发中, 需要使用大量的 jar 包,我们手动去导入;\n\n2. 如何能让一个东西自动帮我导入和配置这个 jar 包。\n\n   由此,maven 诞生了。\n\n## maven--项目架构管理工具\n\n我们目前用来就是方便导入 jar 包的！\n\nMaven 的核心思想，**约定大于配置**\n\n- 有约束，不要去违反。\n\nMaven 会规定好你该如何去编写我们的 java 代码，必须要按照这个规范来。\n\n## 下载，安装，配置环境变量，配置国内镜像，配置本地仓库--略\n\n## 在 IDEA 中使用 Maven\n\n创建 maven 项目\n\n![](img/article/JAVA-javaweb-20210430/20210428162308.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428162631.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428162806.png)\n\n## 创建一个普通的 maven 项目\n\n不选模板创建\n\n一个干净的 maven 项目\n\n![](img/article/JAVA-javaweb-20210430/20210428170220.png)\n\nwebapp 文件夹只有在 web 应用下才会有！\n\n## 标记文件夹目录\n\n![](img/article/JAVA-javaweb-20210430/20210428170647.png)\n\n方法二\n\n![](img/article/JAVA-javaweb-20210430/20210428171043.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428171331.png)\n\n![](img/article/JAVA-javaweb-20210430/20210428172011.png)\n\n## pom 文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.kuang</groupId>\n  <artifactId>javaweb-01-maven</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <!-- package 项目的打包方式\n   jar: java应用\n   war: javaWeb应用\n   -->\n  <packaging>war</packaging>\n\n  <name>javaweb-01-maven Maven Webapp</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <!-- 配置 -->\n  <properties>\n    <!-- 项目的默认构建编码 -->\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <!-- 编码版本 -->\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <!-- 项目依赖 -->\n  <dependencies>\n    <!-- 具体依赖的jar包配置文件 -->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n  </dependencies>\n\n  <!-- 项目构建用的东西 -->\n  <build>\n    <finalName>javaweb-01-maven</finalName>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-war-plugin</artifactId>\n          <version>3.2.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n```\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.kuang</groupId>\n    <artifactId>javaweb-01-maven02</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <!-- maven的高级之处在于，他会帮你导入这个jar包所依赖的其他jar包 -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.11</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n## maven 无法导出或者生效的问题\n\nmaven 由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：\n\n在 build 中配置 resources 节点，来防止我们资源导出失败的问题\n\n```xml\n<build>\n    .......\n      <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <!--打包时该路径下过滤掉的-->\n            <excludes>\n                <exclude>**/*.properties</exclude>\n                <exclude>**/*.xml</exclude>\n             </excludes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <!--打包时该路径下留下的，其他过滤掉-->\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n    ......\n</build>\n```\n\n## maven 默认 web 项目中的 web.xml 版本问题\n\n去 tomcat\\webapps\\ROOT\\WEB-INF\\web.xml 中复制，这里的是 tomcat 9.0 版本中的\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n  version=\"4.0\"\n  metadata-complete=\"true\">\n\n\n</web-app>\n```\n\n# Serverlet\n\n## servlet 简介\n\n- serverlet 就是 sun 公司开发动态 web 的一门技术；\n- sun 公司在这些 API 中提供一个接口叫做：Servlet，如果你想开发一个 servlet 程序，只需要完成两个小步骤：\n  - 编写一个类，实现 servlet 接口。\n  - 把开发好的 java 类部署到 web 服务器中。\n\n**把实现了 Servlet 接口的 java 程序叫做，servlet**\n\n## HelloServlet\n\nServlet 接口在 sun 公司有两个默认的实现类：HttpServlet GenericServlet\n\n1. 构建一个普通 maven 项目，删掉其中的 src 目录，以后我们的学习就在这个项目里面建立 Moudel；这个空的工程就是 Maven 主工程；\n\n2. 关于 maven 父子工程的理解：\n\n   - 父项目中会有\n\n   ```xml\n   <modules>\n           <module>servlet-01</module>\n   </modules>\n   ```\n\n   - 子项目会有\n\n   ```xml\n   <parent>\n           <artifactId>javaweb-servlet</artifactId>\n           <groupId>com.kuang</groupId>\n           <version>1.0-SNAPSHOT</version>\n   </parent>\n   ```\n\n   父项目中的 java 子项目可以直接使用\n\n   ```java\n   son extends father\n   ```\n\n3. Maven 环境优化\n\n   1. 修改`web.xml`为最新的\n   2. 将 maven 的结构搭建完整\n\n4. 编写一个 Servlet 程序\n\n   1. 编写一个普通类\n   2. 实现 Servlet 接口\n   3. 由于 get 或者 post 只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n\n   ```java\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServlet;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   import java.io.PrintWriter;\n\n   public class HelloServlet extends HttpServlet {\n       //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n       @Override\n       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n           PrintWriter writer = resp.getWriter(); //响应流\n           writer.print(\"hello servlet\");\n       }\n       @Override\n       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n           super.doPost(req, resp);\n       }\n   }\n   ```\n\n5. 编写 servlet 的映射\n\n   为什么需要映射，我们写的是 java 程序，但是要通过浏览器访问，而浏览器需要连接 Web 服务器，所以我们需要在 Web 服务器中注册我们写的 servlet，还需要给他一个浏览器能够访问到的路径；\n\n6. 配置 tomcat\n\n7. 启动测试\n\n## Servlet 原理\n\n![](img/article/JAVA-javaweb-20210430/20210428201314.png)\n\n## Mapping 问题\n\n1. 一个 servlet 可以指定一个映射路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n   </servlet-mapping>\n   ```\n\n2. 一个 servlet 可以指定对个映射路径\n\n   ```xml\n   <!--注册servlet-->\n       <servlet>\n           <servlet-name>hello</servlet-name>\n           <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n       </servlet>\n\n       <!--servlet的请求路径-->\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello1</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello2</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello3</url-pattern>\n       </servlet-mapping>\n   ```\n\n3. 一个 servlet 可以指定通用映射路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello/*</url-pattern>\n   </servlet-mapping>\n   ```\n\n4. 默认请求路径\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/*</url-pattern>\n   </servlet-mapping>\n   ```\n\n5. 指定一些后缀或者前缀等等......\n\n   ```xml\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>*.do</url-pattern>\n   </servlet-mapping>\n   可以自定义\n   <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>*.shan</url-pattern>\n   </servlet-mapping>\n   ```\n\n6. 优先级问题\n\n   指定了固定的映射路径优先级最高，如果找不到就会走默认的处理请求\n\n   ```xml\n       <servlet>\n           <servlet-name>errorServlet</servlet-name>\n           <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>\n       </servlet>\n\n       <servlet-mapping>\n           <servlet-name>errorServlet</servlet-name>\n           <url-pattern>/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n一般都是一对一\n\n## ServletContext\n\nweb 容器在启动的时候，它会为每个 web 程序都创建一个对应的 ServletContext 对象，他代表了当前的 Web 应用：\n\n- 共享容器\n\n  我在这个 servlet 中保存的数据，可以在另外一个 servlet 中拿到；（context.setAttribute(); context.getAttribute(); ）\n\n  ![](img/article/JAVA-javaweb-20210430/20210428230921.png)\n\n  ```java\n  @Override\n      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n          ServletContext context = this.getServletContext();\n          //this.getInitParameter();  //初始化参数\n          //this.getServletConfig();  //servlet配置\n          //this.getServletContext(); //servlet上下文\n          resp.setContentType(\"text/html;charset=utf-8\");\n          String username = \"秦疆\";\n          context.setAttribute(\"username\", username);\n      }\n  ```\n\n  ```java\n  @Override\n      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n          ServletContext context = this.getServletContext();\n          String username = (String) context.getAttribute(\"username\");\n          resp.setContentType(\"text/html;charset=utf-8\");\n          resp.getWriter().print(\"名字\"+username);\n      }\n  ```\n\n  ```xml\n  <servlet>\n          <servlet-name>hello</servlet-name>\n          <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n      </servlet>\n      <servlet-mapping>\n          <servlet-name>hello</servlet-name>\n          <url-pattern>/hello</url-pattern>\n      </servlet-mapping>\n\n      <servlet>\n          <servlet-name>getc</servlet-name>\n          <servlet-class>com.kuang.servlet.GetServlet</servlet-class>\n      </servlet>\n      <servlet-mapping>\n          <servlet-name>getc</servlet-name>\n          <url-pattern>/getc</url-pattern>\n  </servlet-mapping>\n  ```\n\n## 请求转发\n\n```java\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ServletContext context = this.getServletContext();\n        System.out.println(\"servlet\");\n       // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/servlet03\"); //请求转发的路径\n      //  requestDispatcher.forward(req,resp); //调用foward实现请求转发\n\n    context.getRequestDispatcher(\"/servlet03\").forward(req,resp); //同上两行，调用foward实现请求转发\n    }\n```\n\n## 读取资源文件\n\nProperties\n\n- 在 java 目录下新建 properties\n- 在 resource 目录下新建 properties\n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为 classpath\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html;charset=utf-8\");\n        InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\");\n        Properties prop = new Properties();\n        prop.load(is);\n        String username = prop.getProperty(\"username\");\n        String password = prop.getProperty(\"password\");\n\n        resp.getWriter().print(username+\":\"+password);\n    }\n```\n\n访问测试都可 OK；\n\n## HttpServletResponse\n\nweb 服务器接收到客户端的 HTTP 请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest 对象。代表相应的一个 HttpServletResponse；\n\n- 我们如果要获取客户端请求过来的参数；找 HttpServletRequest；\n- 如果要给客户响应一些信息；找 HttpServletResponse；\n\n### 简单分类\n\n#### 负责向浏览器发送数据的办法\n\n```java\nServletOutputStream getOutputStream() throw IOException;\nPrintWriter getWriter() throws IOException;\n```\n\n#### 负责向浏览器发送响应头的方法\n\n```java\n(ServletResponse)\nvoid setCharacterEncoding(String charset);\nvoid setContentLength(int len);\nvoid setContentLengthLong(long len);\nvoid setContentType(String type);\n(HttpServletResponse)\nvoid setDateHeader(String name, long date);\nvoid addDateHeader(String name, long date);\nvoid setHeader(String name, String value);\nvoid addHeader(String name, String value);\nvoid setIntHeader(String name, int value);\nvoid addIntHeader(String name, int value);\n```\n\n#### 响应的状态码\n\n404.....................\n\n#### 常见应用\n\n1. 向浏览器输出消息（前面内容）\n2. 下载文件\n   1. 要获取下载文件的路径\n   2. 下载的文件名是什么\n   3. 设置想办法让浏览器能够支持下载我们需要的东西\n   4. 获取下载文件的输入流\n   5. 创建缓冲区\n   6. 获取 OutputStream 对象\n   7. 将 FileOutputStream 流写入到 buffer 缓冲区\n   8. 使用 OutputStream 将缓冲区中的数据输出到客户端！\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //1. 要获取下载文件的路径\n        String realPath = \"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\javaweb-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png\";\n        System.out.println(\"下载文件的路径：\"+realPath);\n        //2. 下载的文件名是什么\n        String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1);\n        //3. 设置想办法让浏览器能够支持下载我们需要的东西\n        resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+URLEncoder.encode(fileName, \"utf-8\"));\n        //4. 获取下载文件的输入流\n        FileInputStream fileInputStream = new FileInputStream(realPath);\n        //5. 创建缓冲区\n        int len = 0;\n        byte[] buffer = new byte[1024];\n        //6. 获取OutputStream对象\n\n        ServletOutputStream outputStream = resp.getOutputStream();\n        //7. 将FileOutputStream流写入到buffer缓冲区\n        //8. 使用OutputStream将缓冲区中的数据输出到客户端！\n        while ((len=fileInputStream.read(buffer))>0){\n            outputStream.write(buffer,0,len);\n        }\n        fileInputStream.close();\n        outputStream.close();\n    }\n```\n\n#### 验证码\n\n验证码怎么来的？\n\n- 前端实现\n- 后端实现、需要用到 java 的图片类，生产一个图片\n\n```java\npublic class ImageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //如何让浏览器5秒自动刷新一次\n        resp.setHeader(\"refresh\",\"3\");\n\n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //的到图片\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n        //告诉浏览器这个请求用图片的方式打开\n        resp.setContentType(\"image/jpeg\");\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader(\"expires\",-1);\n        resp.setHeader(\"Cache-Control\",\"no-cache\");\n        resp.setHeader(\"Pragma\",\"no-cache\");\n        //把图片写给浏览器\n        ImageIO.write(image,\"jpg\", resp.getOutputStream());\n    }\n\n    private String makeNum() {\n        Random random = new Random();\n        String num = random.nextInt(9999999)+\"\";\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < 7-num.length(); i++) {\n            sb.append(\"0\");\n        }\n        num = sb.toString() + num;\n        return num;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n\n```\n\n#### 实现重定向\n\nB 一个 Web 资源收到客户端 A 请求后，B 会通知 A 客户端去访问另外一个 Web 资源 C，这个过程叫做重定向；\n\n常见场景：\n\n- 用户登录\n\n```java\nresp.sendRedirect(\"/index.jsp\");\n```\n\n```java\nresp.setHeader(\"Location\",\"/r/img\");\n        resp.setStatus(302);\n```\n\n面试题：\n\n重定向和转发的区别？\n\n相同点\n\n- 页面都会实现跳转\n\n不同点\n\n- 请求转发的时候，url 不会产生变化 307\n- 重定向的时候，URL 地址会发生变化 302\n\n## HttpServletRequest\n\n```java\n@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.setCharacterEncoding(\"utf-8\");\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String[] hobbys = req.getParameterValues(\"hobby\");\n\n        System.out.println(username);\n        System.out.println(password);\n        System.out.println(Arrays.toString(hobbys));\n\n        //通过请求转发\n        req.getRequestDispatcher(\"./success.jsp\").forward(req, resp);\n    }\n```\n\n# Cookie、Session\n\n## 会话\n\n**概念**：用户打开一个浏览器，点击了很多超链接，访问了很多 Web 资源，关闭浏览器，这个过程称之为会话；\n\n**有状态会话**：\n\n一个网站，怎么证明你来过？\n\n客户端 服务端\n\n1. 服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookies\n2. 服务端登记你来过了，下次你来的时候我来匹配你；session\n\n## 保存会话的两种技术\n\ncookie\n\n- 客户端技术（响应，请求）\n\nsession\n\n- 服务端技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据放在 session 中！\n\n常见场景：网站登陆之后，下次不用登陆了，第二次访问直接就登上了！\n\n## Cookie\n\n1. 从请求中拿到 cookie 信息。\n2. 服务器响应给客户端 cookie。\n\n各种常用方法：\n\n```java\n@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //服务器，告诉你，你来的时间，把这个时间封装成一个信件，你下次带来，我就知道你来了\n        //解决中文乱码\n        resp.setContentType(\"text/html\");\n        req.setCharacterEncoding(\"utf-8\");\n        resp.setCharacterEncoding(\"utf-8\");\n\n        PrintWriter out = resp.getWriter();\n\n        //Cookie，服务器端从客户端获取时\n        Cookie[] cookies = req.getCookies();  //这里返回数组，说明cookies可能存在多个\n        //判断Cookies是否存在\n        if (cookies!=null) {\n            //如果cookies存在\n            out.write(\"你上一次访问的时间是：\");\n\n            for (int i = 0; i < cookies.length; i++) {\n                Cookie cookie = cookies[i];\n                //获取cookie的值 cookie.getValue();\n                if (cookie.getName().equals(\"LastLoginTime\")) {\n                    //获取cookie的名字\n                    long l = Long.parseLong(cookie.getValue());\n                    Date date = new Date(l);\n                    out.print(date.toLocaleString());\n                }\n\n            }\n        }else {\n            out.write(\"这是你第一次访问本站\");\n        }\n        // 服务器给客户端响应一个cookie\n        Cookie cookie = new Cookie(\"LastLoginTime\", System.currentTimeMillis()+\"\");\n\n        //设置cookie有效期，关闭浏览器不会删除cookie\n        cookie.setMaxAge(24*60*60);\n        //响应给客户端一个cookie，可以多个\n        /*\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        */\n        resp.addCookie(cookie);\n    }\n```\n\ncookie：一般会保存在本地的用户目录下 appdata:\n\n一个网站的 cookie 是否存在上限！**细节问题**\n\n- 一个 cookie 只能保存一个信息；\n- 一个 web 站点/域名可以给浏览器发送多个 cookie，最多存放 20 个；\n- 所有 cookie 总大小不超出 4kb;\n- 浏览器总共能储存 300 个 cookie；\n- 具体情况根据浏览器不同会有不同限制；\n\n删除 cookie：\n\n- 不设置有效期，关闭浏览器，自动失效；\n- 设置有效期时间为 0；\n\nPS：解码的一个方法\n\n```java\nURLDecoder.decode(String s, \"UTF-8\");\n```\n\n## Session (重点)\n\n什么是 Session：\n\n- 服务器会给每一个用户（浏览器）创建一个 session 对象；\n- 一个 session 独占一个浏览器，只要浏览器没有关闭，这个 session 就存在；\n- 用户登录之后，整个网站他都可以访问！-->保存用户信息，保存购物车的信息......\n\nSession 和 cookie 的区别：\n\n- Cookie 是把用户的数据写给用户的浏览器，浏览器保存（可以保存）；\n- Session 把用户的数据写到用户独占 session 中，服务器端保存；（减少服务器资源的浪费）\n- Session 对象由服务创建；\n\n使用场景：\n\n- 保存一个登录用户的信息；\n- 购物车信息；\n- 在整个网站中经常会使用的数据，我们将它保存在 session 中；\n\n使用 Session:\n\n```java\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //解决中文乱码\n        resp.setContentType(\"text/html；charset=utf-8\");\n        req.setCharacterEncoding(\"utf-8\");\n        resp.setCharacterEncoding(\"utf-8\");\n\n        //得到session\n        HttpSession session = req.getSession();\n        //给session中存东西\n        session.setAttribute(\"name\", new Person(\"秦疆\", 1));\n        //获取sessionID\n        String id = session.getId();\n        //判断session是否是新创建的\n        if (session.isNew()) {\n            resp.getWriter().write(\"session创建成功，ID\"+id);\n        } else {\n            resp.getWriter().write(\"session已经在服务器中存在，ID\"+id);\n        }\n    }\n```\n\n```java\n//得到session\nHttpSession session = req.getSession();\n//给session中存东西\nPerson person = (Person) session.getAttribute(\"name\");\nresp.getWriter().write(person.toString());\n```\n\n```java\n//移除session\nHttpSession session = req.getSession();\nsession.removeAttribute(\"name\");\n```\n\n```java\n  <!--设置session失效时间-->\n  <session-config>\n    <!--15分钟后失效，timeout以分钟为单位-->\n    <session-timeout>15</session-timeout>\n  </session-config>\n```\n\n# javaBean\n\n实体类\n\njavaBean 有特定的写法：\n\n- 必须要有一个无参构造；\n- 属性必须私有化；\n- 必须有对应的 get/set 方法；\n\n一般用来和数据库的字段做映射 ORM；\n\nORM 对象关系映射\n\n- 表->类\n- 字段->属性\n- 行记录->对象\n\n**people 表**\n\n| id  | name      | age | address |\n| --- | --------- | --- | ------- |\n| 1   | 秦疆 1 号 | 3   | 西安    |\n| 2   | 秦疆 2 号 | 18  | 西安    |\n| 3   | 秦疆 3 号 | 100 | 西安    |\n\n# MVC 三层架构\n\n什么是 MVC：model，view，controller 模型，视图，控制器\n\n![](img/article/JAVA-javaweb-20210430/20210430181656.png)\n\n用户直接访问控制层，控制层就可以直接操作数据库：\n\n```java\nservlet --CURD --->数据库\n弊端：程序十分臃肿，不利于维护\nservlet的代码中；处理请求、响应、视图跳转、处理JDBC，处理业务代码，处理逻辑代码\n\n架构：没有什么是加了一层解决不了的......\n```\n\nModel\n\n- 业务处理：业务逻辑（service）\n- 数据持久层：CURD （Dao）\n\nView\n\n- 展示数据\n- 提供链接发起 servlet 请求（a，form，img.......）\n\nController (Servlet)\n\n- 接收用户的请求：（req：请求参数、Session 信息......）\n- 交给业务层处理对应的代码\n- 控制视图的跳转\n\n```java\n登录 ---接受用户的请求 --- 处理用户的请求（获取用户登录的参数，username，password） --- 交给业务层处理登录业务（判断用户名密码是否正确：事务）--- Dao层查询用户名和密码是否正确 --- 数据库\n```\n\n# Filter\n\nFIlter：过滤器，用来过滤网站数据；\n\n- 处理中文乱码\n- 登录验证\n\n![](img/article/JAVA-javaweb-20210430/20210430200702.png)\n\n## Filter 开发步骤\n\n1. 导包\n\n2. 编写过滤器\n\n   ```java\n   package com.kuang.filter;\n\n   import javax.servlet.*;\n   import java.io.IOException;\n\n   public class CharacterEncodingFilter implements Filter {\n       //初始化\n       public void init(FilterConfig filterConfig) throws ServletException {\n           System.out.println(\"CharacterEncodingFilter初始化\");\n       }\n\n       //  chain（链）\n       /*\n       过滤中的所有代码，在过滤特定请求的时候都会执行\n       必须要让过滤器继续通行  chain.doFilter(request,response);\n        */\n       public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n           request.setCharacterEncoding(\"utf-8\");\n           response.setCharacterEncoding(\"utf-8\");\n           response.setContentType(\"text/html;charset=utf-8\");\n           System.out.println(\"CharacterEncodingFilter执行前......\");\n           chain.doFilter(request,response);//让请求继续走，如果不写，程序会被这里拦截\n           System.out.println(\"CharacterEncodingFilter执行后......\");\n       }\n\n       //销毁\n       public void destroy() {\n           System.out.println(\"CharacterEncodingFilter销毁\");\n       }\n   }\n\n   ```\n\n3. 在 web.xml 中配置 Filter\n\n   ```java\n       <filter>\n           <filter-name>characterEncodingFilter</filter-name>\n           <filter-class>com.kuang.filter.CharacterEncodingFilter</filter-class>\n       </filter>\n\n       <filter-mapping>\n           <filter-name>characterEncodingFilter</filter-name>\n           <!--此访问路径（不是项目路径）下的任何请求，都会经过这个过滤器-->\n           <url-pattern>/servlet/*</url-pattern>\n       </filter-mapping>\n   ```\n\n4. **Filter 链**\n\n   ​ 在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称为一个 Filter 链。\n\n   ​ web 服务器根据 Filter 在 web.xml 中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第二个 filter，如果没有，则调用目标资源。\n\n# 监听器\n\n监听登录人数\n\n```java\npackage com.kuang.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\npublic class OnlineCountListener implements HttpSessionListener {\n    //创建session监听，看你的一举一动\n    //一旦创建session就会触发一次这个事践\n    public void sessionCreated(HttpSessionEvent se) {\n        ServletContext ctx = se.getSession().getServletContext();\n        Integer onlineCount = (Integer) ctx.getAttribute(\"OnlineCount\");\n        if (onlineCount==null) {\n            onlineCount = 1;\n        }else {\n            int count = onlineCount;\n            onlineCount = count + 1;\n        }\n        ctx.setAttribute(\"onlineCount\", onlineCount);\n    }\n    //销毁session监听\n    public void sessionDestroyed(HttpSessionEvent se) {\n\n    }\n}\n\n```\n\n```java\n<listener>\n    <listener-class>com.kuang.listener.OnlineCountListener</listener-class>\n</listener>\n<session-config>\n    <session-timeout>1</session-timeout>\n</session-config>\n```\n\n# 过滤器监听器常见应用\n\n用户登录后才能进入主页！用户注销后就不能进入主页了！\n\n1. 用户登录之后，向 session 中放入用户的数据；\n2. 进入主页的时候要判断用户是否已经登录；下面：在过滤器中实现；\n\n```java\npackage com.kuang.filter;\n\nimport com.kuang.utils.Constant;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SysFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) resp;\n\n        if (request.getSession().getAttribute(Constant.USER_SESSION)==null){\n            response.sendRedirect(\"/sys/Error.jsp\");\n        }\n\n        chain.doFilter(req,resp);\n    }\n    public void destroy() {\n    }\n}\n```\n\n# Junit 测试\n\n`@Test`注解\n\n只能在单元测试代码中使用\n","slug":"JAVA-javaweb-20210430","published":1,"updated":"2022-06-14T04:09:00.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1a000vy4w14xqh76ec","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>web 开发：</p>\n<ul>\n<li>web，网页的意思，<a href=\"http://www.baidu.com/\">www.baidu.com</a></li>\n<li>静态 web<ul>\n<li>html,css</li>\n<li>提供给所有人看的数据始终不会发生变化！</li>\n<li>技术栈：servlet / JSP，ASP，PHP</li>\n</ul>\n</li>\n</ul>\n<p>在 java 中，动态 web 资源开发的技术统称为 JavaWeb</p>\n<h2 id=\"web-应用程序\"><a href=\"#web-应用程序\" class=\"headerlink\" title=\"web 应用程序\"></a>web 应用程序</h2><p>web 应用程序：可以提供浏览器访问的程序；</p>\n<ul>\n<li>a.html、b.html ….. 多个 web 资源，这些 web 资源可以被外界访问，对外界提供服务；</li>\n<li>你们能访问到的任何一个页面或者资源，都存在于这个世界上的某一角落的计算机上。</li>\n<li>URL</li>\n<li>这个统一的 web 资源会被放在同一个文件夹下，web 应用程序–&gt;Tomcat: 服务器</li>\n<li>一个 web 应用由多部分组成（静态 web，动态 web）<ul>\n<li>html，css，js</li>\n<li>jsp，servlet</li>\n<li>java 程序</li>\n<li>jar 包</li>\n<li>配置文件（properties）</li>\n</ul>\n</li>\n</ul>\n<p>web 应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>\n<h2 id=\"静态-web\"><a href=\"#静态-web\" class=\"headerlink\" title=\"静态 web\"></a>静态 web</h2><ul>\n<li><em>.html</em> 这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428131402.png\"></p>\n<ul>\n<li>静态 web 存在的缺点<ul>\n<li>web 页面无法动态更新，所有用户看到都是同一个页面<ul>\n<li>轮播图，点击特效；伪动态</li>\n<li>javaScript （实际开发中，它用的最多）</li>\n<li>VBScript</li>\n</ul>\n</li>\n<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态-web\"><a href=\"#动态-web\" class=\"headerlink\" title=\"动态 web\"></a>动态 web</h2><p>页面会动态展示：“web 的页面展示的效果因人而异”；</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428131746.png\"></p>\n<p>缺点：</p>\n<ul>\n<li>加入服务器的动态 web 资源出现了错误，我们需要重新编写我们的后台程序，重新发布；<ul>\n<li>停机维护</li>\n</ul>\n</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>Web 页面可以动态刷新，所有用户看到的都不是同一个页面</li>\n<li>他可以与数据库交互（数据持久化：注册，商品信息，用户信息……..）</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428132115.png\"></p>\n<h1 id=\"Web-服务器\"><a href=\"#Web-服务器\" class=\"headerlink\" title=\"Web 服务器\"></a>Web 服务器</h1><p>ASP:</p>\n<ul>\n<li>微软：国内最早流行的就是 ASP；</li>\n<li>在 HTML 中嵌入了 VB 的脚本，ASP + COM；</li>\n<li>在 ASP 开发中，基本一个页面都有几千行的代码业务，页面极其混乱</li>\n<li>维护成本高！</li>\n<li>C#</li>\n<li>LLS</li>\n</ul>\n<pre><code class=\"asp\">&lt;h1&gt;\n    &lt;h1&gt;&lt;h1&gt;\n        &lt;h1&gt;\n            &lt;h1&gt;\n                &lt;h1&gt;\n        &lt;h1&gt;\n            &lt;%\n            System.out.println(&quot;hello&quot;)\n                %&gt;\n            &lt;h1&gt;\n                &lt;h1&gt;\n    &lt;h1&gt;&lt;h1&gt;\n&lt;h1&gt;\n</code></pre>\n<p>php :</p>\n<ul>\n<li>php 开发速度很快，功能很强大，跨平台，代码简单（70%，WordPress）</li>\n<li>无法承载大访问量的情况（局限性）</li>\n</ul>\n<p>JSP/Servlet</p>\n<p>B/S: 浏览和服务器</p>\n<p>C/S: 客户端和服务器</p>\n<ul>\n<li>sun 公司主推的 B/S 架构</li>\n<li>基于 java 语言的（所有的大公司，或者一些开源的组件，都是用 java 写的）</li>\n<li>可以承载三高问题带来的影响；</li>\n<li>语法像 ASP， ASP—&gt;JSP，加强市场强度；</li>\n</ul>\n<p>……</p>\n<h2 id=\"web-服务器\"><a href=\"#web-服务器\" class=\"headerlink\" title=\"web 服务器\"></a>web 服务器</h2><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些影响信息；</p>\n<h3 id=\"IIS\"><a href=\"#IIS\" class=\"headerlink\" title=\"IIS\"></a>IIS</h3><p>微软的；ASP…, windows 中自带的</p>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><p>面向百度编程；</p>\n<p>Tomcat 是 Apache 软件基金会（Apache Software Foundation） 的 Jakarta 项目中的一个核心项目，最新的 Servlet 和 JSP 规范总是能在 Tomcat 中的到体现，因为 Tomcat 技术先进，性能稳定，而且免费，因而深受 java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 web 应用服务器。</p>\n<p>Tomcat 服务器是一个免费的开放源代码 web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 jsp 程序的首选。对于一个 java 初学 web 的人来说，它是最佳的选择。</p>\n<p>Tomcat 实际上运行 JSP 页面和 servlet。Tomcat 最新版本为 9.0。</p>\n<h1 id=\"Tomcat-1\"><a href=\"#Tomcat-1\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><h2 id=\"Tomcat-启动和配置\"><a href=\"#Tomcat-启动和配置\" class=\"headerlink\" title=\"Tomcat 启动和配置\"></a>Tomcat 启动和配置</h2><p>文件夹作用：</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428133849.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428133859.png\"></p>\n<p>可以配置启动的端口号</p>\n<ul>\n<li>tomcat 的默认端口号为：8080</li>\n<li>mysql: 3306</li>\n<li>http: 80</li>\n<li>https: 443</li>\n</ul>\n<pre><code class=\"xml\">&lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot;\n           port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;\n</code></pre>\n<p>可以配置主机的名称</p>\n<ul>\n<li>默认的主机名为：localhost-&gt;127.0.0.1</li>\n<li>默认网站应用存放的位置为：webapps</li>\n</ul>\n<pre><code class=\"xml\">&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;\n</code></pre>\n<p><strong>高难度面试题</strong>：</p>\n<p>请你谈谈网站是如何进行访问的！</p>\n<ol>\n<li><p>输入一个域名: 回车</p>\n</li>\n<li><p>检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts 配置文件下有没有这个域名映射：</p>\n<ol>\n<li><p>有：直接返回对应的 IP 地址，这个地址中，有我们需要访问的 web 程序，可以直接访问</p>\n<pre><code class=\"powershell\">192.30.255.112 github.com\n</code></pre>\n</li>\n<li><p>没有：去 DNS 服务器找，找到的话就返回，找不到就返回找不到：</p>\n</li>\n</ol>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428135406.png\"></p>\n</li>\n</ol>\n<h2 id=\"发布一个网站\"><a href=\"#发布一个网站\" class=\"headerlink\" title=\"发布一个网站\"></a>发布一个网站</h2><p>将自己写的网站，放到服务器（Tomcat）中指定的 Web 应用的文件夹（Wevapps）</p>\n<p>网站该有的结构</p>\n<pre><code>--webapps：Tomcat服务器的web目录\n    -ROOT\n    -kuangstudy：网站的目录名\n        -WEB-INF\n            -classes：java程序\n            -lib：web应用所依赖的jar包\n            -web.xml：网站配置文件\n        -index.html 默认的首页\n        -static\n            -css\n                -style.css\n            -js\n            -img\n        -......\n</code></pre>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"什么是-HTTP\"><a href=\"#什么是-HTTP\" class=\"headerlink\" title=\"什么是 HTTP\"></a>什么是 HTTP</h2><p>HTTP（超文本传输协议）是一个简单的请求-响应协议，他通常运行在 TCP 之上。</p>\n<ul>\n<li>文本：html，字符串，~……</li>\n<li>超文本：图片，音乐，视频，定位，地图……….</li>\n<li>默认端口：80</li>\n</ul>\n<p>HTTPS：安全的</p>\n<ul>\n<li>默认端口：443</li>\n</ul>\n<h2 id=\"两个时代\"><a href=\"#两个时代\" class=\"headerlink\" title=\"两个时代\"></a>两个时代</h2><ul>\n<li>http1.0<ul>\n<li>HTTP/1.0：客户端可以与 web 服务器连接后，只能获得一个 web 资源，断开连接</li>\n</ul>\n</li>\n<li>http2.0<ul>\n<li>HTTP/1.1：客户端可以与 web 服务器连接后，可以获得多个 web 资源</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a>HTTP 请求</h2><ul>\n<li>客户端—发送请求（Request）— 服务器</li>\n</ul>\n<p>百度：</p>\n<pre><code class=\"java\">Request URL:https://www.baidu.com/ 请求地址\nRequest Method:GET     get方法/post方法\nStatus Code:200 OK     状态码：200\nRemote （远程） Address：14.215.177.39:443\n</code></pre>\n<pre><code class=\"java\">Accpet:text/html\nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN, zh; q=0.9 语言\nCache-Control:max-age=0\nConnection:keep-alive\n</code></pre>\n<h3 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h3><ul>\n<li><p>请求行中的请求方式：get</p>\n</li>\n<li><p>请求方式：Get，Post，HEAD，DELETE，PUT，TRACT……</p>\n<ul>\n<li>get: 请求能够携带的参数比较少，大小有限制，会在浏览器的 URL 地址栏显示数据内容，不安全，但高效；</li>\n<li>post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的 URL 地址栏显示数据内容，安全，但不高效；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><pre><code class=\"java\">Accpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\n</code></pre>\n<h2 id=\"HTTP-响应\"><a href=\"#HTTP-响应\" class=\"headerlink\" title=\"HTTP 响应\"></a>HTTP 响应</h2><ul>\n<li>服务器—响应—客户端</li>\n</ul>\n<p>百度</p>\n<pre><code class=\"xml\">Cache-control:private  缓存控制\nConnection：Keep-Alive  连接\nContent-Encoding: gzip  编码\nContent-Type:text/html  类型\n</code></pre>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><pre><code class=\"java\">Accpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\nRefresh: 告诉客户端，多久刷新一次；\nLocation: 让网页重新定位；\n</code></pre>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>200：请求响应成功</p>\n<p>3xx：请求重定向</p>\n<p>4xx：找不到资源</p>\n<p>​ 资源不存在；</p>\n<p>5xx：服务器代码错误 500 502：网关错误</p>\n<p>常见面试题：</p>\n<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么?</p>\n<ol>\n<li>域名解析</li>\n<li>发起 TCP 的三次握手</li>\n<li>建立起 TCP 连接后发起 http 请求</li>\n<li>服务器响应 http 请求，浏览器得到 html 代码</li>\n<li>浏览器解析 html 代码，并请求 html 代码中的资源（css JavaScript 图片）</li>\n<li>浏览器对页面进行渲染呈现</li>\n<li>详细请参考:<a href=\"https://www.cnblogs.com/wupeixuan/p/8747918.html\">https://www.cnblogs.com/wupeixuan/p/8747918.html</a></li>\n</ol>\n<h1 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h1><p>为什么学习这个技术?</p>\n<ol>\n<li><p>在 javaweb 开发中, 需要使用大量的 jar 包,我们手动去导入;</p>\n</li>\n<li><p>如何能让一个东西自动帮我导入和配置这个 jar 包。</p>\n<p>由此,maven 诞生了。</p>\n</li>\n</ol>\n<h2 id=\"maven–项目架构管理工具\"><a href=\"#maven–项目架构管理工具\" class=\"headerlink\" title=\"maven–项目架构管理工具\"></a>maven–项目架构管理工具</h2><p>我们目前用来就是方便导入 jar 包的！</p>\n<p>Maven 的核心思想，<strong>约定大于配置</strong></p>\n<ul>\n<li>有约束，不要去违反。</li>\n</ul>\n<p>Maven 会规定好你该如何去编写我们的 java 代码，必须要按照这个规范来。</p>\n<h2 id=\"下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\"><a href=\"#下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\" class=\"headerlink\" title=\"下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\"></a>下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略</h2><h2 id=\"在-IDEA-中使用-Maven\"><a href=\"#在-IDEA-中使用-Maven\" class=\"headerlink\" title=\"在 IDEA 中使用 Maven\"></a>在 IDEA 中使用 Maven</h2><p>创建 maven 项目</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162308.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162631.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162806.png\"></p>\n<h2 id=\"创建一个普通的-maven-项目\"><a href=\"#创建一个普通的-maven-项目\" class=\"headerlink\" title=\"创建一个普通的 maven 项目\"></a>创建一个普通的 maven 项目</h2><p>不选模板创建</p>\n<p>一个干净的 maven 项目</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428170220.png\"></p>\n<p>webapp 文件夹只有在 web 应用下才会有！</p>\n<h2 id=\"标记文件夹目录\"><a href=\"#标记文件夹目录\" class=\"headerlink\" title=\"标记文件夹目录\"></a>标记文件夹目录</h2><p><img src=\"img/article/JAVA-javaweb-20210430/20210428170647.png\"></p>\n<p>方法二</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428171043.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428171331.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428172011.png\"></p>\n<h2 id=\"pom-文件\"><a href=\"#pom-文件\" class=\"headerlink\" title=\"pom 文件\"></a>pom 文件</h2><pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;!-- package 项目的打包方式\n   jar: java应用\n   war: javaWeb应用\n   --&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n\n  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;\n  &lt;!-- FIXME change it to the project&#39;s website --&gt;\n  &lt;url&gt;http://www.example.com&lt;/url&gt;\n\n  &lt;!-- 配置 --&gt;\n  &lt;properties&gt;\n    &lt;!-- 项目的默认构建编码 --&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;!-- 编码版本 --&gt;\n    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n\n  &lt;!-- 项目依赖 --&gt;\n  &lt;dependencies&gt;\n    &lt;!-- 具体依赖的jar包配置文件 --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;4.11&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n\n  &lt;!-- 项目构建用的东西 --&gt;\n  &lt;build&gt;\n    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;\n    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.1.0&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.0.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.8.0&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.22.1&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.2.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.5.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.8.2&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n    &lt;artifactId&gt;javaweb-01-maven02&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- maven的高级之处在于，他会帮你导入这个jar包所依赖的其他jar包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.11&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<h2 id=\"maven-无法导出或者生效的问题\"><a href=\"#maven-无法导出或者生效的问题\" class=\"headerlink\" title=\"maven 无法导出或者生效的问题\"></a>maven 无法导出或者生效的问题</h2><p>maven 由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p>\n<p>在 build 中配置 resources 节点，来防止我们资源导出失败的问题</p>\n<pre><code class=\"xml\">&lt;build&gt;\n    .......\n      &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;!--打包时该路径下过滤掉的--&gt;\n            &lt;excludes&gt;\n                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;\n                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;\n             &lt;/excludes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/java&lt;/directory&gt;\n            &lt;!--打包时该路径下留下的，其他过滤掉--&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**/*.properties&lt;/include&gt;\n                &lt;include&gt;**/*.xml&lt;/include&gt;\n            &lt;/includes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n    ......\n&lt;/build&gt;\n</code></pre>\n<h2 id=\"maven-默认-web-项目中的-web-xml-版本问题\"><a href=\"#maven-默认-web-项目中的-web-xml-版本问题\" class=\"headerlink\" title=\"maven 默认 web 项目中的 web.xml 版本问题\"></a>maven 默认 web 项目中的 web.xml 版本问题</h2><p>去 tomcat\\webapps\\ROOT\\WEB-INF\\web.xml 中复制，这里的是 tomcat 9.0 版本中的</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n  version=&quot;4.0&quot;\n  metadata-complete=&quot;true&quot;&gt;\n\n\n&lt;/web-app&gt;\n</code></pre>\n<h1 id=\"Serverlet\"><a href=\"#Serverlet\" class=\"headerlink\" title=\"Serverlet\"></a>Serverlet</h1><h2 id=\"servlet-简介\"><a href=\"#servlet-简介\" class=\"headerlink\" title=\"servlet 简介\"></a>servlet 简介</h2><ul>\n<li>serverlet 就是 sun 公司开发动态 web 的一门技术；</li>\n<li>sun 公司在这些 API 中提供一个接口叫做：Servlet，如果你想开发一个 servlet 程序，只需要完成两个小步骤：<ul>\n<li>编写一个类，实现 servlet 接口。</li>\n<li>把开发好的 java 类部署到 web 服务器中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>把实现了 Servlet 接口的 java 程序叫做，servlet</strong></p>\n<h2 id=\"HelloServlet\"><a href=\"#HelloServlet\" class=\"headerlink\" title=\"HelloServlet\"></a>HelloServlet</h2><p>Servlet 接口在 sun 公司有两个默认的实现类：HttpServlet GenericServlet</p>\n<ol>\n<li><p>构建一个普通 maven 项目，删掉其中的 src 目录，以后我们的学习就在这个项目里面建立 Moudel；这个空的工程就是 Maven 主工程；</p>\n</li>\n<li><p>关于 maven 父子工程的理解：</p>\n<ul>\n<li>父项目中会有</li>\n</ul>\n<pre><code class=\"xml\">&lt;modules&gt;\n        &lt;module&gt;servlet-01&lt;/module&gt;\n&lt;/modules&gt;\n</code></pre>\n<ul>\n<li>子项目会有</li>\n</ul>\n<pre><code class=\"xml\">&lt;parent&gt;\n        &lt;artifactId&gt;javaweb-servlet&lt;/artifactId&gt;\n        &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<p>父项目中的 java 子项目可以直接使用</p>\n<pre><code class=\"java\">son extends father\n</code></pre>\n</li>\n<li><p>Maven 环境优化</p>\n<ol>\n<li>修改<code>web.xml</code>为最新的</li>\n<li>将 maven 的结构搭建完整</li>\n</ol>\n</li>\n<li><p>编写一个 Servlet 程序</p>\n<ol>\n<li>编写一个普通类</li>\n<li>实现 Servlet 接口</li>\n<li>由于 get 或者 post 只是请求实现的不同方式，可以相互调用，业务逻辑都一样；</li>\n</ol>\n<pre><code class=\"java\">import javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class HelloServlet extends HttpServlet &#123;\n    //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        PrintWriter writer = resp.getWriter(); //响应流\n        writer.print(&quot;hello servlet&quot;);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doPost(req, resp);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>编写 servlet 的映射</p>\n<p>为什么需要映射，我们写的是 java 程序，但是要通过浏览器访问，而浏览器需要连接 Web 服务器，所以我们需要在 Web 服务器中注册我们写的 servlet，还需要给他一个浏览器能够访问到的路径；</p>\n</li>\n<li><p>配置 tomcat</p>\n</li>\n<li><p>启动测试</p>\n</li>\n</ol>\n<h2 id=\"Servlet-原理\"><a href=\"#Servlet-原理\" class=\"headerlink\" title=\"Servlet 原理\"></a>Servlet 原理</h2><p><img src=\"img/article/JAVA-javaweb-20210430/20210428201314.png\"></p>\n<h2 id=\"Mapping-问题\"><a href=\"#Mapping-问题\" class=\"headerlink\" title=\"Mapping 问题\"></a>Mapping 问题</h2><ol>\n<li><p>一个 servlet 可以指定一个映射路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>一个 servlet 可以指定对个映射路径</p>\n<pre><code class=\"xml\">&lt;!--注册servlet--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n    &lt;!--servlet的请求路径--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>一个 servlet 可以指定通用映射路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>默认请求路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>指定一些后缀或者前缀等等……</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n可以自定义\n&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.shan&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>优先级问题</p>\n<p>指定了固定的映射路径优先级最高，如果找不到就会走默认的处理请求</p>\n<pre><code class=\"xml\">    &lt;servlet&gt;\n        &lt;servlet-name&gt;errorServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;errorServlet&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n</ol>\n<p>一般都是一对一</p>\n<h2 id=\"ServletContext\"><a href=\"#ServletContext\" class=\"headerlink\" title=\"ServletContext\"></a>ServletContext</h2><p>web 容器在启动的时候，它会为每个 web 程序都创建一个对应的 ServletContext 对象，他代表了当前的 Web 应用：</p>\n<ul>\n<li><p>共享容器</p>\n<p>我在这个 servlet 中保存的数据，可以在另外一个 servlet 中拿到；（context.setAttribute(); context.getAttribute(); ）</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428230921.png\"></p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext context = this.getServletContext();\n        //this.getInitParameter();  //初始化参数\n        //this.getServletConfig();  //servlet配置\n        //this.getServletContext(); //servlet上下文\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        String username = &quot;秦疆&quot;;\n        context.setAttribute(&quot;username&quot;, username);\n    &#125;\n</code></pre>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        ServletContext context = this.getServletContext();\n        String username = (String) context.getAttribute(&quot;username&quot;);\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        resp.getWriter().print(&quot;名字&quot;+username);\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;servlet&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.GetServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"请求转发\"><a href=\"#请求转发\" class=\"headerlink\" title=\"请求转发\"></a>请求转发</h2><pre><code class=\"java\">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext context = this.getServletContext();\n        System.out.println(&quot;servlet&quot;);\n       // RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/servlet03&quot;); //请求转发的路径\n      //  requestDispatcher.forward(req,resp); //调用foward实现请求转发\n\n    context.getRequestDispatcher(&quot;/servlet03&quot;).forward(req,resp); //同上两行，调用foward实现请求转发\n    &#125;\n</code></pre>\n<h2 id=\"读取资源文件\"><a href=\"#读取资源文件\" class=\"headerlink\" title=\"读取资源文件\"></a>读取资源文件</h2><p>Properties</p>\n<ul>\n<li>在 java 目录下新建 properties</li>\n<li>在 resource 目录下新建 properties</li>\n</ul>\n<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为 classpath</p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);\n        Properties prop = new Properties();\n        prop.load(is);\n        String username = prop.getProperty(&quot;username&quot;);\n        String password = prop.getProperty(&quot;password&quot;);\n\n        resp.getWriter().print(username+&quot;:&quot;+password);\n    &#125;\n</code></pre>\n<p>访问测试都可 OK；</p>\n<h2 id=\"HttpServletResponse\"><a href=\"#HttpServletResponse\" class=\"headerlink\" title=\"HttpServletResponse\"></a>HttpServletResponse</h2><p>web 服务器接收到客户端的 HTTP 请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest 对象。代表相应的一个 HttpServletResponse；</p>\n<ul>\n<li>我们如果要获取客户端请求过来的参数；找 HttpServletRequest；</li>\n<li>如果要给客户响应一些信息；找 HttpServletResponse；</li>\n</ul>\n<h3 id=\"简单分类\"><a href=\"#简单分类\" class=\"headerlink\" title=\"简单分类\"></a>简单分类</h3><h4 id=\"负责向浏览器发送数据的办法\"><a href=\"#负责向浏览器发送数据的办法\" class=\"headerlink\" title=\"负责向浏览器发送数据的办法\"></a>负责向浏览器发送数据的办法</h4><pre><code class=\"java\">ServletOutputStream getOutputStream() throw IOException;\nPrintWriter getWriter() throws IOException;\n</code></pre>\n<h4 id=\"负责向浏览器发送响应头的方法\"><a href=\"#负责向浏览器发送响应头的方法\" class=\"headerlink\" title=\"负责向浏览器发送响应头的方法\"></a>负责向浏览器发送响应头的方法</h4><pre><code class=\"java\">(ServletResponse)\nvoid setCharacterEncoding(String charset);\nvoid setContentLength(int len);\nvoid setContentLengthLong(long len);\nvoid setContentType(String type);\n(HttpServletResponse)\nvoid setDateHeader(String name, long date);\nvoid addDateHeader(String name, long date);\nvoid setHeader(String name, String value);\nvoid addHeader(String name, String value);\nvoid setIntHeader(String name, int value);\nvoid addIntHeader(String name, int value);\n</code></pre>\n<h4 id=\"响应的状态码\"><a href=\"#响应的状态码\" class=\"headerlink\" title=\"响应的状态码\"></a>响应的状态码</h4><p>404…………………</p>\n<h4 id=\"常见应用\"><a href=\"#常见应用\" class=\"headerlink\" title=\"常见应用\"></a>常见应用</h4><ol>\n<li>向浏览器输出消息（前面内容）</li>\n<li>下载文件<ol>\n<li>要获取下载文件的路径</li>\n<li>下载的文件名是什么</li>\n<li>设置想办法让浏览器能够支持下载我们需要的东西</li>\n<li>获取下载文件的输入流</li>\n<li>创建缓冲区</li>\n<li>获取 OutputStream 对象</li>\n<li>将 FileOutputStream 流写入到 buffer 缓冲区</li>\n<li>使用 OutputStream 将缓冲区中的数据输出到客户端！</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //1. 要获取下载文件的路径\n        String realPath = &quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\javaweb-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png&quot;;\n        System.out.println(&quot;下载文件的路径：&quot;+realPath);\n        //2. 下载的文件名是什么\n        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;) + 1);\n        //3. 设置想办法让浏览器能够支持下载我们需要的东西\n        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName, &quot;utf-8&quot;));\n        //4. 获取下载文件的输入流\n        FileInputStream fileInputStream = new FileInputStream(realPath);\n        //5. 创建缓冲区\n        int len = 0;\n        byte[] buffer = new byte[1024];\n        //6. 获取OutputStream对象\n\n        ServletOutputStream outputStream = resp.getOutputStream();\n        //7. 将FileOutputStream流写入到buffer缓冲区\n        //8. 使用OutputStream将缓冲区中的数据输出到客户端！\n        while ((len=fileInputStream.read(buffer))&gt;0)&#123;\n            outputStream.write(buffer,0,len);\n        &#125;\n        fileInputStream.close();\n        outputStream.close();\n    &#125;\n</code></pre>\n<h4 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h4><p>验证码怎么来的？</p>\n<ul>\n<li>前端实现</li>\n<li>后端实现、需要用到 java 的图片类，生产一个图片</li>\n</ul>\n<pre><code class=\"java\">public class ImageServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //如何让浏览器5秒自动刷新一次\n        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);\n\n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //的到图片\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n        //告诉浏览器这个请求用图片的方式打开\n        resp.setContentType(&quot;image/jpeg&quot;);\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader(&quot;expires&quot;,-1);\n        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);\n        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);\n        //把图片写给浏览器\n        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());\n    &#125;\n\n    private String makeNum() &#123;\n        Random random = new Random();\n        String num = random.nextInt(9999999)+&quot;&quot;;\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; 7-num.length(); i++) &#123;\n            sb.append(&quot;0&quot;);\n        &#125;\n        num = sb.toString() + num;\n        return num;\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doPost(req, resp);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"实现重定向\"><a href=\"#实现重定向\" class=\"headerlink\" title=\"实现重定向\"></a>实现重定向</h4><p>B 一个 Web 资源收到客户端 A 请求后，B 会通知 A 客户端去访问另外一个 Web 资源 C，这个过程叫做重定向；</p>\n<p>常见场景：</p>\n<ul>\n<li>用户登录</li>\n</ul>\n<pre><code class=\"java\">resp.sendRedirect(&quot;/index.jsp&quot;);\n</code></pre>\n<pre><code class=\"java\">resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);\n        resp.setStatus(302);\n</code></pre>\n<p>面试题：</p>\n<p>重定向和转发的区别？</p>\n<p>相同点</p>\n<ul>\n<li>页面都会实现跳转</li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>请求转发的时候，url 不会产生变化 307</li>\n<li>重定向的时候，URL 地址会发生变化 302</li>\n</ul>\n<h2 id=\"HttpServletRequest\"><a href=\"#HttpServletRequest\" class=\"headerlink\" title=\"HttpServletRequest\"></a>HttpServletRequest</h2><pre><code class=\"java\">@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        String username = req.getParameter(&quot;username&quot;);\n        String password = req.getParameter(&quot;password&quot;);\n        String[] hobbys = req.getParameterValues(&quot;hobby&quot;);\n\n        System.out.println(username);\n        System.out.println(password);\n        System.out.println(Arrays.toString(hobbys));\n\n        //通过请求转发\n        req.getRequestDispatcher(&quot;./success.jsp&quot;).forward(req, resp);\n    &#125;\n</code></pre>\n<h1 id=\"Cookie、Session\"><a href=\"#Cookie、Session\" class=\"headerlink\" title=\"Cookie、Session\"></a>Cookie、Session</h1><h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h2><p><strong>概念</strong>：用户打开一个浏览器，点击了很多超链接，访问了很多 Web 资源，关闭浏览器，这个过程称之为会话；</p>\n<p><strong>有状态会话</strong>：</p>\n<p>一个网站，怎么证明你来过？</p>\n<p>客户端 服务端</p>\n<ol>\n<li>服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookies</li>\n<li>服务端登记你来过了，下次你来的时候我来匹配你；session</li>\n</ol>\n<h2 id=\"保存会话的两种技术\"><a href=\"#保存会话的两种技术\" class=\"headerlink\" title=\"保存会话的两种技术\"></a>保存会话的两种技术</h2><p>cookie</p>\n<ul>\n<li>客户端技术（响应，请求）</li>\n</ul>\n<p>session</p>\n<ul>\n<li>服务端技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据放在 session 中！</li>\n</ul>\n<p>常见场景：网站登陆之后，下次不用登陆了，第二次访问直接就登上了！</p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><ol>\n<li>从请求中拿到 cookie 信息。</li>\n<li>服务器响应给客户端 cookie。</li>\n</ol>\n<p>各种常用方法：</p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //服务器，告诉你，你来的时间，把这个时间封装成一个信件，你下次带来，我就知道你来了\n        //解决中文乱码\n        resp.setContentType(&quot;text/html&quot;);\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        resp.setCharacterEncoding(&quot;utf-8&quot;);\n\n        PrintWriter out = resp.getWriter();\n\n        //Cookie，服务器端从客户端获取时\n        Cookie[] cookies = req.getCookies();  //这里返回数组，说明cookies可能存在多个\n        //判断Cookies是否存在\n        if (cookies!=null) &#123;\n            //如果cookies存在\n            out.write(&quot;你上一次访问的时间是：&quot;);\n\n            for (int i = 0; i &lt; cookies.length; i++) &#123;\n                Cookie cookie = cookies[i];\n                //获取cookie的值 cookie.getValue();\n                if (cookie.getName().equals(&quot;LastLoginTime&quot;)) &#123;\n                    //获取cookie的名字\n                    long l = Long.parseLong(cookie.getValue());\n                    Date date = new Date(l);\n                    out.print(date.toLocaleString());\n                &#125;\n\n            &#125;\n        &#125;else &#123;\n            out.write(&quot;这是你第一次访问本站&quot;);\n        &#125;\n        // 服务器给客户端响应一个cookie\n        Cookie cookie = new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);\n\n        //设置cookie有效期，关闭浏览器不会删除cookie\n        cookie.setMaxAge(24*60*60);\n        //响应给客户端一个cookie，可以多个\n        /*\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        */\n        resp.addCookie(cookie);\n    &#125;\n</code></pre>\n<p>cookie：一般会保存在本地的用户目录下 appdata:</p>\n<p>一个网站的 cookie 是否存在上限！<strong>细节问题</strong></p>\n<ul>\n<li>一个 cookie 只能保存一个信息；</li>\n<li>一个 web 站点/域名可以给浏览器发送多个 cookie，最多存放 20 个；</li>\n<li>所有 cookie 总大小不超出 4kb;</li>\n<li>浏览器总共能储存 300 个 cookie；</li>\n<li>具体情况根据浏览器不同会有不同限制；</li>\n</ul>\n<p>删除 cookie：</p>\n<ul>\n<li>不设置有效期，关闭浏览器，自动失效；</li>\n<li>设置有效期时间为 0；</li>\n</ul>\n<p>PS：解码的一个方法</p>\n<pre><code class=\"java\">URLDecoder.decode(String s, &quot;UTF-8&quot;);\n</code></pre>\n<h2 id=\"Session-重点\"><a href=\"#Session-重点\" class=\"headerlink\" title=\"Session (重点)\"></a>Session (重点)</h2><p>什么是 Session：</p>\n<ul>\n<li>服务器会给每一个用户（浏览器）创建一个 session 对象；</li>\n<li>一个 session 独占一个浏览器，只要浏览器没有关闭，这个 session 就存在；</li>\n<li>用户登录之后，整个网站他都可以访问！–&gt;保存用户信息，保存购物车的信息……</li>\n</ul>\n<p>Session 和 cookie 的区别：</p>\n<ul>\n<li>Cookie 是把用户的数据写给用户的浏览器，浏览器保存（可以保存）；</li>\n<li>Session 把用户的数据写到用户独占 session 中，服务器端保存；（减少服务器资源的浪费）</li>\n<li>Session 对象由服务创建；</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>保存一个登录用户的信息；</li>\n<li>购物车信息；</li>\n<li>在整个网站中经常会使用的数据，我们将它保存在 session 中；</li>\n</ul>\n<p>使用 Session:</p>\n<pre><code class=\"java\">    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //解决中文乱码\n        resp.setContentType(&quot;text/html；charset=utf-8&quot;);\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        resp.setCharacterEncoding(&quot;utf-8&quot;);\n\n        //得到session\n        HttpSession session = req.getSession();\n        //给session中存东西\n        session.setAttribute(&quot;name&quot;, new Person(&quot;秦疆&quot;, 1));\n        //获取sessionID\n        String id = session.getId();\n        //判断session是否是新创建的\n        if (session.isNew()) &#123;\n            resp.getWriter().write(&quot;session创建成功，ID&quot;+id);\n        &#125; else &#123;\n            resp.getWriter().write(&quot;session已经在服务器中存在，ID&quot;+id);\n        &#125;\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//得到session\nHttpSession session = req.getSession();\n//给session中存东西\nPerson person = (Person) session.getAttribute(&quot;name&quot;);\nresp.getWriter().write(person.toString());\n</code></pre>\n<pre><code class=\"java\">//移除session\nHttpSession session = req.getSession();\nsession.removeAttribute(&quot;name&quot;);\n</code></pre>\n<pre><code class=\"java\">  &lt;!--设置session失效时间--&gt;\n  &lt;session-config&gt;\n    &lt;!--15分钟后失效，timeout以分钟为单位--&gt;\n    &lt;session-timeout&gt;15&lt;/session-timeout&gt;\n  &lt;/session-config&gt;\n</code></pre>\n<h1 id=\"javaBean\"><a href=\"#javaBean\" class=\"headerlink\" title=\"javaBean\"></a>javaBean</h1><p>实体类</p>\n<p>javaBean 有特定的写法：</p>\n<ul>\n<li>必须要有一个无参构造；</li>\n<li>属性必须私有化；</li>\n<li>必须有对应的 get/set 方法；</li>\n</ul>\n<p>一般用来和数据库的字段做映射 ORM；</p>\n<p>ORM 对象关系映射</p>\n<ul>\n<li>表-&gt;类</li>\n<li>字段-&gt;属性</li>\n<li>行记录-&gt;对象</li>\n</ul>\n<p><strong>people 表</strong></p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n<th>address</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>秦疆 1 号</td>\n<td>3</td>\n<td>西安</td>\n</tr>\n<tr>\n<td>2</td>\n<td>秦疆 2 号</td>\n<td>18</td>\n<td>西安</td>\n</tr>\n<tr>\n<td>3</td>\n<td>秦疆 3 号</td>\n<td>100</td>\n<td>西安</td>\n</tr>\n</tbody></table>\n<h1 id=\"MVC-三层架构\"><a href=\"#MVC-三层架构\" class=\"headerlink\" title=\"MVC 三层架构\"></a>MVC 三层架构</h1><p>什么是 MVC：model，view，controller 模型，视图，控制器</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210430181656.png\"></p>\n<p>用户直接访问控制层，控制层就可以直接操作数据库：</p>\n<pre><code class=\"java\">servlet --CURD ---&gt;数据库\n弊端：程序十分臃肿，不利于维护\nservlet的代码中；处理请求、响应、视图跳转、处理JDBC，处理业务代码，处理逻辑代码\n\n架构：没有什么是加了一层解决不了的......\n</code></pre>\n<p>Model</p>\n<ul>\n<li>业务处理：业务逻辑（service）</li>\n<li>数据持久层：CURD （Dao）</li>\n</ul>\n<p>View</p>\n<ul>\n<li>展示数据</li>\n<li>提供链接发起 servlet 请求（a，form，img…….）</li>\n</ul>\n<p>Controller (Servlet)</p>\n<ul>\n<li>接收用户的请求：（req：请求参数、Session 信息……）</li>\n<li>交给业务层处理对应的代码</li>\n<li>控制视图的跳转</li>\n</ul>\n<pre><code class=\"java\">登录 ---接受用户的请求 --- 处理用户的请求（获取用户登录的参数，username，password） --- 交给业务层处理登录业务（判断用户名密码是否正确：事务）--- Dao层查询用户名和密码是否正确 --- 数据库\n</code></pre>\n<h1 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h1><p>FIlter：过滤器，用来过滤网站数据；</p>\n<ul>\n<li>处理中文乱码</li>\n<li>登录验证</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210430200702.png\"></p>\n<h2 id=\"Filter-开发步骤\"><a href=\"#Filter-开发步骤\" class=\"headerlink\" title=\"Filter 开发步骤\"></a>Filter 开发步骤</h2><ol>\n<li><p>导包</p>\n</li>\n<li><p>编写过滤器</p>\n<pre><code class=\"java\">package com.kuang.filter;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class CharacterEncodingFilter implements Filter &#123;\n    //初始化\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);\n    &#125;\n\n    //  chain（链）\n    /*\n    过滤中的所有代码，在过滤特定请求的时候都会执行\n    必须要让过滤器继续通行  chain.doFilter(request,response);\n     */\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        request.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setContentType(&quot;text/html;charset=utf-8&quot;);\n        System.out.println(&quot;CharacterEncodingFilter执行前......&quot;);\n        chain.doFilter(request,response);//让请求继续走，如果不写，程序会被这里拦截\n        System.out.println(&quot;CharacterEncodingFilter执行后......&quot;);\n    &#125;\n\n    //销毁\n    public void destroy() &#123;\n        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>在 web.xml 中配置 Filter</p>\n<pre><code class=\"java\">    &lt;filter&gt;\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;/filter&gt;\n\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n        &lt;!--此访问路径（不是项目路径）下的任何请求，都会经过这个过滤器--&gt;\n        &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n</code></pre>\n</li>\n<li><p><strong>Filter 链</strong></p>\n<p>​ 在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称为一个 Filter 链。</p>\n<p>​ web 服务器根据 Filter 在 web.xml 中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第二个 filter，如果没有，则调用目标资源。</p>\n</li>\n</ol>\n<h1 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h1><p>监听登录人数</p>\n<pre><code class=\"java\">package com.kuang.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\npublic class OnlineCountListener implements HttpSessionListener &#123;\n    //创建session监听，看你的一举一动\n    //一旦创建session就会触发一次这个事践\n    public void sessionCreated(HttpSessionEvent se) &#123;\n        ServletContext ctx = se.getSession().getServletContext();\n        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);\n        if (onlineCount==null) &#123;\n            onlineCount = 1;\n        &#125;else &#123;\n            int count = onlineCount;\n            onlineCount = count + 1;\n        &#125;\n        ctx.setAttribute(&quot;onlineCount&quot;, onlineCount);\n    &#125;\n    //销毁session监听\n    public void sessionDestroyed(HttpSessionEvent se) &#123;\n\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">&lt;listener&gt;\n    &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n&lt;session-config&gt;\n    &lt;session-timeout&gt;1&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n</code></pre>\n<h1 id=\"过滤器监听器常见应用\"><a href=\"#过滤器监听器常见应用\" class=\"headerlink\" title=\"过滤器监听器常见应用\"></a>过滤器监听器常见应用</h1><p>用户登录后才能进入主页！用户注销后就不能进入主页了！</p>\n<ol>\n<li>用户登录之后，向 session 中放入用户的数据；</li>\n<li>进入主页的时候要判断用户是否已经登录；下面：在过滤器中实现；</li>\n</ol>\n<pre><code class=\"java\">package com.kuang.filter;\n\nimport com.kuang.utils.Constant;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SysFilter implements Filter &#123;\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;\n\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) resp;\n\n        if (request.getSession().getAttribute(Constant.USER_SESSION)==null)&#123;\n            response.sendRedirect(&quot;/sys/Error.jsp&quot;);\n        &#125;\n\n        chain.doFilter(req,resp);\n    &#125;\n    public void destroy() &#123;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"Junit-测试\"><a href=\"#Junit-测试\" class=\"headerlink\" title=\"Junit 测试\"></a>Junit 测试</h1><p><code>@Test</code>注解</p>\n<p>只能在单元测试代码中使用</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>web 开发：</p>\n<ul>\n<li>web，网页的意思，<a href=\"http://www.baidu.com/\">www.baidu.com</a></li>\n<li>静态 web<ul>\n<li>html,css</li>\n<li>提供给所有人看的数据始终不会发生变化！</li>\n<li>技术栈：servlet / JSP，ASP，PHP</li>\n</ul>\n</li>\n</ul>\n<p>在 java 中，动态 web 资源开发的技术统称为 JavaWeb</p>\n<h2 id=\"web-应用程序\"><a href=\"#web-应用程序\" class=\"headerlink\" title=\"web 应用程序\"></a>web 应用程序</h2><p>web 应用程序：可以提供浏览器访问的程序；</p>\n<ul>\n<li>a.html、b.html ….. 多个 web 资源，这些 web 资源可以被外界访问，对外界提供服务；</li>\n<li>你们能访问到的任何一个页面或者资源，都存在于这个世界上的某一角落的计算机上。</li>\n<li>URL</li>\n<li>这个统一的 web 资源会被放在同一个文件夹下，web 应用程序–&gt;Tomcat: 服务器</li>\n<li>一个 web 应用由多部分组成（静态 web，动态 web）<ul>\n<li>html，css，js</li>\n<li>jsp，servlet</li>\n<li>java 程序</li>\n<li>jar 包</li>\n<li>配置文件（properties）</li>\n</ul>\n</li>\n</ul>\n<p>web 应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>\n<h2 id=\"静态-web\"><a href=\"#静态-web\" class=\"headerlink\" title=\"静态 web\"></a>静态 web</h2><ul>\n<li><em>.html</em> 这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428131402.png\"></p>\n<ul>\n<li>静态 web 存在的缺点<ul>\n<li>web 页面无法动态更新，所有用户看到都是同一个页面<ul>\n<li>轮播图，点击特效；伪动态</li>\n<li>javaScript （实际开发中，它用的最多）</li>\n<li>VBScript</li>\n</ul>\n</li>\n<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态-web\"><a href=\"#动态-web\" class=\"headerlink\" title=\"动态 web\"></a>动态 web</h2><p>页面会动态展示：“web 的页面展示的效果因人而异”；</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428131746.png\"></p>\n<p>缺点：</p>\n<ul>\n<li>加入服务器的动态 web 资源出现了错误，我们需要重新编写我们的后台程序，重新发布；<ul>\n<li>停机维护</li>\n</ul>\n</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>Web 页面可以动态刷新，所有用户看到的都不是同一个页面</li>\n<li>他可以与数据库交互（数据持久化：注册，商品信息，用户信息……..）</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428132115.png\"></p>\n<h1 id=\"Web-服务器\"><a href=\"#Web-服务器\" class=\"headerlink\" title=\"Web 服务器\"></a>Web 服务器</h1><p>ASP:</p>\n<ul>\n<li>微软：国内最早流行的就是 ASP；</li>\n<li>在 HTML 中嵌入了 VB 的脚本，ASP + COM；</li>\n<li>在 ASP 开发中，基本一个页面都有几千行的代码业务，页面极其混乱</li>\n<li>维护成本高！</li>\n<li>C#</li>\n<li>LLS</li>\n</ul>\n<pre><code class=\"asp\">&lt;h1&gt;\n    &lt;h1&gt;&lt;h1&gt;\n        &lt;h1&gt;\n            &lt;h1&gt;\n                &lt;h1&gt;\n        &lt;h1&gt;\n            &lt;%\n            System.out.println(&quot;hello&quot;)\n                %&gt;\n            &lt;h1&gt;\n                &lt;h1&gt;\n    &lt;h1&gt;&lt;h1&gt;\n&lt;h1&gt;\n</code></pre>\n<p>php :</p>\n<ul>\n<li>php 开发速度很快，功能很强大，跨平台，代码简单（70%，WordPress）</li>\n<li>无法承载大访问量的情况（局限性）</li>\n</ul>\n<p>JSP/Servlet</p>\n<p>B/S: 浏览和服务器</p>\n<p>C/S: 客户端和服务器</p>\n<ul>\n<li>sun 公司主推的 B/S 架构</li>\n<li>基于 java 语言的（所有的大公司，或者一些开源的组件，都是用 java 写的）</li>\n<li>可以承载三高问题带来的影响；</li>\n<li>语法像 ASP， ASP—&gt;JSP，加强市场强度；</li>\n</ul>\n<p>……</p>\n<h2 id=\"web-服务器\"><a href=\"#web-服务器\" class=\"headerlink\" title=\"web 服务器\"></a>web 服务器</h2><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些影响信息；</p>\n<h3 id=\"IIS\"><a href=\"#IIS\" class=\"headerlink\" title=\"IIS\"></a>IIS</h3><p>微软的；ASP…, windows 中自带的</p>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><p>面向百度编程；</p>\n<p>Tomcat 是 Apache 软件基金会（Apache Software Foundation） 的 Jakarta 项目中的一个核心项目，最新的 Servlet 和 JSP 规范总是能在 Tomcat 中的到体现，因为 Tomcat 技术先进，性能稳定，而且免费，因而深受 java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 web 应用服务器。</p>\n<p>Tomcat 服务器是一个免费的开放源代码 web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 jsp 程序的首选。对于一个 java 初学 web 的人来说，它是最佳的选择。</p>\n<p>Tomcat 实际上运行 JSP 页面和 servlet。Tomcat 最新版本为 9.0。</p>\n<h1 id=\"Tomcat-1\"><a href=\"#Tomcat-1\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><h2 id=\"Tomcat-启动和配置\"><a href=\"#Tomcat-启动和配置\" class=\"headerlink\" title=\"Tomcat 启动和配置\"></a>Tomcat 启动和配置</h2><p>文件夹作用：</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428133849.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428133859.png\"></p>\n<p>可以配置启动的端口号</p>\n<ul>\n<li>tomcat 的默认端口号为：8080</li>\n<li>mysql: 3306</li>\n<li>http: 80</li>\n<li>https: 443</li>\n</ul>\n<pre><code class=\"xml\">&lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot;\n           port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;\n</code></pre>\n<p>可以配置主机的名称</p>\n<ul>\n<li>默认的主机名为：localhost-&gt;127.0.0.1</li>\n<li>默认网站应用存放的位置为：webapps</li>\n</ul>\n<pre><code class=\"xml\">&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;\n</code></pre>\n<p><strong>高难度面试题</strong>：</p>\n<p>请你谈谈网站是如何进行访问的！</p>\n<ol>\n<li><p>输入一个域名: 回车</p>\n</li>\n<li><p>检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts 配置文件下有没有这个域名映射：</p>\n<ol>\n<li><p>有：直接返回对应的 IP 地址，这个地址中，有我们需要访问的 web 程序，可以直接访问</p>\n<pre><code class=\"powershell\">192.30.255.112 github.com\n</code></pre>\n</li>\n<li><p>没有：去 DNS 服务器找，找到的话就返回，找不到就返回找不到：</p>\n</li>\n</ol>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428135406.png\"></p>\n</li>\n</ol>\n<h2 id=\"发布一个网站\"><a href=\"#发布一个网站\" class=\"headerlink\" title=\"发布一个网站\"></a>发布一个网站</h2><p>将自己写的网站，放到服务器（Tomcat）中指定的 Web 应用的文件夹（Wevapps）</p>\n<p>网站该有的结构</p>\n<pre><code>--webapps：Tomcat服务器的web目录\n    -ROOT\n    -kuangstudy：网站的目录名\n        -WEB-INF\n            -classes：java程序\n            -lib：web应用所依赖的jar包\n            -web.xml：网站配置文件\n        -index.html 默认的首页\n        -static\n            -css\n                -style.css\n            -js\n            -img\n        -......\n</code></pre>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"什么是-HTTP\"><a href=\"#什么是-HTTP\" class=\"headerlink\" title=\"什么是 HTTP\"></a>什么是 HTTP</h2><p>HTTP（超文本传输协议）是一个简单的请求-响应协议，他通常运行在 TCP 之上。</p>\n<ul>\n<li>文本：html，字符串，~……</li>\n<li>超文本：图片，音乐，视频，定位，地图……….</li>\n<li>默认端口：80</li>\n</ul>\n<p>HTTPS：安全的</p>\n<ul>\n<li>默认端口：443</li>\n</ul>\n<h2 id=\"两个时代\"><a href=\"#两个时代\" class=\"headerlink\" title=\"两个时代\"></a>两个时代</h2><ul>\n<li>http1.0<ul>\n<li>HTTP/1.0：客户端可以与 web 服务器连接后，只能获得一个 web 资源，断开连接</li>\n</ul>\n</li>\n<li>http2.0<ul>\n<li>HTTP/1.1：客户端可以与 web 服务器连接后，可以获得多个 web 资源</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a>HTTP 请求</h2><ul>\n<li>客户端—发送请求（Request）— 服务器</li>\n</ul>\n<p>百度：</p>\n<pre><code class=\"java\">Request URL:https://www.baidu.com/ 请求地址\nRequest Method:GET     get方法/post方法\nStatus Code:200 OK     状态码：200\nRemote （远程） Address：14.215.177.39:443\n</code></pre>\n<pre><code class=\"java\">Accpet:text/html\nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN, zh; q=0.9 语言\nCache-Control:max-age=0\nConnection:keep-alive\n</code></pre>\n<h3 id=\"请求行\"><a href=\"#请求行\" class=\"headerlink\" title=\"请求行\"></a>请求行</h3><ul>\n<li><p>请求行中的请求方式：get</p>\n</li>\n<li><p>请求方式：Get，Post，HEAD，DELETE，PUT，TRACT……</p>\n<ul>\n<li>get: 请求能够携带的参数比较少，大小有限制，会在浏览器的 URL 地址栏显示数据内容，不安全，但高效；</li>\n<li>post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的 URL 地址栏显示数据内容，安全，但不高效；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><pre><code class=\"java\">Accpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\n</code></pre>\n<h2 id=\"HTTP-响应\"><a href=\"#HTTP-响应\" class=\"headerlink\" title=\"HTTP 响应\"></a>HTTP 响应</h2><ul>\n<li>服务器—响应—客户端</li>\n</ul>\n<p>百度</p>\n<pre><code class=\"xml\">Cache-control:private  缓存控制\nConnection：Keep-Alive  连接\nContent-Encoding: gzip  编码\nContent-Type:text/html  类型\n</code></pre>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><pre><code class=\"java\">Accpet: //告诉浏览器，它所支持的数据类型\nAccept-Encoding: //支持哪种编码格式 GBK UTF-8 GB-2312 ISO8859-1\nAccept-Language: //告诉浏览器，他的语言环境\nCache-Control:  //缓存控制\nConnection: //告诉浏览器，请求完成是断开还是保持连接\nHOST: 主机....../.\nRefresh: 告诉客户端，多久刷新一次；\nLocation: 让网页重新定位；\n</code></pre>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>200：请求响应成功</p>\n<p>3xx：请求重定向</p>\n<p>4xx：找不到资源</p>\n<p>​ 资源不存在；</p>\n<p>5xx：服务器代码错误 500 502：网关错误</p>\n<p>常见面试题：</p>\n<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么?</p>\n<ol>\n<li>域名解析</li>\n<li>发起 TCP 的三次握手</li>\n<li>建立起 TCP 连接后发起 http 请求</li>\n<li>服务器响应 http 请求，浏览器得到 html 代码</li>\n<li>浏览器解析 html 代码，并请求 html 代码中的资源（css JavaScript 图片）</li>\n<li>浏览器对页面进行渲染呈现</li>\n<li>详细请参考:<a href=\"https://www.cnblogs.com/wupeixuan/p/8747918.html\">https://www.cnblogs.com/wupeixuan/p/8747918.html</a></li>\n</ol>\n<h1 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h1><p>为什么学习这个技术?</p>\n<ol>\n<li><p>在 javaweb 开发中, 需要使用大量的 jar 包,我们手动去导入;</p>\n</li>\n<li><p>如何能让一个东西自动帮我导入和配置这个 jar 包。</p>\n<p>由此,maven 诞生了。</p>\n</li>\n</ol>\n<h2 id=\"maven–项目架构管理工具\"><a href=\"#maven–项目架构管理工具\" class=\"headerlink\" title=\"maven–项目架构管理工具\"></a>maven–项目架构管理工具</h2><p>我们目前用来就是方便导入 jar 包的！</p>\n<p>Maven 的核心思想，<strong>约定大于配置</strong></p>\n<ul>\n<li>有约束，不要去违反。</li>\n</ul>\n<p>Maven 会规定好你该如何去编写我们的 java 代码，必须要按照这个规范来。</p>\n<h2 id=\"下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\"><a href=\"#下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\" class=\"headerlink\" title=\"下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略\"></a>下载，安装，配置环境变量，配置国内镜像，配置本地仓库–略</h2><h2 id=\"在-IDEA-中使用-Maven\"><a href=\"#在-IDEA-中使用-Maven\" class=\"headerlink\" title=\"在 IDEA 中使用 Maven\"></a>在 IDEA 中使用 Maven</h2><p>创建 maven 项目</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162308.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162631.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428162806.png\"></p>\n<h2 id=\"创建一个普通的-maven-项目\"><a href=\"#创建一个普通的-maven-项目\" class=\"headerlink\" title=\"创建一个普通的 maven 项目\"></a>创建一个普通的 maven 项目</h2><p>不选模板创建</p>\n<p>一个干净的 maven 项目</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428170220.png\"></p>\n<p>webapp 文件夹只有在 web 应用下才会有！</p>\n<h2 id=\"标记文件夹目录\"><a href=\"#标记文件夹目录\" class=\"headerlink\" title=\"标记文件夹目录\"></a>标记文件夹目录</h2><p><img src=\"img/article/JAVA-javaweb-20210430/20210428170647.png\"></p>\n<p>方法二</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428171043.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428171331.png\"></p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428172011.png\"></p>\n<h2 id=\"pom-文件\"><a href=\"#pom-文件\" class=\"headerlink\" title=\"pom 文件\"></a>pom 文件</h2><pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n  &lt;artifactId&gt;javaweb-01-maven&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;!-- package 项目的打包方式\n   jar: java应用\n   war: javaWeb应用\n   --&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n\n  &lt;name&gt;javaweb-01-maven Maven Webapp&lt;/name&gt;\n  &lt;!-- FIXME change it to the project&#39;s website --&gt;\n  &lt;url&gt;http://www.example.com&lt;/url&gt;\n\n  &lt;!-- 配置 --&gt;\n  &lt;properties&gt;\n    &lt;!-- 项目的默认构建编码 --&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;!-- 编码版本 --&gt;\n    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n\n  &lt;!-- 项目依赖 --&gt;\n  &lt;dependencies&gt;\n    &lt;!-- 具体依赖的jar包配置文件 --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;/groupId&gt;\n      &lt;artifactId&gt;junit&lt;/artifactId&gt;\n      &lt;version&gt;4.11&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n\n  &lt;!-- 项目构建用的东西 --&gt;\n  &lt;build&gt;\n    &lt;finalName&gt;javaweb-01-maven&lt;/finalName&gt;\n    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.1.0&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.0.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.8.0&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.22.1&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.2.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.5.2&lt;/version&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.8.2&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n    &lt;artifactId&gt;javaweb-01-maven02&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- maven的高级之处在于，他会帮你导入这个jar包所依赖的其他jar包 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.11&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<h2 id=\"maven-无法导出或者生效的问题\"><a href=\"#maven-无法导出或者生效的问题\" class=\"headerlink\" title=\"maven 无法导出或者生效的问题\"></a>maven 无法导出或者生效的问题</h2><p>maven 由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p>\n<p>在 build 中配置 resources 节点，来防止我们资源导出失败的问题</p>\n<pre><code class=\"xml\">&lt;build&gt;\n    .......\n      &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;!--打包时该路径下过滤掉的--&gt;\n            &lt;excludes&gt;\n                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;\n                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;\n             &lt;/excludes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/java&lt;/directory&gt;\n            &lt;!--打包时该路径下留下的，其他过滤掉--&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**/*.properties&lt;/include&gt;\n                &lt;include&gt;**/*.xml&lt;/include&gt;\n            &lt;/includes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n    ......\n&lt;/build&gt;\n</code></pre>\n<h2 id=\"maven-默认-web-项目中的-web-xml-版本问题\"><a href=\"#maven-默认-web-项目中的-web-xml-版本问题\" class=\"headerlink\" title=\"maven 默认 web 项目中的 web.xml 版本问题\"></a>maven 默认 web 项目中的 web.xml 版本问题</h2><p>去 tomcat\\webapps\\ROOT\\WEB-INF\\web.xml 中复制，这里的是 tomcat 9.0 版本中的</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n  version=&quot;4.0&quot;\n  metadata-complete=&quot;true&quot;&gt;\n\n\n&lt;/web-app&gt;\n</code></pre>\n<h1 id=\"Serverlet\"><a href=\"#Serverlet\" class=\"headerlink\" title=\"Serverlet\"></a>Serverlet</h1><h2 id=\"servlet-简介\"><a href=\"#servlet-简介\" class=\"headerlink\" title=\"servlet 简介\"></a>servlet 简介</h2><ul>\n<li>serverlet 就是 sun 公司开发动态 web 的一门技术；</li>\n<li>sun 公司在这些 API 中提供一个接口叫做：Servlet，如果你想开发一个 servlet 程序，只需要完成两个小步骤：<ul>\n<li>编写一个类，实现 servlet 接口。</li>\n<li>把开发好的 java 类部署到 web 服务器中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>把实现了 Servlet 接口的 java 程序叫做，servlet</strong></p>\n<h2 id=\"HelloServlet\"><a href=\"#HelloServlet\" class=\"headerlink\" title=\"HelloServlet\"></a>HelloServlet</h2><p>Servlet 接口在 sun 公司有两个默认的实现类：HttpServlet GenericServlet</p>\n<ol>\n<li><p>构建一个普通 maven 项目，删掉其中的 src 目录，以后我们的学习就在这个项目里面建立 Moudel；这个空的工程就是 Maven 主工程；</p>\n</li>\n<li><p>关于 maven 父子工程的理解：</p>\n<ul>\n<li>父项目中会有</li>\n</ul>\n<pre><code class=\"xml\">&lt;modules&gt;\n        &lt;module&gt;servlet-01&lt;/module&gt;\n&lt;/modules&gt;\n</code></pre>\n<ul>\n<li>子项目会有</li>\n</ul>\n<pre><code class=\"xml\">&lt;parent&gt;\n        &lt;artifactId&gt;javaweb-servlet&lt;/artifactId&gt;\n        &lt;groupId&gt;com.kuang&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<p>父项目中的 java 子项目可以直接使用</p>\n<pre><code class=\"java\">son extends father\n</code></pre>\n</li>\n<li><p>Maven 环境优化</p>\n<ol>\n<li>修改<code>web.xml</code>为最新的</li>\n<li>将 maven 的结构搭建完整</li>\n</ol>\n</li>\n<li><p>编写一个 Servlet 程序</p>\n<ol>\n<li>编写一个普通类</li>\n<li>实现 Servlet 接口</li>\n<li>由于 get 或者 post 只是请求实现的不同方式，可以相互调用，业务逻辑都一样；</li>\n</ol>\n<pre><code class=\"java\">import javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class HelloServlet extends HttpServlet &#123;\n    //由于get或者post只是请求实现的不同方式，可以相互调用，业务逻辑都一样；\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        PrintWriter writer = resp.getWriter(); //响应流\n        writer.print(&quot;hello servlet&quot;);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doPost(req, resp);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>编写 servlet 的映射</p>\n<p>为什么需要映射，我们写的是 java 程序，但是要通过浏览器访问，而浏览器需要连接 Web 服务器，所以我们需要在 Web 服务器中注册我们写的 servlet，还需要给他一个浏览器能够访问到的路径；</p>\n</li>\n<li><p>配置 tomcat</p>\n</li>\n<li><p>启动测试</p>\n</li>\n</ol>\n<h2 id=\"Servlet-原理\"><a href=\"#Servlet-原理\" class=\"headerlink\" title=\"Servlet 原理\"></a>Servlet 原理</h2><p><img src=\"img/article/JAVA-javaweb-20210430/20210428201314.png\"></p>\n<h2 id=\"Mapping-问题\"><a href=\"#Mapping-问题\" class=\"headerlink\" title=\"Mapping 问题\"></a>Mapping 问题</h2><ol>\n<li><p>一个 servlet 可以指定一个映射路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>一个 servlet 可以指定对个映射路径</p>\n<pre><code class=\"xml\">&lt;!--注册servlet--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n    &lt;!--servlet的请求路径--&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello1&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>一个 servlet 可以指定通用映射路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>默认请求路径</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>指定一些后缀或者前缀等等……</p>\n<pre><code class=\"xml\">&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n可以自定义\n&lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.shan&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n<li><p>优先级问题</p>\n<p>指定了固定的映射路径优先级最高，如果找不到就会走默认的处理请求</p>\n<pre><code class=\"xml\">    &lt;servlet&gt;\n        &lt;servlet-name&gt;errorServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;errorServlet&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n</ol>\n<p>一般都是一对一</p>\n<h2 id=\"ServletContext\"><a href=\"#ServletContext\" class=\"headerlink\" title=\"ServletContext\"></a>ServletContext</h2><p>web 容器在启动的时候，它会为每个 web 程序都创建一个对应的 ServletContext 对象，他代表了当前的 Web 应用：</p>\n<ul>\n<li><p>共享容器</p>\n<p>我在这个 servlet 中保存的数据，可以在另外一个 servlet 中拿到；（context.setAttribute(); context.getAttribute(); ）</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210428230921.png\"></p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext context = this.getServletContext();\n        //this.getInitParameter();  //初始化参数\n        //this.getServletConfig();  //servlet配置\n        //this.getServletContext(); //servlet上下文\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        String username = &quot;秦疆&quot;;\n        context.setAttribute(&quot;username&quot;, username);\n    &#125;\n</code></pre>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        ServletContext context = this.getServletContext();\n        String username = (String) context.getAttribute(&quot;username&quot;);\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        resp.getWriter().print(&quot;名字&quot;+username);\n    &#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;servlet&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.kuang.servlet.GetServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;getc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"请求转发\"><a href=\"#请求转发\" class=\"headerlink\" title=\"请求转发\"></a>请求转发</h2><pre><code class=\"java\">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext context = this.getServletContext();\n        System.out.println(&quot;servlet&quot;);\n       // RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/servlet03&quot;); //请求转发的路径\n      //  requestDispatcher.forward(req,resp); //调用foward实现请求转发\n\n    context.getRequestDispatcher(&quot;/servlet03&quot;).forward(req,resp); //同上两行，调用foward实现请求转发\n    &#125;\n</code></pre>\n<h2 id=\"读取资源文件\"><a href=\"#读取资源文件\" class=\"headerlink\" title=\"读取资源文件\"></a>读取资源文件</h2><p>Properties</p>\n<ul>\n<li>在 java 目录下新建 properties</li>\n<li>在 resource 目录下新建 properties</li>\n</ul>\n<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为 classpath</p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.setContentType(&quot;text/html;charset=utf-8&quot;);\n        InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);\n        Properties prop = new Properties();\n        prop.load(is);\n        String username = prop.getProperty(&quot;username&quot;);\n        String password = prop.getProperty(&quot;password&quot;);\n\n        resp.getWriter().print(username+&quot;:&quot;+password);\n    &#125;\n</code></pre>\n<p>访问测试都可 OK；</p>\n<h2 id=\"HttpServletResponse\"><a href=\"#HttpServletResponse\" class=\"headerlink\" title=\"HttpServletResponse\"></a>HttpServletResponse</h2><p>web 服务器接收到客户端的 HTTP 请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest 对象。代表相应的一个 HttpServletResponse；</p>\n<ul>\n<li>我们如果要获取客户端请求过来的参数；找 HttpServletRequest；</li>\n<li>如果要给客户响应一些信息；找 HttpServletResponse；</li>\n</ul>\n<h3 id=\"简单分类\"><a href=\"#简单分类\" class=\"headerlink\" title=\"简单分类\"></a>简单分类</h3><h4 id=\"负责向浏览器发送数据的办法\"><a href=\"#负责向浏览器发送数据的办法\" class=\"headerlink\" title=\"负责向浏览器发送数据的办法\"></a>负责向浏览器发送数据的办法</h4><pre><code class=\"java\">ServletOutputStream getOutputStream() throw IOException;\nPrintWriter getWriter() throws IOException;\n</code></pre>\n<h4 id=\"负责向浏览器发送响应头的方法\"><a href=\"#负责向浏览器发送响应头的方法\" class=\"headerlink\" title=\"负责向浏览器发送响应头的方法\"></a>负责向浏览器发送响应头的方法</h4><pre><code class=\"java\">(ServletResponse)\nvoid setCharacterEncoding(String charset);\nvoid setContentLength(int len);\nvoid setContentLengthLong(long len);\nvoid setContentType(String type);\n(HttpServletResponse)\nvoid setDateHeader(String name, long date);\nvoid addDateHeader(String name, long date);\nvoid setHeader(String name, String value);\nvoid addHeader(String name, String value);\nvoid setIntHeader(String name, int value);\nvoid addIntHeader(String name, int value);\n</code></pre>\n<h4 id=\"响应的状态码\"><a href=\"#响应的状态码\" class=\"headerlink\" title=\"响应的状态码\"></a>响应的状态码</h4><p>404…………………</p>\n<h4 id=\"常见应用\"><a href=\"#常见应用\" class=\"headerlink\" title=\"常见应用\"></a>常见应用</h4><ol>\n<li>向浏览器输出消息（前面内容）</li>\n<li>下载文件<ol>\n<li>要获取下载文件的路径</li>\n<li>下载的文件名是什么</li>\n<li>设置想办法让浏览器能够支持下载我们需要的东西</li>\n<li>获取下载文件的输入流</li>\n<li>创建缓冲区</li>\n<li>获取 OutputStream 对象</li>\n<li>将 FileOutputStream 流写入到 buffer 缓冲区</li>\n<li>使用 OutputStream 将缓冲区中的数据输出到客户端！</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //1. 要获取下载文件的路径\n        String realPath = &quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\javaweb-servlet\\\\response\\\\src\\\\main\\\\resources\\\\1.png&quot;;\n        System.out.println(&quot;下载文件的路径：&quot;+realPath);\n        //2. 下载的文件名是什么\n        String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;) + 1);\n        //3. 设置想办法让浏览器能够支持下载我们需要的东西\n        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName, &quot;utf-8&quot;));\n        //4. 获取下载文件的输入流\n        FileInputStream fileInputStream = new FileInputStream(realPath);\n        //5. 创建缓冲区\n        int len = 0;\n        byte[] buffer = new byte[1024];\n        //6. 获取OutputStream对象\n\n        ServletOutputStream outputStream = resp.getOutputStream();\n        //7. 将FileOutputStream流写入到buffer缓冲区\n        //8. 使用OutputStream将缓冲区中的数据输出到客户端！\n        while ((len=fileInputStream.read(buffer))&gt;0)&#123;\n            outputStream.write(buffer,0,len);\n        &#125;\n        fileInputStream.close();\n        outputStream.close();\n    &#125;\n</code></pre>\n<h4 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h4><p>验证码怎么来的？</p>\n<ul>\n<li>前端实现</li>\n<li>后端实现、需要用到 java 的图片类，生产一个图片</li>\n</ul>\n<pre><code class=\"java\">public class ImageServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //如何让浏览器5秒自动刷新一次\n        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);\n\n        //在内存中创建一个图片\n        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\n        //的到图片\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        //设置图片的背景颜色\n        g.setColor(Color.white);\n        g.fillRect(0,0,80,20);\n        //给图片写数据\n        g.setColor(Color.BLUE);\n        g.setFont(new Font(null,Font.BOLD,20));\n        g.drawString(makeNum(),0,20);\n        //告诉浏览器这个请求用图片的方式打开\n        resp.setContentType(&quot;image/jpeg&quot;);\n        //网站存在缓存，不让浏览器缓存\n        resp.setDateHeader(&quot;expires&quot;,-1);\n        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);\n        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);\n        //把图片写给浏览器\n        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());\n    &#125;\n\n    private String makeNum() &#123;\n        Random random = new Random();\n        String num = random.nextInt(9999999)+&quot;&quot;;\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; 7-num.length(); i++) &#123;\n            sb.append(&quot;0&quot;);\n        &#125;\n        num = sb.toString() + num;\n        return num;\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doPost(req, resp);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"实现重定向\"><a href=\"#实现重定向\" class=\"headerlink\" title=\"实现重定向\"></a>实现重定向</h4><p>B 一个 Web 资源收到客户端 A 请求后，B 会通知 A 客户端去访问另外一个 Web 资源 C，这个过程叫做重定向；</p>\n<p>常见场景：</p>\n<ul>\n<li>用户登录</li>\n</ul>\n<pre><code class=\"java\">resp.sendRedirect(&quot;/index.jsp&quot;);\n</code></pre>\n<pre><code class=\"java\">resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);\n        resp.setStatus(302);\n</code></pre>\n<p>面试题：</p>\n<p>重定向和转发的区别？</p>\n<p>相同点</p>\n<ul>\n<li>页面都会实现跳转</li>\n</ul>\n<p>不同点</p>\n<ul>\n<li>请求转发的时候，url 不会产生变化 307</li>\n<li>重定向的时候，URL 地址会发生变化 302</li>\n</ul>\n<h2 id=\"HttpServletRequest\"><a href=\"#HttpServletRequest\" class=\"headerlink\" title=\"HttpServletRequest\"></a>HttpServletRequest</h2><pre><code class=\"java\">@Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        String username = req.getParameter(&quot;username&quot;);\n        String password = req.getParameter(&quot;password&quot;);\n        String[] hobbys = req.getParameterValues(&quot;hobby&quot;);\n\n        System.out.println(username);\n        System.out.println(password);\n        System.out.println(Arrays.toString(hobbys));\n\n        //通过请求转发\n        req.getRequestDispatcher(&quot;./success.jsp&quot;).forward(req, resp);\n    &#125;\n</code></pre>\n<h1 id=\"Cookie、Session\"><a href=\"#Cookie、Session\" class=\"headerlink\" title=\"Cookie、Session\"></a>Cookie、Session</h1><h2 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h2><p><strong>概念</strong>：用户打开一个浏览器，点击了很多超链接，访问了很多 Web 资源，关闭浏览器，这个过程称之为会话；</p>\n<p><strong>有状态会话</strong>：</p>\n<p>一个网站，怎么证明你来过？</p>\n<p>客户端 服务端</p>\n<ol>\n<li>服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookies</li>\n<li>服务端登记你来过了，下次你来的时候我来匹配你；session</li>\n</ol>\n<h2 id=\"保存会话的两种技术\"><a href=\"#保存会话的两种技术\" class=\"headerlink\" title=\"保存会话的两种技术\"></a>保存会话的两种技术</h2><p>cookie</p>\n<ul>\n<li>客户端技术（响应，请求）</li>\n</ul>\n<p>session</p>\n<ul>\n<li>服务端技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据放在 session 中！</li>\n</ul>\n<p>常见场景：网站登陆之后，下次不用登陆了，第二次访问直接就登上了！</p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><ol>\n<li>从请求中拿到 cookie 信息。</li>\n<li>服务器响应给客户端 cookie。</li>\n</ol>\n<p>各种常用方法：</p>\n<pre><code class=\"java\">@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //服务器，告诉你，你来的时间，把这个时间封装成一个信件，你下次带来，我就知道你来了\n        //解决中文乱码\n        resp.setContentType(&quot;text/html&quot;);\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        resp.setCharacterEncoding(&quot;utf-8&quot;);\n\n        PrintWriter out = resp.getWriter();\n\n        //Cookie，服务器端从客户端获取时\n        Cookie[] cookies = req.getCookies();  //这里返回数组，说明cookies可能存在多个\n        //判断Cookies是否存在\n        if (cookies!=null) &#123;\n            //如果cookies存在\n            out.write(&quot;你上一次访问的时间是：&quot;);\n\n            for (int i = 0; i &lt; cookies.length; i++) &#123;\n                Cookie cookie = cookies[i];\n                //获取cookie的值 cookie.getValue();\n                if (cookie.getName().equals(&quot;LastLoginTime&quot;)) &#123;\n                    //获取cookie的名字\n                    long l = Long.parseLong(cookie.getValue());\n                    Date date = new Date(l);\n                    out.print(date.toLocaleString());\n                &#125;\n\n            &#125;\n        &#125;else &#123;\n            out.write(&quot;这是你第一次访问本站&quot;);\n        &#125;\n        // 服务器给客户端响应一个cookie\n        Cookie cookie = new Cookie(&quot;LastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;);\n\n        //设置cookie有效期，关闭浏览器不会删除cookie\n        cookie.setMaxAge(24*60*60);\n        //响应给客户端一个cookie，可以多个\n        /*\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        resp.addCookie(cookie);\n        */\n        resp.addCookie(cookie);\n    &#125;\n</code></pre>\n<p>cookie：一般会保存在本地的用户目录下 appdata:</p>\n<p>一个网站的 cookie 是否存在上限！<strong>细节问题</strong></p>\n<ul>\n<li>一个 cookie 只能保存一个信息；</li>\n<li>一个 web 站点/域名可以给浏览器发送多个 cookie，最多存放 20 个；</li>\n<li>所有 cookie 总大小不超出 4kb;</li>\n<li>浏览器总共能储存 300 个 cookie；</li>\n<li>具体情况根据浏览器不同会有不同限制；</li>\n</ul>\n<p>删除 cookie：</p>\n<ul>\n<li>不设置有效期，关闭浏览器，自动失效；</li>\n<li>设置有效期时间为 0；</li>\n</ul>\n<p>PS：解码的一个方法</p>\n<pre><code class=\"java\">URLDecoder.decode(String s, &quot;UTF-8&quot;);\n</code></pre>\n<h2 id=\"Session-重点\"><a href=\"#Session-重点\" class=\"headerlink\" title=\"Session (重点)\"></a>Session (重点)</h2><p>什么是 Session：</p>\n<ul>\n<li>服务器会给每一个用户（浏览器）创建一个 session 对象；</li>\n<li>一个 session 独占一个浏览器，只要浏览器没有关闭，这个 session 就存在；</li>\n<li>用户登录之后，整个网站他都可以访问！–&gt;保存用户信息，保存购物车的信息……</li>\n</ul>\n<p>Session 和 cookie 的区别：</p>\n<ul>\n<li>Cookie 是把用户的数据写给用户的浏览器，浏览器保存（可以保存）；</li>\n<li>Session 把用户的数据写到用户独占 session 中，服务器端保存；（减少服务器资源的浪费）</li>\n<li>Session 对象由服务创建；</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>保存一个登录用户的信息；</li>\n<li>购物车信息；</li>\n<li>在整个网站中经常会使用的数据，我们将它保存在 session 中；</li>\n</ul>\n<p>使用 Session:</p>\n<pre><code class=\"java\">    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //解决中文乱码\n        resp.setContentType(&quot;text/html；charset=utf-8&quot;);\n        req.setCharacterEncoding(&quot;utf-8&quot;);\n        resp.setCharacterEncoding(&quot;utf-8&quot;);\n\n        //得到session\n        HttpSession session = req.getSession();\n        //给session中存东西\n        session.setAttribute(&quot;name&quot;, new Person(&quot;秦疆&quot;, 1));\n        //获取sessionID\n        String id = session.getId();\n        //判断session是否是新创建的\n        if (session.isNew()) &#123;\n            resp.getWriter().write(&quot;session创建成功，ID&quot;+id);\n        &#125; else &#123;\n            resp.getWriter().write(&quot;session已经在服务器中存在，ID&quot;+id);\n        &#125;\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//得到session\nHttpSession session = req.getSession();\n//给session中存东西\nPerson person = (Person) session.getAttribute(&quot;name&quot;);\nresp.getWriter().write(person.toString());\n</code></pre>\n<pre><code class=\"java\">//移除session\nHttpSession session = req.getSession();\nsession.removeAttribute(&quot;name&quot;);\n</code></pre>\n<pre><code class=\"java\">  &lt;!--设置session失效时间--&gt;\n  &lt;session-config&gt;\n    &lt;!--15分钟后失效，timeout以分钟为单位--&gt;\n    &lt;session-timeout&gt;15&lt;/session-timeout&gt;\n  &lt;/session-config&gt;\n</code></pre>\n<h1 id=\"javaBean\"><a href=\"#javaBean\" class=\"headerlink\" title=\"javaBean\"></a>javaBean</h1><p>实体类</p>\n<p>javaBean 有特定的写法：</p>\n<ul>\n<li>必须要有一个无参构造；</li>\n<li>属性必须私有化；</li>\n<li>必须有对应的 get/set 方法；</li>\n</ul>\n<p>一般用来和数据库的字段做映射 ORM；</p>\n<p>ORM 对象关系映射</p>\n<ul>\n<li>表-&gt;类</li>\n<li>字段-&gt;属性</li>\n<li>行记录-&gt;对象</li>\n</ul>\n<p><strong>people 表</strong></p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n<th>address</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>秦疆 1 号</td>\n<td>3</td>\n<td>西安</td>\n</tr>\n<tr>\n<td>2</td>\n<td>秦疆 2 号</td>\n<td>18</td>\n<td>西安</td>\n</tr>\n<tr>\n<td>3</td>\n<td>秦疆 3 号</td>\n<td>100</td>\n<td>西安</td>\n</tr>\n</tbody></table>\n<h1 id=\"MVC-三层架构\"><a href=\"#MVC-三层架构\" class=\"headerlink\" title=\"MVC 三层架构\"></a>MVC 三层架构</h1><p>什么是 MVC：model，view，controller 模型，视图，控制器</p>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210430181656.png\"></p>\n<p>用户直接访问控制层，控制层就可以直接操作数据库：</p>\n<pre><code class=\"java\">servlet --CURD ---&gt;数据库\n弊端：程序十分臃肿，不利于维护\nservlet的代码中；处理请求、响应、视图跳转、处理JDBC，处理业务代码，处理逻辑代码\n\n架构：没有什么是加了一层解决不了的......\n</code></pre>\n<p>Model</p>\n<ul>\n<li>业务处理：业务逻辑（service）</li>\n<li>数据持久层：CURD （Dao）</li>\n</ul>\n<p>View</p>\n<ul>\n<li>展示数据</li>\n<li>提供链接发起 servlet 请求（a，form，img…….）</li>\n</ul>\n<p>Controller (Servlet)</p>\n<ul>\n<li>接收用户的请求：（req：请求参数、Session 信息……）</li>\n<li>交给业务层处理对应的代码</li>\n<li>控制视图的跳转</li>\n</ul>\n<pre><code class=\"java\">登录 ---接受用户的请求 --- 处理用户的请求（获取用户登录的参数，username，password） --- 交给业务层处理登录业务（判断用户名密码是否正确：事务）--- Dao层查询用户名和密码是否正确 --- 数据库\n</code></pre>\n<h1 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h1><p>FIlter：过滤器，用来过滤网站数据；</p>\n<ul>\n<li>处理中文乱码</li>\n<li>登录验证</li>\n</ul>\n<p><img src=\"img/article/JAVA-javaweb-20210430/20210430200702.png\"></p>\n<h2 id=\"Filter-开发步骤\"><a href=\"#Filter-开发步骤\" class=\"headerlink\" title=\"Filter 开发步骤\"></a>Filter 开发步骤</h2><ol>\n<li><p>导包</p>\n</li>\n<li><p>编写过滤器</p>\n<pre><code class=\"java\">package com.kuang.filter;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class CharacterEncodingFilter implements Filter &#123;\n    //初始化\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);\n    &#125;\n\n    //  chain（链）\n    /*\n    过滤中的所有代码，在过滤特定请求的时候都会执行\n    必须要让过滤器继续通行  chain.doFilter(request,response);\n     */\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        request.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setCharacterEncoding(&quot;utf-8&quot;);\n        response.setContentType(&quot;text/html;charset=utf-8&quot;);\n        System.out.println(&quot;CharacterEncodingFilter执行前......&quot;);\n        chain.doFilter(request,response);//让请求继续走，如果不写，程序会被这里拦截\n        System.out.println(&quot;CharacterEncodingFilter执行后......&quot;);\n    &#125;\n\n    //销毁\n    public void destroy() &#123;\n        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>在 web.xml 中配置 Filter</p>\n<pre><code class=\"java\">    &lt;filter&gt;\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;/filter&gt;\n\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n        &lt;!--此访问路径（不是项目路径）下的任何请求，都会经过这个过滤器--&gt;\n        &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n</code></pre>\n</li>\n<li><p><strong>Filter 链</strong></p>\n<p>​ 在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称为一个 Filter 链。</p>\n<p>​ web 服务器根据 Filter 在 web.xml 中的注册顺序，决定先调用哪个 Filter，当第一个 Filter 的 doFilter 方法被调用时，web 服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，在 doFilter 方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有 filter，如果有，则调用第二个 filter，如果没有，则调用目标资源。</p>\n</li>\n</ol>\n<h1 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h1><p>监听登录人数</p>\n<pre><code class=\"java\">package com.kuang.listener;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\npublic class OnlineCountListener implements HttpSessionListener &#123;\n    //创建session监听，看你的一举一动\n    //一旦创建session就会触发一次这个事践\n    public void sessionCreated(HttpSessionEvent se) &#123;\n        ServletContext ctx = se.getSession().getServletContext();\n        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);\n        if (onlineCount==null) &#123;\n            onlineCount = 1;\n        &#125;else &#123;\n            int count = onlineCount;\n            onlineCount = count + 1;\n        &#125;\n        ctx.setAttribute(&quot;onlineCount&quot;, onlineCount);\n    &#125;\n    //销毁session监听\n    public void sessionDestroyed(HttpSessionEvent se) &#123;\n\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">&lt;listener&gt;\n    &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n&lt;session-config&gt;\n    &lt;session-timeout&gt;1&lt;/session-timeout&gt;\n&lt;/session-config&gt;\n</code></pre>\n<h1 id=\"过滤器监听器常见应用\"><a href=\"#过滤器监听器常见应用\" class=\"headerlink\" title=\"过滤器监听器常见应用\"></a>过滤器监听器常见应用</h1><p>用户登录后才能进入主页！用户注销后就不能进入主页了！</p>\n<ol>\n<li>用户登录之后，向 session 中放入用户的数据；</li>\n<li>进入主页的时候要判断用户是否已经登录；下面：在过滤器中实现；</li>\n</ol>\n<pre><code class=\"java\">package com.kuang.filter;\n\nimport com.kuang.utils.Constant;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class SysFilter implements Filter &#123;\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123;\n\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) resp;\n\n        if (request.getSession().getAttribute(Constant.USER_SESSION)==null)&#123;\n            response.sendRedirect(&quot;/sys/Error.jsp&quot;);\n        &#125;\n\n        chain.doFilter(req,resp);\n    &#125;\n    public void destroy() &#123;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"Junit-测试\"><a href=\"#Junit-测试\" class=\"headerlink\" title=\"Junit 测试\"></a>Junit 测试</h1><p><code>@Test</code>注解</p>\n<p>只能在单元测试代码中使用</p>"},{"title":"JAVA-基础","date":"2021-04-04T10:57:41.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n\n\n\n\n视频地址：https://www.kuangstudy.com/\n\n<!-- more -->\n\n# a++ a-- 先执行程序，再自增/减\n\n​       ++a --a 先自增/减，再执行程序\n\n\n\n# Math类 \n\n幂运算 2^3， double pow = Math.pow(3, 2);\n\n\n\n# 逻辑计算 与 &&、 或 ||、 非！\n\n\n\n# 短路运算:  A&&B, A为false时，B不执行\n\n\n\n# 位运算 与 或 取反  异或   &   |   ~   ^ 二进制运算  ，数字逻辑\n\nA= 0011 1100  B= 0000 1101\n\nA&B= 0000 1100   \n\n A|B= 0011 1101\n\nA^B= 0011 0011  \n\n~B= 1111 0010\n\n<<左移 等价于乘2   >>右移 等价于除2    \n\n  eg: 2x8 = 2x2x2x2 = 2<<3=16 \n\n\\>>>  正负取反\n\n\n\n# a+=b  同  a=a+b ,  a-=b  同 a=a-b\n\n\n\n#  字符串连接符 + \n\na = 10 b=20 \n\nprintln(\"\"+a+b);   \n\n结果：1020\n\nprintln(a+b+\"\")\n\n结果：30\n\n\n\n# 三元运算符\n\nx ? y : z\n\n如果 x==true ,结果为 y，否则结果为 z\n\neg: int sc = 58;\n\nString type = sc < 60 ? \"不及格\" : \"及格\"；\n\n\n\n# 包机制\n\ncom.rhyme.shanxin \n\n一般为域名倒置\n\nimport a.b.c.d;  不要用 【.*】，找方法时浪费资源\n\n《JAVA开发手册》 阿里\n\n\n\n# javadoc\n\n```java\n代码中\n\n/**\n* @author shanxin\n* @param name\n* @return\n* @throws Exception\n*/\npublic class abc throw excpetion{\n    \n}\njavadoc  -encoding UTF-8 -charset UTF-8 demo.java\n```\n\n\n\n# java可变参数\n\n1、在方法声明中，在指定类型后加一个省略号（int… a）。\n2、一个方法中只能指定一个可变参数，他必须是方法的最后一个参数，任何普通参数必须在它之前声明。\n3、可变参数的本事还是一个数组\n\n\n\n```java\npublic class Demo04 {\n    //    可变参数\n    public static void main(String[] args) {\n        Demo04 demo04 = new Demo04();\n        demo04.test(1,2,3,4,5,6);\n    }\n\n    public void test(int... i){\n        System.out.println(i[0]);\n        System.out.println(i[1]);\n        System.out.println(i[2]);\n        System.out.println(i[3]);\n        System.out.println(i[4]);\n        System.out.println(i[5]);\n    }\n}\n\n```\n\n\n\n# Arrays常用类\n\n数组string输出\n\n```java\nint[] arr；\nArrays.tostring(arr); \n```\n\n\n\n快速排序\n\n```java\nArrays.sort(arr);\n```\n\n\n\n# 面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\n\n\n\n# 静态方法、非静态方法\n\n```java\n//静态方法，可直接调用\npublic static void say(){\n    System.out.println();\n}\n\n//非静态方法，通过new一个对象调用\npublic void shout(){\n\n}\n```\n\n\n\n两个都是静态方法，可以直接调用\n\n\n\n两个都是非静态方法，可以直接调用\n\n\n\n静态方法不能直接调用非静态方法，因为静态方法是和类一起加载的，时间线特别早，而非静态方法是new之后才存在的。\n\n\n\n# 一个项目应该只存在一个main方法，Application\n\n\n\n# 构造器\n\n1.和类名相同\n\n2.没有返回值\n\n\n\n作用：\n\n1. new 本质在调用构造方法;\n2. 初始化对象的值;\n\n\n\n**注意点**：\n\n1. 定义有参构造之后，如果想使用无参构造，现实的定义是一个无参的构造\n\n   \n\n# 封装 继承 多态\n\n1. 封装：高内聚，低耦合；高内聚，内部数据操作自己完成，不允许外部干涉；低耦合，仅暴露少量方法给外部使用。\n\n   数据的隐藏：通常，应禁止直接访问一个对象中的实际表示，而应该通过操作接口来访问； 属性私有，get/set  set方法内可以进行安全性控制，防止非法输入；\n\n2. 继承：（extends）java中只有单继承，没有多继承；\n\n   1. 继承是类和类之间的一种关系，除此之外类和类之间的关系还有依赖，组合，聚合等；\n\n   2. 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示；\n\n   3. 子类和父类之间，从意义上讲应该具有is a关系；\n\n   4. object类 ：所有类的父类，包括自己写的类；祖宗类~\n\n   5. super：子类通过super来访问父类的属性；无参构造方法有一个隐藏的super();\n\n      有参构造需要自己写super();\n\n   6. 方法重写：\n\n      1. 前提，需要有继承关系，子类重写父类的方法；\n         1. 方法名必须相同；\n         2. 参数列表必须相同；\n         3. 修饰符，范围可以扩大但不能缩小：public>protected>default>private;\n         4. 抛出异常：范围可以缩小但不能扩大：ClassNotFoundException-->Exception(大)\n      2. 子类的方法和父类必须一致，方法体不同；\n      3. 为什么要重写：\n         1. 父类的功能，子类不一定需要，或者不一定满足。\n\n3. 多态：即同一方法可以根据发送对象的不同而采用多种不同的行为方式；\n\n   一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类）；\n\n   1. 多态是方法的多态，属性没有多态；\n\n   2. 父类和子类，有联系，类型转换异常！ClassCastException！\n\n   3. 存在条件：继承关系，方法需要重写；父类引用指向子类对象！father f1 = new son()；\n\n      \n\n   4. 父类引用指向子类的对象；\n\n   5. 把子类转为父类，向上转型；\n\n   6. 把父类转换为子类，向下转型；强制转换（Person）student\n\n   7. 方便方法的调用，减少重复代码！简洁\n\n   \n\n\n\n# 修饰词\n\n| 修饰词            | 本类 | 同一个包的类 | 继承类 | 其他类 |\n| ----------------- | ---- | ------------ | ------ | ------ |\n| private           | √    | ×            | ×      | ×      |\n| 无（默认）default | √    | √            | ×      | ×      |\n| protected         | √    | √            | √      | ×      |\n| public            | √    | √            | √      | √      |\n\n\n\n# A instanceof B，判断A,B之间是否有父子关系\n\n\n\n# 修饰符\n\n1. static 静态修饰，程序第一次加载时就会运行，之后不会再次运行；\n\n```java\npackage com.shanxin.oop.demo06;\n\npublic class Person {\n    {\n        System.out.println(\"匿名代码块\");\n    }\n\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    public Person() {\n        System.out.println(\"构造方法\");\n    }\n\n    public static void main(String[] args) {\n        Person person1 = new Person();\n        System.out.println(\"=======================\");\n        Person person2 = new Person();\n    }\n}\n\n```\n\n静态导入包\n\n```java\npackage com.shanxin.oop.demo06;\n//静态导入包\nimport static java.lang.Math.random;\nimport static java.lang.Math.PI;\n\npublic class test {\n    public static void main(String[] args) {\n//        System.out.println(Math.random());\n//        System.out.println(Math.PI);\n\n        System.out.println(random());\n        System.out.println(PI);\n    }\n}\n\n```\n\n\n\n2. final  修饰常量 final a = 5; 常量表示不能改变的值；\n\n   修饰的类不能被继承\n\n   \n\n# 抽象类\n\n1. abstract修饰符可以用来修饰方法也可以用来修饰类，如果修饰方法，那么方法就是抽象方法；如果修饰类，那么方法就是就是抽象类；\n2. 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。\n3. 抽象类，不能使用new关键字来创建对象，它是用来让子类继承的；\n4. 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的；\n5. 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类；\n\n\n\n# 接口（可以实现多继承）\n\n1. 普通类：只有具体实现；\n2. 抽象类：具体实现和规范（抽象方法）都有!\n3. 接口：只有规范！自己无法写方法~专业的约束！约束和实现分离：面向接口编程~\n4. 借口就是规范，定义的是一组规则，体现了现实世界中的“如果你是。。。则必须能。。。”的思想，如果你是天使，则必须能飞，如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人。\n5. 接口的本质是契约，就像我们人间的法律一样，制定好后大家都遵守。\n6. OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针对具备了抽象能力的语言，就是因为设计模式所研究的，实际上就是如何合理地去抽象。\n7. 声明接口的关键字是class，声明扣扣的关键字是interface\n\n\n\n# 内部类\n\n```java\npackage com.shanxin.oop.demo09;\n\n//成员内部类\npublic class Outer {\n\n    private int id = 10;\n\n    public void out() {\n        System.out.println(\"这是外部类的方法\");\n    }\n\n    //成员内部类\n    class Inner {\n        public void in() {\n            System.out.println(\"这是成员内部类的方法\");\n        }\n\n        //获得外部类的私有属性~\n        public void getID() {\n            System.out.println(id);\n        }\n    }\n\n    //静态内部类\n    public static void B() {\n\n    }\n\n    //局部内部类\n    public void method() {\n        class Inner {\n            public void in() {\n                System.out.println(\"这是局部内部类的方法\");\n            }\n        }\n    }\n}\n\n//一个java类中可以有多个class类，但是只能有一个public class\n//可以在此写测试\n//多的一个类\nclass A {\n\n}\n\n=====================================================================\n\npackage com.shanxin.oop.demo09;\n\npublic class Application {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        //通过外部类实现内部类\n        outer.new Inner();\n\n        Outer.Inner inner = outer.new Inner();\n        inner.getID();\n\n\n        //没有名字初始化类，不用将示例保存到变量中~\n        //使用场景个，监听器，无限套娃~\n        new Apple().eat();\n    }\n}\n\nclass Apple{\n    public void eat() {\n        System.out.println(\"1\");\n    }\n}\n\ninterface UserService{\n\n}\n\n```\n\n\n\n# 异常 Exception 和 Error\n\n主要存在三种异常：\n\n1. 检查性异常 CheckedException：用户错误或问题引起的异常，例如打开不存在的文件，在编译时不能不简单的忽略。\n\n2. 运行时异常 RuntimeException:运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。\n\n3. 错误 Error: 脱离程序员控制的问题，错误在代码中通常被忽略。例如。当栈溢出时，一个错误就发生了，他们在编译时也检查不到。\n\n4. 异常处理框架：java把异常当做对象来处理，并定义了一个基类java.lang.Throwable作为所有异常的超类。javaAPI中已经定义了许多的异常类。这些异常分为两大类，错误Error和异常Exception。\n\n   \n\nError: \n\n1. Error类对象由java虚拟机生成并抛出，大多数错误代码与代码编写者所执行的操作无关；\n2. java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError,这些异常发生时，java虚拟机（JVM）一般会选择线程终止；\n3. 还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkedError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\nException：\n\n1. 在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n\n   1. ArrayIndexOutOfBoundsException  运行时异常\n   2. NullPointerException 空指针异常\n   3. ArithmeticException 算数异常\n   4. MissingResourceException 丢失资源\n   5. ClassNotFoundException 找不到类等异常，这些通常都是不检查异常，程序中可以选择捕获处理，也可以不处理。\n\n   这些异常一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生\n\n   \n\nError 和 Exception的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，java虚拟机（JVM）一般会选择终止线程；Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n\n\n\n# 异常处理机制\n\n抛出异常：throw ,throws\n\n捕获异常：try{}catch{}finally{}\n\n异常处理五个关键字\n\n​\ttry, catch, finally, throw, throws","source":"_posts/JAVA-基础.md","raw":"---\ntitle: JAVA-基础\ndate: 2021-04-04 18:57:41\ntags:\n- java基础\n- 狂神说\ncategories: \n- java\ncover:\n- https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n\n\n\n\n视频地址：https://www.kuangstudy.com/\n\n<!-- more -->\n\n# a++ a-- 先执行程序，再自增/减\n\n​       ++a --a 先自增/减，再执行程序\n\n\n\n# Math类 \n\n幂运算 2^3， double pow = Math.pow(3, 2);\n\n\n\n# 逻辑计算 与 &&、 或 ||、 非！\n\n\n\n# 短路运算:  A&&B, A为false时，B不执行\n\n\n\n# 位运算 与 或 取反  异或   &   |   ~   ^ 二进制运算  ，数字逻辑\n\nA= 0011 1100  B= 0000 1101\n\nA&B= 0000 1100   \n\n A|B= 0011 1101\n\nA^B= 0011 0011  \n\n~B= 1111 0010\n\n<<左移 等价于乘2   >>右移 等价于除2    \n\n  eg: 2x8 = 2x2x2x2 = 2<<3=16 \n\n\\>>>  正负取反\n\n\n\n# a+=b  同  a=a+b ,  a-=b  同 a=a-b\n\n\n\n#  字符串连接符 + \n\na = 10 b=20 \n\nprintln(\"\"+a+b);   \n\n结果：1020\n\nprintln(a+b+\"\")\n\n结果：30\n\n\n\n# 三元运算符\n\nx ? y : z\n\n如果 x==true ,结果为 y，否则结果为 z\n\neg: int sc = 58;\n\nString type = sc < 60 ? \"不及格\" : \"及格\"；\n\n\n\n# 包机制\n\ncom.rhyme.shanxin \n\n一般为域名倒置\n\nimport a.b.c.d;  不要用 【.*】，找方法时浪费资源\n\n《JAVA开发手册》 阿里\n\n\n\n# javadoc\n\n```java\n代码中\n\n/**\n* @author shanxin\n* @param name\n* @return\n* @throws Exception\n*/\npublic class abc throw excpetion{\n    \n}\njavadoc  -encoding UTF-8 -charset UTF-8 demo.java\n```\n\n\n\n# java可变参数\n\n1、在方法声明中，在指定类型后加一个省略号（int… a）。\n2、一个方法中只能指定一个可变参数，他必须是方法的最后一个参数，任何普通参数必须在它之前声明。\n3、可变参数的本事还是一个数组\n\n\n\n```java\npublic class Demo04 {\n    //    可变参数\n    public static void main(String[] args) {\n        Demo04 demo04 = new Demo04();\n        demo04.test(1,2,3,4,5,6);\n    }\n\n    public void test(int... i){\n        System.out.println(i[0]);\n        System.out.println(i[1]);\n        System.out.println(i[2]);\n        System.out.println(i[3]);\n        System.out.println(i[4]);\n        System.out.println(i[5]);\n    }\n}\n\n```\n\n\n\n# Arrays常用类\n\n数组string输出\n\n```java\nint[] arr；\nArrays.tostring(arr); \n```\n\n\n\n快速排序\n\n```java\nArrays.sort(arr);\n```\n\n\n\n# 面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\n\n\n\n# 静态方法、非静态方法\n\n```java\n//静态方法，可直接调用\npublic static void say(){\n    System.out.println();\n}\n\n//非静态方法，通过new一个对象调用\npublic void shout(){\n\n}\n```\n\n\n\n两个都是静态方法，可以直接调用\n\n\n\n两个都是非静态方法，可以直接调用\n\n\n\n静态方法不能直接调用非静态方法，因为静态方法是和类一起加载的，时间线特别早，而非静态方法是new之后才存在的。\n\n\n\n# 一个项目应该只存在一个main方法，Application\n\n\n\n# 构造器\n\n1.和类名相同\n\n2.没有返回值\n\n\n\n作用：\n\n1. new 本质在调用构造方法;\n2. 初始化对象的值;\n\n\n\n**注意点**：\n\n1. 定义有参构造之后，如果想使用无参构造，现实的定义是一个无参的构造\n\n   \n\n# 封装 继承 多态\n\n1. 封装：高内聚，低耦合；高内聚，内部数据操作自己完成，不允许外部干涉；低耦合，仅暴露少量方法给外部使用。\n\n   数据的隐藏：通常，应禁止直接访问一个对象中的实际表示，而应该通过操作接口来访问； 属性私有，get/set  set方法内可以进行安全性控制，防止非法输入；\n\n2. 继承：（extends）java中只有单继承，没有多继承；\n\n   1. 继承是类和类之间的一种关系，除此之外类和类之间的关系还有依赖，组合，聚合等；\n\n   2. 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示；\n\n   3. 子类和父类之间，从意义上讲应该具有is a关系；\n\n   4. object类 ：所有类的父类，包括自己写的类；祖宗类~\n\n   5. super：子类通过super来访问父类的属性；无参构造方法有一个隐藏的super();\n\n      有参构造需要自己写super();\n\n   6. 方法重写：\n\n      1. 前提，需要有继承关系，子类重写父类的方法；\n         1. 方法名必须相同；\n         2. 参数列表必须相同；\n         3. 修饰符，范围可以扩大但不能缩小：public>protected>default>private;\n         4. 抛出异常：范围可以缩小但不能扩大：ClassNotFoundException-->Exception(大)\n      2. 子类的方法和父类必须一致，方法体不同；\n      3. 为什么要重写：\n         1. 父类的功能，子类不一定需要，或者不一定满足。\n\n3. 多态：即同一方法可以根据发送对象的不同而采用多种不同的行为方式；\n\n   一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类）；\n\n   1. 多态是方法的多态，属性没有多态；\n\n   2. 父类和子类，有联系，类型转换异常！ClassCastException！\n\n   3. 存在条件：继承关系，方法需要重写；父类引用指向子类对象！father f1 = new son()；\n\n      \n\n   4. 父类引用指向子类的对象；\n\n   5. 把子类转为父类，向上转型；\n\n   6. 把父类转换为子类，向下转型；强制转换（Person）student\n\n   7. 方便方法的调用，减少重复代码！简洁\n\n   \n\n\n\n# 修饰词\n\n| 修饰词            | 本类 | 同一个包的类 | 继承类 | 其他类 |\n| ----------------- | ---- | ------------ | ------ | ------ |\n| private           | √    | ×            | ×      | ×      |\n| 无（默认）default | √    | √            | ×      | ×      |\n| protected         | √    | √            | √      | ×      |\n| public            | √    | √            | √      | √      |\n\n\n\n# A instanceof B，判断A,B之间是否有父子关系\n\n\n\n# 修饰符\n\n1. static 静态修饰，程序第一次加载时就会运行，之后不会再次运行；\n\n```java\npackage com.shanxin.oop.demo06;\n\npublic class Person {\n    {\n        System.out.println(\"匿名代码块\");\n    }\n\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    public Person() {\n        System.out.println(\"构造方法\");\n    }\n\n    public static void main(String[] args) {\n        Person person1 = new Person();\n        System.out.println(\"=======================\");\n        Person person2 = new Person();\n    }\n}\n\n```\n\n静态导入包\n\n```java\npackage com.shanxin.oop.demo06;\n//静态导入包\nimport static java.lang.Math.random;\nimport static java.lang.Math.PI;\n\npublic class test {\n    public static void main(String[] args) {\n//        System.out.println(Math.random());\n//        System.out.println(Math.PI);\n\n        System.out.println(random());\n        System.out.println(PI);\n    }\n}\n\n```\n\n\n\n2. final  修饰常量 final a = 5; 常量表示不能改变的值；\n\n   修饰的类不能被继承\n\n   \n\n# 抽象类\n\n1. abstract修饰符可以用来修饰方法也可以用来修饰类，如果修饰方法，那么方法就是抽象方法；如果修饰类，那么方法就是就是抽象类；\n2. 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。\n3. 抽象类，不能使用new关键字来创建对象，它是用来让子类继承的；\n4. 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的；\n5. 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类；\n\n\n\n# 接口（可以实现多继承）\n\n1. 普通类：只有具体实现；\n2. 抽象类：具体实现和规范（抽象方法）都有!\n3. 接口：只有规范！自己无法写方法~专业的约束！约束和实现分离：面向接口编程~\n4. 借口就是规范，定义的是一组规则，体现了现实世界中的“如果你是。。。则必须能。。。”的思想，如果你是天使，则必须能飞，如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人。\n5. 接口的本质是契约，就像我们人间的法律一样，制定好后大家都遵守。\n6. OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针对具备了抽象能力的语言，就是因为设计模式所研究的，实际上就是如何合理地去抽象。\n7. 声明接口的关键字是class，声明扣扣的关键字是interface\n\n\n\n# 内部类\n\n```java\npackage com.shanxin.oop.demo09;\n\n//成员内部类\npublic class Outer {\n\n    private int id = 10;\n\n    public void out() {\n        System.out.println(\"这是外部类的方法\");\n    }\n\n    //成员内部类\n    class Inner {\n        public void in() {\n            System.out.println(\"这是成员内部类的方法\");\n        }\n\n        //获得外部类的私有属性~\n        public void getID() {\n            System.out.println(id);\n        }\n    }\n\n    //静态内部类\n    public static void B() {\n\n    }\n\n    //局部内部类\n    public void method() {\n        class Inner {\n            public void in() {\n                System.out.println(\"这是局部内部类的方法\");\n            }\n        }\n    }\n}\n\n//一个java类中可以有多个class类，但是只能有一个public class\n//可以在此写测试\n//多的一个类\nclass A {\n\n}\n\n=====================================================================\n\npackage com.shanxin.oop.demo09;\n\npublic class Application {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        //通过外部类实现内部类\n        outer.new Inner();\n\n        Outer.Inner inner = outer.new Inner();\n        inner.getID();\n\n\n        //没有名字初始化类，不用将示例保存到变量中~\n        //使用场景个，监听器，无限套娃~\n        new Apple().eat();\n    }\n}\n\nclass Apple{\n    public void eat() {\n        System.out.println(\"1\");\n    }\n}\n\ninterface UserService{\n\n}\n\n```\n\n\n\n# 异常 Exception 和 Error\n\n主要存在三种异常：\n\n1. 检查性异常 CheckedException：用户错误或问题引起的异常，例如打开不存在的文件，在编译时不能不简单的忽略。\n\n2. 运行时异常 RuntimeException:运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。\n\n3. 错误 Error: 脱离程序员控制的问题，错误在代码中通常被忽略。例如。当栈溢出时，一个错误就发生了，他们在编译时也检查不到。\n\n4. 异常处理框架：java把异常当做对象来处理，并定义了一个基类java.lang.Throwable作为所有异常的超类。javaAPI中已经定义了许多的异常类。这些异常分为两大类，错误Error和异常Exception。\n\n   \n\nError: \n\n1. Error类对象由java虚拟机生成并抛出，大多数错误代码与代码编写者所执行的操作无关；\n2. java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError,这些异常发生时，java虚拟机（JVM）一般会选择线程终止；\n3. 还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkedError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\nException：\n\n1. 在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n\n   1. ArrayIndexOutOfBoundsException  运行时异常\n   2. NullPointerException 空指针异常\n   3. ArithmeticException 算数异常\n   4. MissingResourceException 丢失资源\n   5. ClassNotFoundException 找不到类等异常，这些通常都是不检查异常，程序中可以选择捕获处理，也可以不处理。\n\n   这些异常一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生\n\n   \n\nError 和 Exception的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，java虚拟机（JVM）一般会选择终止线程；Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n\n\n\n# 异常处理机制\n\n抛出异常：throw ,throws\n\n捕获异常：try{}catch{}finally{}\n\n异常处理五个关键字\n\n​\ttry, catch, finally, throw, throws","slug":"JAVA-基础","published":1,"updated":"2022-04-07T17:25:27.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1b000xy4w19a552abz","content":"<p>视频地址：<a href=\"https://www.kuangstudy.com/\">https://www.kuangstudy.com/</a></p>\n<span id=\"more\"></span>\n\n<h1 id=\"a-a–-先执行程序，再自增-减\"><a href=\"#a-a–-先执行程序，再自增-减\" class=\"headerlink\" title=\"a++ a– 先执行程序，再自增/减\"></a>a++ a– 先执行程序，再自增/减</h1><p>​       ++a –a 先自增/减，再执行程序</p>\n<h1 id=\"Math类\"><a href=\"#Math类\" class=\"headerlink\" title=\"Math类\"></a>Math类</h1><p>幂运算 2^3， double pow = Math.pow(3, 2);</p>\n<h1 id=\"逻辑计算-与-amp-amp-、-或-、-非！\"><a href=\"#逻辑计算-与-amp-amp-、-或-、-非！\" class=\"headerlink\" title=\"逻辑计算 与 &amp;&amp;、 或 ||、 非！\"></a>逻辑计算 与 &amp;&amp;、 或 ||、 非！</h1><h1 id=\"短路运算-A-amp-amp-B-A为false时，B不执行\"><a href=\"#短路运算-A-amp-amp-B-A为false时，B不执行\" class=\"headerlink\" title=\"短路运算:  A&amp;&amp;B, A为false时，B不执行\"></a>短路运算:  A&amp;&amp;B, A为false时，B不执行</h1><h1 id=\"位运算-与-或-取反-异或-amp-二进制运算-，数字逻辑\"><a href=\"#位运算-与-或-取反-异或-amp-二进制运算-，数字逻辑\" class=\"headerlink\" title=\"位运算 与 或 取反  异或   &amp;   |   ~   ^ 二进制运算  ，数字逻辑\"></a>位运算 与 或 取反  异或   &amp;   |   ~   ^ 二进制运算  ，数字逻辑</h1><p>A= 0011 1100  B= 0000 1101</p>\n<p>A&amp;B= 0000 1100   </p>\n<p> A|B= 0011 1101</p>\n<p>A^B= 0011 0011  </p>\n<p>~B= 1111 0010</p>\n<p>&lt;&lt;左移 等价于乘2   &gt;&gt;右移 等价于除2    </p>\n<p>  eg: 2x8 = 2x2x2x2 = 2&lt;&lt;3=16 </p>\n<p>&gt;&gt;&gt;  正负取反</p>\n<h1 id=\"a-b-同-a-a-b-a-b-同-a-a-b\"><a href=\"#a-b-同-a-a-b-a-b-同-a-a-b\" class=\"headerlink\" title=\"a+=b  同  a=a+b ,  a-=b  同 a=a-b\"></a>a+=b  同  a=a+b ,  a-=b  同 a=a-b</h1><h1 id=\"字符串连接符\"><a href=\"#字符串连接符\" class=\"headerlink\" title=\"字符串连接符 +\"></a>字符串连接符 +</h1><p>a = 10 b=20 </p>\n<p>println(“”+a+b);   </p>\n<p>结果：1020</p>\n<p>println(a+b+””)</p>\n<p>结果：30</p>\n<h1 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h1><p>x ? y : z</p>\n<p>如果 x==true ,结果为 y，否则结果为 z</p>\n<p>eg: int sc = 58;</p>\n<p>String type = sc &lt; 60 ? “不及格” : “及格”；</p>\n<h1 id=\"包机制\"><a href=\"#包机制\" class=\"headerlink\" title=\"包机制\"></a>包机制</h1><p>com.rhyme.shanxin </p>\n<p>一般为域名倒置</p>\n<p>import a.b.c.d;  不要用 【.*】，找方法时浪费资源</p>\n<p>《JAVA开发手册》 阿里</p>\n<h1 id=\"javadoc\"><a href=\"#javadoc\" class=\"headerlink\" title=\"javadoc\"></a>javadoc</h1><pre><code class=\"java\">代码中\n\n/**\n* @author shanxin\n* @param name\n* @return\n* @throws Exception\n*/\npublic class abc throw excpetion&#123;\n    \n&#125;\njavadoc  -encoding UTF-8 -charset UTF-8 demo.java\n</code></pre>\n<h1 id=\"java可变参数\"><a href=\"#java可变参数\" class=\"headerlink\" title=\"java可变参数\"></a>java可变参数</h1><p>1、在方法声明中，在指定类型后加一个省略号（int… a）。<br>2、一个方法中只能指定一个可变参数，他必须是方法的最后一个参数，任何普通参数必须在它之前声明。<br>3、可变参数的本事还是一个数组</p>\n<pre><code class=\"java\">public class Demo04 &#123;\n    //    可变参数\n    public static void main(String[] args) &#123;\n        Demo04 demo04 = new Demo04();\n        demo04.test(1,2,3,4,5,6);\n    &#125;\n\n    public void test(int... i)&#123;\n        System.out.println(i[0]);\n        System.out.println(i[1]);\n        System.out.println(i[2]);\n        System.out.println(i[3]);\n        System.out.println(i[4]);\n        System.out.println(i[5]);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"Arrays常用类\"><a href=\"#Arrays常用类\" class=\"headerlink\" title=\"Arrays常用类\"></a>Arrays常用类</h1><p>数组string输出</p>\n<pre><code class=\"java\">int[] arr；\nArrays.tostring(arr); \n</code></pre>\n<p>快速排序</p>\n<pre><code class=\"java\">Arrays.sort(arr);\n</code></pre>\n<h1 id=\"面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\"><a href=\"#面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\" class=\"headerlink\" title=\"面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\"></a>面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据</h1><h1 id=\"静态方法、非静态方法\"><a href=\"#静态方法、非静态方法\" class=\"headerlink\" title=\"静态方法、非静态方法\"></a>静态方法、非静态方法</h1><pre><code class=\"java\">//静态方法，可直接调用\npublic static void say()&#123;\n    System.out.println();\n&#125;\n\n//非静态方法，通过new一个对象调用\npublic void shout()&#123;\n\n&#125;\n</code></pre>\n<p>两个都是静态方法，可以直接调用</p>\n<p>两个都是非静态方法，可以直接调用</p>\n<p>静态方法不能直接调用非静态方法，因为静态方法是和类一起加载的，时间线特别早，而非静态方法是new之后才存在的。</p>\n<h1 id=\"一个项目应该只存在一个main方法，Application\"><a href=\"#一个项目应该只存在一个main方法，Application\" class=\"headerlink\" title=\"一个项目应该只存在一个main方法，Application\"></a>一个项目应该只存在一个main方法，Application</h1><h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><p>1.和类名相同</p>\n<p>2.没有返回值</p>\n<p>作用：</p>\n<ol>\n<li>new 本质在调用构造方法;</li>\n<li>初始化对象的值;</li>\n</ol>\n<p><strong>注意点</strong>：</p>\n<ol>\n<li>定义有参构造之后，如果想使用无参构造，现实的定义是一个无参的构造</li>\n</ol>\n<h1 id=\"封装-继承-多态\"><a href=\"#封装-继承-多态\" class=\"headerlink\" title=\"封装 继承 多态\"></a>封装 继承 多态</h1><ol>\n<li><p>封装：高内聚，低耦合；高内聚，内部数据操作自己完成，不允许外部干涉；低耦合，仅暴露少量方法给外部使用。</p>\n<p>数据的隐藏：通常，应禁止直接访问一个对象中的实际表示，而应该通过操作接口来访问； 属性私有，get/set  set方法内可以进行安全性控制，防止非法输入；</p>\n</li>\n<li><p>继承：（extends）java中只有单继承，没有多继承；</p>\n<ol>\n<li><p>继承是类和类之间的一种关系，除此之外类和类之间的关系还有依赖，组合，聚合等；</p>\n</li>\n<li><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示；</p>\n</li>\n<li><p>子类和父类之间，从意义上讲应该具有is a关系；</p>\n</li>\n<li><p>object类 ：所有类的父类，包括自己写的类；祖宗类~</p>\n</li>\n<li><p>super：子类通过super来访问父类的属性；无参构造方法有一个隐藏的super();</p>\n<p>有参构造需要自己写super();</p>\n</li>\n<li><p>方法重写：</p>\n<ol>\n<li>前提，需要有继承关系，子类重写父类的方法；<ol>\n<li>方法名必须相同；</li>\n<li>参数列表必须相同；</li>\n<li>修饰符，范围可以扩大但不能缩小：public&gt;protected&gt;default&gt;private;</li>\n<li>抛出异常：范围可以缩小但不能扩大：ClassNotFoundException–&gt;Exception(大)</li>\n</ol>\n</li>\n<li>子类的方法和父类必须一致，方法体不同；</li>\n<li>为什么要重写：<ol>\n<li>父类的功能，子类不一定需要，或者不一定满足。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>多态：即同一方法可以根据发送对象的不同而采用多种不同的行为方式；</p>\n<p>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类）；</p>\n<ol>\n<li><p>多态是方法的多态，属性没有多态；</p>\n</li>\n<li><p>父类和子类，有联系，类型转换异常！ClassCastException！</p>\n</li>\n<li><p>存在条件：继承关系，方法需要重写；父类引用指向子类对象！father f1 = new son()；</p>\n</li>\n<li><p>父类引用指向子类的对象；</p>\n</li>\n<li><p>把子类转为父类，向上转型；</p>\n</li>\n<li><p>把父类转换为子类，向下转型；强制转换（Person）student</p>\n</li>\n<li><p>方便方法的调用，减少重复代码！简洁</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"修饰词\"><a href=\"#修饰词\" class=\"headerlink\" title=\"修饰词\"></a>修饰词</h1><table>\n<thead>\n<tr>\n<th>修饰词</th>\n<th>本类</th>\n<th>同一个包的类</th>\n<th>继承类</th>\n<th>其他类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>private</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>无（默认）default</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody></table>\n<h1 id=\"A-instanceof-B，判断A-B之间是否有父子关系\"><a href=\"#A-instanceof-B，判断A-B之间是否有父子关系\" class=\"headerlink\" title=\"A instanceof B，判断A,B之间是否有父子关系\"></a>A instanceof B，判断A,B之间是否有父子关系</h1><h1 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h1><ol>\n<li>static 静态修饰，程序第一次加载时就会运行，之后不会再次运行；</li>\n</ol>\n<pre><code class=\"java\">package com.shanxin.oop.demo06;\n\npublic class Person &#123;\n    &#123;\n        System.out.println(&quot;匿名代码块&quot;);\n    &#125;\n\n    static &#123;\n        System.out.println(&quot;静态代码块&quot;);\n    &#125;\n\n    public Person() &#123;\n        System.out.println(&quot;构造方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Person person1 = new Person();\n        System.out.println(&quot;=======================&quot;);\n        Person person2 = new Person();\n    &#125;\n&#125;\n</code></pre>\n<p>静态导入包</p>\n<pre><code class=\"java\">package com.shanxin.oop.demo06;\n//静态导入包\nimport static java.lang.Math.random;\nimport static java.lang.Math.PI;\n\npublic class test &#123;\n    public static void main(String[] args) &#123;\n//        System.out.println(Math.random());\n//        System.out.println(Math.PI);\n\n        System.out.println(random());\n        System.out.println(PI);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li><p>final  修饰常量 final a = 5; 常量表示不能改变的值；</p>\n<p>修饰的类不能被继承</p>\n</li>\n</ol>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ol>\n<li>abstract修饰符可以用来修饰方法也可以用来修饰类，如果修饰方法，那么方法就是抽象方法；如果修饰类，那么方法就是就是抽象类；</li>\n<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li>\n<li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的；</li>\n<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的；</li>\n<li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类；</li>\n</ol>\n<h1 id=\"接口（可以实现多继承）\"><a href=\"#接口（可以实现多继承）\" class=\"headerlink\" title=\"接口（可以实现多继承）\"></a>接口（可以实现多继承）</h1><ol>\n<li>普通类：只有具体实现；</li>\n<li>抽象类：具体实现和规范（抽象方法）都有!</li>\n<li>接口：只有规范！自己无法写方法<del>专业的约束！约束和实现分离：面向接口编程</del></li>\n<li>借口就是规范，定义的是一组规则，体现了现实世界中的“如果你是。。。则必须能。。。”的思想，如果你是天使，则必须能飞，如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人。</li>\n<li>接口的本质是契约，就像我们人间的法律一样，制定好后大家都遵守。</li>\n<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针对具备了抽象能力的语言，就是因为设计模式所研究的，实际上就是如何合理地去抽象。</li>\n<li>声明接口的关键字是class，声明扣扣的关键字是interface</li>\n</ol>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><pre><code class=\"java\">package com.shanxin.oop.demo09;\n\n//成员内部类\npublic class Outer &#123;\n\n    private int id = 10;\n\n    public void out() &#123;\n        System.out.println(&quot;这是外部类的方法&quot;);\n    &#125;\n\n    //成员内部类\n    class Inner &#123;\n        public void in() &#123;\n            System.out.println(&quot;这是成员内部类的方法&quot;);\n        &#125;\n\n        //获得外部类的私有属性~\n        public void getID() &#123;\n            System.out.println(id);\n        &#125;\n    &#125;\n\n    //静态内部类\n    public static void B() &#123;\n\n    &#125;\n\n    //局部内部类\n    public void method() &#123;\n        class Inner &#123;\n            public void in() &#123;\n                System.out.println(&quot;这是局部内部类的方法&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n//一个java类中可以有多个class类，但是只能有一个public class\n//可以在此写测试\n//多的一个类\nclass A &#123;\n\n&#125;\n\n=====================================================================\n\npackage com.shanxin.oop.demo09;\n\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        Outer outer = new Outer();\n        //通过外部类实现内部类\n        outer.new Inner();\n\n        Outer.Inner inner = outer.new Inner();\n        inner.getID();\n\n\n        //没有名字初始化类，不用将示例保存到变量中~\n        //使用场景个，监听器，无限套娃~\n        new Apple().eat();\n    &#125;\n&#125;\n\nclass Apple&#123;\n    public void eat() &#123;\n        System.out.println(&quot;1&quot;);\n    &#125;\n&#125;\n\ninterface UserService&#123;\n\n&#125;\n</code></pre>\n<h1 id=\"异常-Exception-和-Error\"><a href=\"#异常-Exception-和-Error\" class=\"headerlink\" title=\"异常 Exception 和 Error\"></a>异常 Exception 和 Error</h1><p>主要存在三种异常：</p>\n<ol>\n<li><p>检查性异常 CheckedException：用户错误或问题引起的异常，例如打开不存在的文件，在编译时不能不简单的忽略。</p>\n</li>\n<li><p>运行时异常 RuntimeException:运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。</p>\n</li>\n<li><p>错误 Error: 脱离程序员控制的问题，错误在代码中通常被忽略。例如。当栈溢出时，一个错误就发生了，他们在编译时也检查不到。</p>\n</li>\n<li><p>异常处理框架：java把异常当做对象来处理，并定义了一个基类java.lang.Throwable作为所有异常的超类。javaAPI中已经定义了许多的异常类。这些异常分为两大类，错误Error和异常Exception。</p>\n</li>\n</ol>\n<p>Error: </p>\n<ol>\n<li>Error类对象由java虚拟机生成并抛出，大多数错误代码与代码编写者所执行的操作无关；</li>\n<li>java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError,这些异常发生时，java虚拟机（JVM）一般会选择线程终止；</li>\n<li>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkedError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>\n</ol>\n<p>Exception：</p>\n<ol>\n<li><p>在Exception分支中有一个重要的子类RuntimeException(运行时异常)</p>\n<ol>\n<li>ArrayIndexOutOfBoundsException  运行时异常</li>\n<li>NullPointerException 空指针异常</li>\n<li>ArithmeticException 算数异常</li>\n<li>MissingResourceException 丢失资源</li>\n<li>ClassNotFoundException 找不到类等异常，这些通常都是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>\n</ol>\n<p>这些异常一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</p>\n</li>\n</ol>\n<p>Error 和 Exception的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，java虚拟机（JVM）一般会选择终止线程；Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p>\n<h1 id=\"异常处理机制\"><a href=\"#异常处理机制\" class=\"headerlink\" title=\"异常处理机制\"></a>异常处理机制</h1><p>抛出异常：throw ,throws</p>\n<p>捕获异常：try{}catch{}finally{}</p>\n<p>异常处理五个关键字</p>\n<p>​    try, catch, finally, throw, throws</p>\n","site":{"data":{}},"excerpt":"<p>视频地址：<a href=\"https://www.kuangstudy.com/\">https://www.kuangstudy.com/</a></p>","more":"<h1 id=\"a-a–-先执行程序，再自增-减\"><a href=\"#a-a–-先执行程序，再自增-减\" class=\"headerlink\" title=\"a++ a– 先执行程序，再自增/减\"></a>a++ a– 先执行程序，再自增/减</h1><p>​       ++a –a 先自增/减，再执行程序</p>\n<h1 id=\"Math类\"><a href=\"#Math类\" class=\"headerlink\" title=\"Math类\"></a>Math类</h1><p>幂运算 2^3， double pow = Math.pow(3, 2);</p>\n<h1 id=\"逻辑计算-与-amp-amp-、-或-、-非！\"><a href=\"#逻辑计算-与-amp-amp-、-或-、-非！\" class=\"headerlink\" title=\"逻辑计算 与 &amp;&amp;、 或 ||、 非！\"></a>逻辑计算 与 &amp;&amp;、 或 ||、 非！</h1><h1 id=\"短路运算-A-amp-amp-B-A为false时，B不执行\"><a href=\"#短路运算-A-amp-amp-B-A为false时，B不执行\" class=\"headerlink\" title=\"短路运算:  A&amp;&amp;B, A为false时，B不执行\"></a>短路运算:  A&amp;&amp;B, A为false时，B不执行</h1><h1 id=\"位运算-与-或-取反-异或-amp-二进制运算-，数字逻辑\"><a href=\"#位运算-与-或-取反-异或-amp-二进制运算-，数字逻辑\" class=\"headerlink\" title=\"位运算 与 或 取反  异或   &amp;   |   ~   ^ 二进制运算  ，数字逻辑\"></a>位运算 与 或 取反  异或   &amp;   |   ~   ^ 二进制运算  ，数字逻辑</h1><p>A= 0011 1100  B= 0000 1101</p>\n<p>A&amp;B= 0000 1100   </p>\n<p> A|B= 0011 1101</p>\n<p>A^B= 0011 0011  </p>\n<p>~B= 1111 0010</p>\n<p>&lt;&lt;左移 等价于乘2   &gt;&gt;右移 等价于除2    </p>\n<p>  eg: 2x8 = 2x2x2x2 = 2&lt;&lt;3=16 </p>\n<p>&gt;&gt;&gt;  正负取反</p>\n<h1 id=\"a-b-同-a-a-b-a-b-同-a-a-b\"><a href=\"#a-b-同-a-a-b-a-b-同-a-a-b\" class=\"headerlink\" title=\"a+=b  同  a=a+b ,  a-=b  同 a=a-b\"></a>a+=b  同  a=a+b ,  a-=b  同 a=a-b</h1><h1 id=\"字符串连接符\"><a href=\"#字符串连接符\" class=\"headerlink\" title=\"字符串连接符 +\"></a>字符串连接符 +</h1><p>a = 10 b=20 </p>\n<p>println(“”+a+b);   </p>\n<p>结果：1020</p>\n<p>println(a+b+””)</p>\n<p>结果：30</p>\n<h1 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h1><p>x ? y : z</p>\n<p>如果 x==true ,结果为 y，否则结果为 z</p>\n<p>eg: int sc = 58;</p>\n<p>String type = sc &lt; 60 ? “不及格” : “及格”；</p>\n<h1 id=\"包机制\"><a href=\"#包机制\" class=\"headerlink\" title=\"包机制\"></a>包机制</h1><p>com.rhyme.shanxin </p>\n<p>一般为域名倒置</p>\n<p>import a.b.c.d;  不要用 【.*】，找方法时浪费资源</p>\n<p>《JAVA开发手册》 阿里</p>\n<h1 id=\"javadoc\"><a href=\"#javadoc\" class=\"headerlink\" title=\"javadoc\"></a>javadoc</h1><pre><code class=\"java\">代码中\n\n/**\n* @author shanxin\n* @param name\n* @return\n* @throws Exception\n*/\npublic class abc throw excpetion&#123;\n    \n&#125;\njavadoc  -encoding UTF-8 -charset UTF-8 demo.java\n</code></pre>\n<h1 id=\"java可变参数\"><a href=\"#java可变参数\" class=\"headerlink\" title=\"java可变参数\"></a>java可变参数</h1><p>1、在方法声明中，在指定类型后加一个省略号（int… a）。<br>2、一个方法中只能指定一个可变参数，他必须是方法的最后一个参数，任何普通参数必须在它之前声明。<br>3、可变参数的本事还是一个数组</p>\n<pre><code class=\"java\">public class Demo04 &#123;\n    //    可变参数\n    public static void main(String[] args) &#123;\n        Demo04 demo04 = new Demo04();\n        demo04.test(1,2,3,4,5,6);\n    &#125;\n\n    public void test(int... i)&#123;\n        System.out.println(i[0]);\n        System.out.println(i[1]);\n        System.out.println(i[2]);\n        System.out.println(i[3]);\n        System.out.println(i[4]);\n        System.out.println(i[5]);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"Arrays常用类\"><a href=\"#Arrays常用类\" class=\"headerlink\" title=\"Arrays常用类\"></a>Arrays常用类</h1><p>数组string输出</p>\n<pre><code class=\"java\">int[] arr；\nArrays.tostring(arr); \n</code></pre>\n<p>快速排序</p>\n<pre><code class=\"java\">Arrays.sort(arr);\n</code></pre>\n<h1 id=\"面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\"><a href=\"#面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\" class=\"headerlink\" title=\"面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据\"></a>面向对象的本质就是：以类的方法组织代码，以对象的方法组织（封装）数据</h1><h1 id=\"静态方法、非静态方法\"><a href=\"#静态方法、非静态方法\" class=\"headerlink\" title=\"静态方法、非静态方法\"></a>静态方法、非静态方法</h1><pre><code class=\"java\">//静态方法，可直接调用\npublic static void say()&#123;\n    System.out.println();\n&#125;\n\n//非静态方法，通过new一个对象调用\npublic void shout()&#123;\n\n&#125;\n</code></pre>\n<p>两个都是静态方法，可以直接调用</p>\n<p>两个都是非静态方法，可以直接调用</p>\n<p>静态方法不能直接调用非静态方法，因为静态方法是和类一起加载的，时间线特别早，而非静态方法是new之后才存在的。</p>\n<h1 id=\"一个项目应该只存在一个main方法，Application\"><a href=\"#一个项目应该只存在一个main方法，Application\" class=\"headerlink\" title=\"一个项目应该只存在一个main方法，Application\"></a>一个项目应该只存在一个main方法，Application</h1><h1 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h1><p>1.和类名相同</p>\n<p>2.没有返回值</p>\n<p>作用：</p>\n<ol>\n<li>new 本质在调用构造方法;</li>\n<li>初始化对象的值;</li>\n</ol>\n<p><strong>注意点</strong>：</p>\n<ol>\n<li>定义有参构造之后，如果想使用无参构造，现实的定义是一个无参的构造</li>\n</ol>\n<h1 id=\"封装-继承-多态\"><a href=\"#封装-继承-多态\" class=\"headerlink\" title=\"封装 继承 多态\"></a>封装 继承 多态</h1><ol>\n<li><p>封装：高内聚，低耦合；高内聚，内部数据操作自己完成，不允许外部干涉；低耦合，仅暴露少量方法给外部使用。</p>\n<p>数据的隐藏：通常，应禁止直接访问一个对象中的实际表示，而应该通过操作接口来访问； 属性私有，get/set  set方法内可以进行安全性控制，防止非法输入；</p>\n</li>\n<li><p>继承：（extends）java中只有单继承，没有多继承；</p>\n<ol>\n<li><p>继承是类和类之间的一种关系，除此之外类和类之间的关系还有依赖，组合，聚合等；</p>\n</li>\n<li><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示；</p>\n</li>\n<li><p>子类和父类之间，从意义上讲应该具有is a关系；</p>\n</li>\n<li><p>object类 ：所有类的父类，包括自己写的类；祖宗类~</p>\n</li>\n<li><p>super：子类通过super来访问父类的属性；无参构造方法有一个隐藏的super();</p>\n<p>有参构造需要自己写super();</p>\n</li>\n<li><p>方法重写：</p>\n<ol>\n<li>前提，需要有继承关系，子类重写父类的方法；<ol>\n<li>方法名必须相同；</li>\n<li>参数列表必须相同；</li>\n<li>修饰符，范围可以扩大但不能缩小：public&gt;protected&gt;default&gt;private;</li>\n<li>抛出异常：范围可以缩小但不能扩大：ClassNotFoundException–&gt;Exception(大)</li>\n</ol>\n</li>\n<li>子类的方法和父类必须一致，方法体不同；</li>\n<li>为什么要重写：<ol>\n<li>父类的功能，子类不一定需要，或者不一定满足。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>多态：即同一方法可以根据发送对象的不同而采用多种不同的行为方式；</p>\n<p>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类）；</p>\n<ol>\n<li><p>多态是方法的多态，属性没有多态；</p>\n</li>\n<li><p>父类和子类，有联系，类型转换异常！ClassCastException！</p>\n</li>\n<li><p>存在条件：继承关系，方法需要重写；父类引用指向子类对象！father f1 = new son()；</p>\n</li>\n<li><p>父类引用指向子类的对象；</p>\n</li>\n<li><p>把子类转为父类，向上转型；</p>\n</li>\n<li><p>把父类转换为子类，向下转型；强制转换（Person）student</p>\n</li>\n<li><p>方便方法的调用，减少重复代码！简洁</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"修饰词\"><a href=\"#修饰词\" class=\"headerlink\" title=\"修饰词\"></a>修饰词</h1><table>\n<thead>\n<tr>\n<th>修饰词</th>\n<th>本类</th>\n<th>同一个包的类</th>\n<th>继承类</th>\n<th>其他类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>private</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>无（默认）default</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>public</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody></table>\n<h1 id=\"A-instanceof-B，判断A-B之间是否有父子关系\"><a href=\"#A-instanceof-B，判断A-B之间是否有父子关系\" class=\"headerlink\" title=\"A instanceof B，判断A,B之间是否有父子关系\"></a>A instanceof B，判断A,B之间是否有父子关系</h1><h1 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h1><ol>\n<li>static 静态修饰，程序第一次加载时就会运行，之后不会再次运行；</li>\n</ol>\n<pre><code class=\"java\">package com.shanxin.oop.demo06;\n\npublic class Person &#123;\n    &#123;\n        System.out.println(&quot;匿名代码块&quot;);\n    &#125;\n\n    static &#123;\n        System.out.println(&quot;静态代码块&quot;);\n    &#125;\n\n    public Person() &#123;\n        System.out.println(&quot;构造方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Person person1 = new Person();\n        System.out.println(&quot;=======================&quot;);\n        Person person2 = new Person();\n    &#125;\n&#125;\n</code></pre>\n<p>静态导入包</p>\n<pre><code class=\"java\">package com.shanxin.oop.demo06;\n//静态导入包\nimport static java.lang.Math.random;\nimport static java.lang.Math.PI;\n\npublic class test &#123;\n    public static void main(String[] args) &#123;\n//        System.out.println(Math.random());\n//        System.out.println(Math.PI);\n\n        System.out.println(random());\n        System.out.println(PI);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li><p>final  修饰常量 final a = 5; 常量表示不能改变的值；</p>\n<p>修饰的类不能被继承</p>\n</li>\n</ol>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ol>\n<li>abstract修饰符可以用来修饰方法也可以用来修饰类，如果修饰方法，那么方法就是抽象方法；如果修饰类，那么方法就是就是抽象类；</li>\n<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li>\n<li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的；</li>\n<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的；</li>\n<li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类；</li>\n</ol>\n<h1 id=\"接口（可以实现多继承）\"><a href=\"#接口（可以实现多继承）\" class=\"headerlink\" title=\"接口（可以实现多继承）\"></a>接口（可以实现多继承）</h1><ol>\n<li>普通类：只有具体实现；</li>\n<li>抽象类：具体实现和规范（抽象方法）都有!</li>\n<li>接口：只有规范！自己无法写方法<del>专业的约束！约束和实现分离：面向接口编程</del></li>\n<li>借口就是规范，定义的是一组规则，体现了现实世界中的“如果你是。。。则必须能。。。”的思想，如果你是天使，则必须能飞，如果你是汽车，则必须能跑。如果你是好人，则必须干掉坏人。</li>\n<li>接口的本质是契约，就像我们人间的法律一样，制定好后大家都遵守。</li>\n<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口，为什么我们讨论设计模式都只针对具备了抽象能力的语言，就是因为设计模式所研究的，实际上就是如何合理地去抽象。</li>\n<li>声明接口的关键字是class，声明扣扣的关键字是interface</li>\n</ol>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><pre><code class=\"java\">package com.shanxin.oop.demo09;\n\n//成员内部类\npublic class Outer &#123;\n\n    private int id = 10;\n\n    public void out() &#123;\n        System.out.println(&quot;这是外部类的方法&quot;);\n    &#125;\n\n    //成员内部类\n    class Inner &#123;\n        public void in() &#123;\n            System.out.println(&quot;这是成员内部类的方法&quot;);\n        &#125;\n\n        //获得外部类的私有属性~\n        public void getID() &#123;\n            System.out.println(id);\n        &#125;\n    &#125;\n\n    //静态内部类\n    public static void B() &#123;\n\n    &#125;\n\n    //局部内部类\n    public void method() &#123;\n        class Inner &#123;\n            public void in() &#123;\n                System.out.println(&quot;这是局部内部类的方法&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n//一个java类中可以有多个class类，但是只能有一个public class\n//可以在此写测试\n//多的一个类\nclass A &#123;\n\n&#125;\n\n=====================================================================\n\npackage com.shanxin.oop.demo09;\n\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        Outer outer = new Outer();\n        //通过外部类实现内部类\n        outer.new Inner();\n\n        Outer.Inner inner = outer.new Inner();\n        inner.getID();\n\n\n        //没有名字初始化类，不用将示例保存到变量中~\n        //使用场景个，监听器，无限套娃~\n        new Apple().eat();\n    &#125;\n&#125;\n\nclass Apple&#123;\n    public void eat() &#123;\n        System.out.println(&quot;1&quot;);\n    &#125;\n&#125;\n\ninterface UserService&#123;\n\n&#125;\n</code></pre>\n<h1 id=\"异常-Exception-和-Error\"><a href=\"#异常-Exception-和-Error\" class=\"headerlink\" title=\"异常 Exception 和 Error\"></a>异常 Exception 和 Error</h1><p>主要存在三种异常：</p>\n<ol>\n<li><p>检查性异常 CheckedException：用户错误或问题引起的异常，例如打开不存在的文件，在编译时不能不简单的忽略。</p>\n</li>\n<li><p>运行时异常 RuntimeException:运行时异常是可能被程序员避免的异常，与检查性异常相反，运行时异常可以在编译时被忽略。</p>\n</li>\n<li><p>错误 Error: 脱离程序员控制的问题，错误在代码中通常被忽略。例如。当栈溢出时，一个错误就发生了，他们在编译时也检查不到。</p>\n</li>\n<li><p>异常处理框架：java把异常当做对象来处理，并定义了一个基类java.lang.Throwable作为所有异常的超类。javaAPI中已经定义了许多的异常类。这些异常分为两大类，错误Error和异常Exception。</p>\n</li>\n</ol>\n<p>Error: </p>\n<ol>\n<li>Error类对象由java虚拟机生成并抛出，大多数错误代码与代码编写者所执行的操作无关；</li>\n<li>java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError,这些异常发生时，java虚拟机（JVM）一般会选择线程终止；</li>\n<li>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkedError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>\n</ol>\n<p>Exception：</p>\n<ol>\n<li><p>在Exception分支中有一个重要的子类RuntimeException(运行时异常)</p>\n<ol>\n<li>ArrayIndexOutOfBoundsException  运行时异常</li>\n<li>NullPointerException 空指针异常</li>\n<li>ArithmeticException 算数异常</li>\n<li>MissingResourceException 丢失资源</li>\n<li>ClassNotFoundException 找不到类等异常，这些通常都是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>\n</ol>\n<p>这些异常一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</p>\n</li>\n</ol>\n<p>Error 和 Exception的区别：Error通常是灾难性的致命错误，是程序无法控制和处理的，当出现这些异常时，java虚拟机（JVM）一般会选择终止线程；Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p>\n<h1 id=\"异常处理机制\"><a href=\"#异常处理机制\" class=\"headerlink\" title=\"异常处理机制\"></a>异常处理机制</h1><p>抛出异常：throw ,throws</p>\n<p>捕获异常：try{}catch{}finally{}</p>\n<p>异常处理五个关键字</p>\n<p>​    try, catch, finally, throw, throws</p>"},{"title":"JAVA-常用类","date":"2021-04-06T14:29:11.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n\n\n# 常用类\n\n<!-- more -->\n\n## 内部类\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n概念：在一个类的内部再定义一个完整的类\n\n特点：\n\n- 编译之后可生成独立的字节码文件\n- 内部类可直接访问外部类私有成员，而不破坏封装\n- 可为外部类提供必要的内部功能组件\n\n```java\nOuter$Inner.class` `Outer.class\n```\n\n\n\n```java\n// 身体\nclass Body{\n  // 头部\n  class Header{\n    // 也会生成class文件\n  }\n}\n```\n\n### **成员内部类**\n\n- 在类的内部定义，与实例变量、实例方法同级别的类\n- 外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象\n- 当外部类、内部类存在重名属性时，会优先访问内部类属性\n- 成员内部类里不能定义**静态成员**、可以包含**静态常量(final)**\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"张三\";\n  private int age = 20;\n  //内部类\n  class Inner{\n    private String address = \"北京\";\n    private String phone = \"110\";\n    private String name = \"李四\";\n    \n    //方法\n    public void show(){\n      //打印外部类属性 此时有重名属性name\n      sout(Outer.this.name); // 张三\n      sout(age);\n      //打印内部类中的属性\n      sout(name); // 李四\n      sout(address);\n      sout(phone);\n    }\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 创建外部类对象\n    Outer outer = new Outer();\n    // 创建内部类对象\n    Inner inner = outer.new Inner();\n    \n    //一步到位\n    Inner inner = new Outer(.new Inner();\n                            \n    inner.show();\n  }\n}\n```\n\n### **静态内部类**\n\n- 不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"xxx\";\n  private int age = 20;\n  \n  // 静态内部类，和外部类相同\n  static class Inner{\n    private String address = \"上海\";\n    private String phone = \"111\";\n    // 静态成员\n    private static int count = 1000;\n    \n    //方法\n    public void show(){\n      // 调用外部类的属性\n      // 1. 先创建外部类对象\n      Outer outer = new Outer();\n      // 2. 调用外部类对象的属性\n      sout(outer.name);\n      sout(outer.age);\n      // 调用静态内部类的属性和方法\n      sout(address);\n      sout(phone);\n      // 调用静态内部类的静态属性\n      sout(Inner.count);\n    }\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 直接创建静态内部类对象\n    Outer.Inner inner = new Outer.Inner();\n                     \n    inner.show();\n  }\n}\n```\n\n### **局部内部类**\n\n- 定义在外部类**方法**中，作用范围和创建对象范围仅限于当前方法\n- 局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final\n- 限制类的使用范围\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"刘德华\";\n  private int age = 35;\n  \n  //方法\n  public void show(){\n    // 定义局部变量\n    String address = \"sz\";\n    \n    // 局部内部类：注意不能加任何访问修饰符\n    class Inner{\n      private String phone = \"11234\";\n      private String email = \"ldh@qq.com\";\n      \n      public void show2(){\n        // 访问外部类的属性\n        sout(name); // 相当于 Outer.this.name\n        sout(age);\n        // 访问内部类的属性\n        sout(this.phone);\n        sout(this.email);\n        \n        // 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final\n        \n      }\n    }\n    // 创建局部内部类对象\n    Inner inner = new Inner();\n    inner.show2();\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 创建外部类对象\n    Outer outer = new Outer();\n                     \n    outer.show();\n  }\n}\n```\n\n### **匿名内部类**\n\n- 没有类名的局部内部类（一切特征都与局部内部类相同）\n- 必须继承一个父类或者实现一个接口\n- 定义类、实现类、创建对象的语法合并，只能创建一个该类的对象\n- 优点：减少代码量\n- 缺点可读性较差\n\n\n\n```Java\n// 使用匿名内部类优化（相当于创建了一个局部内部类）\nUsb usb = new Usb(){ // Usb为一个接口\n  @Override\n  public void service(){\n    sout(\"连接电脑成功，fan开始工作\")\n  }\n};\nusb.service();\n```\n\n\n\n## Object类\n\n1. 超类、基类，所有类的直接或间接父类，位于继承树的最顶层\n2. 任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承\n3. Object类中所定义的方法，是所有对象都具备的方法\n4. Object类型可以存储任何对象\n   1. 作为参数，可接受任何对象\n   2. 作为返回值，可返回任何对象\n\n\n\n### getClass类\n\n1. `public final Class<?> getClass(){}`\n\n2. 返回引用中存储的实际对象类型\n\n3. 应用：通常用于判断两个引用中实际存储对象类型是否一致\n\n```java\n// 判断s1 和 s2是不是同一个类型\nClass class1 = s1.getClass();\nClass class2 = s2.getClass();\n// getClass返回 class类型\n```\n\n\n\n### hashcode类\n\n1. `public int hashCode(){}`\n2. 返回该对象的哈希码值\n3. 哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的值\n4. 一般情况下相同对象返回相同哈希码\n\n```java\ns1.hashCode();\ns2.hashCode();\n// 自然不同  hashcode s1 != s2\nStudent s3 = s1;\ns3.hashCode();\n// s3的hashCode与s1相同,将s1赋给s3\n```\n\n\n\n### toString类\n\n1. `public String toSring(){}`\n2. 返回该对象的字符串表示（表现形式）\n3. 可以根据程序需求覆盖该方法，如：展示对象各个属性值\n\n\n\n```java\nsout(s1.toString()); // 直接打印包+类名+哈希值\n\n// 重写 快捷键 alt + Ins\n@override\npublic String toString(){\n  return \"Student [name = \" + name + \", age = \" + age + \"]\";\n}\n```\n\n\n\n### equals()类\n\n1. `public boolean equals(Object obj){}`\n2. 默认实现为(this == obj), 比较两个对象地址是否相同\n3. 可进行覆盖，比较两个对象的内容是否相同\n\n```java\nSystem.out.println(s1.equals(s2)); //false\nSstudent s3 = s1;\nSystem.out.println(s1.equals(s3)); //true\n\nStudent eq1 = new Student(\"xm\", 11);\nStudent eq2 = new Student(\"xm\", 11);\nSystem.out.println(eq1.equals(eq2)); //false,地址不同\n```\n\n\n\n​\t重写equals()方法:\n\n```java\nEntity中:\n// 重写 改变其比较内容\n/*\n步骤  1. 比较两个应用是否指向同一个对象\n     2. 判断obj是否为null\n     3. 判断两个引用只想的实际对象类型是否一致\n     4. 强制类型转换\n     5. 依次比较各个属性值是否相同\n*/\n@override\npublic boolean equals(Object obj){\n  // 1.\n  if(this == obj){\n    return true;\n  }\n  // 2.\n  if(obj == null){\n    return false;\n  }\n  // 3.\n  // if(this.getClass() == obj.getClass()){\n  //\n  // }\n  // instanceof 判断对象是否是某种类型\n  if(obj instanceof Student){\n    // 4.强制类型转换\n    Student s = (Student)obj;\n    // 5. 比较属性\n    if(this.name.equals(s.getName()) && this.age == s.getAge()){\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n\n\n### finalize()方法\n\n1. 当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列\n2. 垃圾对象：没有有效引用指向此对象时，为垃圾对象\n3. 垃圾回收：由gc销毁垃圾对象，释放数据存储空间\n4. 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象\n5. 手动回收机制：使用`System.gc();`通知JVM执行垃圾回收\n\n```java\nfinalize默认为空，重写方法：\n@Override\nprotected void finalize() throws Throwable{\n  sout(this.name + \"对象被回收了\");\n}\n\nStudent s1 = new Student(\"aaa\", 1);\nnew Student(\"aaa\", 1);\n//手动告诉JVM进行回收；\nSystem.gc();\nSystem.out.println(\"回收垃圾\");\n```\n\n\n\n## 包装类\n\n1. **基本数据类型**所对应的**引用数据类型**\n2. Object 可统一所有数据，包装类的默认值是null\n\n| 基本数据类型 | 包装类型  |\n| :----------: | :-------: |\n|     byte     |   Byte    |\n|    short     |   Short   |\n|     int      |  Integer  |\n|     long     |   Long    |\n|    float     |   Float   |\n|    double    |  Double   |\n|   boolean    |  Boolean  |\n|     char     | Character |\n\n \n\n### **类型转换与装箱、拆箱**\n\n1. 8种包装类提供不用类型间的转换方式\n   1. Number父类中提供的6个共性方法\n   2. `parseXXX( )`静态方法\n   3. `valueOf( )`静态方法\n2. 注意：需保证类型兼容，否则抛出`NumberFormatException`异常\n\n```java\npublic static void main(String[] args) {\n        // 装箱， 基本类型 → 引用类型\n        // 基本类型\n        int num1 = 18;\n        // 使用Integer类创建对象\n        Integer integer1 = new Integer(num1);\n        Integer integer2 = Integer.valueOf(num1);\n\n        System.out.println(\"装箱\");\n        System.out.println(integer1);\n        System.out.println(integer2);\n\n        // 拆箱， 引用类型 → 基本类型\n        Integer integer3 = new Integer(100);\n        int num2 = integer3.intValue();\n\n        System.out.println(\"拆箱\");\n        System.out.println(num2);\n\n        //↑ JDK1.5 之前，JDK1.5之后自动装箱和拆箱\n        int age = 30;\n        //自动装箱\n        Integer integer4 = age;\n        System.out.println(\"自动装箱\");\n        System.out.println(integer4);\n        //自动拆箱\n        int age2 = integer4;\n\n        System.out.println(\"自动拆箱\");\n        System.out.println(age2);\n        System.out.println(\"---------------------------------------\");\n        //基本类型和字符串之间的转换\n        //基本类型转换为字符串\n        // 基本类型和字符串之间转换\n        // 1. 基本类型转成字符串\n        int n1 = 100;\n        // 1.1 使用+号\n        String s1 = n1 + \"\";\n        // 1.2 使用Integer中的toString()方法\n        String s2 = Integer.toString(n1,2);\n        System.out.println(s2);\n       //String s2 = Integer.toString(n1, x); // x为进制要求\n\n        // 2. 字符串转成基本类型\n        String str = \"150\";\n        // 使用Integer.parseXXX();\n        int n2 = Integer.parseInt(str);\n        System.out.println(n2);\n\n        // boolean 字符串形式转成基本类型，\"true\" ---> true 非“true ———> false\n        String str2 = \"true\";\n        boolean b1 = Boolean.parseBoolean(str2);\n        System.out.println(b1);\n    }\n```\n\n \n\n## 整数缓冲区\n\n1. Java预先创建了256个常用的证书包装类型对象\n2. 在实际应用当中，对已创建的对象进行复用\n\n```java\n  public static void main(String[] args) {\n        // 面试题\n        Integer integer1 = new Integer(100);\n        Integer integer2 = new Integer(100);\n        System.out.println(integer1 == integer2); // false\n\n        Integer integer3 =  Integer.valueOf(100);// 自动装箱\n        // 相当于调用 Integer.valueOf(100);\n        Integer integer4 = Integer.valueOf(100);\n        System.out.println(integer3 == integer4); // true\n\n        Integer integer5 = Integer.valueOf(200);// 自动装箱\n        Integer integer6 = Integer.valueOf(200);\n        System.out.println(integer5 == integer6); // false\n\n        // 因为缓存区数组 [-128, 127] 在这之内地址一样\n    }\n```\n\n\n\n## String类\n\n1. 字符串是final修饰的常量，创建之后不可改变\n2. 字符串字面值存储在字符串池中，可以共享\n3. `String s = \"Hello\";`产生一个对象，字符串池中存储\n4. `String s = new String(\"Hello\");` 产生两个对象，**堆、池**各一个\n\n```java\npublic static void main(String[] args) {\n\n        // 1. length(); 返回字符串长度\n        // 2. charAt(int index); 返回某个位置的字符\n        // 3. contains(String str); 判断是否包含某个字符串\n\n        String content = \"java是最好的语言, java no1\";\n        System.out.println(content.length()); // 10\n        System.out.println(content.charAt(content.length() - 1)); // 言\n        System.out.println(content.contains(\"java\")); // true\n\n        // 4. toCharArray(); 返回字符串对应数组\n        // 5. indexOf(); 返回子字符串首次出现的位置\n        // 6. lastIndexOf(); 返回字符串最后一次出现的位置\n\n        System.out.println(content.toCharArray());\n        System.out.println(content.indexOf(\"java\")); // 0\n        System.out.println(content.indexOf(\"java\", 4)); // 从索引4开始找 返回12\n        System.out.println(content.lastIndexOf(\"java\")); // 12\n\n        // 7. trim(); //去掉字符串前后空格\n        // 8. toUpperCase(); toLowerCase(); 转换大小写\n        // 9. endWith(str); startWith(str);  判断是否以str 结尾、开头\n\n        String ct = \" hello world \";\n        System.out.println(ct.trim()); // \"hello world\"\n        System.out.println(ct.toUpperCase()); // HELLO WORLD\n        System.out.println(ct.toLowerCase()); // hello world\n        System.out.println(ct.endsWith(\"world\")); // true\n        System.out.println(ct.startsWith(\"hello\")); // true\n\n        // 10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串\n        // 11. split(); 对字符串拆分\n\n        System.out.println(content.replace(\"java\", \"python\")); // php是最好的语言, php no1\n\n        String say = \"java is the best language\";\n        String[] arr = say.split(\" \"); // \"[ ,]+\" 表示空格 逗号切分 +号表示切分可以多个 比如多个空格\n        System.out.println(arr.length); // 5\n        for (String string : arr) {\n            System.out.println(string);\n        }\n        // 打印出\n        //java\n        //is\n        //the\n        //best\n        //language\n\n        // 补充两个equals/compareTo();比较大小\n        String s1 = \"hello\";\n        String s2 = \"HELLO\";\n        System.out.println(s1.equalsIgnoreCase(s2));// 忽略大小写比较true\n\n        // compareTo(); 两字符不同时比较字符字典序的ascii码\n        // 字符相同时比较长度 返回差值\n\n    }\n```\n\n### String 常用方法\n\n1. length(); 返回字符串长度；\n2. charAt(int index); 返回某个位置的字符；\n3. contains(String str); 判断是否包含某个字符串；\n4. toCharArray(); 返回字符串对应数组；\n5. indexOf(); 返回子字符串首次出现的位置；\n6. lastIndexOf(); 返回字符串最后一次出现的位置；\n7. trim(); //去掉字符串前后空格；\n8. toUpperCase(); toLowerCase(); 转换大小写；\n9. endWith(str); startWith(str);  判断是否以str 结尾、开头；\n10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串；\n11. split(); 对字符串拆分；\n\n\n\n#### 案例演示\n\n需求：\n\n1. 已知String str = \"this is a text\";\n2. 将str中的单词单独获取\n3. 将str中的text替换成practice\n4. 在text前面插入一个easy\n5. 将每个单词的首字母改为大写\n\n```java\npublic static void main(String[] args) {\n//        已知String str = \"this is a text\";\n//        将str中的单词单独获取\n//        将str中的text替换成practice\n//        在text前面插入一个easy\n//        将每个单词的首字母改为大写\n\n        String str = \"this is a text\";\n        String[] arr = str.split(\" \");\n        for (String s : arr) {\n            System.out.println(s);\n        }\n\n\n        str = str.replace(\"text\", \"practice\");\n        System.out.println(str);\n\n        str =  str.replace(\"practice\", \"easy practice\");\n        System.out.println(str);\n\n        for (int i = 0; i < arr.length; i++) {\n            char first = arr[i].charAt(0);\n            char upperfirst = Character.toUpperCase(first);\n            String newstr = upperfirst + arr[i].substring(1);\n            System.out.println(newstr);\n\n        }\n    }\n```\n\n\n\n### StringBuffer 和 StringBuilder\n\n1. StringBuffer : 可变长字符串，运行效率慢、线程安全\n2. StringBuilder : 可边长字符串、运行快、线程不安全\n\n效率都比String高且节省内存\n\n```java\n\t\tStringBuffer sb = new StringBuffer();\n        sb.append(\"java世界第一\");\n        System.out.println(sb.toString());\n        sb.append(\"java真香\");\n        System.out.println(sb.toString());\n        sb.append(\"java不错\");\n        System.out.println(sb.toString());\n        sb.insert(0,\"我在最前面\");\n        System.out.println(sb.toString());\n        sb.replace(0,5,\"hello\");\n        System.out.println(sb.toString());\n        sb.delete(0,5);\n        System.out.println(sb.toString());\n        sb.delete(0,sb.length());\n        System.out.println(\"delete\" + sb.toString());\n```\n\n\n\n测试效率：\n\n```java\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        String str = \"\";\n        for (int i = 0; i < 99999; i++) {\n            str+=i;\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println((float) (end-start)/1000 + \"s\");\n\n\n        long start2 = System.currentTimeMillis();\n        StringBuffer sb = new StringBuffer(\"\");\n        for (int i = 0; i < 99999; i++) {\n            sb.append(i);\n        }\n\n        long end2 = System.currentTimeMillis();\n\n        System.out.println(end2-start2 + \"ms\");\n\n        long start3 = System.currentTimeMillis();\n        StringBuilder sbu = new StringBuilder(\"\");\n        for (int i = 0; i < 99999; i++) {\n            sbu.append(i);\n        }\n\n        long end3 = System.currentTimeMillis();\n\n        System.out.println(end3-start3 + \"ms\");\n\n    }\n\n输出结果：\n18.49s\n10ms\n0ms\n    \n可见效率差距\n```\n\n\n\n\n\n## BigDecimal类\n\n1. 位置 `java.math` 包中\n\n2. 作用 精确计算浮点数\n\n3. 创建方式 `BigDecimal bd = new BigDecimal(\"1.0\");`\n\n   ```java\n   public static void main(String[] args) {\n           double d1 = 1.0;\n           double d2 = 0.9;\n           System.out.println(\"d1-d2=\" + (d1-d2));\n   \n           double res = (1.4-0.5)/0.9;\n           System.out.println(\"result=\" + res);\n   \n   \n           BigDecimal bd1 = new BigDecimal(\"1.0\");\n           BigDecimal bd2 = new BigDecimal(\"0.9\");\n   \n           BigDecimal bdres1 = bd1.add(bd2); //加\n           BigDecimal bdres2 = bd1.subtract(bd2); //减\n           BigDecimal bdres3 = bd1.multiply(bd2); //乘\n           BigDecimal bdres4 = \n               bd1.divide(bd2,2,BigDecimal.ROUND_HALF_UP); //除\n       // bd1.divide(除数,小数精确到几位,BigDecimal.ROUND_HALF_UP=四舍五入);\n           System.out.println(\"加=\"+bdres1+\"\\n减=\"+bdres2+\"\\n乘=\"+bdres3+\"\\n除=\"+bdres4);\n       }\n   ```\n\n   ```java\n   d1-d2=0.09999999999999998\n   result=0.9999999999999999\n   加=1.9\n   减=0.1\n   乘=0.90\n   除=1.11\n   ```\n\n\n\n## 时间-Date类\n\n1. Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代; ( 时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns; ) \n\n```java\npublic static void main(String[] args) {\n        Date date1 = new Date();\n        System.out.println(date1.toString());\n        System.out.println(date1.toLocaleString());\n\n        //昨天\n        Date date2 = new Date(date1.getTime() - (60*60*24*1000));\n        System.out.println(date2.toLocaleString());\n\n\n        //方法after before\n        boolean b1 = date1.after(date2);\n        System.out.println(b1);\n\n        boolean b2 = date1.before(date2);\n        System.out.println(b2);\n\n\n        //比较compareTo(),比较毫秒值\n        int d1 = date1.compareTo(date2);\n        System.out.println(d1);\n\n        int d2 = date1.compareTo(date1);\n        System.out.println(d2);\n\n        //比较是否相等\n        boolean b3 = date1.equals(date2);\n        System.out.println(b3);\n\n    }\n```\n\n\n\n## 时间-Calendar类\n\n1. Calendar提供了获取或设置各种日历字段的方法\n2. 构造方法 `protected Calendar();` 由于是protected 所以无法直接创建\n3. 其他方法\n\n| 方法名                                                       | 说明                                       |\n| :----------------------------------------------------------- | :----------------------------------------- |\n| static Calendar getInstance()                                | 使用默认时区和区域获取日历                 |\n| void set(int year, int month, int date, int hourofday, int minute, int second) | 设置日历的年、月、日、时、分、秒           |\n| int get(int field)                                           | 返回给定日历字段的值。字段比如年、月、日   |\n| void setTime(Date date)                                      | 用给定的date设置此日历时间                 |\n| Date getTime()                                               | 返回一个date表示此日历的时间               |\n| void add(int field, int amount)                              | 按照日历的规则，给指定字段添加或减少时间量 |\n| long getTimeInMilles()                                       | 毫秒为单位返回该日历的时间值               |\n\n```java\npublic static void main(String[] args) {\n        //创建Calendar对象\n        Calendar calendar = Calendar.getInstance();\n        System.out.println(calendar.getTime().toString());\n        System.out.println(calendar.getTimeInMillis());\n\n        //获取时间信息\n        //获取年\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR); //12时制\n        int hour2 = calendar.get(Calendar.HOUR_OF_DAY);//24时制\n        int minute = calendar.get(Calendar.MINUTE);\n        int second = calendar.get(Calendar.SECOND);\n        int week = calendar.get(Calendar.DAY_OF_WEEK);\n        String[] arr = {\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"};\n        String week2 = arr[week-1];\n        System.out.println(year + \"/\" + (month+1) + \"/\" + date  + \"-\" + hour + \"(\"+ hour2 +\")\"  + \":\" + minute + \":\" + second + \"-[ 星期\" + week2 + \"]\");\n\n        //修改时间\n        Calendar calendar1 = Calendar.getInstance();\n        calendar1.set(Calendar.DAY_OF_MONTH, 5);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //add方法修改时间\n        calendar1.add(Calendar.HOUR, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //补充方法\n        int max = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max);\n        System.out.println(min);\n\n        calendar1.add(Calendar.MONTH, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n        \n        int max2 = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min2 =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max2);\n        System.out.println(min2);\n\n    }\n```\n\n```powershell\nTue Apr 06 21:25:51 CST 2021\n1617715551128\n2021/4/6-9(21):25:51-[星期二]\n2021-4-5 21:25:51\n2021-4-5 22:25:51\n30\n1\n2021-5-5 22:25:51\n31\n1\n```\n\n\n\n## SimpleDateFormat类\n\n1. SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类\n2. 进行格式化（日期→文本）、解析（文本→日期）\n3. 常用的时间模式字母\n\n| 字母 | 日期或时间         | 示例 |\n| :--- | :----------------- | :--- |\n| y    | 年                 | 2019 |\n| 08   | 年中月份           | 08   |\n| d    | 月中天数           | 10   |\n| H    | 一天中小时（0-23） | 22   |\n| m    | 分钟               | 16   |\n| s    | 秒                 | 59   |\n| S    | 毫秒               | 356  |\n\n```java\n public static void main(String[] args) throws Exception{\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n\n        Date date = new Date();\n        String str = sdf.format(date);\n        System.out.println(str);\n\n        Date date2 = sdf.parse(\"1990/05/01\");\n\t\tSystem.out.println(date2);\n    }\n```\n\n\n\n## System类\n\n主要用于获取系统的属性数据和其他操作，构造方法私有的\n\n| 方法名                           | 说明                                               |\n| :------------------------------- | :------------------------------------------------- |\n| static void arraycopy(...)       | 复制数组                                           |\n| static long currentTimeMillis(); | 获取当前系统时间，返回毫秒值                       |\n| static void gc();                | 建议jvm赶快启动垃圾回收期器回收垃圾                |\n| static void exit(int status);    | 退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出 |\n\n\n\n```java\npublic static void main(String[] args) {\n        // arrcopy 数组的复制\n        // src: 源数组\n        // srcPos: 从哪个位置开始复制 0\n        // dest: 目标数组\n        // destPos: 目标数组的位置\n        // length: 复制的长度\n        int[] arr = {20, 10, 15, 8, 35, 26, 45, 90};\n        int[] targetarr = new int[8];\n\n        System.arraycopy(arr, 4, targetarr, 6,2);\n        System.out.println(Arrays.toString(targetarr));\n\n        //Arrays.copyOf()底层源码实现方式依旧为arraycopy\n        int[] targetarr2 = Arrays.copyOf(arr,6);\n        System.out.println(Arrays.toString(targetarr2));\n\n        //退出JVM,下面的代码不再执行\n        System.exit(0);\n        System.out.println(\"程序结束了···········\");\n    }\n```\n\n\n\n","source":"_posts/JAVA-常用类-20210416.md","raw":"---\ntitle: JAVA-常用类\ndate: 2021-04-06 22:29:11\ntags:\n- java基础\ncategories:\n- java\ncover:\n- https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n\n\n# 常用类\n\n<!-- more -->\n\n## 内部类\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n概念：在一个类的内部再定义一个完整的类\n\n特点：\n\n- 编译之后可生成独立的字节码文件\n- 内部类可直接访问外部类私有成员，而不破坏封装\n- 可为外部类提供必要的内部功能组件\n\n```java\nOuter$Inner.class` `Outer.class\n```\n\n\n\n```java\n// 身体\nclass Body{\n  // 头部\n  class Header{\n    // 也会生成class文件\n  }\n}\n```\n\n### **成员内部类**\n\n- 在类的内部定义，与实例变量、实例方法同级别的类\n- 外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象\n- 当外部类、内部类存在重名属性时，会优先访问内部类属性\n- 成员内部类里不能定义**静态成员**、可以包含**静态常量(final)**\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"张三\";\n  private int age = 20;\n  //内部类\n  class Inner{\n    private String address = \"北京\";\n    private String phone = \"110\";\n    private String name = \"李四\";\n    \n    //方法\n    public void show(){\n      //打印外部类属性 此时有重名属性name\n      sout(Outer.this.name); // 张三\n      sout(age);\n      //打印内部类中的属性\n      sout(name); // 李四\n      sout(address);\n      sout(phone);\n    }\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 创建外部类对象\n    Outer outer = new Outer();\n    // 创建内部类对象\n    Inner inner = outer.new Inner();\n    \n    //一步到位\n    Inner inner = new Outer(.new Inner();\n                            \n    inner.show();\n  }\n}\n```\n\n### **静态内部类**\n\n- 不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"xxx\";\n  private int age = 20;\n  \n  // 静态内部类，和外部类相同\n  static class Inner{\n    private String address = \"上海\";\n    private String phone = \"111\";\n    // 静态成员\n    private static int count = 1000;\n    \n    //方法\n    public void show(){\n      // 调用外部类的属性\n      // 1. 先创建外部类对象\n      Outer outer = new Outer();\n      // 2. 调用外部类对象的属性\n      sout(outer.name);\n      sout(outer.age);\n      // 调用静态内部类的属性和方法\n      sout(address);\n      sout(phone);\n      // 调用静态内部类的静态属性\n      sout(Inner.count);\n    }\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 直接创建静态内部类对象\n    Outer.Inner inner = new Outer.Inner();\n                     \n    inner.show();\n  }\n}\n```\n\n### **局部内部类**\n\n- 定义在外部类**方法**中，作用范围和创建对象范围仅限于当前方法\n- 局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final\n- 限制类的使用范围\n\n\n\n```java\n// 外部类\npublic class Outer{\n  //实例变量\n  private String name = \"刘德华\";\n  private int age = 35;\n  \n  //方法\n  public void show(){\n    // 定义局部变量\n    String address = \"sz\";\n    \n    // 局部内部类：注意不能加任何访问修饰符\n    class Inner{\n      private String phone = \"11234\";\n      private String email = \"ldh@qq.com\";\n      \n      public void show2(){\n        // 访问外部类的属性\n        sout(name); // 相当于 Outer.this.name\n        sout(age);\n        // 访问内部类的属性\n        sout(this.phone);\n        sout(this.email);\n        \n        // 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final\n        \n      }\n    }\n    // 创建局部内部类对象\n    Inner inner = new Inner();\n    inner.show2();\n  }\n}\n\n// 测试类\npublic class Test{\n  psvm(String[] args){\n    // 创建外部类对象\n    Outer outer = new Outer();\n                     \n    outer.show();\n  }\n}\n```\n\n### **匿名内部类**\n\n- 没有类名的局部内部类（一切特征都与局部内部类相同）\n- 必须继承一个父类或者实现一个接口\n- 定义类、实现类、创建对象的语法合并，只能创建一个该类的对象\n- 优点：减少代码量\n- 缺点可读性较差\n\n\n\n```Java\n// 使用匿名内部类优化（相当于创建了一个局部内部类）\nUsb usb = new Usb(){ // Usb为一个接口\n  @Override\n  public void service(){\n    sout(\"连接电脑成功，fan开始工作\")\n  }\n};\nusb.service();\n```\n\n\n\n## Object类\n\n1. 超类、基类，所有类的直接或间接父类，位于继承树的最顶层\n2. 任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承\n3. Object类中所定义的方法，是所有对象都具备的方法\n4. Object类型可以存储任何对象\n   1. 作为参数，可接受任何对象\n   2. 作为返回值，可返回任何对象\n\n\n\n### getClass类\n\n1. `public final Class<?> getClass(){}`\n\n2. 返回引用中存储的实际对象类型\n\n3. 应用：通常用于判断两个引用中实际存储对象类型是否一致\n\n```java\n// 判断s1 和 s2是不是同一个类型\nClass class1 = s1.getClass();\nClass class2 = s2.getClass();\n// getClass返回 class类型\n```\n\n\n\n### hashcode类\n\n1. `public int hashCode(){}`\n2. 返回该对象的哈希码值\n3. 哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的值\n4. 一般情况下相同对象返回相同哈希码\n\n```java\ns1.hashCode();\ns2.hashCode();\n// 自然不同  hashcode s1 != s2\nStudent s3 = s1;\ns3.hashCode();\n// s3的hashCode与s1相同,将s1赋给s3\n```\n\n\n\n### toString类\n\n1. `public String toSring(){}`\n2. 返回该对象的字符串表示（表现形式）\n3. 可以根据程序需求覆盖该方法，如：展示对象各个属性值\n\n\n\n```java\nsout(s1.toString()); // 直接打印包+类名+哈希值\n\n// 重写 快捷键 alt + Ins\n@override\npublic String toString(){\n  return \"Student [name = \" + name + \", age = \" + age + \"]\";\n}\n```\n\n\n\n### equals()类\n\n1. `public boolean equals(Object obj){}`\n2. 默认实现为(this == obj), 比较两个对象地址是否相同\n3. 可进行覆盖，比较两个对象的内容是否相同\n\n```java\nSystem.out.println(s1.equals(s2)); //false\nSstudent s3 = s1;\nSystem.out.println(s1.equals(s3)); //true\n\nStudent eq1 = new Student(\"xm\", 11);\nStudent eq2 = new Student(\"xm\", 11);\nSystem.out.println(eq1.equals(eq2)); //false,地址不同\n```\n\n\n\n​\t重写equals()方法:\n\n```java\nEntity中:\n// 重写 改变其比较内容\n/*\n步骤  1. 比较两个应用是否指向同一个对象\n     2. 判断obj是否为null\n     3. 判断两个引用只想的实际对象类型是否一致\n     4. 强制类型转换\n     5. 依次比较各个属性值是否相同\n*/\n@override\npublic boolean equals(Object obj){\n  // 1.\n  if(this == obj){\n    return true;\n  }\n  // 2.\n  if(obj == null){\n    return false;\n  }\n  // 3.\n  // if(this.getClass() == obj.getClass()){\n  //\n  // }\n  // instanceof 判断对象是否是某种类型\n  if(obj instanceof Student){\n    // 4.强制类型转换\n    Student s = (Student)obj;\n    // 5. 比较属性\n    if(this.name.equals(s.getName()) && this.age == s.getAge()){\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n\n\n### finalize()方法\n\n1. 当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列\n2. 垃圾对象：没有有效引用指向此对象时，为垃圾对象\n3. 垃圾回收：由gc销毁垃圾对象，释放数据存储空间\n4. 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象\n5. 手动回收机制：使用`System.gc();`通知JVM执行垃圾回收\n\n```java\nfinalize默认为空，重写方法：\n@Override\nprotected void finalize() throws Throwable{\n  sout(this.name + \"对象被回收了\");\n}\n\nStudent s1 = new Student(\"aaa\", 1);\nnew Student(\"aaa\", 1);\n//手动告诉JVM进行回收；\nSystem.gc();\nSystem.out.println(\"回收垃圾\");\n```\n\n\n\n## 包装类\n\n1. **基本数据类型**所对应的**引用数据类型**\n2. Object 可统一所有数据，包装类的默认值是null\n\n| 基本数据类型 | 包装类型  |\n| :----------: | :-------: |\n|     byte     |   Byte    |\n|    short     |   Short   |\n|     int      |  Integer  |\n|     long     |   Long    |\n|    float     |   Float   |\n|    double    |  Double   |\n|   boolean    |  Boolean  |\n|     char     | Character |\n\n \n\n### **类型转换与装箱、拆箱**\n\n1. 8种包装类提供不用类型间的转换方式\n   1. Number父类中提供的6个共性方法\n   2. `parseXXX( )`静态方法\n   3. `valueOf( )`静态方法\n2. 注意：需保证类型兼容，否则抛出`NumberFormatException`异常\n\n```java\npublic static void main(String[] args) {\n        // 装箱， 基本类型 → 引用类型\n        // 基本类型\n        int num1 = 18;\n        // 使用Integer类创建对象\n        Integer integer1 = new Integer(num1);\n        Integer integer2 = Integer.valueOf(num1);\n\n        System.out.println(\"装箱\");\n        System.out.println(integer1);\n        System.out.println(integer2);\n\n        // 拆箱， 引用类型 → 基本类型\n        Integer integer3 = new Integer(100);\n        int num2 = integer3.intValue();\n\n        System.out.println(\"拆箱\");\n        System.out.println(num2);\n\n        //↑ JDK1.5 之前，JDK1.5之后自动装箱和拆箱\n        int age = 30;\n        //自动装箱\n        Integer integer4 = age;\n        System.out.println(\"自动装箱\");\n        System.out.println(integer4);\n        //自动拆箱\n        int age2 = integer4;\n\n        System.out.println(\"自动拆箱\");\n        System.out.println(age2);\n        System.out.println(\"---------------------------------------\");\n        //基本类型和字符串之间的转换\n        //基本类型转换为字符串\n        // 基本类型和字符串之间转换\n        // 1. 基本类型转成字符串\n        int n1 = 100;\n        // 1.1 使用+号\n        String s1 = n1 + \"\";\n        // 1.2 使用Integer中的toString()方法\n        String s2 = Integer.toString(n1,2);\n        System.out.println(s2);\n       //String s2 = Integer.toString(n1, x); // x为进制要求\n\n        // 2. 字符串转成基本类型\n        String str = \"150\";\n        // 使用Integer.parseXXX();\n        int n2 = Integer.parseInt(str);\n        System.out.println(n2);\n\n        // boolean 字符串形式转成基本类型，\"true\" ---> true 非“true ———> false\n        String str2 = \"true\";\n        boolean b1 = Boolean.parseBoolean(str2);\n        System.out.println(b1);\n    }\n```\n\n \n\n## 整数缓冲区\n\n1. Java预先创建了256个常用的证书包装类型对象\n2. 在实际应用当中，对已创建的对象进行复用\n\n```java\n  public static void main(String[] args) {\n        // 面试题\n        Integer integer1 = new Integer(100);\n        Integer integer2 = new Integer(100);\n        System.out.println(integer1 == integer2); // false\n\n        Integer integer3 =  Integer.valueOf(100);// 自动装箱\n        // 相当于调用 Integer.valueOf(100);\n        Integer integer4 = Integer.valueOf(100);\n        System.out.println(integer3 == integer4); // true\n\n        Integer integer5 = Integer.valueOf(200);// 自动装箱\n        Integer integer6 = Integer.valueOf(200);\n        System.out.println(integer5 == integer6); // false\n\n        // 因为缓存区数组 [-128, 127] 在这之内地址一样\n    }\n```\n\n\n\n## String类\n\n1. 字符串是final修饰的常量，创建之后不可改变\n2. 字符串字面值存储在字符串池中，可以共享\n3. `String s = \"Hello\";`产生一个对象，字符串池中存储\n4. `String s = new String(\"Hello\");` 产生两个对象，**堆、池**各一个\n\n```java\npublic static void main(String[] args) {\n\n        // 1. length(); 返回字符串长度\n        // 2. charAt(int index); 返回某个位置的字符\n        // 3. contains(String str); 判断是否包含某个字符串\n\n        String content = \"java是最好的语言, java no1\";\n        System.out.println(content.length()); // 10\n        System.out.println(content.charAt(content.length() - 1)); // 言\n        System.out.println(content.contains(\"java\")); // true\n\n        // 4. toCharArray(); 返回字符串对应数组\n        // 5. indexOf(); 返回子字符串首次出现的位置\n        // 6. lastIndexOf(); 返回字符串最后一次出现的位置\n\n        System.out.println(content.toCharArray());\n        System.out.println(content.indexOf(\"java\")); // 0\n        System.out.println(content.indexOf(\"java\", 4)); // 从索引4开始找 返回12\n        System.out.println(content.lastIndexOf(\"java\")); // 12\n\n        // 7. trim(); //去掉字符串前后空格\n        // 8. toUpperCase(); toLowerCase(); 转换大小写\n        // 9. endWith(str); startWith(str);  判断是否以str 结尾、开头\n\n        String ct = \" hello world \";\n        System.out.println(ct.trim()); // \"hello world\"\n        System.out.println(ct.toUpperCase()); // HELLO WORLD\n        System.out.println(ct.toLowerCase()); // hello world\n        System.out.println(ct.endsWith(\"world\")); // true\n        System.out.println(ct.startsWith(\"hello\")); // true\n\n        // 10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串\n        // 11. split(); 对字符串拆分\n\n        System.out.println(content.replace(\"java\", \"python\")); // php是最好的语言, php no1\n\n        String say = \"java is the best language\";\n        String[] arr = say.split(\" \"); // \"[ ,]+\" 表示空格 逗号切分 +号表示切分可以多个 比如多个空格\n        System.out.println(arr.length); // 5\n        for (String string : arr) {\n            System.out.println(string);\n        }\n        // 打印出\n        //java\n        //is\n        //the\n        //best\n        //language\n\n        // 补充两个equals/compareTo();比较大小\n        String s1 = \"hello\";\n        String s2 = \"HELLO\";\n        System.out.println(s1.equalsIgnoreCase(s2));// 忽略大小写比较true\n\n        // compareTo(); 两字符不同时比较字符字典序的ascii码\n        // 字符相同时比较长度 返回差值\n\n    }\n```\n\n### String 常用方法\n\n1. length(); 返回字符串长度；\n2. charAt(int index); 返回某个位置的字符；\n3. contains(String str); 判断是否包含某个字符串；\n4. toCharArray(); 返回字符串对应数组；\n5. indexOf(); 返回子字符串首次出现的位置；\n6. lastIndexOf(); 返回字符串最后一次出现的位置；\n7. trim(); //去掉字符串前后空格；\n8. toUpperCase(); toLowerCase(); 转换大小写；\n9. endWith(str); startWith(str);  判断是否以str 结尾、开头；\n10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串；\n11. split(); 对字符串拆分；\n\n\n\n#### 案例演示\n\n需求：\n\n1. 已知String str = \"this is a text\";\n2. 将str中的单词单独获取\n3. 将str中的text替换成practice\n4. 在text前面插入一个easy\n5. 将每个单词的首字母改为大写\n\n```java\npublic static void main(String[] args) {\n//        已知String str = \"this is a text\";\n//        将str中的单词单独获取\n//        将str中的text替换成practice\n//        在text前面插入一个easy\n//        将每个单词的首字母改为大写\n\n        String str = \"this is a text\";\n        String[] arr = str.split(\" \");\n        for (String s : arr) {\n            System.out.println(s);\n        }\n\n\n        str = str.replace(\"text\", \"practice\");\n        System.out.println(str);\n\n        str =  str.replace(\"practice\", \"easy practice\");\n        System.out.println(str);\n\n        for (int i = 0; i < arr.length; i++) {\n            char first = arr[i].charAt(0);\n            char upperfirst = Character.toUpperCase(first);\n            String newstr = upperfirst + arr[i].substring(1);\n            System.out.println(newstr);\n\n        }\n    }\n```\n\n\n\n### StringBuffer 和 StringBuilder\n\n1. StringBuffer : 可变长字符串，运行效率慢、线程安全\n2. StringBuilder : 可边长字符串、运行快、线程不安全\n\n效率都比String高且节省内存\n\n```java\n\t\tStringBuffer sb = new StringBuffer();\n        sb.append(\"java世界第一\");\n        System.out.println(sb.toString());\n        sb.append(\"java真香\");\n        System.out.println(sb.toString());\n        sb.append(\"java不错\");\n        System.out.println(sb.toString());\n        sb.insert(0,\"我在最前面\");\n        System.out.println(sb.toString());\n        sb.replace(0,5,\"hello\");\n        System.out.println(sb.toString());\n        sb.delete(0,5);\n        System.out.println(sb.toString());\n        sb.delete(0,sb.length());\n        System.out.println(\"delete\" + sb.toString());\n```\n\n\n\n测试效率：\n\n```java\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        String str = \"\";\n        for (int i = 0; i < 99999; i++) {\n            str+=i;\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println((float) (end-start)/1000 + \"s\");\n\n\n        long start2 = System.currentTimeMillis();\n        StringBuffer sb = new StringBuffer(\"\");\n        for (int i = 0; i < 99999; i++) {\n            sb.append(i);\n        }\n\n        long end2 = System.currentTimeMillis();\n\n        System.out.println(end2-start2 + \"ms\");\n\n        long start3 = System.currentTimeMillis();\n        StringBuilder sbu = new StringBuilder(\"\");\n        for (int i = 0; i < 99999; i++) {\n            sbu.append(i);\n        }\n\n        long end3 = System.currentTimeMillis();\n\n        System.out.println(end3-start3 + \"ms\");\n\n    }\n\n输出结果：\n18.49s\n10ms\n0ms\n    \n可见效率差距\n```\n\n\n\n\n\n## BigDecimal类\n\n1. 位置 `java.math` 包中\n\n2. 作用 精确计算浮点数\n\n3. 创建方式 `BigDecimal bd = new BigDecimal(\"1.0\");`\n\n   ```java\n   public static void main(String[] args) {\n           double d1 = 1.0;\n           double d2 = 0.9;\n           System.out.println(\"d1-d2=\" + (d1-d2));\n   \n           double res = (1.4-0.5)/0.9;\n           System.out.println(\"result=\" + res);\n   \n   \n           BigDecimal bd1 = new BigDecimal(\"1.0\");\n           BigDecimal bd2 = new BigDecimal(\"0.9\");\n   \n           BigDecimal bdres1 = bd1.add(bd2); //加\n           BigDecimal bdres2 = bd1.subtract(bd2); //减\n           BigDecimal bdres3 = bd1.multiply(bd2); //乘\n           BigDecimal bdres4 = \n               bd1.divide(bd2,2,BigDecimal.ROUND_HALF_UP); //除\n       // bd1.divide(除数,小数精确到几位,BigDecimal.ROUND_HALF_UP=四舍五入);\n           System.out.println(\"加=\"+bdres1+\"\\n减=\"+bdres2+\"\\n乘=\"+bdres3+\"\\n除=\"+bdres4);\n       }\n   ```\n\n   ```java\n   d1-d2=0.09999999999999998\n   result=0.9999999999999999\n   加=1.9\n   减=0.1\n   乘=0.90\n   除=1.11\n   ```\n\n\n\n## 时间-Date类\n\n1. Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代; ( 时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns; ) \n\n```java\npublic static void main(String[] args) {\n        Date date1 = new Date();\n        System.out.println(date1.toString());\n        System.out.println(date1.toLocaleString());\n\n        //昨天\n        Date date2 = new Date(date1.getTime() - (60*60*24*1000));\n        System.out.println(date2.toLocaleString());\n\n\n        //方法after before\n        boolean b1 = date1.after(date2);\n        System.out.println(b1);\n\n        boolean b2 = date1.before(date2);\n        System.out.println(b2);\n\n\n        //比较compareTo(),比较毫秒值\n        int d1 = date1.compareTo(date2);\n        System.out.println(d1);\n\n        int d2 = date1.compareTo(date1);\n        System.out.println(d2);\n\n        //比较是否相等\n        boolean b3 = date1.equals(date2);\n        System.out.println(b3);\n\n    }\n```\n\n\n\n## 时间-Calendar类\n\n1. Calendar提供了获取或设置各种日历字段的方法\n2. 构造方法 `protected Calendar();` 由于是protected 所以无法直接创建\n3. 其他方法\n\n| 方法名                                                       | 说明                                       |\n| :----------------------------------------------------------- | :----------------------------------------- |\n| static Calendar getInstance()                                | 使用默认时区和区域获取日历                 |\n| void set(int year, int month, int date, int hourofday, int minute, int second) | 设置日历的年、月、日、时、分、秒           |\n| int get(int field)                                           | 返回给定日历字段的值。字段比如年、月、日   |\n| void setTime(Date date)                                      | 用给定的date设置此日历时间                 |\n| Date getTime()                                               | 返回一个date表示此日历的时间               |\n| void add(int field, int amount)                              | 按照日历的规则，给指定字段添加或减少时间量 |\n| long getTimeInMilles()                                       | 毫秒为单位返回该日历的时间值               |\n\n```java\npublic static void main(String[] args) {\n        //创建Calendar对象\n        Calendar calendar = Calendar.getInstance();\n        System.out.println(calendar.getTime().toString());\n        System.out.println(calendar.getTimeInMillis());\n\n        //获取时间信息\n        //获取年\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR); //12时制\n        int hour2 = calendar.get(Calendar.HOUR_OF_DAY);//24时制\n        int minute = calendar.get(Calendar.MINUTE);\n        int second = calendar.get(Calendar.SECOND);\n        int week = calendar.get(Calendar.DAY_OF_WEEK);\n        String[] arr = {\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"};\n        String week2 = arr[week-1];\n        System.out.println(year + \"/\" + (month+1) + \"/\" + date  + \"-\" + hour + \"(\"+ hour2 +\")\"  + \":\" + minute + \":\" + second + \"-[ 星期\" + week2 + \"]\");\n\n        //修改时间\n        Calendar calendar1 = Calendar.getInstance();\n        calendar1.set(Calendar.DAY_OF_MONTH, 5);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //add方法修改时间\n        calendar1.add(Calendar.HOUR, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //补充方法\n        int max = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max);\n        System.out.println(min);\n\n        calendar1.add(Calendar.MONTH, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n        \n        int max2 = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min2 =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max2);\n        System.out.println(min2);\n\n    }\n```\n\n```powershell\nTue Apr 06 21:25:51 CST 2021\n1617715551128\n2021/4/6-9(21):25:51-[星期二]\n2021-4-5 21:25:51\n2021-4-5 22:25:51\n30\n1\n2021-5-5 22:25:51\n31\n1\n```\n\n\n\n## SimpleDateFormat类\n\n1. SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类\n2. 进行格式化（日期→文本）、解析（文本→日期）\n3. 常用的时间模式字母\n\n| 字母 | 日期或时间         | 示例 |\n| :--- | :----------------- | :--- |\n| y    | 年                 | 2019 |\n| 08   | 年中月份           | 08   |\n| d    | 月中天数           | 10   |\n| H    | 一天中小时（0-23） | 22   |\n| m    | 分钟               | 16   |\n| s    | 秒                 | 59   |\n| S    | 毫秒               | 356  |\n\n```java\n public static void main(String[] args) throws Exception{\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n\n        Date date = new Date();\n        String str = sdf.format(date);\n        System.out.println(str);\n\n        Date date2 = sdf.parse(\"1990/05/01\");\n\t\tSystem.out.println(date2);\n    }\n```\n\n\n\n## System类\n\n主要用于获取系统的属性数据和其他操作，构造方法私有的\n\n| 方法名                           | 说明                                               |\n| :------------------------------- | :------------------------------------------------- |\n| static void arraycopy(...)       | 复制数组                                           |\n| static long currentTimeMillis(); | 获取当前系统时间，返回毫秒值                       |\n| static void gc();                | 建议jvm赶快启动垃圾回收期器回收垃圾                |\n| static void exit(int status);    | 退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出 |\n\n\n\n```java\npublic static void main(String[] args) {\n        // arrcopy 数组的复制\n        // src: 源数组\n        // srcPos: 从哪个位置开始复制 0\n        // dest: 目标数组\n        // destPos: 目标数组的位置\n        // length: 复制的长度\n        int[] arr = {20, 10, 15, 8, 35, 26, 45, 90};\n        int[] targetarr = new int[8];\n\n        System.arraycopy(arr, 4, targetarr, 6,2);\n        System.out.println(Arrays.toString(targetarr));\n\n        //Arrays.copyOf()底层源码实现方式依旧为arraycopy\n        int[] targetarr2 = Arrays.copyOf(arr,6);\n        System.out.println(Arrays.toString(targetarr2));\n\n        //退出JVM,下面的代码不再执行\n        System.exit(0);\n        System.out.println(\"程序结束了···········\");\n    }\n```\n\n\n\n","slug":"JAVA-常用类-20210416","published":1,"updated":"2022-04-07T17:25:27.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1c0010y4w1cd7h7byk","content":"<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><span id=\"more\"></span>\n\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>成员内部类、静态内部类、局部内部类、匿名内部类</p>\n<p>概念：在一个类的内部再定义一个完整的类</p>\n<p>特点：</p>\n<ul>\n<li>编译之后可生成独立的字节码文件</li>\n<li>内部类可直接访问外部类私有成员，而不破坏封装</li>\n<li>可为外部类提供必要的内部功能组件</li>\n</ul>\n<pre><code class=\"java\">Outer$Inner.class` `Outer.class\n</code></pre>\n<pre><code class=\"java\">// 身体\nclass Body&#123;\n  // 头部\n  class Header&#123;\n    // 也会生成class文件\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a><strong>成员内部类</strong></h3><ul>\n<li>在类的内部定义，与实例变量、实例方法同级别的类</li>\n<li>外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象</li>\n<li>当外部类、内部类存在重名属性时，会优先访问内部类属性</li>\n<li>成员内部类里不能定义<strong>静态成员</strong>、可以包含<strong>静态常量(final)</strong></li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;张三&quot;;\n  private int age = 20;\n  //内部类\n  class Inner&#123;\n    private String address = &quot;北京&quot;;\n    private String phone = &quot;110&quot;;\n    private String name = &quot;李四&quot;;\n    \n    //方法\n    public void show()&#123;\n      //打印外部类属性 此时有重名属性name\n      sout(Outer.this.name); // 张三\n      sout(age);\n      //打印内部类中的属性\n      sout(name); // 李四\n      sout(address);\n      sout(phone);\n    &#125;\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 创建外部类对象\n    Outer outer = new Outer();\n    // 创建内部类对象\n    Inner inner = outer.new Inner();\n    \n    //一步到位\n    Inner inner = new Outer(.new Inner();\n                            \n    inner.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a><strong>静态内部类</strong></h3><ul>\n<li>不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员</li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;xxx&quot;;\n  private int age = 20;\n  \n  // 静态内部类，和外部类相同\n  static class Inner&#123;\n    private String address = &quot;上海&quot;;\n    private String phone = &quot;111&quot;;\n    // 静态成员\n    private static int count = 1000;\n    \n    //方法\n    public void show()&#123;\n      // 调用外部类的属性\n      // 1. 先创建外部类对象\n      Outer outer = new Outer();\n      // 2. 调用外部类对象的属性\n      sout(outer.name);\n      sout(outer.age);\n      // 调用静态内部类的属性和方法\n      sout(address);\n      sout(phone);\n      // 调用静态内部类的静态属性\n      sout(Inner.count);\n    &#125;\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 直接创建静态内部类对象\n    Outer.Inner inner = new Outer.Inner();\n                     \n    inner.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a><strong>局部内部类</strong></h3><ul>\n<li>定义在外部类<strong>方法</strong>中，作用范围和创建对象范围仅限于当前方法</li>\n<li>局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final</li>\n<li>限制类的使用范围</li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;刘德华&quot;;\n  private int age = 35;\n  \n  //方法\n  public void show()&#123;\n    // 定义局部变量\n    String address = &quot;sz&quot;;\n    \n    // 局部内部类：注意不能加任何访问修饰符\n    class Inner&#123;\n      private String phone = &quot;11234&quot;;\n      private String email = &quot;ldh@qq.com&quot;;\n      \n      public void show2()&#123;\n        // 访问外部类的属性\n        sout(name); // 相当于 Outer.this.name\n        sout(age);\n        // 访问内部类的属性\n        sout(this.phone);\n        sout(this.email);\n        \n        // 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final\n        \n      &#125;\n    &#125;\n    // 创建局部内部类对象\n    Inner inner = new Inner();\n    inner.show2();\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 创建外部类对象\n    Outer outer = new Outer();\n                     \n    outer.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a><strong>匿名内部类</strong></h3><ul>\n<li>没有类名的局部内部类（一切特征都与局部内部类相同）</li>\n<li>必须继承一个父类或者实现一个接口</li>\n<li>定义类、实现类、创建对象的语法合并，只能创建一个该类的对象</li>\n<li>优点：减少代码量</li>\n<li>缺点可读性较差</li>\n</ul>\n<pre><code class=\"Java\">// 使用匿名内部类优化（相当于创建了一个局部内部类）\nUsb usb = new Usb()&#123; // Usb为一个接口\n  @Override\n  public void service()&#123;\n    sout(&quot;连接电脑成功，fan开始工作&quot;)\n  &#125;\n&#125;;\nusb.service();\n</code></pre>\n<h2 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h2><ol>\n<li>超类、基类，所有类的直接或间接父类，位于继承树的最顶层</li>\n<li>任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承</li>\n<li>Object类中所定义的方法，是所有对象都具备的方法</li>\n<li>Object类型可以存储任何对象<ol>\n<li>作为参数，可接受任何对象</li>\n<li>作为返回值，可返回任何对象</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"getClass类\"><a href=\"#getClass类\" class=\"headerlink\" title=\"getClass类\"></a>getClass类</h3><ol>\n<li><p><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></p>\n</li>\n<li><p>返回引用中存储的实际对象类型</p>\n</li>\n<li><p>应用：通常用于判断两个引用中实际存储对象类型是否一致</p>\n</li>\n</ol>\n<pre><code class=\"java\">// 判断s1 和 s2是不是同一个类型\nClass class1 = s1.getClass();\nClass class2 = s2.getClass();\n// getClass返回 class类型\n</code></pre>\n<h3 id=\"hashcode类\"><a href=\"#hashcode类\" class=\"headerlink\" title=\"hashcode类\"></a>hashcode类</h3><ol>\n<li><code>public int hashCode()&#123;&#125;</code></li>\n<li>返回该对象的哈希码值</li>\n<li>哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的值</li>\n<li>一般情况下相同对象返回相同哈希码</li>\n</ol>\n<pre><code class=\"java\">s1.hashCode();\ns2.hashCode();\n// 自然不同  hashcode s1 != s2\nStudent s3 = s1;\ns3.hashCode();\n// s3的hashCode与s1相同,将s1赋给s3\n</code></pre>\n<h3 id=\"toString类\"><a href=\"#toString类\" class=\"headerlink\" title=\"toString类\"></a>toString类</h3><ol>\n<li><code>public String toSring()&#123;&#125;</code></li>\n<li>返回该对象的字符串表示（表现形式）</li>\n<li>可以根据程序需求覆盖该方法，如：展示对象各个属性值</li>\n</ol>\n<pre><code class=\"java\">sout(s1.toString()); // 直接打印包+类名+哈希值\n\n// 重写 快捷键 alt + Ins\n@override\npublic String toString()&#123;\n  return &quot;Student [name = &quot; + name + &quot;, age = &quot; + age + &quot;]&quot;;\n&#125;\n</code></pre>\n<h3 id=\"equals-类\"><a href=\"#equals-类\" class=\"headerlink\" title=\"equals()类\"></a>equals()类</h3><ol>\n<li><code>public boolean equals(Object obj)&#123;&#125;</code></li>\n<li>默认实现为(this == obj), 比较两个对象地址是否相同</li>\n<li>可进行覆盖，比较两个对象的内容是否相同</li>\n</ol>\n<pre><code class=\"java\">System.out.println(s1.equals(s2)); //false\nSstudent s3 = s1;\nSystem.out.println(s1.equals(s3)); //true\n\nStudent eq1 = new Student(&quot;xm&quot;, 11);\nStudent eq2 = new Student(&quot;xm&quot;, 11);\nSystem.out.println(eq1.equals(eq2)); //false,地址不同\n</code></pre>\n<p>​    重写equals()方法:</p>\n<pre><code class=\"java\">Entity中:\n// 重写 改变其比较内容\n/*\n步骤  1. 比较两个应用是否指向同一个对象\n     2. 判断obj是否为null\n     3. 判断两个引用只想的实际对象类型是否一致\n     4. 强制类型转换\n     5. 依次比较各个属性值是否相同\n*/\n@override\npublic boolean equals(Object obj)&#123;\n  // 1.\n  if(this == obj)&#123;\n    return true;\n  &#125;\n  // 2.\n  if(obj == null)&#123;\n    return false;\n  &#125;\n  // 3.\n  // if(this.getClass() == obj.getClass())&#123;\n  //\n  // &#125;\n  // instanceof 判断对象是否是某种类型\n  if(obj instanceof Student)&#123;\n    // 4.强制类型转换\n    Student s = (Student)obj;\n    // 5. 比较属性\n    if(this.name.equals(s.getName()) &amp;&amp; this.age == s.getAge())&#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;\n</code></pre>\n<h3 id=\"finalize-方法\"><a href=\"#finalize-方法\" class=\"headerlink\" title=\"finalize()方法\"></a>finalize()方法</h3><ol>\n<li>当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列</li>\n<li>垃圾对象：没有有效引用指向此对象时，为垃圾对象</li>\n<li>垃圾回收：由gc销毁垃圾对象，释放数据存储空间</li>\n<li>自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象</li>\n<li>手动回收机制：使用<code>System.gc();</code>通知JVM执行垃圾回收</li>\n</ol>\n<pre><code class=\"java\">finalize默认为空，重写方法：\n@Override\nprotected void finalize() throws Throwable&#123;\n  sout(this.name + &quot;对象被回收了&quot;);\n&#125;\n\nStudent s1 = new Student(&quot;aaa&quot;, 1);\nnew Student(&quot;aaa&quot;, 1);\n//手动告诉JVM进行回收；\nSystem.gc();\nSystem.out.println(&quot;回收垃圾&quot;);\n</code></pre>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><ol>\n<li><strong>基本数据类型</strong>所对应的<strong>引用数据类型</strong></li>\n<li>Object 可统一所有数据，包装类的默认值是null</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Character</td>\n</tr>\n</tbody></table>\n<h3 id=\"类型转换与装箱、拆箱\"><a href=\"#类型转换与装箱、拆箱\" class=\"headerlink\" title=\"类型转换与装箱、拆箱\"></a><strong>类型转换与装箱、拆箱</strong></h3><ol>\n<li>8种包装类提供不用类型间的转换方式<ol>\n<li>Number父类中提供的6个共性方法</li>\n<li><code>parseXXX( )</code>静态方法</li>\n<li><code>valueOf( )</code>静态方法</li>\n</ol>\n</li>\n<li>注意：需保证类型兼容，否则抛出<code>NumberFormatException</code>异常</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        // 装箱， 基本类型 → 引用类型\n        // 基本类型\n        int num1 = 18;\n        // 使用Integer类创建对象\n        Integer integer1 = new Integer(num1);\n        Integer integer2 = Integer.valueOf(num1);\n\n        System.out.println(&quot;装箱&quot;);\n        System.out.println(integer1);\n        System.out.println(integer2);\n\n        // 拆箱， 引用类型 → 基本类型\n        Integer integer3 = new Integer(100);\n        int num2 = integer3.intValue();\n\n        System.out.println(&quot;拆箱&quot;);\n        System.out.println(num2);\n\n        //↑ JDK1.5 之前，JDK1.5之后自动装箱和拆箱\n        int age = 30;\n        //自动装箱\n        Integer integer4 = age;\n        System.out.println(&quot;自动装箱&quot;);\n        System.out.println(integer4);\n        //自动拆箱\n        int age2 = integer4;\n\n        System.out.println(&quot;自动拆箱&quot;);\n        System.out.println(age2);\n        System.out.println(&quot;---------------------------------------&quot;);\n        //基本类型和字符串之间的转换\n        //基本类型转换为字符串\n        // 基本类型和字符串之间转换\n        // 1. 基本类型转成字符串\n        int n1 = 100;\n        // 1.1 使用+号\n        String s1 = n1 + &quot;&quot;;\n        // 1.2 使用Integer中的toString()方法\n        String s2 = Integer.toString(n1,2);\n        System.out.println(s2);\n       //String s2 = Integer.toString(n1, x); // x为进制要求\n\n        // 2. 字符串转成基本类型\n        String str = &quot;150&quot;;\n        // 使用Integer.parseXXX();\n        int n2 = Integer.parseInt(str);\n        System.out.println(n2);\n\n        // boolean 字符串形式转成基本类型，&quot;true&quot; ---&gt; true 非“true ———&gt; false\n        String str2 = &quot;true&quot;;\n        boolean b1 = Boolean.parseBoolean(str2);\n        System.out.println(b1);\n    &#125;\n</code></pre>\n<h2 id=\"整数缓冲区\"><a href=\"#整数缓冲区\" class=\"headerlink\" title=\"整数缓冲区\"></a>整数缓冲区</h2><ol>\n<li>Java预先创建了256个常用的证书包装类型对象</li>\n<li>在实际应用当中，对已创建的对象进行复用</li>\n</ol>\n<pre><code class=\"java\">  public static void main(String[] args) &#123;\n        // 面试题\n        Integer integer1 = new Integer(100);\n        Integer integer2 = new Integer(100);\n        System.out.println(integer1 == integer2); // false\n\n        Integer integer3 =  Integer.valueOf(100);// 自动装箱\n        // 相当于调用 Integer.valueOf(100);\n        Integer integer4 = Integer.valueOf(100);\n        System.out.println(integer3 == integer4); // true\n\n        Integer integer5 = Integer.valueOf(200);// 自动装箱\n        Integer integer6 = Integer.valueOf(200);\n        System.out.println(integer5 == integer6); // false\n\n        // 因为缓存区数组 [-128, 127] 在这之内地址一样\n    &#125;\n</code></pre>\n<h2 id=\"String类\"><a href=\"#String类\" class=\"headerlink\" title=\"String类\"></a>String类</h2><ol>\n<li>字符串是final修饰的常量，创建之后不可改变</li>\n<li>字符串字面值存储在字符串池中，可以共享</li>\n<li><code>String s = &quot;Hello&quot;;</code>产生一个对象，字符串池中存储</li>\n<li><code>String s = new String(&quot;Hello&quot;);</code> 产生两个对象，<strong>堆、池</strong>各一个</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        // 1. length(); 返回字符串长度\n        // 2. charAt(int index); 返回某个位置的字符\n        // 3. contains(String str); 判断是否包含某个字符串\n\n        String content = &quot;java是最好的语言, java no1&quot;;\n        System.out.println(content.length()); // 10\n        System.out.println(content.charAt(content.length() - 1)); // 言\n        System.out.println(content.contains(&quot;java&quot;)); // true\n\n        // 4. toCharArray(); 返回字符串对应数组\n        // 5. indexOf(); 返回子字符串首次出现的位置\n        // 6. lastIndexOf(); 返回字符串最后一次出现的位置\n\n        System.out.println(content.toCharArray());\n        System.out.println(content.indexOf(&quot;java&quot;)); // 0\n        System.out.println(content.indexOf(&quot;java&quot;, 4)); // 从索引4开始找 返回12\n        System.out.println(content.lastIndexOf(&quot;java&quot;)); // 12\n\n        // 7. trim(); //去掉字符串前后空格\n        // 8. toUpperCase(); toLowerCase(); 转换大小写\n        // 9. endWith(str); startWith(str);  判断是否以str 结尾、开头\n\n        String ct = &quot; hello world &quot;;\n        System.out.println(ct.trim()); // &quot;hello world&quot;\n        System.out.println(ct.toUpperCase()); // HELLO WORLD\n        System.out.println(ct.toLowerCase()); // hello world\n        System.out.println(ct.endsWith(&quot;world&quot;)); // true\n        System.out.println(ct.startsWith(&quot;hello&quot;)); // true\n\n        // 10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串\n        // 11. split(); 对字符串拆分\n\n        System.out.println(content.replace(&quot;java&quot;, &quot;python&quot;)); // php是最好的语言, php no1\n\n        String say = &quot;java is the best language&quot;;\n        String[] arr = say.split(&quot; &quot;); // &quot;[ ,]+&quot; 表示空格 逗号切分 +号表示切分可以多个 比如多个空格\n        System.out.println(arr.length); // 5\n        for (String string : arr) &#123;\n            System.out.println(string);\n        &#125;\n        // 打印出\n        //java\n        //is\n        //the\n        //best\n        //language\n\n        // 补充两个equals/compareTo();比较大小\n        String s1 = &quot;hello&quot;;\n        String s2 = &quot;HELLO&quot;;\n        System.out.println(s1.equalsIgnoreCase(s2));// 忽略大小写比较true\n\n        // compareTo(); 两字符不同时比较字符字典序的ascii码\n        // 字符相同时比较长度 返回差值\n\n    &#125;\n</code></pre>\n<h3 id=\"String-常用方法\"><a href=\"#String-常用方法\" class=\"headerlink\" title=\"String 常用方法\"></a>String 常用方法</h3><ol>\n<li>length(); 返回字符串长度；</li>\n<li>charAt(int index); 返回某个位置的字符；</li>\n<li>contains(String str); 判断是否包含某个字符串；</li>\n<li>toCharArray(); 返回字符串对应数组；</li>\n<li>indexOf(); 返回子字符串首次出现的位置；</li>\n<li>lastIndexOf(); 返回字符串最后一次出现的位置；</li>\n<li>trim(); //去掉字符串前后空格；</li>\n<li>toUpperCase(); toLowerCase(); 转换大小写；</li>\n<li>endWith(str); startWith(str);  判断是否以str 结尾、开头；</li>\n<li>replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串；</li>\n<li>split(); 对字符串拆分；</li>\n</ol>\n<h4 id=\"案例演示\"><a href=\"#案例演示\" class=\"headerlink\" title=\"案例演示\"></a>案例演示</h4><p>需求：</p>\n<ol>\n<li>已知String str = “this is a text”;</li>\n<li>将str中的单词单独获取</li>\n<li>将str中的text替换成practice</li>\n<li>在text前面插入一个easy</li>\n<li>将每个单词的首字母改为大写</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n//        已知String str = &quot;this is a text&quot;;\n//        将str中的单词单独获取\n//        将str中的text替换成practice\n//        在text前面插入一个easy\n//        将每个单词的首字母改为大写\n\n        String str = &quot;this is a text&quot;;\n        String[] arr = str.split(&quot; &quot;);\n        for (String s : arr) &#123;\n            System.out.println(s);\n        &#125;\n\n\n        str = str.replace(&quot;text&quot;, &quot;practice&quot;);\n        System.out.println(str);\n\n        str =  str.replace(&quot;practice&quot;, &quot;easy practice&quot;);\n        System.out.println(str);\n\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            char first = arr[i].charAt(0);\n            char upperfirst = Character.toUpperCase(first);\n            String newstr = upperfirst + arr[i].substring(1);\n            System.out.println(newstr);\n\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"StringBuffer-和-StringBuilder\"><a href=\"#StringBuffer-和-StringBuilder\" class=\"headerlink\" title=\"StringBuffer 和 StringBuilder\"></a>StringBuffer 和 StringBuilder</h3><ol>\n<li>StringBuffer : 可变长字符串，运行效率慢、线程安全</li>\n<li>StringBuilder : 可边长字符串、运行快、线程不安全</li>\n</ol>\n<p>效率都比String高且节省内存</p>\n<pre><code class=\"java\">        StringBuffer sb = new StringBuffer();\n        sb.append(&quot;java世界第一&quot;);\n        System.out.println(sb.toString());\n        sb.append(&quot;java真香&quot;);\n        System.out.println(sb.toString());\n        sb.append(&quot;java不错&quot;);\n        System.out.println(sb.toString());\n        sb.insert(0,&quot;我在最前面&quot;);\n        System.out.println(sb.toString());\n        sb.replace(0,5,&quot;hello&quot;);\n        System.out.println(sb.toString());\n        sb.delete(0,5);\n        System.out.println(sb.toString());\n        sb.delete(0,sb.length());\n        System.out.println(&quot;delete&quot; + sb.toString());\n</code></pre>\n<p>测试效率：</p>\n<pre><code class=\"java\">    public static void main(String[] args) &#123;\n        long start = System.currentTimeMillis();\n        String str = &quot;&quot;;\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            str+=i;\n        &#125;\n\n        long end = System.currentTimeMillis();\n\n        System.out.println((float) (end-start)/1000 + &quot;s&quot;);\n\n\n        long start2 = System.currentTimeMillis();\n        StringBuffer sb = new StringBuffer(&quot;&quot;);\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            sb.append(i);\n        &#125;\n\n        long end2 = System.currentTimeMillis();\n\n        System.out.println(end2-start2 + &quot;ms&quot;);\n\n        long start3 = System.currentTimeMillis();\n        StringBuilder sbu = new StringBuilder(&quot;&quot;);\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            sbu.append(i);\n        &#125;\n\n        long end3 = System.currentTimeMillis();\n\n        System.out.println(end3-start3 + &quot;ms&quot;);\n\n    &#125;\n\n输出结果：\n18.49s\n10ms\n0ms\n    \n可见效率差距\n</code></pre>\n<h2 id=\"BigDecimal类\"><a href=\"#BigDecimal类\" class=\"headerlink\" title=\"BigDecimal类\"></a>BigDecimal类</h2><ol>\n<li><p>位置 <code>java.math</code> 包中</p>\n</li>\n<li><p>作用 精确计算浮点数</p>\n</li>\n<li><p>创建方式 <code>BigDecimal bd = new BigDecimal(&quot;1.0&quot;);</code></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        double d1 = 1.0;\n        double d2 = 0.9;\n        System.out.println(&quot;d1-d2=&quot; + (d1-d2));\n\n        double res = (1.4-0.5)/0.9;\n        System.out.println(&quot;result=&quot; + res);\n\n\n        BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;);\n        BigDecimal bd2 = new BigDecimal(&quot;0.9&quot;);\n\n        BigDecimal bdres1 = bd1.add(bd2); //加\n        BigDecimal bdres2 = bd1.subtract(bd2); //减\n        BigDecimal bdres3 = bd1.multiply(bd2); //乘\n        BigDecimal bdres4 = \n            bd1.divide(bd2,2,BigDecimal.ROUND_HALF_UP); //除\n    // bd1.divide(除数,小数精确到几位,BigDecimal.ROUND_HALF_UP=四舍五入);\n        System.out.println(&quot;加=&quot;+bdres1+&quot;\\n减=&quot;+bdres2+&quot;\\n乘=&quot;+bdres3+&quot;\\n除=&quot;+bdres4);\n    &#125;\n</code></pre>\n<pre><code class=\"java\">d1-d2=0.09999999999999998\nresult=0.9999999999999999\n加=1.9\n减=0.1\n乘=0.90\n除=1.11\n</code></pre>\n</li>\n</ol>\n<h2 id=\"时间-Date类\"><a href=\"#时间-Date类\" class=\"headerlink\" title=\"时间-Date类\"></a>时间-Date类</h2><ol>\n<li>Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代; ( 时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns; ) </li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Date date1 = new Date();\n        System.out.println(date1.toString());\n        System.out.println(date1.toLocaleString());\n\n        //昨天\n        Date date2 = new Date(date1.getTime() - (60*60*24*1000));\n        System.out.println(date2.toLocaleString());\n\n\n        //方法after before\n        boolean b1 = date1.after(date2);\n        System.out.println(b1);\n\n        boolean b2 = date1.before(date2);\n        System.out.println(b2);\n\n\n        //比较compareTo(),比较毫秒值\n        int d1 = date1.compareTo(date2);\n        System.out.println(d1);\n\n        int d2 = date1.compareTo(date1);\n        System.out.println(d2);\n\n        //比较是否相等\n        boolean b3 = date1.equals(date2);\n        System.out.println(b3);\n\n    &#125;\n</code></pre>\n<h2 id=\"时间-Calendar类\"><a href=\"#时间-Calendar类\" class=\"headerlink\" title=\"时间-Calendar类\"></a>时间-Calendar类</h2><ol>\n<li>Calendar提供了获取或设置各种日历字段的方法</li>\n<li>构造方法 <code>protected Calendar();</code> 由于是protected 所以无法直接创建</li>\n<li>其他方法</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">static Calendar getInstance()</td>\n<td align=\"left\">使用默认时区和区域获取日历</td>\n</tr>\n<tr>\n<td align=\"left\">void set(int year, int month, int date, int hourofday, int minute, int second)</td>\n<td align=\"left\">设置日历的年、月、日、时、分、秒</td>\n</tr>\n<tr>\n<td align=\"left\">int get(int field)</td>\n<td align=\"left\">返回给定日历字段的值。字段比如年、月、日</td>\n</tr>\n<tr>\n<td align=\"left\">void setTime(Date date)</td>\n<td align=\"left\">用给定的date设置此日历时间</td>\n</tr>\n<tr>\n<td align=\"left\">Date getTime()</td>\n<td align=\"left\">返回一个date表示此日历的时间</td>\n</tr>\n<tr>\n<td align=\"left\">void add(int field, int amount)</td>\n<td align=\"left\">按照日历的规则，给指定字段添加或减少时间量</td>\n</tr>\n<tr>\n<td align=\"left\">long getTimeInMilles()</td>\n<td align=\"left\">毫秒为单位返回该日历的时间值</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建Calendar对象\n        Calendar calendar = Calendar.getInstance();\n        System.out.println(calendar.getTime().toString());\n        System.out.println(calendar.getTimeInMillis());\n\n        //获取时间信息\n        //获取年\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR); //12时制\n        int hour2 = calendar.get(Calendar.HOUR_OF_DAY);//24时制\n        int minute = calendar.get(Calendar.MINUTE);\n        int second = calendar.get(Calendar.SECOND);\n        int week = calendar.get(Calendar.DAY_OF_WEEK);\n        String[] arr = &#123;&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;&#125;;\n        String week2 = arr[week-1];\n        System.out.println(year + &quot;/&quot; + (month+1) + &quot;/&quot; + date  + &quot;-&quot; + hour + &quot;(&quot;+ hour2 +&quot;)&quot;  + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;-[ 星期&quot; + week2 + &quot;]&quot;);\n\n        //修改时间\n        Calendar calendar1 = Calendar.getInstance();\n        calendar1.set(Calendar.DAY_OF_MONTH, 5);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //add方法修改时间\n        calendar1.add(Calendar.HOUR, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //补充方法\n        int max = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max);\n        System.out.println(min);\n\n        calendar1.add(Calendar.MONTH, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n        \n        int max2 = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min2 =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max2);\n        System.out.println(min2);\n\n    &#125;\n</code></pre>\n<pre><code class=\"powershell\">Tue Apr 06 21:25:51 CST 2021\n1617715551128\n2021/4/6-9(21):25:51-[星期二]\n2021-4-5 21:25:51\n2021-4-5 22:25:51\n30\n1\n2021-5-5 22:25:51\n31\n1\n</code></pre>\n<h2 id=\"SimpleDateFormat类\"><a href=\"#SimpleDateFormat类\" class=\"headerlink\" title=\"SimpleDateFormat类\"></a>SimpleDateFormat类</h2><ol>\n<li>SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类</li>\n<li>进行格式化（日期→文本）、解析（文本→日期）</li>\n<li>常用的时间模式字母</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字母</th>\n<th align=\"left\">日期或时间</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">y</td>\n<td align=\"left\">年</td>\n<td align=\"left\">2019</td>\n</tr>\n<tr>\n<td align=\"left\">08</td>\n<td align=\"left\">年中月份</td>\n<td align=\"left\">08</td>\n</tr>\n<tr>\n<td align=\"left\">d</td>\n<td align=\"left\">月中天数</td>\n<td align=\"left\">10</td>\n</tr>\n<tr>\n<td align=\"left\">H</td>\n<td align=\"left\">一天中小时（0-23）</td>\n<td align=\"left\">22</td>\n</tr>\n<tr>\n<td align=\"left\">m</td>\n<td align=\"left\">分钟</td>\n<td align=\"left\">16</td>\n</tr>\n<tr>\n<td align=\"left\">s</td>\n<td align=\"left\">秒</td>\n<td align=\"left\">59</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">毫秒</td>\n<td align=\"left\">356</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\"> public static void main(String[] args) throws Exception&#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\n\n        Date date = new Date();\n        String str = sdf.format(date);\n        System.out.println(str);\n\n        Date date2 = sdf.parse(&quot;1990/05/01&quot;);\n        System.out.println(date2);\n    &#125;\n</code></pre>\n<h2 id=\"System类\"><a href=\"#System类\" class=\"headerlink\" title=\"System类\"></a>System类</h2><p>主要用于获取系统的属性数据和其他操作，构造方法私有的</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">static void arraycopy(…)</td>\n<td align=\"left\">复制数组</td>\n</tr>\n<tr>\n<td align=\"left\">static long currentTimeMillis();</td>\n<td align=\"left\">获取当前系统时间，返回毫秒值</td>\n</tr>\n<tr>\n<td align=\"left\">static void gc();</td>\n<td align=\"left\">建议jvm赶快启动垃圾回收期器回收垃圾</td>\n</tr>\n<tr>\n<td align=\"left\">static void exit(int status);</td>\n<td align=\"left\">退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        // arrcopy 数组的复制\n        // src: 源数组\n        // srcPos: 从哪个位置开始复制 0\n        // dest: 目标数组\n        // destPos: 目标数组的位置\n        // length: 复制的长度\n        int[] arr = &#123;20, 10, 15, 8, 35, 26, 45, 90&#125;;\n        int[] targetarr = new int[8];\n\n        System.arraycopy(arr, 4, targetarr, 6,2);\n        System.out.println(Arrays.toString(targetarr));\n\n        //Arrays.copyOf()底层源码实现方式依旧为arraycopy\n        int[] targetarr2 = Arrays.copyOf(arr,6);\n        System.out.println(Arrays.toString(targetarr2));\n\n        //退出JVM,下面的代码不再执行\n        System.exit(0);\n        System.out.println(&quot;程序结束了···········&quot;);\n    &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1>","more":"<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>成员内部类、静态内部类、局部内部类、匿名内部类</p>\n<p>概念：在一个类的内部再定义一个完整的类</p>\n<p>特点：</p>\n<ul>\n<li>编译之后可生成独立的字节码文件</li>\n<li>内部类可直接访问外部类私有成员，而不破坏封装</li>\n<li>可为外部类提供必要的内部功能组件</li>\n</ul>\n<pre><code class=\"java\">Outer$Inner.class` `Outer.class\n</code></pre>\n<pre><code class=\"java\">// 身体\nclass Body&#123;\n  // 头部\n  class Header&#123;\n    // 也会生成class文件\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a><strong>成员内部类</strong></h3><ul>\n<li>在类的内部定义，与实例变量、实例方法同级别的类</li>\n<li>外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象</li>\n<li>当外部类、内部类存在重名属性时，会优先访问内部类属性</li>\n<li>成员内部类里不能定义<strong>静态成员</strong>、可以包含<strong>静态常量(final)</strong></li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;张三&quot;;\n  private int age = 20;\n  //内部类\n  class Inner&#123;\n    private String address = &quot;北京&quot;;\n    private String phone = &quot;110&quot;;\n    private String name = &quot;李四&quot;;\n    \n    //方法\n    public void show()&#123;\n      //打印外部类属性 此时有重名属性name\n      sout(Outer.this.name); // 张三\n      sout(age);\n      //打印内部类中的属性\n      sout(name); // 李四\n      sout(address);\n      sout(phone);\n    &#125;\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 创建外部类对象\n    Outer outer = new Outer();\n    // 创建内部类对象\n    Inner inner = outer.new Inner();\n    \n    //一步到位\n    Inner inner = new Outer(.new Inner();\n                            \n    inner.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a><strong>静态内部类</strong></h3><ul>\n<li>不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员</li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;xxx&quot;;\n  private int age = 20;\n  \n  // 静态内部类，和外部类相同\n  static class Inner&#123;\n    private String address = &quot;上海&quot;;\n    private String phone = &quot;111&quot;;\n    // 静态成员\n    private static int count = 1000;\n    \n    //方法\n    public void show()&#123;\n      // 调用外部类的属性\n      // 1. 先创建外部类对象\n      Outer outer = new Outer();\n      // 2. 调用外部类对象的属性\n      sout(outer.name);\n      sout(outer.age);\n      // 调用静态内部类的属性和方法\n      sout(address);\n      sout(phone);\n      // 调用静态内部类的静态属性\n      sout(Inner.count);\n    &#125;\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 直接创建静态内部类对象\n    Outer.Inner inner = new Outer.Inner();\n                     \n    inner.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a><strong>局部内部类</strong></h3><ul>\n<li>定义在外部类<strong>方法</strong>中，作用范围和创建对象范围仅限于当前方法</li>\n<li>局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final</li>\n<li>限制类的使用范围</li>\n</ul>\n<pre><code class=\"java\">// 外部类\npublic class Outer&#123;\n  //实例变量\n  private String name = &quot;刘德华&quot;;\n  private int age = 35;\n  \n  //方法\n  public void show()&#123;\n    // 定义局部变量\n    String address = &quot;sz&quot;;\n    \n    // 局部内部类：注意不能加任何访问修饰符\n    class Inner&#123;\n      private String phone = &quot;11234&quot;;\n      private String email = &quot;ldh@qq.com&quot;;\n      \n      public void show2()&#123;\n        // 访问外部类的属性\n        sout(name); // 相当于 Outer.this.name\n        sout(age);\n        // 访问内部类的属性\n        sout(this.phone);\n        sout(this.email);\n        \n        // 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final\n        \n      &#125;\n    &#125;\n    // 创建局部内部类对象\n    Inner inner = new Inner();\n    inner.show2();\n  &#125;\n&#125;\n\n// 测试类\npublic class Test&#123;\n  psvm(String[] args)&#123;\n    // 创建外部类对象\n    Outer outer = new Outer();\n                     \n    outer.show();\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a><strong>匿名内部类</strong></h3><ul>\n<li>没有类名的局部内部类（一切特征都与局部内部类相同）</li>\n<li>必须继承一个父类或者实现一个接口</li>\n<li>定义类、实现类、创建对象的语法合并，只能创建一个该类的对象</li>\n<li>优点：减少代码量</li>\n<li>缺点可读性较差</li>\n</ul>\n<pre><code class=\"Java\">// 使用匿名内部类优化（相当于创建了一个局部内部类）\nUsb usb = new Usb()&#123; // Usb为一个接口\n  @Override\n  public void service()&#123;\n    sout(&quot;连接电脑成功，fan开始工作&quot;)\n  &#125;\n&#125;;\nusb.service();\n</code></pre>\n<h2 id=\"Object类\"><a href=\"#Object类\" class=\"headerlink\" title=\"Object类\"></a>Object类</h2><ol>\n<li>超类、基类，所有类的直接或间接父类，位于继承树的最顶层</li>\n<li>任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承</li>\n<li>Object类中所定义的方法，是所有对象都具备的方法</li>\n<li>Object类型可以存储任何对象<ol>\n<li>作为参数，可接受任何对象</li>\n<li>作为返回值，可返回任何对象</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"getClass类\"><a href=\"#getClass类\" class=\"headerlink\" title=\"getClass类\"></a>getClass类</h3><ol>\n<li><p><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></p>\n</li>\n<li><p>返回引用中存储的实际对象类型</p>\n</li>\n<li><p>应用：通常用于判断两个引用中实际存储对象类型是否一致</p>\n</li>\n</ol>\n<pre><code class=\"java\">// 判断s1 和 s2是不是同一个类型\nClass class1 = s1.getClass();\nClass class2 = s2.getClass();\n// getClass返回 class类型\n</code></pre>\n<h3 id=\"hashcode类\"><a href=\"#hashcode类\" class=\"headerlink\" title=\"hashcode类\"></a>hashcode类</h3><ol>\n<li><code>public int hashCode()&#123;&#125;</code></li>\n<li>返回该对象的哈希码值</li>\n<li>哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的值</li>\n<li>一般情况下相同对象返回相同哈希码</li>\n</ol>\n<pre><code class=\"java\">s1.hashCode();\ns2.hashCode();\n// 自然不同  hashcode s1 != s2\nStudent s3 = s1;\ns3.hashCode();\n// s3的hashCode与s1相同,将s1赋给s3\n</code></pre>\n<h3 id=\"toString类\"><a href=\"#toString类\" class=\"headerlink\" title=\"toString类\"></a>toString类</h3><ol>\n<li><code>public String toSring()&#123;&#125;</code></li>\n<li>返回该对象的字符串表示（表现形式）</li>\n<li>可以根据程序需求覆盖该方法，如：展示对象各个属性值</li>\n</ol>\n<pre><code class=\"java\">sout(s1.toString()); // 直接打印包+类名+哈希值\n\n// 重写 快捷键 alt + Ins\n@override\npublic String toString()&#123;\n  return &quot;Student [name = &quot; + name + &quot;, age = &quot; + age + &quot;]&quot;;\n&#125;\n</code></pre>\n<h3 id=\"equals-类\"><a href=\"#equals-类\" class=\"headerlink\" title=\"equals()类\"></a>equals()类</h3><ol>\n<li><code>public boolean equals(Object obj)&#123;&#125;</code></li>\n<li>默认实现为(this == obj), 比较两个对象地址是否相同</li>\n<li>可进行覆盖，比较两个对象的内容是否相同</li>\n</ol>\n<pre><code class=\"java\">System.out.println(s1.equals(s2)); //false\nSstudent s3 = s1;\nSystem.out.println(s1.equals(s3)); //true\n\nStudent eq1 = new Student(&quot;xm&quot;, 11);\nStudent eq2 = new Student(&quot;xm&quot;, 11);\nSystem.out.println(eq1.equals(eq2)); //false,地址不同\n</code></pre>\n<p>​    重写equals()方法:</p>\n<pre><code class=\"java\">Entity中:\n// 重写 改变其比较内容\n/*\n步骤  1. 比较两个应用是否指向同一个对象\n     2. 判断obj是否为null\n     3. 判断两个引用只想的实际对象类型是否一致\n     4. 强制类型转换\n     5. 依次比较各个属性值是否相同\n*/\n@override\npublic boolean equals(Object obj)&#123;\n  // 1.\n  if(this == obj)&#123;\n    return true;\n  &#125;\n  // 2.\n  if(obj == null)&#123;\n    return false;\n  &#125;\n  // 3.\n  // if(this.getClass() == obj.getClass())&#123;\n  //\n  // &#125;\n  // instanceof 判断对象是否是某种类型\n  if(obj instanceof Student)&#123;\n    // 4.强制类型转换\n    Student s = (Student)obj;\n    // 5. 比较属性\n    if(this.name.equals(s.getName()) &amp;&amp; this.age == s.getAge())&#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;\n</code></pre>\n<h3 id=\"finalize-方法\"><a href=\"#finalize-方法\" class=\"headerlink\" title=\"finalize()方法\"></a>finalize()方法</h3><ol>\n<li>当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列</li>\n<li>垃圾对象：没有有效引用指向此对象时，为垃圾对象</li>\n<li>垃圾回收：由gc销毁垃圾对象，释放数据存储空间</li>\n<li>自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象</li>\n<li>手动回收机制：使用<code>System.gc();</code>通知JVM执行垃圾回收</li>\n</ol>\n<pre><code class=\"java\">finalize默认为空，重写方法：\n@Override\nprotected void finalize() throws Throwable&#123;\n  sout(this.name + &quot;对象被回收了&quot;);\n&#125;\n\nStudent s1 = new Student(&quot;aaa&quot;, 1);\nnew Student(&quot;aaa&quot;, 1);\n//手动告诉JVM进行回收；\nSystem.gc();\nSystem.out.println(&quot;回收垃圾&quot;);\n</code></pre>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><ol>\n<li><strong>基本数据类型</strong>所对应的<strong>引用数据类型</strong></li>\n<li>Object 可统一所有数据，包装类的默认值是null</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Character</td>\n</tr>\n</tbody></table>\n<h3 id=\"类型转换与装箱、拆箱\"><a href=\"#类型转换与装箱、拆箱\" class=\"headerlink\" title=\"类型转换与装箱、拆箱\"></a><strong>类型转换与装箱、拆箱</strong></h3><ol>\n<li>8种包装类提供不用类型间的转换方式<ol>\n<li>Number父类中提供的6个共性方法</li>\n<li><code>parseXXX( )</code>静态方法</li>\n<li><code>valueOf( )</code>静态方法</li>\n</ol>\n</li>\n<li>注意：需保证类型兼容，否则抛出<code>NumberFormatException</code>异常</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        // 装箱， 基本类型 → 引用类型\n        // 基本类型\n        int num1 = 18;\n        // 使用Integer类创建对象\n        Integer integer1 = new Integer(num1);\n        Integer integer2 = Integer.valueOf(num1);\n\n        System.out.println(&quot;装箱&quot;);\n        System.out.println(integer1);\n        System.out.println(integer2);\n\n        // 拆箱， 引用类型 → 基本类型\n        Integer integer3 = new Integer(100);\n        int num2 = integer3.intValue();\n\n        System.out.println(&quot;拆箱&quot;);\n        System.out.println(num2);\n\n        //↑ JDK1.5 之前，JDK1.5之后自动装箱和拆箱\n        int age = 30;\n        //自动装箱\n        Integer integer4 = age;\n        System.out.println(&quot;自动装箱&quot;);\n        System.out.println(integer4);\n        //自动拆箱\n        int age2 = integer4;\n\n        System.out.println(&quot;自动拆箱&quot;);\n        System.out.println(age2);\n        System.out.println(&quot;---------------------------------------&quot;);\n        //基本类型和字符串之间的转换\n        //基本类型转换为字符串\n        // 基本类型和字符串之间转换\n        // 1. 基本类型转成字符串\n        int n1 = 100;\n        // 1.1 使用+号\n        String s1 = n1 + &quot;&quot;;\n        // 1.2 使用Integer中的toString()方法\n        String s2 = Integer.toString(n1,2);\n        System.out.println(s2);\n       //String s2 = Integer.toString(n1, x); // x为进制要求\n\n        // 2. 字符串转成基本类型\n        String str = &quot;150&quot;;\n        // 使用Integer.parseXXX();\n        int n2 = Integer.parseInt(str);\n        System.out.println(n2);\n\n        // boolean 字符串形式转成基本类型，&quot;true&quot; ---&gt; true 非“true ———&gt; false\n        String str2 = &quot;true&quot;;\n        boolean b1 = Boolean.parseBoolean(str2);\n        System.out.println(b1);\n    &#125;\n</code></pre>\n<h2 id=\"整数缓冲区\"><a href=\"#整数缓冲区\" class=\"headerlink\" title=\"整数缓冲区\"></a>整数缓冲区</h2><ol>\n<li>Java预先创建了256个常用的证书包装类型对象</li>\n<li>在实际应用当中，对已创建的对象进行复用</li>\n</ol>\n<pre><code class=\"java\">  public static void main(String[] args) &#123;\n        // 面试题\n        Integer integer1 = new Integer(100);\n        Integer integer2 = new Integer(100);\n        System.out.println(integer1 == integer2); // false\n\n        Integer integer3 =  Integer.valueOf(100);// 自动装箱\n        // 相当于调用 Integer.valueOf(100);\n        Integer integer4 = Integer.valueOf(100);\n        System.out.println(integer3 == integer4); // true\n\n        Integer integer5 = Integer.valueOf(200);// 自动装箱\n        Integer integer6 = Integer.valueOf(200);\n        System.out.println(integer5 == integer6); // false\n\n        // 因为缓存区数组 [-128, 127] 在这之内地址一样\n    &#125;\n</code></pre>\n<h2 id=\"String类\"><a href=\"#String类\" class=\"headerlink\" title=\"String类\"></a>String类</h2><ol>\n<li>字符串是final修饰的常量，创建之后不可改变</li>\n<li>字符串字面值存储在字符串池中，可以共享</li>\n<li><code>String s = &quot;Hello&quot;;</code>产生一个对象，字符串池中存储</li>\n<li><code>String s = new String(&quot;Hello&quot;);</code> 产生两个对象，<strong>堆、池</strong>各一个</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        // 1. length(); 返回字符串长度\n        // 2. charAt(int index); 返回某个位置的字符\n        // 3. contains(String str); 判断是否包含某个字符串\n\n        String content = &quot;java是最好的语言, java no1&quot;;\n        System.out.println(content.length()); // 10\n        System.out.println(content.charAt(content.length() - 1)); // 言\n        System.out.println(content.contains(&quot;java&quot;)); // true\n\n        // 4. toCharArray(); 返回字符串对应数组\n        // 5. indexOf(); 返回子字符串首次出现的位置\n        // 6. lastIndexOf(); 返回字符串最后一次出现的位置\n\n        System.out.println(content.toCharArray());\n        System.out.println(content.indexOf(&quot;java&quot;)); // 0\n        System.out.println(content.indexOf(&quot;java&quot;, 4)); // 从索引4开始找 返回12\n        System.out.println(content.lastIndexOf(&quot;java&quot;)); // 12\n\n        // 7. trim(); //去掉字符串前后空格\n        // 8. toUpperCase(); toLowerCase(); 转换大小写\n        // 9. endWith(str); startWith(str);  判断是否以str 结尾、开头\n\n        String ct = &quot; hello world &quot;;\n        System.out.println(ct.trim()); // &quot;hello world&quot;\n        System.out.println(ct.toUpperCase()); // HELLO WORLD\n        System.out.println(ct.toLowerCase()); // hello world\n        System.out.println(ct.endsWith(&quot;world&quot;)); // true\n        System.out.println(ct.startsWith(&quot;hello&quot;)); // true\n\n        // 10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串\n        // 11. split(); 对字符串拆分\n\n        System.out.println(content.replace(&quot;java&quot;, &quot;python&quot;)); // php是最好的语言, php no1\n\n        String say = &quot;java is the best language&quot;;\n        String[] arr = say.split(&quot; &quot;); // &quot;[ ,]+&quot; 表示空格 逗号切分 +号表示切分可以多个 比如多个空格\n        System.out.println(arr.length); // 5\n        for (String string : arr) &#123;\n            System.out.println(string);\n        &#125;\n        // 打印出\n        //java\n        //is\n        //the\n        //best\n        //language\n\n        // 补充两个equals/compareTo();比较大小\n        String s1 = &quot;hello&quot;;\n        String s2 = &quot;HELLO&quot;;\n        System.out.println(s1.equalsIgnoreCase(s2));// 忽略大小写比较true\n\n        // compareTo(); 两字符不同时比较字符字典序的ascii码\n        // 字符相同时比较长度 返回差值\n\n    &#125;\n</code></pre>\n<h3 id=\"String-常用方法\"><a href=\"#String-常用方法\" class=\"headerlink\" title=\"String 常用方法\"></a>String 常用方法</h3><ol>\n<li>length(); 返回字符串长度；</li>\n<li>charAt(int index); 返回某个位置的字符；</li>\n<li>contains(String str); 判断是否包含某个字符串；</li>\n<li>toCharArray(); 返回字符串对应数组；</li>\n<li>indexOf(); 返回子字符串首次出现的位置；</li>\n<li>lastIndexOf(); 返回字符串最后一次出现的位置；</li>\n<li>trim(); //去掉字符串前后空格；</li>\n<li>toUpperCase(); toLowerCase(); 转换大小写；</li>\n<li>endWith(str); startWith(str);  判断是否以str 结尾、开头；</li>\n<li>replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串；</li>\n<li>split(); 对字符串拆分；</li>\n</ol>\n<h4 id=\"案例演示\"><a href=\"#案例演示\" class=\"headerlink\" title=\"案例演示\"></a>案例演示</h4><p>需求：</p>\n<ol>\n<li>已知String str = “this is a text”;</li>\n<li>将str中的单词单独获取</li>\n<li>将str中的text替换成practice</li>\n<li>在text前面插入一个easy</li>\n<li>将每个单词的首字母改为大写</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n//        已知String str = &quot;this is a text&quot;;\n//        将str中的单词单独获取\n//        将str中的text替换成practice\n//        在text前面插入一个easy\n//        将每个单词的首字母改为大写\n\n        String str = &quot;this is a text&quot;;\n        String[] arr = str.split(&quot; &quot;);\n        for (String s : arr) &#123;\n            System.out.println(s);\n        &#125;\n\n\n        str = str.replace(&quot;text&quot;, &quot;practice&quot;);\n        System.out.println(str);\n\n        str =  str.replace(&quot;practice&quot;, &quot;easy practice&quot;);\n        System.out.println(str);\n\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            char first = arr[i].charAt(0);\n            char upperfirst = Character.toUpperCase(first);\n            String newstr = upperfirst + arr[i].substring(1);\n            System.out.println(newstr);\n\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"StringBuffer-和-StringBuilder\"><a href=\"#StringBuffer-和-StringBuilder\" class=\"headerlink\" title=\"StringBuffer 和 StringBuilder\"></a>StringBuffer 和 StringBuilder</h3><ol>\n<li>StringBuffer : 可变长字符串，运行效率慢、线程安全</li>\n<li>StringBuilder : 可边长字符串、运行快、线程不安全</li>\n</ol>\n<p>效率都比String高且节省内存</p>\n<pre><code class=\"java\">        StringBuffer sb = new StringBuffer();\n        sb.append(&quot;java世界第一&quot;);\n        System.out.println(sb.toString());\n        sb.append(&quot;java真香&quot;);\n        System.out.println(sb.toString());\n        sb.append(&quot;java不错&quot;);\n        System.out.println(sb.toString());\n        sb.insert(0,&quot;我在最前面&quot;);\n        System.out.println(sb.toString());\n        sb.replace(0,5,&quot;hello&quot;);\n        System.out.println(sb.toString());\n        sb.delete(0,5);\n        System.out.println(sb.toString());\n        sb.delete(0,sb.length());\n        System.out.println(&quot;delete&quot; + sb.toString());\n</code></pre>\n<p>测试效率：</p>\n<pre><code class=\"java\">    public static void main(String[] args) &#123;\n        long start = System.currentTimeMillis();\n        String str = &quot;&quot;;\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            str+=i;\n        &#125;\n\n        long end = System.currentTimeMillis();\n\n        System.out.println((float) (end-start)/1000 + &quot;s&quot;);\n\n\n        long start2 = System.currentTimeMillis();\n        StringBuffer sb = new StringBuffer(&quot;&quot;);\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            sb.append(i);\n        &#125;\n\n        long end2 = System.currentTimeMillis();\n\n        System.out.println(end2-start2 + &quot;ms&quot;);\n\n        long start3 = System.currentTimeMillis();\n        StringBuilder sbu = new StringBuilder(&quot;&quot;);\n        for (int i = 0; i &lt; 99999; i++) &#123;\n            sbu.append(i);\n        &#125;\n\n        long end3 = System.currentTimeMillis();\n\n        System.out.println(end3-start3 + &quot;ms&quot;);\n\n    &#125;\n\n输出结果：\n18.49s\n10ms\n0ms\n    \n可见效率差距\n</code></pre>\n<h2 id=\"BigDecimal类\"><a href=\"#BigDecimal类\" class=\"headerlink\" title=\"BigDecimal类\"></a>BigDecimal类</h2><ol>\n<li><p>位置 <code>java.math</code> 包中</p>\n</li>\n<li><p>作用 精确计算浮点数</p>\n</li>\n<li><p>创建方式 <code>BigDecimal bd = new BigDecimal(&quot;1.0&quot;);</code></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        double d1 = 1.0;\n        double d2 = 0.9;\n        System.out.println(&quot;d1-d2=&quot; + (d1-d2));\n\n        double res = (1.4-0.5)/0.9;\n        System.out.println(&quot;result=&quot; + res);\n\n\n        BigDecimal bd1 = new BigDecimal(&quot;1.0&quot;);\n        BigDecimal bd2 = new BigDecimal(&quot;0.9&quot;);\n\n        BigDecimal bdres1 = bd1.add(bd2); //加\n        BigDecimal bdres2 = bd1.subtract(bd2); //减\n        BigDecimal bdres3 = bd1.multiply(bd2); //乘\n        BigDecimal bdres4 = \n            bd1.divide(bd2,2,BigDecimal.ROUND_HALF_UP); //除\n    // bd1.divide(除数,小数精确到几位,BigDecimal.ROUND_HALF_UP=四舍五入);\n        System.out.println(&quot;加=&quot;+bdres1+&quot;\\n减=&quot;+bdres2+&quot;\\n乘=&quot;+bdres3+&quot;\\n除=&quot;+bdres4);\n    &#125;\n</code></pre>\n<pre><code class=\"java\">d1-d2=0.09999999999999998\nresult=0.9999999999999999\n加=1.9\n减=0.1\n乘=0.90\n除=1.11\n</code></pre>\n</li>\n</ol>\n<h2 id=\"时间-Date类\"><a href=\"#时间-Date类\" class=\"headerlink\" title=\"时间-Date类\"></a>时间-Date类</h2><ol>\n<li>Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代; ( 时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns; ) </li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Date date1 = new Date();\n        System.out.println(date1.toString());\n        System.out.println(date1.toLocaleString());\n\n        //昨天\n        Date date2 = new Date(date1.getTime() - (60*60*24*1000));\n        System.out.println(date2.toLocaleString());\n\n\n        //方法after before\n        boolean b1 = date1.after(date2);\n        System.out.println(b1);\n\n        boolean b2 = date1.before(date2);\n        System.out.println(b2);\n\n\n        //比较compareTo(),比较毫秒值\n        int d1 = date1.compareTo(date2);\n        System.out.println(d1);\n\n        int d2 = date1.compareTo(date1);\n        System.out.println(d2);\n\n        //比较是否相等\n        boolean b3 = date1.equals(date2);\n        System.out.println(b3);\n\n    &#125;\n</code></pre>\n<h2 id=\"时间-Calendar类\"><a href=\"#时间-Calendar类\" class=\"headerlink\" title=\"时间-Calendar类\"></a>时间-Calendar类</h2><ol>\n<li>Calendar提供了获取或设置各种日历字段的方法</li>\n<li>构造方法 <code>protected Calendar();</code> 由于是protected 所以无法直接创建</li>\n<li>其他方法</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">static Calendar getInstance()</td>\n<td align=\"left\">使用默认时区和区域获取日历</td>\n</tr>\n<tr>\n<td align=\"left\">void set(int year, int month, int date, int hourofday, int minute, int second)</td>\n<td align=\"left\">设置日历的年、月、日、时、分、秒</td>\n</tr>\n<tr>\n<td align=\"left\">int get(int field)</td>\n<td align=\"left\">返回给定日历字段的值。字段比如年、月、日</td>\n</tr>\n<tr>\n<td align=\"left\">void setTime(Date date)</td>\n<td align=\"left\">用给定的date设置此日历时间</td>\n</tr>\n<tr>\n<td align=\"left\">Date getTime()</td>\n<td align=\"left\">返回一个date表示此日历的时间</td>\n</tr>\n<tr>\n<td align=\"left\">void add(int field, int amount)</td>\n<td align=\"left\">按照日历的规则，给指定字段添加或减少时间量</td>\n</tr>\n<tr>\n<td align=\"left\">long getTimeInMilles()</td>\n<td align=\"left\">毫秒为单位返回该日历的时间值</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建Calendar对象\n        Calendar calendar = Calendar.getInstance();\n        System.out.println(calendar.getTime().toString());\n        System.out.println(calendar.getTimeInMillis());\n\n        //获取时间信息\n        //获取年\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR); //12时制\n        int hour2 = calendar.get(Calendar.HOUR_OF_DAY);//24时制\n        int minute = calendar.get(Calendar.MINUTE);\n        int second = calendar.get(Calendar.SECOND);\n        int week = calendar.get(Calendar.DAY_OF_WEEK);\n        String[] arr = &#123;&quot;日&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;&#125;;\n        String week2 = arr[week-1];\n        System.out.println(year + &quot;/&quot; + (month+1) + &quot;/&quot; + date  + &quot;-&quot; + hour + &quot;(&quot;+ hour2 +&quot;)&quot;  + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;-[ 星期&quot; + week2 + &quot;]&quot;);\n\n        //修改时间\n        Calendar calendar1 = Calendar.getInstance();\n        calendar1.set(Calendar.DAY_OF_MONTH, 5);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //add方法修改时间\n        calendar1.add(Calendar.HOUR, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n\n        //补充方法\n        int max = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max);\n        System.out.println(min);\n\n        calendar1.add(Calendar.MONTH, 1);\n        System.out.println(calendar1.getTime().toLocaleString());\n        \n        int max2 = calendar1.getActualMaximum(Calendar.DAY_OF_MONTH); //本月最大多少天\n        int min2 =  calendar1.getActualMinimum(Calendar.DAY_OF_MONTH);//本月最小多少天？\n        System.out.println(max2);\n        System.out.println(min2);\n\n    &#125;\n</code></pre>\n<pre><code class=\"powershell\">Tue Apr 06 21:25:51 CST 2021\n1617715551128\n2021/4/6-9(21):25:51-[星期二]\n2021-4-5 21:25:51\n2021-4-5 22:25:51\n30\n1\n2021-5-5 22:25:51\n31\n1\n</code></pre>\n<h2 id=\"SimpleDateFormat类\"><a href=\"#SimpleDateFormat类\" class=\"headerlink\" title=\"SimpleDateFormat类\"></a>SimpleDateFormat类</h2><ol>\n<li>SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类</li>\n<li>进行格式化（日期→文本）、解析（文本→日期）</li>\n<li>常用的时间模式字母</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字母</th>\n<th align=\"left\">日期或时间</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">y</td>\n<td align=\"left\">年</td>\n<td align=\"left\">2019</td>\n</tr>\n<tr>\n<td align=\"left\">08</td>\n<td align=\"left\">年中月份</td>\n<td align=\"left\">08</td>\n</tr>\n<tr>\n<td align=\"left\">d</td>\n<td align=\"left\">月中天数</td>\n<td align=\"left\">10</td>\n</tr>\n<tr>\n<td align=\"left\">H</td>\n<td align=\"left\">一天中小时（0-23）</td>\n<td align=\"left\">22</td>\n</tr>\n<tr>\n<td align=\"left\">m</td>\n<td align=\"left\">分钟</td>\n<td align=\"left\">16</td>\n</tr>\n<tr>\n<td align=\"left\">s</td>\n<td align=\"left\">秒</td>\n<td align=\"left\">59</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">毫秒</td>\n<td align=\"left\">356</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\"> public static void main(String[] args) throws Exception&#123;\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);\n\n        Date date = new Date();\n        String str = sdf.format(date);\n        System.out.println(str);\n\n        Date date2 = sdf.parse(&quot;1990/05/01&quot;);\n        System.out.println(date2);\n    &#125;\n</code></pre>\n<h2 id=\"System类\"><a href=\"#System类\" class=\"headerlink\" title=\"System类\"></a>System类</h2><p>主要用于获取系统的属性数据和其他操作，构造方法私有的</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">static void arraycopy(…)</td>\n<td align=\"left\">复制数组</td>\n</tr>\n<tr>\n<td align=\"left\">static long currentTimeMillis();</td>\n<td align=\"left\">获取当前系统时间，返回毫秒值</td>\n</tr>\n<tr>\n<td align=\"left\">static void gc();</td>\n<td align=\"left\">建议jvm赶快启动垃圾回收期器回收垃圾</td>\n</tr>\n<tr>\n<td align=\"left\">static void exit(int status);</td>\n<td align=\"left\">退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        // arrcopy 数组的复制\n        // src: 源数组\n        // srcPos: 从哪个位置开始复制 0\n        // dest: 目标数组\n        // destPos: 目标数组的位置\n        // length: 复制的长度\n        int[] arr = &#123;20, 10, 15, 8, 35, 26, 45, 90&#125;;\n        int[] targetarr = new int[8];\n\n        System.arraycopy(arr, 4, targetarr, 6,2);\n        System.out.println(Arrays.toString(targetarr));\n\n        //Arrays.copyOf()底层源码实现方式依旧为arraycopy\n        int[] targetarr2 = Arrays.copyOf(arr,6);\n        System.out.println(Arrays.toString(targetarr2));\n\n        //退出JVM,下面的代码不再执行\n        System.exit(0);\n        System.out.println(&quot;程序结束了···········&quot;);\n    &#125;\n</code></pre>"},{"title":"中国城市坐标(包含市辖区)","date":"2021-09-08T08:07:03.000Z","_content":"\n================\n\n<!-- more -->\n\n原文地址：https://www.cnblogs.com/henuyuxiang/p/12981201.html\n\n```json\n{\n  \"全国\": [116.413384, 39.910925],\n  \"北京市\": [116.413384, 39.910925],\n  \"北京市-市辖区\": [116.413384, 39.910925],\n  \"北京市-市辖区-东城区\": [116.422401, 39.934827],\n  \"北京市-市辖区-西城区\": [116.372514, 39.918124],\n  \"北京市-市辖区-朝阳区\": [116.449559, 39.926375],\n  \"北京市-市辖区-丰台区\": [116.292402, 39.864937],\n  \"北京市-市辖区-石景山区\": [116.229613, 39.911354],\n  \"北京市-市辖区-海淀区\": [116.305434, 39.96549],\n  \"北京市-市辖区-门头沟区\": [116.107604, 39.946147],\n  \"北京市-市辖区-房山区\": [116.149444, 39.754326],\n  \"北京市-市辖区-通州区\": [116.663415, 39.916017],\n  \"北京市-市辖区-顺义区\": [116.661424, 40.136351],\n  \"北京市-市辖区-昌平区\": [116.237618, 40.226413],\n  \"北京市-市辖区-大兴区\": [116.348625, 39.732555],\n  \"北京市-市辖区-怀柔区\": [116.638386, 40.322618],\n  \"北京市-市辖区-平谷区\": [117.127379, 40.146951],\n  \"北京市-市辖区-密云区\": [116.849547, 40.382176],\n  \"北京市-市辖区-延庆区\": [115.981632, 40.462169],\n  \"天津市\": [117.209523, 39.093668],\n  \"天津市-市辖区\": [117.209523, 39.093668],\n  \"天津市-市辖区-和平区\": [117.221467, 39.12339],\n  \"天津市-市辖区-河东区\": [117.258413, 39.134487],\n  \"天津市-市辖区-河西区\": [117.229416, 39.115718],\n  \"天津市-市辖区-南开区\": [117.156515, 39.144105],\n  \"天津市-市辖区-河北区\": [117.203593, 39.153485],\n  \"天津市-市辖区-红桥区\": [117.157518, 39.173286],\n  \"天津市-市辖区-东丽区\": [117.320569, 39.092332],\n  \"天津市-市辖区-西青区\": [117.01441, 39.148727],\n  \"天津市-市辖区-津南区\": [117.363387, 38.944148],\n  \"天津市-市辖区-北辰区\": [117.141403, 39.230344],\n  \"天津市-市辖区-武清区\": [117.050597, 39.389871],\n  \"天津市-市辖区-宝坻区\": [117.316601, 39.723194],\n  \"天津市-市辖区-滨海新区\": [117.717399, 39.009416],\n  \"天津市-市辖区-宁河区\": [117.832393, 39.336956],\n  \"天津市-市辖区-静海区\": [116.980469, 38.953371],\n  \"天津市-市辖区-蓟州区\": [117.414579, 40.051509],\n  \"河北省\": [114.536596, 38.043202],\n  \"河北省-石家庄市\": [114.521532, 38.048312],\n  \"河北省-石家庄市-长安区\": [114.545612, 38.043256],\n  \"河北省-石家庄市-桥西区\": [114.46742, 38.010381],\n  \"河北省-石家庄市-新华区\": [114.469438, 38.05712],\n  \"河北省-石家庄市-井陉矿区\": [114.068632, 38.070566],\n  \"河北省-石家庄市-裕华区\": [114.537583, 38.012088],\n  \"河北省-石家庄市-藁城区\": [114.853378, 38.027817],\n  \"河北省-石家庄市-鹿泉区\": [114.320598, 38.091749],\n  \"河北省-石家庄市-栾城区\": [114.654576, 37.905816],\n  \"河北省-石家庄市-井陉县\": [114.151463, 38.038386],\n  \"河北省-石家庄市-正定县\": [114.577481, 38.151714],\n  \"河北省-石家庄市-行唐县\": [114.559607, 38.444239],\n  \"河北省-石家庄市-灵寿县\": [114.389478, 38.314629],\n  \"河北省-石家庄市-高邑县\": [114.618413, 37.62188],\n  \"河北省-石家庄市-深泽县\": [115.207404, 38.190451],\n  \"河北省-石家庄市-赞皇县\": [114.392464, 37.671667],\n  \"河北省-石家庄市-无极县\": [114.982439, 38.185436],\n  \"河北省-石家庄市-平山县\": [113.985435, 38.271951],\n  \"河北省-石家庄市-元氏县\": [114.532566, 37.772339],\n  \"河北省-石家庄市-赵县\": [114.782597, 37.761859],\n  \"河北省-石家庄市-晋州市\": [115.050529, 38.039491],\n  \"河北省-石家庄市-新乐市\": [114.690532, 38.349293],\n  \"河北省-唐山市\": [118.186459, 39.636584],\n  \"河北省-唐山市-路南区\": [118.160607, 39.631043],\n  \"河北省-唐山市-路北区\": [118.206399, 39.630661],\n  \"河北省-唐山市-古冶区\": [118.453401, 39.739736],\n  \"河北省-唐山市-开平区\": [118.268608, 39.677144],\n  \"河北省-唐山市-丰南区\": [118.090366, 39.58154],\n  \"河北省-唐山市-丰润区\": [118.168541, 39.838353],\n  \"河北省-唐山市-曹妃甸区\": [118.46646, 39.279284],\n  \"河北省-唐山市-滦县\": [118.71048, 39.747116],\n  \"河北省-唐山市-滦南县\": [118.680405, 39.510045],\n  \"河北省-唐山市-乐亭县\": [118.919384, 39.431931],\n  \"河北省-唐山市-迁西县\": [118.320384, 40.147837],\n  \"河北省-唐山市-玉田县\": [117.745434, 39.906592],\n  \"河北省-唐山市-遵化市\": [117.972375, 40.195533],\n  \"河北省-唐山市-迁安市\": [118.706457, 40.004184],\n  \"河北省-秦皇岛市\": [119.608531, 39.941748],\n  \"河北省-秦皇岛市-海港区\": [119.617475, 39.940413],\n  \"河北省-秦皇岛市-山海关区\": [119.782435, 39.984446],\n  \"河北省-秦皇岛市-北戴河区\": [119.491526, 39.841006],\n  \"河北省-秦皇岛市-抚宁区\": [119.251549, 39.881414],\n  \"河北省-秦皇岛市-青龙满族自治县\": [118.956481, 40.412794],\n  \"河北省-秦皇岛市-昌黎县\": [119.169375, 39.719051],\n  \"河北省-秦皇岛市-卢龙县\": [118.899489, 39.897958],\n  \"河北省-邯郸市\": [114.545628, 36.631263],\n  \"河北省-邯郸市-邯山区\": [114.496389, 36.586692],\n  \"河北省-邯郸市-丛台区\": [114.499433, 36.642673],\n  \"河北省-邯郸市-复兴区\": [114.479412, 36.623325],\n  \"河北省-邯郸市-峰峰矿区\": [114.219483, 36.425654],\n  \"河北省-邯郸市-邯郸县\": [114.537309, 36.599675],\n  \"河北省-邯郸市-临漳县\": [114.626427, 36.340766],\n  \"河北省-邯郸市-成安县\": [114.676577, 36.449796],\n  \"河北省-邯郸市-大名县\": [115.154613, 36.291288],\n  \"河北省-邯郸市-涉县\": [113.697584, 36.590692],\n  \"河北省-邯郸市-磁县\": [114.380432, 36.380359],\n  \"河北省-邯郸市-肥乡县\": [114.806547, 36.553825],\n  \"河北省-邯郸市-永年县\": [114.550625, 36.747569],\n  \"河北省-邯郸市-邱县\": [115.193395, 36.817362],\n  \"河北省-邯郸市-鸡泽县\": [114.896586, 36.916398],\n  \"河北省-邯郸市-广平县\": [114.954415, 36.48978],\n  \"河北省-邯郸市-馆陶县\": [115.288537, 36.553957],\n  \"河北省-邯郸市-魏县\": [114.94545, 36.366156],\n  \"河北省-邯郸市-曲周县\": [114.963404, 36.771545],\n  \"河北省-邯郸市-武安市\": [114.210516, 36.702488],\n  \"河北省-邢台市\": [114.511462, 37.076686],\n  \"河北省-邢台市-桥东区\": [114.513471, 37.07375],\n  \"河北省-邢台市-桥西区\": [114.474393, 37.066172],\n  \"河北省-邢台市-邢台县\": [114.143411, 37.177109],\n  \"河北省-邢台市-临城县\": [114.505443, 37.450789],\n  \"河北省-邢台市-内丘县\": [114.518493, 37.292858],\n  \"河北省-邢台市-柏乡县\": [114.699497, 37.488759],\n  \"河北省-邢台市-隆尧县\": [114.776616, 37.355908],\n  \"河北省-邢台市-任县\": [114.678606, 37.126727],\n  \"河北省-邢台市-南和县\": [114.690548, 37.010998],\n  \"河北省-邢台市-宁晋县\": [114.925562, 37.625612],\n  \"河北省-邢台市-巨鹿县\": [115.043587, 37.227088],\n  \"河北省-邢台市-新河县\": [115.248547, 37.534591],\n  \"河北省-邢台市-广宗县\": [115.149605, 37.080457],\n  \"河北省-邢台市-平乡县\": [115.036582, 37.069096],\n  \"河北省-邢台市-威县\": [115.273618, 36.981582],\n  \"河北省-邢台市-清河县\": [115.674394, 37.046375],\n  \"河北省-邢台市-临西县\": [115.507629, 36.87676],\n  \"河北省-邢台市-南宫市\": [115.414529, 37.364069],\n  \"河北省-邢台市-沙河市\": [114.509474, 36.861127],\n  \"河北省-保定市\": [115.471464, 38.879988],\n  \"河北省-保定市-竞秀区\": [115.465434, 38.883788],\n  \"河北省-保定市-莲池区\": [115.535488, 38.860676],\n  \"河北省-保定市-满城区\": [115.328375, 38.955441],\n  \"河北省-保定市-清苑区\": [115.496606, 38.771002],\n  \"河北省-保定市-徐水区\": [115.66248, 39.024713],\n  \"河北省-保定市-涞水县\": [115.720543, 39.400334],\n  \"河北省-保定市-阜平县\": [114.201563, 38.855351],\n  \"河北省-保定市-定兴县\": [115.81441, 39.269424],\n  \"河北省-保定市-唐县\": [114.989447, 38.75402],\n  \"河北省-保定市-高阳县\": [115.785447, 38.706258],\n  \"河北省-保定市-容城县\": [115.868631, 39.048559],\n  \"河北省-保定市-涞源县\": [114.700476, 39.366272],\n  \"河北省-保定市-望都县\": [115.161588, 38.700158],\n  \"河北省-保定市-安新县\": [115.942426, 38.941734],\n  \"河北省-保定市-易县\": [115.503607, 39.355054],\n  \"河北省-保定市-曲阳县\": [114.751455, 38.628384],\n  \"河北省-保定市-蠡县\": [115.590445, 38.494201],\n  \"河北省-保定市-顺平县\": [115.141597, 38.843261],\n  \"河北省-保定市-博野县\": [115.470467, 38.463408],\n  \"河北省-保定市-雄县\": [116.114601, 39.00018],\n  \"河北省-保定市-涿州市\": [115.98162, 39.491066],\n  \"河北省-保定市-安国市\": [115.333408, 38.424828],\n  \"河北省-保定市-高碑店市\": [115.880569, 39.332335],\n  \"河北省-张家口市\": [114.892572, 40.773237],\n  \"河北省-张家口市-桥东区\": [114.900606, 40.794268],\n  \"河北省-张家口市-桥西区\": [114.876516, 40.825606],\n  \"河北省-张家口市-宣化区\": [115.105444, 40.614592],\n  \"河北省-张家口市-下花园区\": [115.293517, 40.508145],\n  \"河北省-张家口市-万全区\": [114.747426, 40.77315],\n  \"河北省-张家口市-崇礼区\": [115.289549, 40.980478],\n  \"河北省-张家口市-张北县\": [114.726375, 41.164944],\n  \"河北省-张家口市-康保县\": [114.606356, 41.858637],\n  \"河北省-张家口市-沽源县\": [115.695407, 41.676016],\n  \"河北省-张家口市-尚义县\": [113.975524, 41.081888],\n  \"河北省-张家口市-蔚县\": [114.595401, 39.847089],\n  \"河北省-张家口市-阳原县\": [114.157524, 40.109588],\n  \"河北省-张家口市-怀安县\": [114.392469, 40.680369],\n  \"河北省-张家口市-怀来县\": [115.524553, 40.42029],\n  \"河北省-张家口市-涿鹿县\": [115.211383, 40.385834],\n  \"河北省-张家口市-赤城县\": [115.838506, 40.918761],\n  \"河北省-承德市\": [117.969398, 40.957856],\n  \"河北省-承德市-双桥区\": [117.949428, 40.980824],\n  \"河北省-承德市-双滦区\": [117.806578, 40.964729],\n  \"河北省-承德市-鹰手营子矿区\": [117.665609, 40.552043],\n  \"河北省-承德市-承德县\": [118.180456, 40.774367],\n  \"河北省-承德市-兴隆县\": [117.507427, 40.423454],\n  \"河北省-承德市-平泉县\": [118.707427, 41.023756],\n  \"河北省-承德市-滦平县\": [117.339498, 40.947561],\n  \"河北省-承德市-隆化县\": [117.745451, 41.319899],\n  \"河北省-承德市-丰宁满族自治县\": [116.652393, 41.215336],\n  \"河北省-承德市-宽城满族自治县\": [118.491594, 40.617152],\n  \"河北省-承德市-围场满族蒙古族自治县\": [117.766564, 41.944324],\n  \"河北省-沧州市\": [116.845581, 38.310215],\n  \"河北省-沧州市-新华区\": [116.872433, 38.320367],\n  \"河北省-沧州市-运河区\": [116.838612, 38.316523],\n  \"河北省-沧州市-沧县\": [116.884398, 38.299453],\n  \"河北省-沧州市-青县\": [116.810575, 38.588465],\n  \"河北省-沧州市-东光县\": [116.54341, 37.894514],\n  \"河北省-沧州市-海兴县\": [117.504418, 38.149402],\n  \"河北省-沧州市-盐山县\": [117.237414, 38.064318],\n  \"河北省-沧州市-肃宁县\": [115.836518, 38.428906],\n  \"河北省-沧州市-南皮县\": [116.715601, 38.045188],\n  \"河北省-沧州市-吴桥县\": [116.397392, 37.633909],\n  \"河北省-沧州市-献县\": [116.12956, 38.195981],\n  \"河北省-沧州市-孟村回族自治县\": [117.110436, 38.059839],\n  \"河北省-沧州市-泊头市\": [116.584628, 38.089257],\n  \"河北省-沧州市-任丘市\": [116.105605, 38.717349],\n  \"河北省-沧州市-黄骅市\": [117.336481, 38.377494],\n  \"河北省-沧州市-河间市\": [116.105628, 38.451357],\n  \"河北省-廊坊市\": [116.690582, 39.543367],\n  \"河北省-廊坊市-安次区\": [116.709633, 39.52616],\n  \"河北省-廊坊市-广阳区\": [116.717614, 39.528611],\n  \"河北省-廊坊市-固安县\": [116.30542, 39.444485],\n  \"河北省-廊坊市-永清县\": [116.505429, 39.327853],\n  \"河北省-廊坊市-香河县\": [117.012402, 39.767939],\n  \"河北省-廊坊市-大城县\": [116.660409, 38.710859],\n  \"河北省-廊坊市-文安县\": [116.464609, 38.87895],\n  \"河北省-廊坊市-大厂回族自治县\": [116.996409, 39.892208],\n  \"河北省-廊坊市-霸州市\": [116.398397, 39.130921],\n  \"河北省-廊坊市-三河市\": [117.084588, 39.9881],\n  \"河北省-衡水市\": [115.675406, 37.745191],\n  \"河北省-衡水市-桃城区\": [115.681395, 37.741637],\n  \"河北省-衡水市-冀州区\": [115.58543, 37.557086],\n  \"河北省-衡水市-枣强县\": [115.730563, 37.519364],\n  \"河北省-衡水市-武邑县\": [115.894514, 37.807764],\n  \"河北省-衡水市-武强县\": [115.989614, 38.046857],\n  \"河北省-衡水市-饶阳县\": [115.732572, 38.241038],\n  \"河北省-衡水市-安平县\": [115.525549, 38.240507],\n  \"河北省-衡水市-故城县\": [115.972602, 37.353348],\n  \"河北省-衡水市-景县\": [116.277411, 37.698815],\n  \"河北省-衡水市-阜城县\": [116.182422, 37.868732],\n  \"河北省-衡水市-深州市\": [115.566369, 38.006941],\n  \"河北省-定州市\": [114.996496, 38.522199],\n  \"河北省-辛集市\": [115.224451, 37.949309],\n  \"山西省\": [112.569376, 37.879829],\n  \"山西省-太原市\": [112.556391, 37.876989],\n  \"山西省-太原市-小店区\": [112.572396, 37.742323],\n  \"山西省-太原市-迎泽区\": [112.569385, 37.869532],\n  \"山西省-太原市-杏花岭区\": [112.576383, 37.900186],\n  \"山西省-太原市-尖草坪区\": [112.493605, 37.945943],\n  \"山西省-太原市-万柏林区\": [112.522577, 37.864974],\n  \"山西省-太原市-晋源区\": [112.484564, 37.721169],\n  \"山西省-太原市-清徐县\": [112.364558, 37.613067],\n  \"山西省-太原市-阳曲县\": [112.679409, 38.064621],\n  \"山西省-太原市-娄烦县\": [111.803591, 38.073195],\n  \"山西省-太原市-古交市\": [112.182453, 37.913],\n  \"山西省-大同市\": [113.306436, 40.082469],\n  \"山西省-大同市-城区\": [113.304425, 40.081998],\n  \"山西省-大同市-矿区\": [113.162402, 39.996839],\n  \"山西省-大同市-南郊区\": [113.162402, 39.996839],\n  \"山西省-大同市-新荣区\": [113.146444, 40.261971],\n  \"山西省-大同市-阳高县\": [113.755414, 40.367392],\n  \"山西省-大同市-天镇县\": [114.097478, 40.426412],\n  \"山西省-大同市-广灵县\": [114.288586, 39.766004],\n  \"山西省-大同市-灵丘县\": [114.241368, 39.448825],\n  \"山西省-大同市-浑源县\": [113.7056, 39.698953],\n  \"山西省-大同市-左云县\": [112.709463, 40.019623],\n  \"山西省-大同市-大同县\": [113.618471, 40.04623],\n  \"山西省-阳泉市\": [113.587617, 37.862361],\n  \"山西省-阳泉市-城区\": [113.606568, 37.853433],\n  \"山西省-阳泉市-矿区\": [113.561521, 37.874409],\n  \"山西省-阳泉市-郊区\": [113.600603, 37.950353],\n  \"山西省-阳泉市-平定县\": [113.664421, 37.792796],\n  \"山西省-阳泉市-盂县\": [113.41842, 38.09198],\n  \"山西省-长治市\": [113.122559, 36.201268],\n  \"山西省-长治市-城区\": [113.129521, 36.209472],\n  \"山西省-长治市-郊区\": [113.105622, 36.261066],\n  \"山西省-长治市-长治县\": [113.057416, 36.059286],\n  \"山西省-长治市-襄垣县\": [113.057413, 36.541686],\n  \"山西省-长治市-屯留县\": [112.898475, 36.321631],\n  \"山西省-长治市-平顺县\": [113.442517, 36.205989],\n  \"山西省-长治市-黎城县\": [113.393432, 36.50867],\n  \"山西省-长治市-壶关县\": [113.21358, 36.121335],\n  \"山西省-长治市-长子县\": [112.884566, 36.128002],\n  \"山西省-长治市-武乡县\": [112.870606, 36.843168],\n  \"山西省-长治市-沁县\": [112.705458, 36.76219],\n  \"山西省-长治市-沁源县\": [112.344452, 36.506103],\n  \"山西省-长治市-潞城市\": [113.235578, 36.339691],\n  \"山西省-晋城市\": [112.858578, 35.496285],\n  \"山西省-晋城市-城区\": [112.855303, 35.520559],\n  \"山西省-晋城市-沁水县\": [112.193426, 35.696364],\n  \"山西省-晋城市-阳城县\": [112.421454, 35.492181],\n  \"山西省-晋城市-陵川县\": [113.287407, 35.781744],\n  \"山西省-晋城市-泽州县\": [112.794401, 35.59977],\n  \"山西省-晋城市-高平市\": [112.930412, 35.804337],\n  \"山西省-朔州市\": [112.439371, 39.337108],\n  \"山西省-朔州市-朔城区\": [112.438376, 39.325303],\n  \"山西省-朔州市-平鲁区\": [112.295525, 39.517389],\n  \"山西省-朔州市-山阴县\": [112.822432, 39.53403],\n  \"山西省-朔州市-应县\": [113.197494, 39.560078],\n  \"山西省-朔州市-右玉县\": [112.4735, 39.99486],\n  \"山西省-朔州市-怀仁县\": [113.106608, 39.833757],\n  \"山西省-晋中市\": [112.759595, 37.692839],\n  \"山西省-晋中市-榆次区\": [112.714504, 37.70394],\n  \"山西省-晋中市-榆社县\": [112.981599, 37.07637],\n  \"山西省-晋中市-左权县\": [113.385452, 37.088555],\n  \"山西省-晋中市-和顺县\": [113.576606, 37.334808],\n  \"山西省-晋中市-昔阳县\": [113.713613, 37.617884],\n  \"山西省-晋中市-寿阳县\": [113.18341, 37.901308],\n  \"山西省-晋中市-太谷县\": [112.557384, 37.427396],\n  \"山西省-晋中市-祁县\": [112.342442, 37.364131],\n  \"山西省-晋中市-平遥县\": [112.182456, 37.195601],\n  \"山西省-晋中市-灵石县\": [111.785618, 36.853368],\n  \"山西省-晋中市-介休市\": [111.923563, 37.032686],\n  \"山西省-运城市\": [111.013389, 35.032707],\n  \"山西省-运城市-盐湖区\": [111.004377, 35.021425],\n  \"山西省-运城市-临猗县\": [110.780407, 35.149542],\n  \"山西省-运城市-万荣县\": [110.844576, 35.421109],\n  \"山西省-运城市-闻喜县\": [111.23141, 35.362931],\n  \"山西省-运城市-稷山县\": [110.989415, 35.610403],\n  \"山西省-运城市-新绛县\": [111.231406, 35.62263],\n  \"山西省-运城市-绛县\": [111.575487, 35.497276],\n  \"山西省-运城市-垣曲县\": [111.676607, 35.303015],\n  \"山西省-运城市-夏县\": [111.226431, 35.147462],\n  \"山西省-运城市-平陆县\": [111.22348, 34.842925],\n  \"山西省-运城市-芮城县\": [110.700612, 34.699388],\n  \"山西省-运城市-永济市\": [110.454578, 34.87283],\n  \"山西省-运城市-河津市\": [110.718572, 35.601927],\n  \"山西省-忻州市\": [112.740624, 38.422383],\n  \"山西省-忻州市-忻府区\": [112.752614, 38.40988],\n  \"山西省-忻州市-定襄县\": [112.963529, 38.479974],\n  \"山西省-忻州市-五台县\": [113.261451, 38.734182],\n  \"山西省-忻州市-代县\": [112.966552, 39.072728],\n  \"山西省-忻州市-繁峙县\": [113.271408, 39.195237],\n  \"山西省-忻州市-宁武县\": [112.326398, 39.024342],\n  \"山西省-忻州市-静乐县\": [111.945432, 38.365147],\n  \"山西省-忻州市-神池县\": [112.217383, 39.096876],\n  \"山西省-忻州市-五寨县\": [111.85341, 38.91702],\n  \"山西省-忻州市-岢岚县\": [111.579478, 38.710151],\n  \"山西省-忻州市-河曲县\": [111.144449, 39.390702],\n  \"山西省-忻州市-保德县\": [111.092542, 39.028337],\n  \"山西省-忻州市-偏关县\": [111.514474, 39.44223],\n  \"山西省-忻州市-原平市\": [112.717487, 38.736476],\n  \"山西省-临汾市\": [111.52553, 36.093742],\n  \"山西省-临汾市-尧都区\": [111.58643, 36.084562],\n  \"山西省-临汾市-曲沃县\": [111.482396, 35.647327],\n  \"山西省-临汾市-翼城县\": [111.725376, 35.744429],\n  \"山西省-临汾市-襄汾县\": [111.44854, 35.882063],\n  \"山西省-临汾市-洪洞县\": [111.681589, 36.259467],\n  \"山西省-临汾市-古县\": [111.926573, 36.272338],\n  \"山西省-临汾市-安泽县\": [112.256613, 36.153514],\n  \"山西省-临汾市-浮山县\": [111.855385, 35.974393],\n  \"山西省-临汾市-吉县\": [110.688546, 36.103999],\n  \"山西省-临汾市-乡宁县\": [110.853498, 35.976442],\n  \"山西省-临汾市-大宁县\": [110.759384, 36.471306],\n  \"山西省-临汾市-隰县\": [110.947591, 36.699061],\n  \"山西省-临汾市-永和县\": [110.638416, 36.765909],\n  \"山西省-临汾市-蒲县\": [111.102474, 36.418005],\n  \"山西省-临汾市-汾西县\": [111.569546, 36.658782],\n  \"山西省-临汾市-侯马市\": [111.378397, 35.625365],\n  \"山西省-临汾市-霍州市\": [111.761509, 36.574607],\n  \"山西省-吕梁市\": [111.15045, 37.524498],\n  \"山西省-吕梁市-离石区\": [111.157491, 37.523577],\n  \"山西省-吕梁市-文水县\": [112.035599, 37.4443],\n  \"山西省-吕梁市-交城县\": [112.162568, 37.557772],\n  \"山西省-吕梁市-兴县\": [111.134392, 38.468804],\n  \"山西省-吕梁市-临县\": [110.998415, 37.957211],\n  \"山西省-吕梁市-柳林县\": [110.89539, 37.435493],\n  \"山西省-吕梁市-石楼县\": [110.841596, 37.004471],\n  \"山西省-吕梁市-岚县\": [111.678592, 38.285029],\n  \"山西省-吕梁市-方山县\": [111.25037, 37.90102],\n  \"山西省-吕梁市-中阳县\": [111.18563, 37.362873],\n  \"山西省-吕梁市-交口县\": [111.187628, 36.987873],\n  \"山西省-吕梁市-孝义市\": [111.785606, 37.151063],\n  \"山西省-吕梁市-汾阳市\": [111.794597, 37.271292],\n  \"内蒙古自治区\": [111.772606, 40.823156],\n  \"内蒙古自治区-呼和浩特市\": [111.755509, 40.848423],\n  \"内蒙古自治区-呼和浩特市-新城区\": [111.67162, 40.863877],\n  \"内蒙古自治区-呼和浩特市-回民区\": [111.63047, 40.814506],\n  \"内蒙古自治区-呼和浩特市-玉泉区\": [111.681575, 40.758059],\n  \"内蒙古自治区-呼和浩特市-赛罕区\": [111.708421, 40.798394],\n  \"内蒙古自治区-呼和浩特市-土默特左旗\": [111.169587, 40.735294],\n  \"内蒙古自治区-呼和浩特市-托克托县\": [111.200575, 40.283147],\n  \"内蒙古自治区-呼和浩特市-和林格尔县\": [111.82843, 40.384798],\n  \"内蒙古自治区-呼和浩特市-清水河县\": [111.653576, 39.926334],\n  \"内蒙古自治区-呼和浩特市-武川县\": [111.457497, 41.102419],\n  \"内蒙古自治区-包头市\": [109.846544, 40.662929],\n  \"内蒙古自治区-包头市-东河区\": [110.050395, 40.582228],\n  \"内蒙古自治区-包头市-昆都仑区\": [109.845538, 40.647644],\n  \"内蒙古自治区-包头市-青山区\": [109.907416, 40.649473],\n  \"内蒙古自治区-包头市-石拐区\": [110.278381, 40.678299],\n  \"内蒙古自治区-包头市-白云鄂博矿区\": [109.979626, 41.774995],\n  \"内蒙古自治区-包头市-九原区\": [109.969588, 40.613397],\n  \"内蒙古自治区-包头市-土默特右旗\": [110.530389, 40.575127],\n  \"内蒙古自治区-包头市-固阳县\": [110.066433, 41.040163],\n  \"内蒙古自治区-包头市-达尔罕茂明安联合旗\": [110.439521, 41.704549],\n  \"内蒙古自治区-乌海市\": [106.800391, 39.662006],\n  \"内蒙古自治区-乌海市-海勃湾区\": [106.829439, 39.696908],\n  \"内蒙古自治区-乌海市-海南区\": [106.898471, 39.446828],\n  \"内蒙古自治区-乌海市-乌达区\": [106.732606, 39.511469],\n  \"内蒙古自治区-赤峰市\": [118.89552, 42.261686],\n  \"内蒙古自治区-赤峰市-红山区\": [118.963564, 42.270478],\n  \"内蒙古自治区-赤峰市-元宝山区\": [119.295405, 42.045125],\n  \"内蒙古自治区-赤峰市-松山区\": [118.939414, 42.292482],\n  \"内蒙古自治区-赤峰市-阿鲁科尔沁旗\": [120.072614, 43.877953],\n  \"内蒙古自治区-赤峰市-巴林左旗\": [119.386443, 43.976383],\n  \"内蒙古自治区-赤峰市-巴林右旗\": [118.670394, 43.540132],\n  \"内蒙古自治区-赤峰市-林西县\": [118.062461, 43.62421],\n  \"内蒙古自治区-赤峰市-克什克腾旗\": [117.55162, 43.270758],\n  \"内蒙古自治区-赤峰市-翁牛特旗\": [119.012509, 42.942019],\n  \"内蒙古自治区-赤峰市-喀喇沁旗\": [118.710474, 41.932214],\n  \"内蒙古自治区-赤峰市-宁城县\": [119.350609, 41.600245],\n  \"内蒙古自治区-赤峰市-敖汉旗\": [119.927578, 42.296507],\n  \"内蒙古自治区-通辽市\": [122.250522, 43.65798],\n  \"内蒙古自治区-通辽市-科尔沁区\": [122.262457, 43.628712],\n  \"内蒙古自治区-通辽市-科尔沁左翼中旗\": [123.318589, 44.132294],\n  \"内蒙古自治区-通辽市-科尔沁左翼后旗\": [122.363563, 42.939562],\n  \"内蒙古自治区-通辽市-开鲁县\": [121.325386, 43.606369],\n  \"内蒙古自治区-通辽市-库伦旗\": [121.817406, 42.741211],\n  \"内蒙古自治区-通辽市-奈曼旗\": [120.664646, 42.871846],\n  \"内蒙古自治区-通辽市-扎鲁特旗\": [120.918626, 44.562213],\n  \"内蒙古自治区-通辽市-霍林郭勒市\": [119.670466, 45.537513],\n  \"内蒙古自治区-鄂尔多斯市\": [109.787443, 39.614482],\n  \"内蒙古自治区-鄂尔多斯市-东胜区\": [109.96956, 39.827987],\n  \"内蒙古自治区-鄂尔多斯市-康巴什区\": [109.869627, 39.616378],\n  \"内蒙古自治区-鄂尔多斯市-达拉特旗\": [110.040366, 40.418907],\n  \"内蒙古自治区-鄂尔多斯市-准格尔旗\": [111.246398, 39.87054],\n  \"内蒙古自治区-鄂尔多斯市-鄂托克前旗\": [107.484585, 38.188217],\n  \"内蒙古自治区-鄂尔多斯市-鄂托克旗\": [107.982445, 39.095293],\n  \"内蒙古自治区-鄂尔多斯市-杭锦旗\": [108.742413, 39.838816],\n  \"内蒙古自治区-鄂尔多斯市-乌审旗\": [108.824435, 38.610027],\n  \"内蒙古自治区-鄂尔多斯市-伊金霍洛旗\": [109.75459, 39.570093],\n  \"内蒙古自治区-呼伦贝尔市\": [119.77237, 49.218446],\n  \"内蒙古自治区-呼伦贝尔市-海拉尔区\": [119.742465, 49.218216],\n  \"内蒙古自治区-呼伦贝尔市-扎赉诺尔区\": [117.385436, 49.604099],\n  \"内蒙古自治区-呼伦贝尔市-阿荣旗\": [123.46544, 48.131971],\n  \"内蒙古自治区-呼伦贝尔市-莫力达瓦达斡尔族自治旗\": [124.525576, 48.482896],\n  \"内蒙古自治区-呼伦贝尔市-鄂伦春自治旗\": [123.732345, 50.597948],\n  \"内蒙古自治区-呼伦贝尔市-鄂温克族自治旗\": [119.761351, 49.153045],\n  \"内蒙古自治区-呼伦贝尔市-陈巴尔虎旗\": [119.430462, 49.334914],\n  \"内蒙古自治区-呼伦贝尔市-新巴尔虎左旗\": [118.276608, 48.223787],\n  \"内蒙古自治区-呼伦贝尔市-新巴尔虎右旗\": [116.830632, 48.677054],\n  \"内蒙古自治区-呼伦贝尔市-满洲里市\": [117.385436, 49.604099],\n  \"内蒙古自治区-呼伦贝尔市-牙克石市\": [120.718347, 49.292024],\n  \"内蒙古自治区-呼伦贝尔市-扎兰屯市\": [122.744454, 48.019956],\n  \"内蒙古自治区-呼伦贝尔市-额尔古纳市\": [120.186634, 50.248132],\n  \"内蒙古自治区-呼伦贝尔市-根河市\": [121.527585, 50.78614],\n  \"内蒙古自治区-巴彦淖尔市\": [107.394398, 40.749359],\n  \"内蒙古自治区-巴彦淖尔市-临河区\": [107.369534, 40.756681],\n  \"内蒙古自治区-巴彦淖尔市-五原县\": [108.273491, 41.094455],\n  \"内蒙古自治区-巴彦淖尔市-磴口县\": [107.014522, 40.33647],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特前旗\": [108.658615, 40.742104],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特中旗\": [108.519512, 41.593346],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特后旗\": [107.081546, 41.089422],\n  \"内蒙古自治区-巴彦淖尔市-杭锦后旗\": [107.157372, 40.892179],\n  \"内蒙古自治区-乌兰察布市\": [113.139468, 41.000748],\n  \"内蒙古自治区-乌兰察布市-集宁区\": [113.120587, 41.041146],\n  \"内蒙古自治区-乌兰察布市-卓资县\": [112.58441, 40.900292],\n  \"内蒙古自治区-乌兰察布市-化德县\": [114.016409, 41.909603],\n  \"内蒙古自治区-乌兰察布市-商都县\": [113.584639, 41.567567],\n  \"内蒙古自治区-乌兰察布市-兴和县\": [113.840579, 40.879342],\n  \"内蒙古自治区-乌兰察布市-凉城县\": [112.5106, 40.537163],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼前旗\": [113.221605, 40.791267],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼中旗\": [112.64258, 41.283273],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼后旗\": [113.198531, 41.441771],\n  \"内蒙古自治区-乌兰察布市-四子王旗\": [111.712419, 41.539353],\n  \"内蒙古自治区-乌兰察布市-丰镇市\": [113.116601, 40.441805],\n  \"内蒙古自治区-兴安盟\": [122.044365, 46.088464],\n  \"内蒙古自治区-兴安盟-乌兰浩特市\": [122.099622, 46.078654],\n  \"内蒙古自治区-兴安盟-阿尔山市\": [119.950653, 47.183054],\n  \"内蒙古自治区-兴安盟-科尔沁右翼前旗\": [121.964553, 46.082649],\n  \"内蒙古自治区-兴安盟-科尔沁右翼中旗\": [121.483548, 45.066471],\n  \"内蒙古自治区-兴安盟-扎赉特旗\": [122.906444, 46.72919],\n  \"内蒙古自治区-兴安盟-突泉县\": [121.600545, 45.38783],\n  \"内蒙古自治区-锡林郭勒盟\": [116.054391, 43.939423],\n  \"内蒙古自治区-锡林郭勒盟-二连浩特市\": [111.958363, 43.6488],\n  \"内蒙古自治区-锡林郭勒盟-锡林浩特市\": [116.093614, 43.938334],\n  \"内蒙古自治区-锡林郭勒盟-阿巴嘎旗\": [114.957367, 44.028102],\n  \"内蒙古自治区-锡林郭勒盟-苏尼特左旗\": [113.67348, 43.865554],\n  \"内蒙古自治区-锡林郭勒盟-苏尼特右旗\": [112.648569, 42.747369],\n  \"内蒙古自治区-锡林郭勒盟-东乌珠穆沁旗\": [116.978504, 45.515743],\n  \"内蒙古自治区-锡林郭勒盟-西乌珠穆沁旗\": [117.616377, 44.593803],\n  \"内蒙古自治区-锡林郭勒盟-太仆寺旗\": [115.290535, 41.882292],\n  \"内蒙古自治区-锡林郭勒盟-镶黄旗\": [113.854505, 42.237661],\n  \"内蒙古自治区-锡林郭勒盟-正镶白旗\": [115.036622, 42.292605],\n  \"内蒙古自治区-锡林郭勒盟-正蓝旗\": [115.998604, 42.247119],\n  \"内蒙古自治区-锡林郭勒盟-多伦县\": [116.492509, 42.208921],\n  \"内蒙古自治区-阿拉善盟\": [105.735377, 38.858276],\n  \"内蒙古自治区-阿拉善盟-阿拉善左旗\": [105.672599, 38.839094],\n  \"内蒙古自治区-阿拉善盟-阿拉善右旗\": [101.673464, 39.222241],\n  \"内蒙古自治区-阿拉善盟-额济纳旗\": [101.062403, 41.960298],\n  \"辽宁省\": [123.435598, 41.841465],\n  \"辽宁省-沈阳市\": [123.466452, 41.68879],\n  \"辽宁省-沈阳市-和平区\": [123.426644, 41.795236],\n  \"辽宁省-沈阳市-沈河区\": [123.465461, 41.802274],\n  \"辽宁省-沈阳市-大东区\": [123.476405, 41.811425],\n  \"辽宁省-沈阳市-皇姑区\": [123.431621, 41.826042],\n  \"辽宁省-沈阳市-铁西区\": [123.383436, 41.809038],\n  \"辽宁省-沈阳市-苏家屯区\": [123.350435, 41.671254],\n  \"辽宁省-沈阳市-浑南区\": [123.567539, 41.849226],\n  \"辽宁省-沈阳市-沈北新区\": [123.533605, 42.058914],\n  \"辽宁省-沈阳市-于洪区\": [123.314633, 41.799668],\n  \"辽宁省-沈阳市-辽中区\": [122.772378, 41.523149],\n  \"辽宁省-沈阳市-康平县\": [123.337511, 42.749925],\n  \"辽宁省-沈阳市-法库县\": [123.414621, 42.509607],\n  \"辽宁省-沈阳市-新民市\": [122.875395, 42.007109],\n  \"辽宁省-大连市\": [121.621631, 38.918954],\n  \"辽宁省-大连市-中山区\": [121.651547, 38.924511],\n  \"辽宁省-大连市-西岗区\": [121.618625, 38.920473],\n  \"辽宁省-大连市-沙河口区\": [121.594507, 38.913544],\n  \"辽宁省-大连市-甘井子区\": [121.531519, 38.958002],\n  \"辽宁省-大连市-旅顺口区\": [121.268597, 38.856832],\n  \"辽宁省-大连市-金州区\": [121.789436, 39.056433],\n  \"辽宁省-大连市-普兰店区\": [121.94646, 39.398089],\n  \"辽宁省-大连市-长海县\": [122.594627, 39.27827],\n  \"辽宁省-大连市-瓦房店市\": [121.985638, 39.632741],\n  \"辽宁省-大连市-庄河市\": [122.974495, 39.686956],\n  \"辽宁省-鞍山市\": [123.001373, 41.115054],\n  \"辽宁省-鞍山市-铁东区\": [122.9974, 41.096332],\n  \"辽宁省-鞍山市-铁西区\": [122.97549, 41.125475],\n  \"辽宁省-鞍山市-立山区\": [123.035484, 41.156116],\n  \"辽宁省-鞍山市-千山区\": [122.967574, 41.080939],\n  \"辽宁省-鞍山市-台安县\": [122.44255, 41.41859],\n  \"辽宁省-鞍山市-岫岩满族自治县\": [123.287547, 40.295892],\n  \"辽宁省-鞍山市-海城市\": [122.691569, 40.887634],\n  \"辽宁省-抚顺市\": [123.964375, 41.88597],\n  \"辽宁省-抚顺市-新抚区\": [123.919582, 41.867806],\n  \"辽宁省-抚顺市-东洲区\": [124.04555, 41.859191],\n  \"辽宁省-抚顺市-望花区\": [123.790604, 41.85903],\n  \"辽宁省-抚顺市-顺城区\": [123.951414, 41.889164],\n  \"辽宁省-抚顺市-抚顺县\": [123.92159, 41.887037],\n  \"辽宁省-抚顺市-新宾满族自治县\": [125.046356, 41.739969],\n  \"辽宁省-抚顺市-清原满族自治县\": [124.93036, 42.106761],\n  \"辽宁省-本溪市\": [123.692507, 41.492916],\n  \"辽宁省-本溪市-平山区\": [123.774614, 41.301604],\n  \"辽宁省-本溪市-溪湖区\": [123.774611, 41.334803],\n  \"辽宁省-本溪市-明山区\": [123.823474, 41.314939],\n  \"辽宁省-本溪市-南芬区\": [123.751467, 41.107096],\n  \"辽宁省-本溪市-本溪满族自治县\": [124.127585, 41.307903],\n  \"辽宁省-本溪市-桓仁满族自治县\": [125.367544, 41.272925],\n  \"辽宁省-丹东市\": [124.361547, 40.006409],\n  \"辽宁省-丹东市-元宝区\": [124.402584, 40.142251],\n  \"辽宁省-丹东市-振兴区\": [124.366579, 40.110719],\n  \"辽宁省-丹东市-振安区\": [124.434387, 40.164697],\n  \"辽宁省-丹东市-宽甸满族自治县\": [124.790427, 40.737553],\n  \"辽宁省-丹东市-东港市\": [124.15961, 39.867716],\n  \"辽宁省-丹东市-凤城市\": [124.072422, 40.45918],\n  \"辽宁省-锦州市\": [121.132596, 41.100931],\n  \"辽宁省-锦州市-古塔区\": [121.134585, 41.122901],\n  \"辽宁省-锦州市-凌河区\": [121.15759, 41.120691],\n  \"辽宁省-锦州市-太和区\": [121.110453, 41.115109],\n  \"辽宁省-锦州市-黑山县\": [122.130557, 41.671593],\n  \"辽宁省-锦州市-义县\": [121.245569, 41.538939],\n  \"辽宁省-锦州市-凌海市\": [121.362539, 41.166488],\n  \"辽宁省-锦州市-北镇市\": [121.783447, 41.594428],\n  \"辽宁省-营口市\": [122.241575, 40.673137],\n  \"辽宁省-营口市-站前区\": [122.265437, 40.678764],\n  \"辽宁省-营口市-西市区\": [122.213582, 40.672111],\n  \"辽宁省-营口市-鲅鱼圈区\": [122.127573, 40.23234],\n  \"辽宁省-营口市-老边区\": [122.386439, 40.686384],\n  \"辽宁省-营口市-盖州市\": [122.355591, 40.406167],\n  \"辽宁省-营口市-大石桥市\": [122.51538, 40.650802],\n  \"辽宁省-阜新市\": [121.676408, 42.028022],\n  \"辽宁省-阜新市-海州区\": [121.669436, 42.023735],\n  \"辽宁省-阜新市-新邱区\": [121.799363, 42.093935],\n  \"辽宁省-阜新市-太平区\": [121.685384, 42.016968],\n  \"辽宁省-阜新市-清河门区\": [121.422479, 41.789319],\n  \"辽宁省-阜新市-细河区\": [121.686392, 42.031871],\n  \"辽宁省-阜新市-阜新蒙古族自治县\": [121.763574, 42.071368],\n  \"辽宁省-阜新市-彰武县\": [122.545449, 42.392707],\n  \"辽宁省-辽阳市\": [123.243366, 41.274161],\n  \"辽宁省-辽阳市-白塔区\": [123.180608, 41.275845],\n  \"辽宁省-辽阳市-文圣区\": [123.191605, 41.268438],\n  \"辽宁省-辽阳市-宏伟区\": [123.20358, 41.223368],\n  \"辽宁省-辽阳市-弓长岭区\": [123.426615, 41.157327],\n  \"辽宁省-辽阳市-太子河区\": [123.188604, 41.259226],\n  \"辽宁省-辽阳市-辽阳县\": [123.112421, 41.211679],\n  \"辽宁省-辽阳市-灯塔市\": [123.345462, 41.432474],\n  \"辽宁省-盘锦市\": [122.07749, 41.125875],\n  \"辽宁省-盘锦市-双台子区\": [122.046393, 41.206072],\n  \"辽宁省-盘锦市-兴隆台区\": [122.076499, 41.164499],\n  \"辽宁省-盘锦市-大洼区\": [122.088555, 41.008179],\n  \"辽宁省-盘锦市-盘山县\": [122.00356, 41.248264],\n  \"辽宁省-铁岭市\": [123.732365, 42.229948],\n  \"辽宁省-铁岭市-银州区\": [123.848386, 42.292574],\n  \"辽宁省-铁岭市-清河区\": [124.165563, 42.552495],\n  \"辽宁省-铁岭市-铁岭县\": [123.735372, 42.229226],\n  \"辽宁省-铁岭市-西丰县\": [124.733615, 42.744014],\n  \"辽宁省-铁岭市-昌图县\": [124.117501, 42.792178],\n  \"辽宁省-铁岭市-调兵山市\": [123.573509, 42.473738],\n  \"辽宁省-铁岭市-开原市\": [124.044569, 42.552079],\n  \"辽宁省-朝阳市\": [120.457499, 41.579821],\n  \"辽宁省-朝阳市-双塔区\": [120.460487, 41.571779],\n  \"辽宁省-朝阳市-龙城区\": [120.443567, 41.598469],\n  \"辽宁省-朝阳市-朝阳县\": [120.259391, 41.241076],\n  \"辽宁省-朝阳市-建平县\": [119.64938, 41.409456],\n  \"辽宁省-朝阳市-喀喇沁左翼蒙古族自治县\": [119.747414, 41.133689],\n  \"辽宁省-朝阳市-北票市\": [120.777628, 41.806483],\n  \"辽宁省-朝阳市-凌源市\": [119.407358, 41.251651],\n  \"辽宁省-葫芦岛市\": [120.843398, 40.717364],\n  \"辽宁省-葫芦岛市-连山区\": [120.876482, 40.780894],\n  \"辽宁省-葫芦岛市-龙港区\": [120.900621, 40.741057],\n  \"辽宁省-葫芦岛市-南票区\": [120.756493, 41.113098],\n  \"辽宁省-葫芦岛市-绥中县\": [120.350425, 40.331843],\n  \"辽宁省-葫芦岛市-建昌县\": [119.843595, 40.83038],\n  \"辽宁省-葫芦岛市-兴城市\": [120.764558, 40.616556],\n  \"吉林省\": [125.33258, 43.901714],\n  \"吉林省-长春市\": [125.330602, 43.821954],\n  \"吉林省-长春市-南关区\": [125.35661, 43.869873],\n  \"吉林省-长春市-宽城区\": [125.334625, 43.949502],\n  \"吉林省-长春市-朝阳区\": [125.295401, 43.840641],\n  \"吉林省-长春市-二道区\": [125.380468, 43.871277],\n  \"吉林省-长春市-绿园区\": [125.262443, 43.88681],\n  \"吉林省-长春市-双阳区\": [125.671448, 43.531091],\n  \"吉林省-长春市-九台区\": [125.845564, 44.157792],\n  \"吉林省-长春市-农安县\": [125.191484, 44.438904],\n  \"吉林省-长春市-榆树市\": [126.539609, 44.84544],\n  \"吉林省-长春市-德惠市\": [125.734515, 44.527161],\n  \"吉林省-吉林市\": [126.555635, 43.843568],\n  \"吉林省-吉林市-昌邑区\": [126.581449, 43.887992],\n  \"吉林省-吉林市-龙潭区\": [126.568545, 43.916343],\n  \"吉林省-吉林市-船营区\": [126.54765, 43.839927],\n  \"吉林省-吉林市-丰满区\": [126.56857, 43.827152],\n  \"吉林省-吉林市-永吉县\": [126.504416, 43.678721],\n  \"吉林省-吉林市-蛟河市\": [127.35148, 43.730004],\n  \"吉林省-吉林市-桦甸市\": [126.752484, 42.977983],\n  \"吉林省-吉林市-舒兰市\": [126.971377, 44.41227],\n  \"吉林省-吉林市-磐石市\": [126.066616, 42.951817],\n  \"吉林省-四平市\": [124.356482, 43.171994],\n  \"吉林省-四平市-铁西区\": [124.352467, 43.152575],\n  \"吉林省-四平市-铁东区\": [124.416483, 43.167994],\n  \"吉林省-四平市-梨树县\": [124.342401, 43.313346],\n  \"吉林省-四平市-伊通满族自治县\": [125.311485, 43.351104],\n  \"吉林省-四平市-公主岭市\": [124.829449, 43.510833],\n  \"吉林省-四平市-双辽市\": [123.509438, 43.524527],\n  \"吉林省-辽源市\": [125.150425, 42.894055],\n  \"吉林省-辽源市-龙山区\": [125.143452, 42.907634],\n  \"吉林省-辽源市-西安区\": [125.155373, 42.933308],\n  \"吉林省-辽源市-东丰县\": [125.537378, 42.683311],\n  \"吉林省-辽源市-东辽县\": [124.997589, 42.931879],\n  \"吉林省-通化市\": [125.946606, 41.733816],\n  \"吉林省-通化市-东昌区\": [125.933595, 41.708405],\n  \"吉林省-通化市-二道江区\": [126.049592, 41.779966],\n  \"吉林省-通化市-通化县\": [125.765392, 41.685682],\n  \"吉林省-通化市-辉南县\": [126.053581, 42.6907],\n  \"吉林省-通化市-柳河县\": [125.751424, 42.290871],\n  \"吉林省-通化市-梅河口市\": [125.717608, 42.544884],\n  \"吉林省-通化市-集安市\": [126.199577, 41.1313],\n  \"吉林省-白山市\": [126.42963, 41.939627],\n  \"吉林省-白山市-浑江区\": [126.42362, 41.950424],\n  \"吉林省-白山市-江源区\": [126.597391, 42.062939],\n  \"吉林省-白山市-抚松县\": [127.455371, 42.227335],\n  \"吉林省-白山市-靖宇县\": [126.819499, 42.394766],\n  \"吉林省-白山市-长白朝鲜族自治县\": [128.207584, 41.425896],\n  \"吉林省-白山市-临江市\": [126.924582, 41.817679],\n  \"吉林省-松原市\": [124.831482, 45.147404],\n  \"吉林省-松原市-宁江区\": [124.823423, 45.178039],\n  \"吉林省-松原市-前郭尔罗斯蒙古族自治县\": [124.830456, 45.123416],\n  \"吉林省-松原市-长岭县\": [123.974374, 44.281638],\n  \"吉林省-松原市-乾安县\": [124.047564, 45.008434],\n  \"吉林省-松原市-扶余市\": [126.056606, 44.994168],\n  \"吉林省-白城市\": [122.845591, 45.625504],\n  \"吉林省-白城市-洮北区\": [122.85751, 45.627525],\n  \"吉林省-白城市-镇赉县\": [123.206576, 45.853117],\n  \"吉林省-白城市-通榆县\": [123.094521, 44.818964],\n  \"吉林省-白城市-洮南市\": [122.794468, 45.341132],\n  \"吉林省-白城市-大安市\": [124.298504, 45.513045],\n  \"吉林省-延边朝鲜族自治州\": [129.477376, 42.915743],\n  \"吉林省-延边朝鲜族自治州-延吉市\": [129.52052, 42.912717],\n  \"吉林省-延边朝鲜族自治州-图们市\": [129.850382, 42.974283],\n  \"吉林省-延边朝鲜族自治州-敦化市\": [128.238612, 43.378291],\n  \"吉林省-延边朝鲜族自治州-珲春市\": [130.372613, 42.868515],\n  \"吉林省-延边朝鲜族自治州-龙井市\": [129.432635, 42.771535],\n  \"吉林省-延边朝鲜族自治州-和龙市\": [129.017387, 42.552323],\n  \"吉林省-延边朝鲜族自治州-汪清县\": [129.777609, 43.318451],\n  \"吉林省-延边朝鲜族自治州-安图县\": [128.905448, 43.117917],\n  \"黑龙江省\": [126.669653, 45.74793],\n  \"黑龙江省-哈尔滨市\": [126.541615, 45.808826],\n  \"黑龙江省-哈尔滨市-道里区\": [126.623432, 45.761844],\n  \"黑龙江省-哈尔滨市-南岗区\": [126.675638, 45.765866],\n  \"黑龙江省-哈尔滨市-道外区\": [126.655604, 45.797776],\n  \"黑龙江省-哈尔滨市-平房区\": [126.643547, 45.603862],\n  \"黑龙江省-哈尔滨市-松北区\": [126.516483, 45.808593],\n  \"黑龙江省-哈尔滨市-香坊区\": [126.669624, 45.71362],\n  \"黑龙江省-哈尔滨市-呼兰区\": [126.594399, 45.89521],\n  \"黑龙江省-哈尔滨市-阿城区\": [126.964356, 45.554275],\n  \"黑龙江省-哈尔滨市-双城区\": [126.319623, 45.388112],\n  \"黑龙江省-哈尔滨市-依兰县\": [129.57452, 46.33126],\n  \"黑龙江省-哈尔滨市-方正县\": [128.835634, 45.857758],\n  \"黑龙江省-哈尔滨市-宾县\": [127.473497, 45.752465],\n  \"黑龙江省-哈尔滨市-巴彦县\": [127.410548, 46.091283],\n  \"黑龙江省-哈尔滨市-木兰县\": [128.050356, 45.956871],\n  \"黑龙江省-哈尔滨市-通河县\": [128.752416, 45.996393],\n  \"黑龙江省-哈尔滨市-延寿县\": [128.338606, 45.457641],\n  \"黑龙江省-哈尔滨市-尚志市\": [128.015488, 45.215474],\n  \"黑龙江省-哈尔滨市-五常市\": [127.173529, 44.937843],\n  \"黑龙江省-齐齐哈尔市\": [123.924571, 47.359977],\n  \"黑龙江省-齐齐哈尔市-龙沙区\": [123.964376, 47.323577],\n  \"黑龙江省-齐齐哈尔市-建华区\": [123.96135, 47.360555],\n  \"黑龙江省-齐齐哈尔市-铁锋区\": [123.984416, 47.347019],\n  \"黑龙江省-齐齐哈尔市-昂昂溪区\": [123.829406, 47.161332],\n  \"黑龙江省-齐齐哈尔市-富拉尔基区\": [123.63651, 47.215504],\n  \"黑龙江省-齐齐哈尔市-碾子山区\": [122.894367, 47.523236],\n  \"黑龙江省-齐齐哈尔市-梅里斯达斡尔族区\": [123.759541, 47.31555],\n  \"黑龙江省-齐齐哈尔市-龙江县\": [123.211539, 47.343606],\n  \"黑龙江省-齐齐哈尔市-依安县\": [125.312482, 47.899484],\n  \"黑龙江省-齐齐哈尔市-泰来县\": [123.423626, 46.397829],\n  \"黑龙江省-齐齐哈尔市-甘南县\": [123.512486, 47.926884],\n  \"黑龙江省-齐齐哈尔市-富裕县\": [124.480542, 47.780228],\n  \"黑龙江省-齐齐哈尔市-克山县\": [125.881378, 48.043172],\n  \"黑龙江省-齐齐哈尔市-克东县\": [126.255387, 48.048244],\n  \"黑龙江省-齐齐哈尔市-拜泉县\": [126.105421, 47.601867],\n  \"黑龙江省-齐齐哈尔市-讷河市\": [124.890549, 48.490087],\n  \"黑龙江省-鸡西市\": [130.975619, 45.300872],\n  \"黑龙江省-鸡西市-鸡冠区\": [130.987632, 45.309806],\n  \"黑龙江省-鸡西市-恒山区\": [130.911385, 45.216972],\n  \"黑龙江省-鸡西市-滴道区\": [130.85058, 45.354434],\n  \"黑龙江省-鸡西市-梨树区\": [130.703396, 45.098242],\n  \"黑龙江省-鸡西市-城子河区\": [131.018469, 45.344435],\n  \"黑龙江省-鸡西市-麻山区\": [130.484536, 45.217935],\n  \"黑龙江省-鸡西市-鸡东县\": [131.130558, 45.266185],\n  \"黑龙江省-鸡西市-虎林市\": [132.943466, 45.768947],\n  \"黑龙江省-鸡西市-密山市\": [131.853531, 45.535641],\n  \"黑龙江省-鹤岗市\": [130.304433, 47.356056],\n  \"黑龙江省-鹤岗市-向阳区\": [130.300468, 47.348581],\n  \"黑龙江省-鹤岗市-工农区\": [130.281617, 47.32443],\n  \"黑龙江省-鹤岗市-南山区\": [130.29354, 47.321246],\n  \"黑龙江省-鹤岗市-兴安区\": [130.245546, 47.258716],\n  \"黑龙江省-鹤岗市-东山区\": [130.323361, 47.344987],\n  \"黑龙江省-鹤岗市-兴山区\": [130.317364, 47.396045],\n  \"黑龙江省-鹤岗市-萝北县\": [130.835495, 47.583422],\n  \"黑龙江省-鹤岗市-绥滨县\": [131.859487, 47.295265],\n  \"黑龙江省-双鸭山市\": [131.165342, 46.653186],\n  \"黑龙江省-双鸭山市-尖山区\": [131.165342, 46.652586],\n  \"黑龙江省-双鸭山市-岭东区\": [131.164377, 46.464596],\n  \"黑龙江省-双鸭山市-四方台区\": [131.345657, 46.602012],\n  \"黑龙江省-双鸭山市-宝山区\": [131.407375, 46.583598],\n  \"黑龙江省-双鸭山市-集贤县\": [131.147434, 46.734518],\n  \"黑龙江省-双鸭山市-友谊县\": [131.814595, 46.772973],\n  \"黑龙江省-双鸭山市-宝清县\": [132.203594, 46.332652],\n  \"黑龙江省-双鸭山市-饶河县\": [134.020469, 46.804183],\n  \"黑龙江省-大庆市\": [125.108658, 46.593633],\n  \"黑龙江省-大庆市-萨尔图区\": [125.13351, 46.638936],\n  \"黑龙江省-大庆市-龙凤区\": [125.140473, 46.567678],\n  \"黑龙江省-大庆市-让胡路区\": [124.877599, 46.658078],\n  \"黑龙江省-大庆市-红岗区\": [124.897477, 46.404313],\n  \"黑龙江省-大庆市-大同区\": [124.819377, 46.045584],\n  \"黑龙江省-大庆市-肇州县\": [125.275368, 45.705108],\n  \"黑龙江省-大庆市-肇源县\": [125.084573, 45.524153],\n  \"黑龙江省-大庆市-林甸县\": [124.86965, 47.177234],\n  \"黑龙江省-大庆市-杜尔伯特蒙古族自治县\": [124.449359, 46.868768],\n  \"黑龙江省-伊春市\": [128.847546, 47.733318],\n  \"黑龙江省-伊春市-伊春区\": [128.913459, 47.733954],\n  \"黑龙江省-伊春市-南岔区\": [129.289572, 47.14375],\n  \"黑龙江省-伊春市-友好区\": [128.842579, 47.846436],\n  \"黑龙江省-伊春市-西林区\": [129.319594, 47.486393],\n  \"黑龙江省-伊春市-翠峦区\": [128.676482, 47.732894],\n  \"黑龙江省-伊春市-新青区\": [129.540647, 48.296135],\n  \"黑龙江省-伊春市-美溪区\": [129.135368, 47.641344],\n  \"黑龙江省-伊春市-金山屯区\": [129.435639, 47.418759],\n  \"黑龙江省-伊春市-五营区\": [129.25135, 48.114271],\n  \"黑龙江省-伊春市-乌马河区\": [128.805546, 47.733619],\n  \"黑龙江省-伊春市-汤旺河区\": [129.577474, 48.460614],\n  \"黑龙江省-伊春市-带岭区\": [129.027425, 47.034572],\n  \"黑龙江省-伊春市-乌伊岭区\": [129.444577, 48.596169],\n  \"黑龙江省-伊春市-红星区\": [129.397507, 48.24548],\n  \"黑龙江省-伊春市-上甘岭区\": [129.030437, 47.980914],\n  \"黑龙江省-伊春市-嘉荫县\": [130.410555, 48.894983],\n  \"黑龙江省-伊春市-铁力市\": [128.038365, 46.992949],\n  \"黑龙江省-佳木斯市\": [130.327359, 46.80569],\n  \"黑龙江省-佳木斯市-向阳区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-前进区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-东风区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-郊区\": [130.333378, 46.816168],\n  \"黑龙江省-佳木斯市-桦南县\": [130.560385, 46.245077],\n  \"黑龙江省-佳木斯市-桦川县\": [130.725549, 47.028817],\n  \"黑龙江省-佳木斯市-汤原县\": [129.911645, 46.735327],\n  \"黑龙江省-佳木斯市-同江市\": [132.517509, 47.647981],\n  \"黑龙江省-佳木斯市-富锦市\": [132.044539, 47.255933],\n  \"黑龙江省-佳木斯市-抚远市\": [134.31449, 48.370945],\n  \"黑龙江省-七台河市\": [131.011545, 45.7763],\n  \"黑龙江省-七台河市-新兴区\": [130.938371, 45.82231],\n  \"黑龙江省-七台河市-桃山区\": [131.026444, 45.7718],\n  \"黑龙江省-七台河市-茄子河区\": [131.074481, 45.791238],\n  \"黑龙江省-七台河市-勃利县\": [130.598533, 45.760964],\n  \"黑龙江省-牡丹江市\": [129.63954, 44.556246],\n  \"黑龙江省-牡丹江市-东安区\": [129.633478, 44.58746],\n  \"黑龙江省-牡丹江市-阳明区\": [129.642527, 44.601775],\n  \"黑龙江省-牡丹江市-爱民区\": [129.598364, 44.60235],\n  \"黑龙江省-牡丹江市-西安区\": [129.622413, 44.583861],\n  \"黑龙江省-牡丹江市-林口县\": [130.287579, 45.284129],\n  \"黑龙江省-牡丹江市-绥芬河市\": [131.157392, 44.418154],\n  \"黑龙江省-牡丹江市-海林市\": [129.387427, 44.599872],\n  \"黑龙江省-牡丹江市-宁安市\": [129.489368, 44.346984],\n  \"黑龙江省-牡丹江市-穆棱市\": [130.530559, 44.924785],\n  \"黑龙江省-牡丹江市-东宁市\": [131.131544, 44.096101],\n  \"黑龙江省-黑河市\": [127.53549, 50.251272],\n  \"黑龙江省-黑河市-爱辉区\": [127.506632, 50.25771],\n  \"黑龙江省-黑河市-嫩江县\": [125.227635, 49.19132],\n  \"黑龙江省-黑河市-逊克县\": [128.485585, 49.569491],\n  \"黑龙江省-黑河市-孙吴县\": [127.342388, 49.431451],\n  \"黑龙江省-黑河市-北安市\": [126.49738, 48.24742],\n  \"黑龙江省-黑河市-五大连池市\": [126.211555, 48.52261],\n  \"黑龙江省-绥化市\": [126.975357, 46.660032],\n  \"黑龙江省-绥化市-北林区\": [126.991449, 46.643493],\n  \"黑龙江省-绥化市-望奎县\": [126.492385, 46.839168],\n  \"黑龙江省-绥化市-兰西县\": [126.29462, 46.258095],\n  \"黑龙江省-绥化市-青冈县\": [126.100489, 46.710685],\n  \"黑龙江省-绥化市-庆安县\": [127.514612, 46.885744],\n  \"黑龙江省-绥化市-明水县\": [125.912483, 47.179483],\n  \"黑龙江省-绥化市-绥棱县\": [127.120515, 47.242516],\n  \"黑龙江省-绥化市-安达市\": [125.348622, 46.425719],\n  \"黑龙江省-绥化市-肇东市\": [125.968537, 46.056938],\n  \"黑龙江省-绥化市-海伦市\": [126.936509, 47.456904],\n  \"黑龙江省-大兴安岭地区\": [123.644559, 52.510947],\n  \"黑龙江省-大兴安岭地区-呼玛县\": [126.65965, 51.730947],\n  \"黑龙江省-大兴安岭地区-塔河县\": [124.716513, 52.340305],\n  \"黑龙江省-大兴安岭地区-漠河县\": [122.545421, 52.978304],\n  \"上海市\": [121.480539, 31.235929],\n  \"上海市-市辖区\": [121.480539, 31.235929],\n  \"上海市-市辖区-黄浦区\": [121.491586, 31.237247],\n  \"上海市-市辖区-徐汇区\": [121.443396, 31.194557],\n  \"上海市-市辖区-长宁区\": [121.430454, 31.226848],\n  \"上海市-市辖区-静安区\": [121.453432, 31.233845],\n  \"上海市-市辖区-普陀区\": [121.403569, 31.254973],\n  \"上海市-市辖区-虹口区\": [121.511586, 31.269747],\n  \"上海市-市辖区-杨浦区\": [121.53252, 31.265524],\n  \"上海市-市辖区-闵行区\": [121.388612, 31.118843],\n  \"上海市-市辖区-宝山区\": [121.496563, 31.410279],\n  \"上海市-市辖区-嘉定区\": [121.272595, 31.380155],\n  \"上海市-市辖区-浦东新区\": [121.550455, 31.227348],\n  \"上海市-市辖区-金山区\": [121.34848, 30.747852],\n  \"上海市-市辖区-松江区\": [121.23448, 31.037135],\n  \"上海市-市辖区-青浦区\": [121.130553, 31.155454],\n  \"上海市-市辖区-奉贤区\": [121.480504, 30.92372],\n  \"上海市-市辖区-崇明区\": [121.403557, 31.62857],\n  \"江苏省\": [118.769552, 32.066777],\n  \"江苏省-南京市\": [118.802422, 32.064653],\n  \"江苏省-南京市-玄武区\": [118.804413, 32.054757],\n  \"江苏省-南京市-秦淮区\": [118.800407, 32.045139],\n  \"江苏省-南京市-建邺区\": [118.738569, 32.00937],\n  \"江苏省-南京市-鼓楼区\": [118.776519, 32.072405],\n  \"江苏省-南京市-浦口区\": [118.634604, 32.064679],\n  \"江苏省-南京市-栖霞区\": [118.915423, 32.1026],\n  \"江苏省-南京市-雨花台区\": [118.785445, 31.997859],\n  \"江苏省-南京市-江宁区\": [118.846567, 31.958527],\n  \"江苏省-南京市-六合区\": [118.827471, 32.328666],\n  \"江苏省-南京市-溧水区\": [119.034404, 31.657284],\n  \"江苏省-南京市-高淳区\": [118.898498, 31.333639],\n  \"江苏省-无锡市\": [120.318583, 31.49881],\n  \"江苏省-无锡市-锡山区\": [120.363426, 31.594762],\n  \"江苏省-无锡市-惠山区\": [120.304596, 31.686741],\n  \"江苏省-无锡市-滨湖区\": [120.291548, 31.53464],\n  \"江苏省-无锡市-梁溪区\": [120.3096, 31.571645],\n  \"江苏省-无锡市-新吴区\": [120.370396, 31.55485],\n  \"江苏省-无锡市-江阴市\": [120.370396, 31.55485],\n  \"江苏省-无锡市-宜兴市\": [119.831606, 31.342957],\n  \"江苏省-徐州市\": [117.290575, 34.212667],\n  \"江苏省-徐州市-鼓楼区\": [117.192579, 34.29376],\n  \"江苏省-徐州市-云龙区\": [117.258424, 34.259087],\n  \"江苏省-徐州市-贾汪区\": [117.46943, 34.44162],\n  \"江苏省-徐州市-泉山区\": [117.20059, 34.249943],\n  \"江苏省-徐州市-铜山区\": [117.17557, 34.1861],\n  \"江苏省-徐州市-丰县\": [116.602582, 34.69977],\n  \"江苏省-徐州市-沛县\": [116.942586, 34.765152],\n  \"江苏省-徐州市-睢宁县\": [117.947433, 33.918789],\n  \"江苏省-徐州市-新沂市\": [118.361537, 34.375611],\n  \"江苏省-徐州市-邳州市\": [117.963411, 34.339753],\n  \"江苏省-常州市\": [119.981485, 31.815796],\n  \"江苏省-常州市-天宁区\": [119.980463, 31.78557],\n  \"江苏省-常州市-钟楼区\": [119.908463, 31.807647],\n  \"江苏省-常州市-新北区\": [119.977514, 31.836324],\n  \"江苏省-常州市-武进区\": [119.948612, 31.706447],\n  \"江苏省-常州市-金坛区\": [119.604571, 31.728893],\n  \"江苏省-常州市-溧阳市\": [119.491506, 31.422102],\n  \"江苏省-苏州市\": [120.592412, 31.303564],\n  \"江苏省-苏州市-虎丘区\": [120.578472, 31.301933],\n  \"江苏省-苏州市-吴中区\": [120.638508, 31.268261],\n  \"江苏省-苏州市-相城区\": [120.648566, 31.37469],\n  \"江苏省-苏州市-姑苏区\": [120.623455, 31.341831],\n  \"江苏省-苏州市-吴江区\": [120.651567, 31.144644],\n  \"江苏省-苏州市-常熟市\": [120.759496, 31.659538],\n  \"江苏省-苏州市-张家港市\": [120.561554, 31.881141],\n  \"江苏省-苏州市-昆山市\": [120.987452, 31.390863],\n  \"江苏省-苏州市-太仓市\": [121.135595, 31.464599],\n  \"江苏省-南通市\": [120.901592, 31.986549],\n  \"江苏省-南通市-崇川区\": [120.86342, 32.015923],\n  \"江苏省-南通市-港闸区\": [120.824452, 32.037345],\n  \"江苏省-南通市-通州区\": [121.081425, 32.070356],\n  \"江苏省-南通市-海安县\": [120.474433, 32.539196],\n  \"江苏省-南通市-如东县\": [121.192438, 32.335873],\n  \"江苏省-南通市-启东市\": [121.663474, 31.814233],\n  \"江苏省-南通市-如皋市\": [120.579466, 32.377851],\n  \"江苏省-南通市-海门市\": [121.188436, 31.873612],\n  \"江苏省-连云港市\": [119.228621, 34.60225],\n  \"江苏省-连云港市-连云区\": [119.346588, 34.765337],\n  \"江苏省-连云港市-海州区\": [119.169408, 34.577456],\n  \"江苏省-连云港市-赣榆区\": [119.179435, 34.847682],\n  \"江苏省-连云港市-东海县\": [118.759565, 34.547919],\n  \"江苏省-连云港市-灌云县\": [119.246534, 34.288616],\n  \"江苏省-连云港市-灌南县\": [119.322538, 34.092591],\n  \"江苏省-淮安市\": [119.021484, 33.616295],\n  \"江苏省-淮安市-淮安区\": [119.147463, 33.509],\n  \"江苏省-淮安市-淮阴区\": [119.041422, 33.63815],\n  \"江苏省-淮安市-清江浦区\": [119.032414, 33.558562],\n  \"江苏省-淮安市-洪泽区\": [118.879584, 33.299625],\n  \"江苏省-淮安市-涟水县\": [119.266448, 33.787079],\n  \"江苏省-淮安市-盱眙县\": [118.551441, 33.018255],\n  \"江苏省-淮安市-金湖县\": [119.026469, 33.031284],\n  \"江苏省-盐城市\": [120.167544, 33.355101],\n  \"江苏省-盐城市-亭湖区\": [120.204578, 33.395893],\n  \"江苏省-盐城市-盐都区\": [120.160503, 33.34402],\n  \"江苏省-盐城市-大丰区\": [120.507439, 33.20476],\n  \"江苏省-盐城市-响水县\": [119.584601, 34.204743],\n  \"江苏省-盐城市-滨海县\": [119.827621, 33.995647],\n  \"江苏省-盐城市-阜宁县\": [119.809581, 33.765079],\n  \"江苏省-盐城市-射阳县\": [120.264446, 33.781014],\n  \"江苏省-盐城市-建湖县\": [119.805531, 33.469833],\n  \"江苏省-盐城市-东台市\": [120.326537, 32.872716],\n  \"江苏省-扬州市\": [119.419419, 32.400677],\n  \"江苏省-扬州市-广陵区\": [119.438505, 32.400661],\n  \"江苏省-扬州市-邗江区\": [119.404385, 32.382751],\n  \"江苏省-扬州市-江都区\": [119.576603, 32.440295],\n  \"江苏省-扬州市-宝应县\": [119.365556, 33.247205],\n  \"江苏省-扬州市-仪征市\": [119.191467, 32.27809],\n  \"江苏省-扬州市-高邮市\": [119.465616, 32.787147],\n  \"江苏省-镇江市\": [119.430489, 32.194716],\n  \"江苏省-镇江市-京口区\": [119.475604, 32.203785],\n  \"江苏省-镇江市-润州区\": [119.41844, 32.201495],\n  \"江苏省-镇江市-丹徒区\": [119.440501, 32.13792],\n  \"江苏省-镇江市-丹阳市\": [119.612501, 32.01592],\n  \"江苏省-镇江市-扬中市\": [119.80352, 32.242967],\n  \"江苏省-镇江市-句容市\": [119.175433, 31.950923],\n  \"江苏省-泰州市\": [119.929566, 32.460675],\n  \"江苏省-泰州市-海陵区\": [119.925525, 32.496732],\n  \"江苏省-泰州市-高港区\": [119.888421, 32.324862],\n  \"江苏省-泰州市-姜堰区\": [120.133398, 32.515234],\n  \"江苏省-泰州市-兴化市\": [119.857514, 32.917824],\n  \"江苏省-泰州市-靖江市\": [120.283532, 31.98817],\n  \"江苏省-泰州市-泰兴市\": [120.058599, 32.177474],\n  \"江苏省-宿迁市\": [118.281574, 33.96775],\n  \"江苏省-宿迁市-宿城区\": [118.249567, 33.968678],\n  \"江苏省-宿迁市-宿豫区\": [118.336401, 33.954804],\n  \"江苏省-宿迁市-沭阳县\": [118.810419, 34.117454],\n  \"江苏省-宿迁市-泗阳县\": [118.709466, 33.728328],\n  \"江苏省-宿迁市-泗洪县\": [118.222416, 33.465733],\n  \"浙江省\": [120.159533, 30.271548],\n  \"浙江省-杭州市\": [120.215512, 30.253083],\n  \"浙江省-杭州市-上城区\": [120.175579, 30.248398],\n  \"浙江省-杭州市-下城区\": [120.187607, 30.286744],\n  \"浙江省-杭州市-江干区\": [120.211539, 30.263311],\n  \"浙江省-杭州市-拱墅区\": [120.148447, 30.324643],\n  \"浙江省-杭州市-西湖区\": [120.136438, 30.265916],\n  \"浙江省-杭州市-滨江区\": [120.218471, 30.214333],\n  \"浙江省-杭州市-萧山区\": [120.218471, 30.214333],\n  \"浙江省-杭州市-余杭区\": [120.306592, 30.424739],\n  \"浙江省-杭州市-富阳区\": [119.966556, 30.054723],\n  \"浙江省-杭州市-桐庐县\": [119.697599, 29.798585],\n  \"浙江省-杭州市-淳安县\": [119.048392, 29.61495],\n  \"浙江省-杭州市-建德市\": [119.287398, 29.481154],\n  \"浙江省-杭州市-临安市\": [119.731517, 30.239806],\n  \"浙江省-宁波市\": [121.628572, 29.866033],\n  \"浙江省-宁波市-海曙区\": [121.557403, 29.865721],\n  \"浙江省-宁波市-江东区\": [121.576533, 29.8733],\n  \"浙江省-宁波市-江北区\": [121.560421, 29.892948],\n  \"浙江省-宁波市-北仑区\": [121.850576, 29.904659],\n  \"浙江省-宁波市-镇海区\": [121.722519, 29.954885],\n  \"浙江省-宁波市-鄞州区\": [121.555427, 29.824206],\n  \"浙江省-宁波市-象山县\": [121.875564, 29.482271],\n  \"浙江省-宁波市-宁海县\": [121.436432, 29.294317],\n  \"浙江省-宁波市-余姚市\": [121.160585, 30.042735],\n  \"浙江省-宁波市-慈溪市\": [121.272596, 30.175257],\n  \"浙江省-宁波市-奉化市\": [121.413528, 29.661146],\n  \"浙江省-温州市\": [120.706477, 28.001085],\n  \"浙江省-温州市-鹿城区\": [120.661586, 28.020352],\n  \"浙江省-温州市-龙湾区\": [120.819468, 27.938652],\n  \"浙江省-温州市-瓯海区\": [120.621447, 27.972857],\n  \"浙江省-温州市-洞头区\": [121.163549, 27.84187],\n  \"浙江省-温州市-永嘉县\": [120.688524, 28.15645],\n  \"浙江省-温州市-平阳县\": [120.572515, 27.667724],\n  \"浙江省-温州市-苍南县\": [120.433595, 27.523067],\n  \"浙江省-温州市-文成县\": [120.097488, 27.793217],\n  \"浙江省-温州市-泰顺县\": [119.723537, 27.562171],\n  \"浙江省-温州市-瑞安市\": [120.661582, 27.783951],\n  \"浙江省-温州市-乐清市\": [120.992502, 28.11818],\n  \"浙江省-嘉兴市\": [120.763552, 30.750975],\n  \"浙江省-嘉兴市-南湖区\": [120.78961, 30.751547],\n  \"浙江省-嘉兴市-秀洲区\": [120.715437, 30.770207],\n  \"浙江省-嘉兴市-嘉善县\": [120.932511, 30.837122],\n  \"浙江省-嘉兴市-海盐县\": [120.952445, 30.531873],\n  \"浙江省-嘉兴市-海宁市\": [120.686565, 30.517924],\n  \"浙江省-嘉兴市-平湖市\": [121.022575, 30.682241],\n  \"浙江省-嘉兴市-桐乡市\": [120.571543, 30.636311],\n  \"浙江省-湖州市\": [120.094517, 30.898964],\n  \"浙江省-湖州市-吴兴区\": [120.191605, 30.862955],\n  \"浙江省-湖州市-南浔区\": [120.424601, 30.855243],\n  \"浙江省-湖州市-德清县\": [119.983465, 30.548628],\n  \"浙江省-湖州市-长兴县\": [119.917498, 31.032579],\n  \"浙江省-湖州市-安吉县\": [119.686563, 30.644425],\n  \"浙江省-绍兴市\": [120.585478, 30.036369],\n  \"浙江省-绍兴市-越城区\": [120.588437, 29.99531],\n  \"浙江省-绍兴市-柯桥区\": [120.451511, 30.079004],\n  \"浙江省-绍兴市-上虞区\": [120.87451, 30.038243],\n  \"浙江省-绍兴市-新昌县\": [120.91057, 29.505541],\n  \"浙江省-绍兴市-诸暨市\": [120.253408, 29.714935],\n  \"浙江省-绍兴市-嵊州市\": [120.837437, 29.567327],\n  \"浙江省-金华市\": [119.653436, 29.084639],\n  \"浙江省-金华市-婺城区\": [119.578593, 29.091775],\n  \"浙江省-金华市-金东区\": [119.699582, 29.104765],\n  \"浙江省-金华市-武义县\": [119.822566, 28.898244],\n  \"浙江省-金华市-浦江县\": [119.898436, 29.458693],\n  \"浙江省-金华市-磐安县\": [120.456513, 29.060103],\n  \"浙江省-金华市-兰溪市\": [119.466599, 29.214044],\n  \"浙江省-金华市-义乌市\": [120.081581, 29.31115],\n  \"浙江省-金华市-东阳市\": [120.248422, 29.295861],\n  \"浙江省-金华市-永康市\": [120.054551, 28.894204],\n  \"浙江省-衢州市\": [118.866597, 28.975546],\n  \"浙江省-衢州市-柯城区\": [118.877584, 28.974204],\n  \"浙江省-衢州市-衢江区\": [118.965539, 28.986238],\n  \"浙江省-衢州市-常山县\": [118.517557, 28.906998],\n  \"浙江省-衢州市-开化县\": [118.421459, 29.143188],\n  \"浙江省-衢州市-龙游县\": [119.178418, 29.034487],\n  \"浙江省-衢州市-江山市\": [118.633583, 28.742868],\n  \"浙江省-舟山市\": [122.213556, 29.990912],\n  \"浙江省-舟山市-定海区\": [122.113601, 30.025462],\n  \"浙江省-舟山市-普陀区\": [122.331544, 29.976836],\n  \"浙江省-舟山市-岱山县\": [122.232605, 30.269656],\n  \"浙江省-舟山市-嵊泗县\": [122.457588, 30.731274],\n  \"浙江省-台州市\": [121.427435, 28.662194],\n  \"浙江省-台州市-椒江区\": [121.449408, 28.679258],\n  \"浙江省-台州市-黄岩区\": [121.268566, 28.655334],\n  \"浙江省-台州市-路桥区\": [121.371578, 28.586947],\n  \"浙江省-台州市-玉环县\": [121.238513, 28.141863],\n  \"浙江省-台州市-三门县\": [121.402554, 29.110355],\n  \"浙江省-台州市-天台县\": [121.013553, 29.149514],\n  \"浙江省-台州市-仙居县\": [120.735435, 28.853226],\n  \"浙江省-台州市-温岭市\": [121.392589, 28.377655],\n  \"浙江省-台州市-临海市\": [121.151585, 28.864049],\n  \"浙江省-丽水市\": [119.929573, 28.473278],\n  \"浙江省-丽水市-莲都区\": [119.919519, 28.451745],\n  \"浙江省-丽水市-青田县\": [120.296573, 28.145488],\n  \"浙江省-丽水市-缙云县\": [120.097478, 28.665215],\n  \"浙江省-丽水市-遂昌县\": [119.282435, 28.598455],\n  \"浙江省-丽水市-松阳县\": [119.488544, 28.455056],\n  \"浙江省-丽水市-云和县\": [119.579597, 28.12147],\n  \"浙江省-丽水市-庆元县\": [119.069487, 27.625432],\n  \"浙江省-丽水市-景宁畲族自治县\": [119.64243, 27.979554],\n  \"浙江省-丽水市-龙泉市\": [119.148445, 28.080509],\n  \"安徽省\": [117.33054, 31.734294],\n  \"安徽省-合肥市\": [117.233443, 31.826578],\n  \"安徽省-合肥市-瑶海区\": [117.315587, 31.863787],\n  \"安徽省-合肥市-庐阳区\": [117.271459, 31.884887],\n  \"安徽省-合肥市-蜀山区\": [117.266461, 31.857378],\n  \"安徽省-合肥市-包河区\": [117.316576, 31.799293],\n  \"安徽省-合肥市-长丰县\": [117.17356, 32.483723],\n  \"安徽省-合肥市-肥东县\": [117.475401, 31.89389],\n  \"安徽省-合肥市-肥西县\": [117.164558, 31.712962],\n  \"安徽省-合肥市-庐江县\": [117.293577, 31.261328],\n  \"安徽省-合肥市-巢湖市\": [117.895576, 31.629002],\n  \"安徽省-芜湖市\": [118.439431, 31.358537],\n  \"安徽省-芜湖市-镜湖区\": [118.392606, 31.345867],\n  \"安徽省-芜湖市-弋江区\": [118.37958, 31.317566],\n  \"安徽省-芜湖市-鸠江区\": [118.397588, 31.375805],\n  \"安徽省-芜湖市-三山区\": [118.274602, 31.22528],\n  \"安徽省-芜湖市-芜湖县\": [118.582443, 31.141239],\n  \"安徽省-芜湖市-繁昌县\": [118.205424, 31.107959],\n  \"安徽省-芜湖市-南陵县\": [118.340418, 30.92026],\n  \"安徽省-芜湖市-无为县\": [118.071407, 31.340204],\n  \"安徽省-蚌埠市\": [117.395513, 32.921524],\n  \"安徽省-蚌埠市-龙子湖区\": [117.399513, 32.948644],\n  \"安徽省-蚌埠市-蚌山区\": [117.379441, 32.923379],\n  \"安徽省-蚌埠市-禹会区\": [117.348452, 32.93531],\n  \"安徽省-蚌埠市-淮上区\": [117.366383, 32.970547],\n  \"安徽省-蚌埠市-怀远县\": [117.211506, 32.976004],\n  \"安徽省-蚌埠市-五河县\": [117.887561, 33.132709],\n  \"安徽省-蚌埠市-固镇县\": [117.323548, 33.323274],\n  \"安徽省-淮南市\": [117.006389, 32.631847],\n  \"安徽省-淮南市-大通区\": [117.059583, 32.63727],\n  \"安徽省-淮南市-田家庵区\": [117.023445, 32.653323],\n  \"安徽省-淮南市-谢家集区\": [116.865439, 32.606255],\n  \"安徽省-淮南市-八公山区\": [116.840564, 32.637137],\n  \"安徽省-淮南市-潘集区\": [116.841581, 32.777955],\n  \"安徽省-淮南市-凤台县\": [116.717573, 32.715104],\n  \"安徽省-淮南市-寿县\": [116.805563, 32.561546],\n  \"安徽省-马鞍山市\": [118.51358, 31.676266],\n  \"安徽省-马鞍山市-花山区\": [118.499606, 31.725473],\n  \"安徽省-马鞍山市-雨山区\": [118.505597, 31.687745],\n  \"安徽省-马鞍山市-博望区\": [118.504605, 31.576649],\n  \"安徽省-马鞍山市-当涂县\": [118.504605, 31.576649],\n  \"安徽省-马鞍山市-含山县\": [118.129204, 31.740485],\n  \"安徽省-马鞍山市-和县\": [118.359513, 31.748244],\n  \"安徽省-淮北市\": [116.804537, 33.961656],\n  \"安徽省-淮北市-杜集区\": [116.834612, 33.997285],\n  \"安徽省-淮北市-相山区\": [116.800521, 33.965827],\n  \"安徽省-淮北市-烈山区\": [116.819599, 33.901574],\n  \"安徽省-淮北市-濉溪县\": [116.772389, 33.921629],\n  \"安徽省-铜陵市\": [117.818477, 30.951233],\n  \"安徽省-铜陵市-铜官区\": [117.821457, 30.940386],\n  \"安徽省-铜陵市-义安区\": [117.798568, 30.958512],\n  \"安徽省-铜陵市-郊区\": [117.80755, 30.897741],\n  \"安徽省-铜陵市-枞阳县\": [117.226437, 30.705671],\n  \"安徽省-安庆市\": [117.063604, 30.530957],\n  \"安徽省-安庆市-迎江区\": [117.097514, 30.517523],\n  \"安徽省-安庆市-大观区\": [117.040538, 30.518232],\n  \"安徽省-安庆市-宜秀区\": [116.993441, 30.619676],\n  \"安徽省-安庆市-怀宁县\": [116.836593, 30.7394],\n  \"安徽省-安庆市-潜山县\": [116.587611, 30.636756],\n  \"安徽省-安庆市-太湖县\": [116.315476, 30.460113],\n  \"安徽省-安庆市-宿松县\": [116.135524, 30.159787],\n  \"安徽省-安庆市-望江县\": [116.70059, 30.129968],\n  \"安徽省-安庆市-岳西县\": [116.366555, 30.855228],\n  \"安徽省-安庆市-桐城市\": [116.980466, 31.041969],\n  \"安徽省-黄山市\": [118.345437, 29.72189],\n  \"安徽省-黄山市-屯溪区\": [118.321418, 29.702144],\n  \"安徽省-黄山市-黄山区\": [118.14761, 30.278651],\n  \"安徽省-黄山市-徽州区\": [118.343436, 29.834221],\n  \"安徽省-黄山市-歙县\": [118.42146, 29.866288],\n  \"安徽省-黄山市-休宁县\": [118.20543, 29.795459],\n  \"安徽省-黄山市-黟县\": [117.944477, 29.931047],\n  \"安徽省-黄山市-祁门县\": [117.723393, 29.860344],\n  \"安徽省-滁州市\": [118.339406, 32.261271],\n  \"安徽省-滁州市-琅琊区\": [118.312441, 32.300867],\n  \"安徽省-滁州市-南谯区\": [118.423482, 32.206132],\n  \"安徽省-滁州市-来安县\": [118.442412, 32.45845],\n  \"安徽省-滁州市-全椒县\": [118.280584, 32.09194],\n  \"安徽省-滁州市-定远县\": [117.704471, 32.537047],\n  \"安徽省-滁州市-凤阳县\": [117.538585, 32.880977],\n  \"安徽省-滁州市-天长市\": [118.950489, 32.794116],\n  \"安徽省-滁州市-明光市\": [117.99551, 32.783023],\n  \"安徽省-阜阳市\": [115.820436, 32.896061],\n  \"安徽省-阜阳市-颍州区\": [115.813411, 32.889625],\n  \"安徽省-阜阳市-颍东区\": [115.863617, 32.917362],\n  \"安徽省-阜阳市-颍泉区\": [115.815426, 32.931314],\n  \"安徽省-阜阳市-临泉县\": [115.267616, 33.04596],\n  \"安徽省-阜阳市-太和县\": [115.628615, 33.16596],\n  \"安徽省-阜阳市-阜南县\": [115.602546, 32.664097],\n  \"安徽省-阜阳市-颍上县\": [116.263477, 32.659028],\n  \"安徽省-阜阳市-界首市\": [115.38061, 33.262775],\n  \"安徽省-宿州市\": [116.970544, 33.652095],\n  \"安徽省-宿州市-埇桥区\": [116.98348, 33.646131],\n  \"安徽省-宿州市-砀山县\": [116.372524, 34.448428],\n  \"安徽省-宿州市-萧县\": [116.953585, 34.194269],\n  \"安徽省-宿州市-灵璧县\": [117.564557, 33.547892],\n  \"安徽省-宿州市-泗县\": [117.91659, 33.488695],\n  \"安徽省-六安市\": [116.52641, 31.741451],\n  \"安徽省-六安市-金安区\": [116.545438, 31.756288],\n  \"安徽省-六安市-裕安区\": [116.48655, 31.743626],\n  \"安徽省-六安市-叶集区\": [115.947476, 31.835263],\n  \"安徽省-六安市-霍邱县\": [115.947476, 31.835263],\n  \"安徽省-六安市-舒城县\": [116.955602, 31.467692],\n  \"安徽省-六安市-金寨县\": [115.940441, 31.733462],\n  \"安徽省-六安市-霍山县\": [116.339576, 31.398571],\n  \"安徽省-亳州市\": [115.784463, 33.850643],\n  \"安徽省-亳州市-谯城区\": [115.785472, 33.882663],\n  \"安徽省-亳州市-涡阳县\": [116.221609, 33.498567],\n  \"安徽省-亳州市-蒙城县\": [116.571589, 33.271658],\n  \"安徽省-亳州市-利辛县\": [116.191494, 33.155596],\n  \"安徽省-池州市\": [117.498421, 30.670884],\n  \"安徽省-池州市-贵池区\": [117.57449, 30.693858],\n  \"安徽省-池州市-东至县\": [117.034481, 30.116535],\n  \"安徽省-池州市-石台县\": [117.492394, 30.21653],\n  \"安徽省-池州市-青阳县\": [117.853431, 30.645634],\n  \"安徽省-宣城市\": [118.765534, 30.946602],\n  \"安徽省-宣城市-宣州区\": [118.762549, 30.952158],\n  \"安徽省-宣城市-郎溪县\": [119.186466, 31.132682],\n  \"安徽省-宣城市-广德县\": [119.427476, 30.883667],\n  \"安徽省-宣城市-泾县\": [118.426435, 30.694672],\n  \"安徽省-宣城市-绩溪县\": [118.585444, 30.073292],\n  \"安徽省-宣城市-旌德县\": [118.546467, 30.292481],\n  \"安徽省-宣城市-宁国市\": [118.98961, 30.639352],\n  \"福建省\": [119.302447, 26.106339],\n  \"福建省-福州市\": [119.30347, 26.080429],\n  \"福建省-福州市-鼓楼区\": [119.310492, 26.088114],\n  \"福建省-福州市-台江区\": [119.320528, 26.058528],\n  \"福建省-福州市-仓山区\": [119.280432, 26.052842],\n  \"福建省-福州市-马尾区\": [119.445519, 26.004534],\n  \"福建省-福州市-晋安区\": [119.334579, 26.087214],\n  \"福建省-福州市-闽侯县\": [119.138482, 26.156035],\n  \"福建省-福州市-连江县\": [119.546479, 26.203583],\n  \"福建省-福州市-罗源县\": [119.55648, 26.495496],\n  \"福建省-福州市-闽清县\": [118.869577, 26.226848],\n  \"福建省-福州市-永泰县\": [118.938431, 25.872787],\n  \"福建省-福州市-平潭县\": [119.796501, 25.5047],\n  \"福建省-福州市-福清市\": [119.390465, 25.726343],\n  \"福建省-福州市-长乐市\": [119.529438, 25.969257],\n  \"福建省-厦门市\": [118.096435, 24.485407],\n  \"福建省-厦门市-思明区\": [118.088408, 24.451948],\n  \"福建省-厦门市-海沧区\": [118.039562, 24.490326],\n  \"福建省-厦门市-湖里区\": [118.153588, 24.517573],\n  \"福建省-厦门市-集美区\": [118.103435, 24.582019],\n  \"福建省-厦门市-同安区\": [118.158563, 24.729114],\n  \"福建省-厦门市-翔安区\": [118.254576, 24.624216],\n  \"福建省-莆田市\": [119.014521, 25.459865],\n  \"福建省-莆田市-城厢区\": [119.001536, 25.424344],\n  \"福建省-莆田市-涵江区\": [119.122567, 25.464464],\n  \"福建省-莆田市-荔城区\": [119.019482, 25.439754],\n  \"福建省-莆田市-秀屿区\": [119.111571, 25.323654],\n  \"福建省-莆田市-仙游县\": [118.698454, 25.368291],\n  \"福建省-三明市\": [117.645521, 26.269737],\n  \"福建省-三明市-梅列区\": [117.65255, 26.277336],\n  \"福建省-三明市-三元区\": [117.614415, 26.240219],\n  \"福建省-三明市-明溪县\": [117.208518, 26.361854],\n  \"福建省-三明市-清流县\": [116.823593, 26.183357],\n  \"福建省-三明市-宁化县\": [116.660426, 26.267956],\n  \"福建省-三明市-大田县\": [117.85344, 25.698933],\n  \"福建省-三明市-尤溪县\": [118.19744, 26.176218],\n  \"福建省-三明市-沙县\": [117.798561, 26.402813],\n  \"福建省-三明市-将乐县\": [117.477409, 26.73521],\n  \"福建省-三明市-泰宁县\": [117.182596, 26.90566],\n  \"福建省-三明市-建宁县\": [116.852506, 26.836825],\n  \"福建省-三明市-永安市\": [117.371443, 25.948144],\n  \"福建省-泉州市\": [118.682446, 24.879952],\n  \"福建省-泉州市-鲤城区\": [118.593481, 24.913354],\n  \"福建省-泉州市-丰泽区\": [118.61958, 24.89497],\n  \"福建省-泉州市-洛江区\": [118.677416, 24.946214],\n  \"福建省-泉州市-泉港区\": [118.922433, 25.13965],\n  \"福建省-泉州市-惠安县\": [118.803416, 25.03695],\n  \"福建省-泉州市-安溪县\": [118.192425, 25.06176],\n  \"福建省-泉州市-永春县\": [118.300486, 25.327974],\n  \"福建省-泉州市-德化县\": [118.24755, 25.497309],\n  \"福建省-泉州市-金门县\": [118.330415, 24.440445],\n  \"福建省-泉州市-石狮市\": [118.654519, 24.737665],\n  \"福建省-泉州市-晋江市\": [118.558431, 24.787825],\n  \"福建省-泉州市-南安市\": [118.392572, 24.966362],\n  \"福建省-漳州市\": [117.653576, 24.51893],\n  \"福建省-漳州市-芗城区\": [117.66059, 24.516268],\n  \"福建省-漳州市-龙文区\": [117.716455, 24.50951],\n  \"福建省-漳州市-云霄县\": [117.346448, 23.964073],\n  \"福建省-漳州市-漳浦县\": [117.620443, 24.123462],\n  \"福建省-漳州市-诏安县\": [117.182559, 23.717054],\n  \"福建省-漳州市-长泰县\": [117.765553, 24.631244],\n  \"福建省-漳州市-东山县\": [117.43656, 23.706895],\n  \"福建省-漳州市-南靖县\": [117.363446, 24.520852],\n  \"福建省-漳州市-平和县\": [117.322552, 24.368365],\n  \"福建省-漳州市-华安县\": [117.540586, 25.010068],\n  \"福建省-漳州市-龙海市\": [117.824451, 24.45294],\n  \"福建省-南平市\": [118.0595, 27.292158],\n  \"福建省-南平市-延平区\": [118.188451, 26.643808],\n  \"福建省-南平市-建阳区\": [118.127525, 27.337502],\n  \"福建省-南平市-顺昌县\": [117.816519, 26.799104],\n  \"福建省-南平市-浦城县\": [118.547439, 27.92339],\n  \"福建省-南平市-光泽县\": [117.340482, 27.547273],\n  \"福建省-南平市-松溪县\": [118.791454, 27.532555],\n  \"福建省-南平市-政和县\": [118.863587, 27.371749],\n  \"福建省-南平市-邵武市\": [117.49942, 27.34647],\n  \"福建省-南平市-武夷山市\": [118.041577, 27.762554],\n  \"福建省-南平市-建瓯市\": [118.311461, 27.028955],\n  \"福建省-龙岩市\": [117.023448, 25.08122],\n  \"福建省-龙岩市-新罗区\": [117.043543, 25.104078],\n  \"福建省-龙岩市-永定区\": [116.892447, 24.869137],\n  \"福建省-龙岩市-长汀县\": [116.363568, 25.839185],\n  \"福建省-龙岩市-上杭县\": [116.426443, 25.05557],\n  \"福建省-龙岩市-武平县\": [116.107589, 25.100855],\n  \"福建省-龙岩市-连城县\": [116.760446, 25.716337],\n  \"福建省-龙岩市-漳平市\": [117.426556, 25.295743],\n  \"福建省-宁德市\": [119.554511, 26.672242],\n  \"福建省-宁德市-蕉城区\": [119.533442, 26.666739],\n  \"福建省-宁德市-霞浦县\": [120.011427, 26.891349],\n  \"福建省-宁德市-古田县\": [118.752578, 26.583262],\n  \"福建省-宁德市-屏南县\": [118.992596, 26.914265],\n  \"福建省-宁德市-寿宁县\": [119.511425, 27.46665],\n  \"福建省-宁德市-周宁县\": [119.345567, 27.110239],\n  \"福建省-宁德市-柘荣县\": [119.907457, 27.239962],\n  \"福建省-宁德市-福安市\": [119.654406, 27.094324],\n  \"福建省-宁德市-福鼎市\": [120.223452, 27.330525],\n  \"江西省\": [115.915423, 28.681691],\n  \"江西省-南昌市\": [115.864589, 28.689455],\n  \"江西省-南昌市-东湖区\": [115.905466, 28.691259],\n  \"江西省-南昌市-西湖区\": [115.883536, 28.661977],\n  \"江西省-南昌市-青云谱区\": [115.931416, 28.627236],\n  \"江西省-南昌市-湾里区\": [115.737596, 28.720195],\n  \"江西省-南昌市-青山湖区\": [115.968552, 28.687596],\n  \"江西省-南昌市-新建区\": [115.821451, 28.698749],\n  \"江西省-南昌市-南昌县\": [115.95046, 28.551604],\n  \"江西省-南昌市-安义县\": [115.555441, 28.850794],\n  \"江西省-南昌市-进贤县\": [116.248538, 28.382759],\n  \"江西省-景德镇市\": [117.184576, 29.274248],\n  \"江西省-景德镇市-昌江区\": [117.190579, 29.278854],\n  \"江西省-景德镇市-珠山区\": [117.209548, 29.305778],\n  \"江西省-景德镇市-浮梁县\": [117.221466, 29.357788],\n  \"江西省-景德镇市-乐平市\": [117.158511, 28.984364],\n  \"江西省-萍乡市\": [113.861496, 27.628393],\n  \"江西省-萍乡市-安源区\": [113.87744, 27.621308],\n  \"江西省-萍乡市-湘东区\": [113.7405, 27.645875],\n  \"江西省-萍乡市-莲花县\": [113.968541, 27.133463],\n  \"江西省-萍乡市-上栗县\": [113.801538, 27.886416],\n  \"江西省-萍乡市-芦溪县\": [114.036519, 27.636605],\n  \"江西省-九江市\": [116.007535, 29.711341],\n  \"江西省-九江市-濂溪区\": [115.995599, 29.677495],\n  \"江西省-九江市-浔阳区\": [115.996558, 29.733094],\n  \"江西省-九江市-九江县\": [115.917402, 29.614805],\n  \"江西省-九江市-武宁县\": [115.107442, 29.262352],\n  \"江西省-九江市-修水县\": [114.553568, 29.031176],\n  \"江西省-九江市-永修县\": [115.815407, 29.028006],\n  \"江西省-九江市-德安县\": [115.762578, 29.319172],\n  \"江西省-九江市-都昌县\": [116.210552, 29.278965],\n  \"江西省-九江市-湖口县\": [116.258471, 29.737132],\n  \"江西省-九江市-彭泽县\": [116.55551, 29.902122],\n  \"江西省-九江市-瑞昌市\": [115.68743, 29.681951],\n  \"江西省-九江市-共青城市\": [115.762578, 29.319172],\n  \"江西省-九江市-庐山市\": [116.051426, 29.454539],\n  \"江西省-新余市\": [114.923535, 27.823579],\n  \"江西省-新余市-渝水区\": [114.951424, 27.80684],\n  \"江西省-新余市-分宜县\": [114.698472, 27.820731],\n  \"江西省-鹰潭市\": [117.075575, 28.265787],\n  \"江西省-鹰潭市-月湖区\": [117.043548, 28.245078],\n  \"江西省-鹰潭市-余江县\": [116.824594, 28.215354],\n  \"江西省-鹰潭市-贵溪市\": [117.251399, 28.298735],\n  \"江西省-赣州市\": [114.940503, 25.835176],\n  \"江西省-赣州市-章贡区\": [114.927551, 25.823747],\n  \"江西省-赣州市-南康区\": [114.771538, 25.667053],\n  \"江西省-赣州市-赣县\": [115.01857, 25.866385],\n  \"江西省-赣州市-信丰县\": [114.929521, 25.391975],\n  \"江西省-赣州市-大余县\": [114.368407, 25.407637],\n  \"江西省-赣州市-上犹县\": [114.558549, 25.790519],\n  \"江西省-赣州市-崇义县\": [114.314572, 25.687687],\n  \"江西省-赣州市-安远县\": [115.400559, 25.142743],\n  \"江西省-赣州市-龙南县\": [114.796554, 24.916599],\n  \"江西省-赣州市-定南县\": [115.034564, 24.789784],\n  \"江西省-赣州市-全南县\": [114.536582, 24.748206],\n  \"江西省-赣州市-宁都县\": [116.015494, 26.47598],\n  \"江西省-赣州市-于都县\": [115.421499, 25.957894],\n  \"江西省-赣州市-兴国县\": [115.369552, 26.343883],\n  \"江西省-赣州市-会昌县\": [115.79246, 25.606662],\n  \"江西省-赣州市-寻乌县\": [115.653515, 24.969447],\n  \"江西省-赣州市-石城县\": [116.352594, 26.318972],\n  \"江西省-赣州市-瑞金市\": [116.033421, 25.891666],\n  \"江西省-吉安市\": [115.000511, 27.119727],\n  \"江西省-吉安市-吉州区\": [115.001539, 27.149315],\n  \"江西省-吉安市-青原区\": [115.021561, 27.087663],\n  \"江西省-吉安市-吉安县\": [114.914591, 27.044989],\n  \"江西省-吉安市-吉水县\": [115.14257, 27.23526],\n  \"江西省-吉安市-峡江县\": [115.322403, 27.588235],\n  \"江西省-吉安市-新干县\": [115.393595, 27.746081],\n  \"江西省-吉安市-永丰县\": [115.447402, 27.324342],\n  \"江西省-吉安市-泰和县\": [114.915591, 26.795697],\n  \"江西省-吉安市-遂川县\": [114.527562, 26.319517],\n  \"江西省-吉安市-万安县\": [114.792577, 26.464073],\n  \"江西省-吉安市-安福县\": [114.626478, 27.399076],\n  \"江西省-吉安市-永新县\": [114.249415, 26.951537],\n  \"江西省-吉安市-井冈山市\": [114.295556, 26.75371],\n  \"江西省-宜春市\": [114.423564, 27.820856],\n  \"江西省-宜春市-袁州区\": [114.434561, 27.802583],\n  \"江西省-宜春市-奉新县\": [115.406551, 28.694029],\n  \"江西省-宜春市-万载县\": [114.452537, 28.112133],\n  \"江西省-宜春市-上高县\": [114.931541, 28.238815],\n  \"江西省-宜春市-宜丰县\": [114.700858, 28.400373],\n  \"江西省-宜春市-靖安县\": [115.369553, 28.867082],\n  \"江西省-宜春市-铜鼓县\": [114.377411, 28.527083],\n  \"江西省-宜春市-丰城市\": [115.777478, 28.166614],\n  \"江西省-宜春市-樟树市\": [115.552419, 28.062153],\n  \"江西省-宜春市-高安市\": [115.382565, 28.422857],\n  \"江西省-抚州市\": [116.364539, 27.954892],\n  \"江西省-抚州市-临川区\": [116.31849, 27.940459],\n  \"江西省-抚州市-南城县\": [116.643399, 27.576241],\n  \"江西省-抚州市-黎川县\": [116.914507, 27.28834],\n  \"江西省-抚州市-南丰县\": [116.531404, 27.224734],\n  \"江西省-抚州市-崇仁县\": [116.083549, 27.75908],\n  \"江西省-抚州市-乐安县\": [115.837496, 27.43408],\n  \"江西省-抚州市-宜黄县\": [116.242542, 27.560563],\n  \"江西省-抚州市-金溪县\": [116.760404, 27.925329],\n  \"江西省-抚州市-资溪县\": [117.06657, 27.711846],\n  \"江西省-抚州市-东乡县\": [116.609542, 28.253977],\n  \"江西省-抚州市-广昌县\": [116.342561, 26.848454],\n  \"江西省-上饶市\": [117.94946, 28.460626],\n  \"江西省-上饶市-信州区\": [117.973412, 28.437628],\n  \"江西省-上饶市-广丰区\": [118.19742, 28.442615],\n  \"江西省-上饶市-上饶县\": [117.915584, 28.454187],\n  \"江西省-上饶市-玉山县\": [118.251563, 28.68775],\n  \"江西省-上饶市-铅山县\": [117.716422, 28.321505],\n  \"江西省-上饶市-横峰县\": [117.602397, 28.41344],\n  \"江西省-上饶市-弋阳县\": [117.455506, 28.384082],\n  \"江西省-上饶市-余干县\": [116.701601, 28.707866],\n  \"江西省-上饶市-鄱阳县\": [116.710566, 29.011453],\n  \"江西省-上饶市-万年县\": [117.064599, 28.700054],\n  \"江西省-上饶市-婺源县\": [117.868445, 29.254039],\n  \"江西省-上饶市-德兴市\": [117.58548, 28.952565],\n  \"山东省\": [117.027442, 36.674857],\n  \"山东省-济南市\": [117.126399, 36.656554],\n  \"山东省-济南市-历下区\": [117.082567, 36.672163],\n  \"山东省-济南市-市中区\": [117.004399, 36.657552],\n  \"山东省-济南市-槐荫区\": [116.907458, 36.657562],\n  \"山东省-济南市-天桥区\": [116.993399, 36.684068],\n  \"山东省-济南市-历城区\": [117.07159, 36.685656],\n  \"山东省-济南市-长清区\": [116.758387, 36.560216],\n  \"山东省-济南市-平阴县\": [116.462617, 36.294861],\n  \"山东省-济南市-济阳县\": [117.180621, 36.983971],\n  \"山东省-济南市-商河县\": [117.16353, 37.314971],\n  \"山东省-济南市-章丘市\": [117.532565, 36.685533],\n  \"山东省-青岛市\": [120.389455, 36.072227],\n  \"山东省-青岛市-市南区\": [120.418585, 36.081466],\n  \"山东省-青岛市-市北区\": [120.381404, 36.09345],\n  \"山东省-青岛市-黄岛区\": [120.204547, 35.966383],\n  \"山东省-青岛市-崂山区\": [120.475397, 36.113499],\n  \"山东省-青岛市-李沧区\": [120.439603, 36.151025],\n  \"山东省-青岛市-城阳区\": [120.402527, 36.312886],\n  \"山东省-青岛市-胶州市\": [120.039535, 36.270349],\n  \"山东省-青岛市-即墨市\": [120.453536, 36.394749],\n  \"山东省-青岛市-平度市\": [119.994414, 36.782692],\n  \"山东省-青岛市-莱西市\": [120.524556, 36.893956],\n  \"山东省-淄博市\": [118.061453, 36.819086],\n  \"山东省-淄博市-淄川区\": [117.973412, 36.649835],\n  \"山东省-淄博市-张店区\": [118.024591, 36.811942],\n  \"山东省-淄博市-博山区\": [117.868469, 36.500848],\n  \"山东省-淄博市-临淄区\": [118.315395, 36.832294],\n  \"山东省-淄博市-周村区\": [117.876482, 36.808994],\n  \"山东省-淄博市-桓台县\": [118.104434, 36.965608],\n  \"山东省-淄博市-高青县\": [117.833394, 37.177269],\n  \"山东省-淄博市-沂源县\": [118.177489, 36.190917],\n  \"山东省-枣庄市\": [117.330542, 34.815994],\n  \"山东省-枣庄市-市中区\": [117.562566, 34.869963],\n  \"山东省-枣庄市-薛城区\": [117.269458, 34.801125],\n  \"山东省-枣庄市-峄城区\": [117.596391, 34.7786],\n  \"山东省-枣庄市-台儿庄区\": [117.740425, 34.568763],\n  \"山东省-枣庄市-山亭区\": [117.467443, 35.105692],\n  \"山东省-枣庄市-滕州市\": [117.172565, 35.120035],\n  \"山东省-东营市\": [118.681385, 37.439642],\n  \"山东省-东营市-东营区\": [118.588463, 37.454847],\n  \"山东省-东营市-河口区\": [118.532505, 37.89112],\n  \"山东省-东营市-垦利区\": [118.581432, 37.578555],\n  \"山东省-东营市-利津县\": [118.261618, 37.49586],\n  \"山东省-东营市-广饶县\": [118.413499, 37.059638],\n  \"山东省-烟台市\": [121.454415, 37.470038],\n  \"山东省-烟台市-芝罘区\": [121.40654, 37.546313],\n  \"山东省-烟台市-福山区\": [121.274605, 37.503668],\n  \"山东省-烟台市-牟平区\": [121.606549, 37.392915],\n  \"山东省-烟台市-莱山区\": [121.451381, 37.517649],\n  \"山东省-烟台市-长岛县\": [120.74343, 37.927628],\n  \"山东省-烟台市-龙口市\": [120.485369, 37.652555],\n  \"山东省-烟台市-莱阳市\": [120.718414, 36.984636],\n  \"山东省-烟台市-莱州市\": [119.948593, 37.182637],\n  \"山东省-烟台市-蓬莱市\": [120.765562, 37.816439],\n  \"山东省-烟台市-招远市\": [120.440602, 37.361137],\n  \"山东省-烟台市-栖霞市\": [120.856417, 37.341418],\n  \"山东省-烟台市-海阳市\": [121.180458, 36.69327],\n  \"山东省-潍坊市\": [119.168378, 36.712652],\n  \"山东省-潍坊市-潍城区\": [119.031429, 36.732854],\n  \"山东省-潍坊市-寒亭区\": [119.226615, 36.780744],\n  \"山东省-潍坊市-坊子区\": [119.172401, 36.660742],\n  \"山东省-潍坊市-奎文区\": [119.139471, 36.712752],\n  \"山东省-潍坊市-临朐县\": [118.54945, 36.51913],\n  \"山东省-潍坊市-昌乐县\": [118.836488, 36.712996],\n  \"山东省-潍坊市-青州市\": [118.486537, 36.690417],\n  \"山东省-潍坊市-诸城市\": [119.416402, 36.002009],\n  \"山东省-潍坊市-寿光市\": [118.797415, 36.861922],\n  \"山东省-潍坊市-安丘市\": [119.225608, 36.483842],\n  \"山东省-潍坊市-高密市\": [119.762411, 36.388957],\n  \"山东省-潍坊市-昌邑市\": [119.404406, 36.865161],\n  \"山东省-济宁市\": [116.593612, 35.420177],\n  \"山东省-济宁市-任城区\": [116.55447, 35.493731],\n  \"山东省-济宁市-兖州区\": [116.805536, 35.599737],\n  \"山东省-济宁市-微山县\": [117.135414, 34.813315],\n  \"山东省-济宁市-鱼台县\": [116.657393, 35.017888],\n  \"山东省-济宁市-金乡县\": [116.31853, 35.072569],\n  \"山东省-济宁市-嘉祥县\": [116.348613, 35.413255],\n  \"山东省-济宁市-汶上县\": [116.505441, 35.717055],\n  \"山东省-济宁市-泗水县\": [117.257429, 35.6706],\n  \"山东省-济宁市-梁山县\": [116.10262, 35.808064],\n  \"山东省-济宁市-曲阜市\": [116.993416, 35.587372],\n  \"山东省-济宁市-邹城市\": [117.014404, 35.407521],\n  \"山东省-泰安市\": [117.094495, 36.205858],\n  \"山东省-泰安市-泰山区\": [117.141411, 36.199445],\n  \"山东省-泰安市-岱岳区\": [117.048556, 36.193291],\n  \"山东省-泰安市-宁阳县\": [116.812579, 35.764539],\n  \"山东省-泰安市-东平县\": [116.477594, 35.941908],\n  \"山东省-泰安市-新泰市\": [117.774606, 35.91462],\n  \"山东省-泰安市-肥城市\": [116.775401, 36.188811],\n  \"山东省-威海市\": [122.127541, 37.516431],\n  \"山东省-威海市-环翠区\": [122.129538, 37.507968],\n  \"山东省-威海市-文登区\": [122.064428, 37.200113],\n  \"山东省-威海市-荣成市\": [122.492505, 37.171318],\n  \"山东省-威海市-乳山市\": [121.546429, 36.925177],\n  \"山东省-日照市\": [119.533415, 35.422839],\n  \"山东省-日照市-东港区\": [119.468624, 35.431049],\n  \"山东省-日照市-岚山区\": [119.32553, 35.127432],\n  \"山东省-日照市-五莲县\": [119.21558, 35.755697],\n  \"山东省-日照市-莒县\": [118.843538, 35.585872],\n  \"山东省-莱芜市\": [117.68355, 36.219472],\n  \"山东省-莱芜市-莱城区\": [117.666591, 36.208841],\n  \"山东省-莱芜市-钢城区\": [117.817496, 36.064719],\n  \"山东省-临沂市\": [118.363533, 35.110671],\n  \"山东省-临沂市-兰山区\": [118.3545, 35.05734],\n  \"山东省-临沂市-罗庄区\": [118.291513, 35.002504],\n  \"山东省-临沂市-河东区\": [118.409547, 35.095676],\n  \"山东省-临沂市-沂南县\": [118.471492, 35.556098],\n  \"山东省-临沂市-郯城县\": [118.373587, 34.619226],\n  \"山东省-临沂市-沂水县\": [118.634617, 35.796181],\n  \"山东省-临沂市-兰陵县\": [118.077409, 34.863616],\n  \"山东省-临沂市-费县\": [117.984425, 35.272304],\n  \"山东省-临沂市-平邑县\": [117.646541, 35.51202],\n  \"山东省-临沂市-莒南县\": [118.841541, 35.180812],\n  \"山东省-临沂市-蒙阴县\": [117.951415, 35.716347],\n  \"山东省-临沂市-临沭县\": [118.657495, 34.926019],\n  \"山东省-德州市\": [116.365557, 37.441308],\n  \"山东省-德州市-德城区\": [116.305449, 37.456993],\n  \"山东省-德州市-陵城区\": [116.77141, 37.476844],\n  \"山东省-德州市-宁津县\": [116.806538, 37.658019],\n  \"山东省-德州市-庆云县\": [117.391452, 37.781585],\n  \"山东省-德州市-临邑县\": [116.873404, 37.196169],\n  \"山东省-德州市-齐河县\": [116.769387, 36.789945],\n  \"山东省-德州市-平原县\": [116.440505, 37.171221],\n  \"山东省-德州市-夏津县\": [116.008534, 36.954155],\n  \"山东省-德州市-武城县\": [116.075506, 37.219222],\n  \"山东省-德州市-乐陵市\": [117.238406, 37.735925],\n  \"山东省-德州市-禹城市\": [116.644371, 36.940242],\n  \"山东省-聊城市\": [115.991588, 36.462758],\n  \"山东省-聊城市-东昌府区\": [115.994587, 36.440378],\n  \"山东省-聊城市-阳谷县\": [115.798396, 36.120816],\n  \"山东省-聊城市-莘县\": [115.677397, 36.239907],\n  \"山东省-聊城市-茌平县\": [116.261455, 36.586785],\n  \"山东省-聊城市-东阿县\": [116.254493, 36.340958],\n  \"山东省-聊城市-冠县\": [115.449396, 36.490243],\n  \"山东省-聊城市-高唐县\": [116.235604, 36.851591],\n  \"山东省-聊城市-临清市\": [115.71147, 36.844289],\n  \"山东省-滨州市\": [117.977404, 37.388196],\n  \"山东省-滨州市-滨城区\": [118.026604, 37.436843],\n  \"山东省-滨州市-沾化区\": [118.105454, 37.705298],\n  \"山东省-滨州市-惠民县\": [117.51651, 37.495803],\n  \"山东省-滨州市-阳信县\": [117.584437, 37.647338],\n  \"山东省-滨州市-无棣县\": [117.632457, 37.777567],\n  \"山东省-滨州市-博兴县\": [118.117493, 37.160477],\n  \"山东省-滨州市-邹平县\": [117.749478, 36.870032],\n  \"山东省-菏泽市\": [115.487545, 35.239407],\n  \"山东省-菏泽市-牡丹区\": [115.423443, 35.257018],\n  \"山东省-菏泽市-定陶区\": [115.579437, 35.077275],\n  \"山东省-菏泽市-曹县\": [115.548457, 34.831809],\n  \"山东省-菏泽市-单县\": [116.111584, 34.784658],\n  \"山东省-菏泽市-成武县\": [115.896519, 34.958606],\n  \"山东省-菏泽市-巨野县\": [116.210258, 35.402062],\n  \"山东省-菏泽市-郓城县\": [115.950451, 35.605902],\n  \"山东省-菏泽市-鄄城县\": [115.516607, 35.569204],\n  \"山东省-菏泽市-东明县\": [115.096417, 35.295702],\n  \"河南省\": [113.759384, 34.771713],\n  \"河南省-郑州市\": [113.631419, 34.753439],\n  \"河南省-郑州市-中原区\": [113.619476, 34.754451],\n  \"河南省-郑州市-二七区\": [113.64641, 34.731045],\n  \"河南省-郑州市-管城回族区\": [113.683525, 34.759674],\n  \"河南省-郑州市-金水区\": [113.666448, 34.80607],\n  \"河南省-郑州市-上街区\": [113.315497, 34.808819],\n  \"河南省-郑州市-惠济区\": [113.623455, 34.87352],\n  \"河南省-郑州市-中牟县\": [113.982485, 34.725011],\n  \"河南省-郑州市-巩义市\": [113.028431, 34.754097],\n  \"河南省-郑州市-荥阳市\": [113.389423, 34.793811],\n  \"河南省-郑州市-新密市\": [113.397391, 34.545898],\n  \"河南省-郑州市-新郑市\": [113.746434, 34.401766],\n  \"河南省-郑州市-登封市\": [113.056423, 34.459697],\n  \"河南省-开封市\": [114.314593, 34.802886],\n  \"河南省-开封市-龙亭区\": [114.361413, 34.822036],\n  \"河南省-开封市-顺河回族区\": [114.361413, 34.822036],\n  \"河南省-开封市-鼓楼区\": [114.361413, 34.822036],\n  \"河南省-开封市-禹王台区\": [114.361413, 34.822036],\n  \"河南省-开封市-金明区\": [114.229635, 34.798756],\n  \"河南省-开封市-祥符区\": [114.452186, 34.726004],\n  \"河南省-开封市-杞县\": [114.789592, 34.554857],\n  \"河南省-开封市-通许县\": [114.473436, 34.486772],\n  \"河南省-开封市-尉氏县\": [114.199561, 34.417228],\n  \"河南省-开封市-兰考县\": [114.827461, 34.828493],\n  \"河南省-洛阳市\": [112.459421, 34.624263],\n  \"河南省-洛阳市-老城区\": [112.476504, 34.689601],\n  \"河南省-洛阳市-西工区\": [112.4344, 34.666768],\n  \"河南省-洛阳市-瀍河回族区\": [112.506604, 34.685462],\n  \"河南省-洛阳市-涧西区\": [112.402552, 34.663469],\n  \"河南省-洛阳市-吉利区\": [112.595478, 34.907013],\n  \"河南省-洛阳市-洛龙区\": [112.470469, 34.624705],\n  \"河南省-洛阳市-孟津县\": [112.451418, 34.831732],\n  \"河南省-洛阳市-新安县\": [112.14061, 34.734383],\n  \"河南省-洛阳市-栾川县\": [111.622427, 33.791822],\n  \"河南省-洛阳市-嵩县\": [112.092408, 34.140722],\n  \"河南省-洛阳市-汝阳县\": [112.479503, 34.159843],\n  \"河南省-洛阳市-宜阳县\": [112.179465, 34.541047],\n  \"河南省-洛阳市-洛宁县\": [111.659587, 34.394985],\n  \"河南省-洛阳市-伊川县\": [112.432407, 34.427646],\n  \"河南省-洛阳市-偃师市\": [112.796421, 34.733797],\n  \"河南省-平顶山市\": [113.199529, 33.772051],\n  \"河南省-平顶山市-新华区\": [113.30044, 33.743657],\n  \"河南省-平顶山市-卫东区\": [113.341611, 33.740376],\n  \"河南省-平顶山市-石龙区\": [112.905455, 33.904754],\n  \"河南省-平顶山市-湛河区\": [113.250515, 33.68579],\n  \"河南省-平顶山市-宝丰县\": [113.061447, 33.874746],\n  \"河南省-平顶山市-叶县\": [113.363582, 33.632492],\n  \"河南省-平顶山市-鲁山县\": [112.914434, 33.744879],\n  \"河南省-平顶山市-郏县\": [113.219606, 33.977486],\n  \"河南省-平顶山市-舞钢市\": [113.53141, 33.299431],\n  \"河南省-平顶山市-汝州市\": [112.85055, 34.172768],\n  \"河南省-安阳市\": [114.3995, 36.105941],\n  \"河南省-安阳市-文峰区\": [114.363374, 36.096833],\n  \"河南省-安阳市-北关区\": [114.362382, 36.113132],\n  \"河南省-安阳市-殷都区\": [114.309598, 36.115758],\n  \"河南省-安阳市-龙安区\": [114.307593, 36.082753],\n  \"河南省-安阳市-安阳县\": [114.238382, 36.218907],\n  \"河南省-安阳市-汤阴县\": [114.363409, 35.927644],\n  \"河南省-安阳市-滑县\": [114.525553, 35.581045],\n  \"河南省-安阳市-内黄县\": [114.907589, 35.97695],\n  \"河南省-安阳市-林州市\": [113.82559, 36.088853],\n  \"河南省-鹤壁市\": [114.303594, 35.752357],\n  \"河南省-鹤壁市-鹤山区\": [114.169555, 35.96028],\n  \"河南省-鹤壁市-山城区\": [114.190621, 35.90337],\n  \"河南省-鹤壁市-淇滨区\": [114.305591, 35.746953],\n  \"河南省-鹤壁市-浚县\": [114.557608, 35.681917],\n  \"河南省-鹤壁市-淇县\": [114.21549, 35.627277],\n  \"河南省-新乡市\": [113.9336, 35.30964],\n  \"河南省-新乡市-红旗区\": [113.881416, 35.310136],\n  \"河南省-新乡市-卫滨区\": [113.872439, 35.308459],\n  \"河南省-新乡市-凤泉区\": [113.912459, 35.375665],\n  \"河南省-新乡市-牧野区\": [113.915513, 35.321023],\n  \"河南省-新乡市-新乡县\": [113.811594, 35.196564],\n  \"河南省-新乡市-获嘉县\": [113.663417, 35.265809],\n  \"河南省-新乡市-原阳县\": [113.946624, 35.071164],\n  \"河南省-新乡市-延津县\": [114.211512, 35.147807],\n  \"河南省-新乡市-封丘县\": [114.425606, 35.046858],\n  \"河南省-新乡市-长垣县\": [114.67561, 35.207198],\n  \"河南省-新乡市-卫辉市\": [114.071601, 35.404069],\n  \"河南省-新乡市-辉县市\": [113.811573, 35.467958],\n  \"河南省-焦作市\": [113.248548, 35.220963],\n  \"河南省-焦作市-解放区\": [113.237572, 35.24631],\n  \"河南省-焦作市-中站区\": [113.189448, 35.242617],\n  \"河南省-焦作市-马村区\": [113.328544, 35.261894],\n  \"河南省-焦作市-山阳区\": [113.260484, 35.220272],\n  \"河南省-焦作市-修武县\": [113.454582, 35.229323],\n  \"河南省-焦作市-博爱县\": [113.070478, 35.177308],\n  \"河南省-焦作市-武陟县\": [113.408396, 35.105838],\n  \"河南省-焦作市-温县\": [113.086569, 34.946135],\n  \"河南省-焦作市-沁阳市\": [112.957517, 35.093786],\n  \"河南省-焦作市-孟州市\": [112.797395, 34.913598],\n  \"河南省-濮阳市\": [115.035597, 35.767593],\n  \"河南省-濮阳市-华龙区\": [115.080413, 35.783633],\n  \"河南省-濮阳市-清丰县\": [115.110472, 35.891308],\n  \"河南省-濮阳市-南乐县\": [115.211386, 36.076031],\n  \"河南省-濮阳市-范县\": [115.510586, 35.857655],\n  \"河南省-濮阳市-台前县\": [115.878568, 35.975013],\n  \"河南省-濮阳市-濮阳县\": [115.035584, 35.717889],\n  \"河南省-许昌市\": [113.858476, 34.041432],\n  \"河南省-许昌市-魏都区\": [113.829596, 34.030861],\n  \"河南省-许昌市-许昌县\": [113.829615, 34.129967],\n  \"河南省-许昌市-鄢陵县\": [114.18562, 34.107963],\n  \"河南省-许昌市-襄城县\": [113.513431, 33.856968],\n  \"河南省-许昌市-禹州市\": [113.495505, 34.146082],\n  \"河南省-许昌市-长葛市\": [113.774421, 34.223016],\n  \"河南省-漯河市\": [114.023421, 33.587711],\n  \"河南省-漯河市-源汇区\": [113.990414, 33.578423],\n  \"河南省-漯河市-郾城区\": [114.013394, 33.593416],\n  \"河南省-漯河市-召陵区\": [114.100467, 33.592468],\n  \"河南省-漯河市-舞阳县\": [113.61549, 33.443578],\n  \"河南省-漯河市-临颍县\": [113.937578, 33.832692],\n  \"河南省-三门峡市\": [111.206533, 34.778327],\n  \"河南省-三门峡市-湖滨区\": [111.195574, 34.775997],\n  \"河南省-三门峡市-陕州区\": [111.109451, 34.726915],\n  \"河南省-三门峡市-渑池县\": [111.768542, 34.773197],\n  \"河南省-三门峡市-卢氏县\": [111.054564, 34.059925],\n  \"河南省-三门峡市-义马市\": [111.880515, 34.753028],\n  \"河南省-三门峡市-灵宝市\": [110.900408, 34.523143],\n  \"河南省-南阳市\": [112.534501, 32.996562],\n  \"河南省-南阳市-宛城区\": [112.546454, 33.00987],\n  \"河南省-南阳市-卧龙区\": [112.541462, 32.992484],\n  \"河南省-南阳市-南召县\": [112.435425, 33.496186],\n  \"河南省-南阳市-方城县\": [113.018503, 33.260539],\n  \"河南省-南阳市-西峡县\": [111.480398, 33.313316],\n  \"河南省-南阳市-镇平县\": [112.241544, 33.039719],\n  \"河南省-南阳市-内乡县\": [111.855425, 33.051203],\n  \"河南省-南阳市-淅川县\": [111.497432, 33.144185],\n  \"河南省-南阳市-社旗县\": [112.954493, 33.062237],\n  \"河南省-南阳市-唐河县\": [112.813424, 32.687721],\n  \"河南省-南阳市-新野县\": [112.36655, 32.526632],\n  \"河南省-南阳市-桐柏县\": [113.434473, 32.385131],\n  \"河南省-南阳市-邓州市\": [112.09342, 32.693917],\n  \"河南省-商丘市\": [115.662449, 34.420202],\n  \"河南省-商丘市-梁园区\": [115.620602, 34.449471],\n  \"河南省-商丘市-睢阳区\": [115.659476, 34.394152],\n  \"河南省-商丘市-民权县\": [115.154576, 34.652479],\n  \"河南省-商丘市-睢县\": [115.078411, 34.451617],\n  \"河南省-商丘市-宁陵县\": [115.320418, 34.466634],\n  \"河南省-商丘市-柘城县\": [115.312435, 34.09736],\n  \"河南省-商丘市-虞城县\": [115.834473, 34.405332],\n  \"河南省-商丘市-夏邑县\": [116.137512, 34.243523],\n  \"河南省-商丘市-永城市\": [116.455566, 33.934801],\n  \"河南省-信阳市\": [114.097483, 32.153015],\n  \"河南省-信阳市-浉河区\": [114.065581, 32.122554],\n  \"河南省-信阳市-平桥区\": [114.132407, 32.107325],\n  \"河南省-信阳市-罗山县\": [114.51953, 32.20915],\n  \"河南省-信阳市-光山县\": [114.925533, 32.015907],\n  \"河南省-信阳市-新县\": [114.885525, 31.649738],\n  \"河南省-信阳市-商城县\": [115.413513, 31.804345],\n  \"河南省-信阳市-固始县\": [115.660488, 32.174174],\n  \"河南省-信阳市-潢川县\": [115.058471, 32.137531],\n  \"河南省-信阳市-淮滨县\": [115.426439, 32.47947],\n  \"河南省-信阳市-息县\": [114.747453, 32.348956],\n  \"河南省-周口市\": [114.703483, 33.631829],\n  \"河南省-周口市-川汇区\": [114.657602, 33.652997],\n  \"河南省-周口市-扶沟县\": [114.40151, 34.065906],\n  \"河南省-周口市-西华县\": [114.535597, 33.773215],\n  \"河南省-周口市-商水县\": [114.618416, 33.548877],\n  \"河南省-周口市-沈丘县\": [115.105455, 33.415691],\n  \"河南省-周口市-郸城县\": [115.183478, 33.650828],\n  \"河南省-周口市-淮阳县\": [114.892586, 33.737347],\n  \"河南省-周口市-太康县\": [114.844384, 34.070038],\n  \"河南省-周口市-鹿邑县\": [115.490585, 33.867173],\n  \"河南省-周口市-项城市\": [114.881514, 33.473007],\n  \"河南省-驻马店市\": [114.028471, 33.017842],\n  \"河南省-驻马店市-驿城区\": [114.000387, 32.97952],\n  \"河南省-驻马店市-西平县\": [114.027474, 33.393861],\n  \"河南省-驻马店市-上蔡县\": [114.270487, 33.268511],\n  \"河南省-驻马店市-平舆县\": [114.625429, 32.967982],\n  \"河南省-驻马店市-正阳县\": [114.399497, 32.611641],\n  \"河南省-驻马店市-确山县\": [114.032495, 32.808176],\n  \"河南省-驻马店市-泌阳县\": [113.333558, 32.729731],\n  \"河南省-驻马店市-汝南县\": [114.369409, 33.013141],\n  \"河南省-驻马店市-遂平县\": [114.019441, 33.151971],\n  \"河南省-驻马店市-新蔡县\": [114.992469, 32.755269],\n  \"河南省-济源市\": [112.608581, 35.072907],\n  \"湖北省\": [114.348441, 30.5516],\n  \"湖北省-武汉市\": [114.311582, 30.598467],\n  \"湖北省-武汉市-江岸区\": [114.316579, 30.605403],\n  \"湖北省-武汉市-江汉区\": [114.277506, 30.607282],\n  \"湖北省-武汉市-硚口区\": [114.22146, 30.587584],\n  \"湖北省-武汉市-汉阳区\": [114.225446, 30.560052],\n  \"湖北省-武汉市-武昌区\": [114.322549, 30.559567],\n  \"湖北省-武汉市-青山区\": [114.391493, 30.646593],\n  \"湖北省-武汉市-洪山区\": [114.350456, 30.506334],\n  \"湖北省-武汉市-东西湖区\": [114.143459, 30.62592],\n  \"湖北省-武汉市-汉南区\": [114.091515, 30.314809],\n  \"湖北省-武汉市-蔡甸区\": [114.03548, 30.588114],\n  \"湖北省-武汉市-江夏区\": [114.328551, 30.381564],\n  \"湖北省-武汉市-黄陂区\": [114.382454, 30.887534],\n  \"湖北省-武汉市-新洲区\": [114.807543, 30.847244],\n  \"湖北省-黄石市\": [115.045533, 30.205208],\n  \"湖北省-黄石市-黄石港区\": [115.072417, 30.229053],\n  \"湖北省-黄石市-西塞山区\": [115.116481, 30.210695],\n  \"湖北省-黄石市-下陆区\": [114.967416, 30.180046],\n  \"湖北省-黄石市-铁山区\": [114.907571, 30.212251],\n  \"湖北省-黄石市-阳新县\": [115.221427, 29.836542],\n  \"湖北省-黄石市-大冶市\": [114.986436, 30.101668],\n  \"湖北省-十堰市\": [110.80453, 32.635062],\n  \"湖北省-十堰市-茅箭区\": [110.81958, 32.597287],\n  \"湖北省-十堰市-张湾区\": [110.775424, 32.6584],\n  \"湖北省-十堰市-郧阳区\": [110.818577, 32.840592],\n  \"湖北省-十堰市-郧西县\": [110.432473, 32.999167],\n  \"湖北省-十堰市-竹山县\": [110.235582, 32.230304],\n  \"湖北省-十堰市-竹溪县\": [109.721542, 32.32412],\n  \"湖北省-十堰市-房县\": [110.747462, 32.061685],\n  \"湖北省-十堰市-丹江口市\": [111.519532, 32.546253],\n  \"湖北省-宜昌市\": [111.292549, 30.697446],\n  \"湖北省-宜昌市-西陵区\": [111.29256, 30.716749],\n  \"湖北省-宜昌市-伍家岗区\": [111.367422, 30.650737],\n  \"湖北省-宜昌市-点军区\": [111.274471, 30.69933],\n  \"湖北省-宜昌市-猇亭区\": [111.441574, 30.536466],\n  \"湖北省-宜昌市-夷陵区\": [111.33253, 30.774833],\n  \"湖北省-宜昌市-远安县\": [111.64653, 31.066628],\n  \"湖北省-宜昌市-兴山县\": [110.753446, 31.354464],\n  \"湖北省-宜昌市-秭归县\": [110.984449, 30.831932],\n  \"湖北省-宜昌市-长阳土家族自治县\": [111.213507, 30.478646],\n  \"湖北省-宜昌市-五峰土家族自治县\": [111.052581, 30.171156],\n  \"湖北省-宜昌市-宜都市\": [111.456516, 30.384404],\n  \"湖北省-宜昌市-当阳市\": [111.794569, 30.826989],\n  \"湖北省-宜昌市-枝江市\": [111.76654, 30.431731],\n  \"湖北省-襄阳市\": [112.128537, 32.014797],\n  \"湖北省-襄阳市-襄城区\": [112.140572, 32.016175],\n  \"湖北省-襄阳市-樊城区\": [112.142599, 32.050572],\n  \"湖北省-襄阳市-襄州区\": [112.218434, 32.093376],\n  \"湖北省-襄阳市-南漳县\": [111.845386, 31.78113],\n  \"湖北省-襄阳市-谷城县\": [111.659576, 32.268983],\n  \"湖北省-襄阳市-保康县\": [111.267441, 31.883847],\n  \"湖北省-襄阳市-老河口市\": [111.681556, 32.39246],\n  \"湖北省-襄阳市-枣阳市\": [112.778471, 32.13473],\n  \"湖北省-襄阳市-宜城市\": [112.264611, 31.72547],\n  \"湖北省-鄂州市\": [114.901607, 30.396572],\n  \"湖北省-鄂州市-梁子湖区\": [114.691507, 30.105907],\n  \"湖北省-鄂州市-华容区\": [114.736426, 30.5406],\n  \"湖北省-鄂州市-鄂城区\": [114.8986, 30.406389],\n  \"湖北省-荆门市\": [112.206393, 31.041733],\n  \"湖北省-荆门市-东宝区\": [112.208388, 31.058429],\n  \"湖北省-荆门市-掇刀区\": [112.214428, 30.979911],\n  \"湖北省-荆门市-京山县\": [113.126548, 31.024331],\n  \"湖北省-荆门市-沙洋县\": [112.595485, 30.715315],\n  \"湖北省-荆门市-钟祥市\": [112.594471, 31.17403],\n  \"湖北省-孝感市\": [113.92251, 30.930689],\n  \"湖北省-孝感市-孝南区\": [113.91749, 30.922978],\n  \"湖北省-孝感市-孝昌县\": [114.004409, 31.26454],\n  \"湖北省-孝感市-大悟县\": [114.133413, 31.56722],\n  \"湖北省-孝感市-云梦县\": [113.759412, 31.027218],\n  \"湖北省-孝感市-应城市\": [113.579567, 30.933977],\n  \"湖北省-孝感市-安陆市\": [113.695583, 31.261415],\n  \"湖北省-孝感市-汉川市\": [113.845549, 30.666914],\n  \"湖北省-荆州市\": [112.245523, 30.340842],\n  \"湖北省-荆州市-沙市区\": [112.261577, 30.316572],\n  \"湖北省-荆州市-荆州区\": [112.196414, 30.358989],\n  \"湖北省-荆州市-公安县\": [112.236502, 30.064401],\n  \"湖北省-荆州市-监利县\": [112.91142, 29.845735],\n  \"湖北省-荆州市-江陵县\": [112.431452, 30.048043],\n  \"湖北省-荆州市-石首市\": [112.43142, 29.727034],\n  \"湖北省-荆州市-洪湖市\": [113.482553, 29.83277],\n  \"湖北省-荆州市-松滋市\": [111.77358, 30.175342],\n  \"湖北省-黄冈市\": [114.87849, 30.459359],\n  \"湖北省-黄冈市-黄州区\": [114.886532, 30.440224],\n  \"湖北省-黄冈市-团风县\": [114.878524, 30.649368],\n  \"湖北省-黄冈市-红安县\": [114.624426, 31.294297],\n  \"湖北省-黄冈市-罗田县\": [115.405547, 30.78891],\n  \"湖北省-黄冈市-英山县\": [115.687422, 30.74135],\n  \"湖北省-黄冈市-浠水县\": [115.271569, 30.457461],\n  \"湖北省-黄冈市-蕲春县\": [115.442399, 30.232535],\n  \"湖北省-黄冈市-黄梅县\": [115.950462, 30.076605],\n  \"湖北省-黄冈市-麻城市\": [115.016562, 31.176996],\n  \"湖北省-黄冈市-武穴市\": [115.567392, 29.850441],\n  \"湖北省-咸宁市\": [114.328519, 29.847056],\n  \"湖北省-咸宁市-咸安区\": [114.30457, 29.858154],\n  \"湖北省-咸宁市-嘉鱼县\": [113.94557, 29.976354],\n  \"湖北省-咸宁市-通城县\": [113.823568, 29.250858],\n  \"湖北省-咸宁市-崇阳县\": [114.046563, 29.561334],\n  \"湖北省-咸宁市-通山县\": [114.489393, 29.612634],\n  \"湖北省-咸宁市-赤壁市\": [113.906437, 29.730666],\n  \"湖北省-随州市\": [113.38945, 31.696517],\n  \"湖北省-随州市-曾都区\": [113.377513, 31.722123],\n  \"湖北省-随州市-随县\": [113.377513, 31.722123],\n  \"湖北省-随州市-广水市\": [113.832593, 31.622476],\n  \"湖北省-恩施土家族苗族自治州\": [109.494593, 30.27794],\n  \"湖北省-恩施土家族苗族自治州-恩施市\": [109.48655, 30.301037],\n  \"湖北省-恩施土家族苗族自治州-利川市\": [108.942481, 30.297203],\n  \"湖北省-恩施土家族苗族自治州-建始县\": [109.728556, 30.607907],\n  \"湖北省-恩施土家族苗族自治州-巴东县\": [110.347575, 31.048064],\n  \"湖北省-恩施土家族苗族自治州-宣恩县\": [109.497568, 29.992604],\n  \"湖北省-恩施土家族苗族自治州-咸丰县\": [109.146608, 29.671078],\n  \"湖北省-恩施土家族苗族自治州-来凤县\": [109.413495, 29.499444],\n  \"湖北省-恩施土家族苗族自治州-鹤峰县\": [110.040424, 29.896116],\n  \"湖北省-仙桃市\": [113.461591, 30.368272],\n  \"湖北省-潜江市\": [112.905474, 30.408358],\n  \"湖北省-天门市\": [113.172409, 30.669622],\n  \"湖北省-神农架林区\": [110.682525, 31.750496],\n  \"湖南省\": [112.989603, 28.11827],\n  \"湖南省-长沙市\": [112.945473, 28.234889],\n  \"湖南省-长沙市-芙蓉区\": [113.039408, 28.191913],\n  \"湖南省-长沙市-天心区\": [112.996592, 28.118211],\n  \"湖南省-长沙市-岳麓区\": [112.937448, 28.241489],\n  \"湖南省-长沙市-开福区\": [112.992585, 28.261379],\n  \"湖南省-长沙市-雨花区\": [113.042422, 28.142233],\n  \"湖南省-长沙市-望城区\": [112.824466, 28.367403],\n  \"湖南省-长沙市-长沙县\": [113.087559, 28.251818],\n  \"湖南省-长沙市-宁乡县\": [112.558407, 28.284105],\n  \"湖南省-长沙市-浏阳市\": [113.649398, 28.169832],\n  \"湖南省-株洲市\": [113.140471, 27.833568],\n  \"湖南省-株洲市-荷塘区\": [113.180452, 27.862156],\n  \"湖南省-株洲市-芦淞区\": [113.158419, 27.791509],\n  \"湖南省-株洲市-石峰区\": [113.124568, 27.880705],\n  \"湖南省-株洲市-天元区\": [113.089541, 27.833084],\n  \"湖南省-株洲市-株洲县\": [113.150427, 27.704323],\n  \"湖南省-株洲市-攸县\": [113.351578, 27.005772],\n  \"湖南省-株洲市-茶陵县\": [113.545472, 26.783589],\n  \"湖南省-株洲市-炎陵县\": [113.779419, 26.496061],\n  \"湖南省-株洲市-醴陵市\": [113.503483, 27.652325],\n  \"湖南省-湘潭市\": [112.950464, 27.835702],\n  \"湖南省-湘潭市-雨湖区\": [112.91345, 27.862467],\n  \"湖南省-湘潭市-岳塘区\": [112.975589, 27.877721],\n  \"湖南省-湘潭市-湘潭县\": [112.957505, 27.784983],\n  \"湖南省-湘潭市-湘乡市\": [112.541492, 27.740191],\n  \"湖南省-湘潭市-韶山市\": [112.533499, 27.921044],\n  \"湖南省-衡阳市\": [112.578447, 26.899576],\n  \"湖南省-衡阳市-珠晖区\": [112.626594, 26.900265],\n  \"湖南省-衡阳市-雁峰区\": [112.623588, 26.894368],\n  \"湖南省-衡阳市-石鼓区\": [112.60453, 26.948962],\n  \"湖南省-衡阳市-蒸湘区\": [112.573444, 26.91772],\n  \"湖南省-衡阳市-南岳区\": [112.745574, 27.23836],\n  \"湖南省-衡阳市-衡阳县\": [112.377553, 26.975295],\n  \"湖南省-衡阳市-衡南县\": [112.684403, 26.744532],\n  \"湖南省-衡阳市-衡山县\": [112.875563, 27.235996],\n  \"湖南省-衡阳市-衡东县\": [112.959495, 27.087043],\n  \"湖南省-衡阳市-祁东县\": [112.096447, 26.805995],\n  \"湖南省-衡阳市-耒阳市\": [112.866597, 26.428066],\n  \"湖南省-衡阳市-常宁市\": [112.405561, 26.42672],\n  \"湖南省-邵阳市\": [111.474433, 27.24527],\n  \"湖南省-邵阳市-双清区\": [111.503442, 27.239109],\n  \"湖南省-邵阳市-大祥区\": [111.445528, 27.227014],\n  \"湖南省-邵阳市-北塔区\": [111.458497, 27.251536],\n  \"湖南省-邵阳市-邵东县\": [111.750491, 27.264507],\n  \"湖南省-邵阳市-新邵县\": [111.464449, 27.327132],\n  \"湖南省-邵阳市-邵阳县\": [111.280508, 26.996528],\n  \"湖南省-邵阳市-隆回县\": [111.039507, 27.119946],\n  \"湖南省-邵阳市-洞口县\": [110.582579, 27.065975],\n  \"湖南省-邵阳市-绥宁县\": [110.16242, 26.588423],\n  \"湖南省-邵阳市-新宁县\": [110.863491, 26.439724],\n  \"湖南省-邵阳市-城步苗族自治县\": [110.328537, 26.396203],\n  \"湖南省-邵阳市-武冈市\": [110.638408, 26.732899],\n  \"湖南省-岳阳市\": [113.135489, 29.363178],\n  \"湖南省-岳阳市-岳阳楼区\": [113.136481, 29.377995],\n  \"湖南省-岳阳市-云溪区\": [113.278407, 29.479907],\n  \"湖南省-岳阳市-君山区\": [113.012517, 29.467129],\n  \"湖南省-岳阳市-岳阳县\": [113.122544, 29.150269],\n  \"湖南省-岳阳市-华容县\": [112.547462, 29.536286],\n  \"湖南省-岳阳市-湘阴县\": [112.889522, 28.676676],\n  \"湖南省-岳阳市-平江县\": [113.587604, 28.707564],\n  \"湖南省-岳阳市-汨罗市\": [113.073493, 28.812455],\n  \"湖南省-岳阳市-临湘市\": [113.456562, 29.482801],\n  \"湖南省-常德市\": [111.705452, 29.03775],\n  \"湖南省-常德市-武陵区\": [111.689545, 29.060783],\n  \"湖南省-常德市-鼎城区\": [111.687522, 29.024443],\n  \"湖南省-常德市-安乡县\": [112.177506, 29.41732],\n  \"湖南省-常德市-汉寿县\": [111.976412, 28.912288],\n  \"湖南省-常德市-澧县\": [111.765534, 29.638946],\n  \"湖南省-常德市-临澧县\": [111.653585, 29.446544],\n  \"湖南省-常德市-桃源县\": [111.495407, 28.908694],\n  \"湖南省-常德市-石门县\": [111.386451, 29.590366],\n  \"湖南省-常德市-津市市\": [111.884517, 29.611259],\n  \"湖南省-张家界市\": [110.485533, 29.122816],\n  \"湖南省-张家界市-永定区\": [110.544432, 29.126191],\n  \"湖南省-张家界市-武陵源区\": [110.557499, 29.351681],\n  \"湖南省-张家界市-慈利县\": [111.145471, 29.435987],\n  \"湖南省-张家界市-桑植县\": [110.170413, 29.405923],\n  \"湖南省-益阳市\": [112.361516, 28.559711],\n  \"湖南省-益阳市-资阳区\": [112.330435, 28.597235],\n  \"湖南省-益阳市-赫山区\": [112.380598, 28.584984],\n  \"湖南省-益阳市-南县\": [112.402542, 29.36707],\n  \"湖南省-益阳市-桃江县\": [112.162541, 28.523871],\n  \"湖南省-益阳市-安化县\": [111.219493, 28.380054],\n  \"湖南省-益阳市-沅江市\": [112.360532, 28.850234],\n  \"湖南省-郴州市\": [113.02146, 25.776683],\n  \"湖南省-郴州市-北湖区\": [113.017482, 25.790815],\n  \"湖南省-郴州市-苏仙区\": [113.048423, 25.806737],\n  \"湖南省-郴州市-桂阳县\": [112.74056, 25.759775],\n  \"湖南省-郴州市-宜章县\": [112.955479, 25.405714],\n  \"湖南省-郴州市-永兴县\": [113.122533, 26.132968],\n  \"湖南省-郴州市-嘉禾县\": [112.375584, 25.593422],\n  \"湖南省-郴州市-临武县\": [112.570411, 25.282527],\n  \"湖南省-郴州市-汝城县\": [113.691545, 25.556057],\n  \"湖南省-郴州市-桂东县\": [113.951594, 26.083174],\n  \"湖南省-郴州市-安仁县\": [113.275424, 26.715683],\n  \"湖南省-郴州市-资兴市\": [113.242556, 25.981874],\n  \"湖南省-永州市\": [111.619455, 26.425864],\n  \"湖南省-永州市-零陵区\": [111.637502, 26.227682],\n  \"湖南省-永州市-冷水滩区\": [111.598426, 26.467706],\n  \"湖南省-永州市-祁阳县\": [111.84742, 26.586435],\n  \"湖南省-永州市-东安县\": [111.323542, 26.398288],\n  \"湖南省-永州市-双牌县\": [111.667594, 25.967169],\n  \"湖南省-永州市-道县\": [111.607404, 25.53253],\n  \"湖南省-永州市-江永县\": [111.350437, 25.279721],\n  \"湖南省-永州市-宁远县\": [111.952453, 25.577052],\n  \"湖南省-永州市-蓝山县\": [112.203435, 25.375935],\n  \"湖南省-永州市-新田县\": [112.210409, 25.909826],\n  \"湖南省-永州市-江华瑶族自治县\": [111.585452, 25.191349],\n  \"湖南省-怀化市\": [110.008514, 27.575161],\n  \"湖南省-怀化市-鹤城区\": [110.0464, 27.585226],\n  \"湖南省-怀化市-中方县\": [109.951462, 27.446081],\n  \"湖南省-怀化市-沅陵县\": [110.400431, 28.459018],\n  \"湖南省-怀化市-辰溪县\": [110.190487, 28.012605],\n  \"湖南省-怀化市-溆浦县\": [110.601551, 27.913963],\n  \"湖南省-怀化市-会同县\": [109.741586, 26.893384],\n  \"湖南省-怀化市-麻阳苗族自治县\": [109.809436, 27.87193],\n  \"湖南省-怀化市-新晃侗族自治县\": [109.181472, 27.358783],\n  \"湖南省-怀化市-芷江侗族自治县\": [109.691402, 27.449513],\n  \"湖南省-怀化市-靖州苗族侗族自治县\": [109.702452, 26.581321],\n  \"湖南省-怀化市-通道侗族自治县\": [109.790445, 26.16422],\n  \"湖南省-怀化市-洪江市\": [109.84351, 27.215077],\n  \"湖南省-娄底市\": [112.001503, 27.703209],\n  \"湖南省-娄底市-娄星区\": [112.008558, 27.735605],\n  \"湖南省-娄底市-双峰县\": [112.18146, 27.462983],\n  \"湖南省-娄底市-新化县\": [111.334515, 27.732667],\n  \"湖南省-娄底市-冷水江市\": [111.44154, 27.692059],\n  \"湖南省-娄底市-涟源市\": [111.670562, 27.698168],\n  \"湖南省-湘西土家族苗族自治州\": [109.745577, 28.317369],\n  \"湖南省-湘西土家族苗族自治州-吉首市\": [109.704449, 28.267493],\n  \"湖南省-湘西土家族苗族自治州-泸溪县\": [110.226599, 28.221873],\n  \"湖南省-湘西土家族苗族自治州-凤凰县\": [109.605527, 27.953848],\n  \"湖南省-湘西土家族苗族自治州-花垣县\": [109.488562, 28.57791],\n  \"湖南省-湘西土家族苗族自治州-保靖县\": [109.666474, 28.705969],\n  \"湖南省-湘西土家族苗族自治州-古丈县\": [109.957507, 28.623084],\n  \"湖南省-湘西土家族苗族自治州-永顺县\": [109.863586, 28.985774],\n  \"湖南省-湘西土家族苗族自治州-龙山县\": [109.450416, 29.464122],\n  \"广东省\": [113.272429, 23.137949],\n  \"广东省-广州市\": [113.271431, 23.135336],\n  \"广东省-广州市-荔湾区\": [113.250502, 23.131791],\n  \"广东省-广州市-越秀区\": [113.273426, 23.13526],\n  \"广东省-广州市-海珠区\": [113.32354, 23.088981],\n  \"广东省-广州市-天河区\": [113.368509, 23.130358],\n  \"广东省-广州市-白云区\": [113.279433, 23.164317],\n  \"广东省-广州市-黄埔区\": [113.466563, 23.112058],\n  \"广东省-广州市-番禺区\": [113.39047, 22.943831],\n  \"广东省-广州市-花都区\": [113.226576, 23.411162],\n  \"广东省-广州市-南沙区\": [113.531436, 22.807929],\n  \"广东省-广州市-从化区\": [113.593585, 23.553986],\n  \"广东省-广州市-增城区\": [113.817546, 23.266592],\n  \"广东省-韶关市\": [113.603527, 24.815881],\n  \"广东省-韶关市-武江区\": [113.594556, 24.798486],\n  \"广东省-韶关市-浈江区\": [113.617477, 24.810414],\n  \"广东省-韶关市-曲江区\": [113.611501, 24.688408],\n  \"广东省-韶关市-始兴县\": [114.068567, 24.958558],\n  \"广东省-韶关市-仁化县\": [113.755443, 25.092288],\n  \"广东省-韶关市-翁源县\": [114.136427, 24.356594],\n  \"广东省-韶关市-乳源瑶族自治县\": [113.282431, 24.782333],\n  \"广东省-韶关市-新丰县\": [114.213512, 24.065547],\n  \"广东省-韶关市-乐昌市\": [113.354579, 25.135592],\n  \"广东省-韶关市-南雄市\": [114.318579, 25.123527],\n  \"广东省-深圳市\": [114.064552, 22.548457],\n  \"广东省-深圳市-罗湖区\": [114.137432, 22.554485],\n  \"广东省-深圳市-福田区\": [114.061547, 22.528466],\n  \"广东省-深圳市-南山区\": [113.936539, 22.5385],\n  \"广东省-深圳市-宝安区\": [113.890427, 22.560033],\n  \"广东省-深圳市-龙岗区\": [114.254455, 22.726017],\n  \"广东省-深圳市-盐田区\": [114.24343, 22.563438],\n  \"广东省-珠海市\": [113.582555, 22.276565],\n  \"广东省-珠海市-香洲区\": [113.550472, 22.273004],\n  \"广东省-珠海市-斗门区\": [113.303467, 22.215516],\n  \"广东省-珠海市-金湾区\": [113.369517, 22.152577],\n  \"广东省-汕头市\": [116.688529, 23.359092],\n  \"广东省-汕头市-龙湖区\": [116.723525, 23.377776],\n  \"广东省-汕头市-金平区\": [116.70955, 23.37175],\n  \"广东省-汕头市-濠江区\": [116.733517, 23.291546],\n  \"广东省-汕头市-潮阳区\": [116.608515, 23.270855],\n  \"广东省-汕头市-潮南区\": [116.439491, 23.256341],\n  \"广东省-汕头市-澄海区\": [116.762425, 23.472341],\n  \"广东省-汕头市-南澳县\": [117.030496, 23.427812],\n  \"广东省-佛山市\": [113.128512, 23.027759],\n  \"广东省-佛山市-禅城区\": [113.129505, 23.015374],\n  \"广东省-佛山市-南海区\": [113.149446, 23.035011],\n  \"广东省-佛山市-顺德区\": [113.300453, 22.810453],\n  \"广东省-佛山市-三水区\": [112.903471, 23.16192],\n  \"广东省-佛山市-高明区\": [112.899472, 22.90635],\n  \"广东省-江门市\": [113.088556, 22.584604],\n  \"广东省-江门市-蓬江区\": [113.084546, 22.601066],\n  \"广东省-江门市-江海区\": [113.117557, 22.566115],\n  \"广东省-江门市-新会区\": [113.038455, 22.465113],\n  \"广东省-江门市-台山市\": [112.800445, 22.257923],\n  \"广东省-江门市-开平市\": [112.704464, 22.382499],\n  \"广东省-江门市-鹤山市\": [112.970527, 22.771169],\n  \"广东省-江门市-恩平市\": [112.311438, 22.189035],\n  \"广东省-湛江市\": [110.365554, 21.276723],\n  \"广东省-湛江市-赤坎区\": [110.372533, 21.272135],\n  \"广东省-湛江市-霞山区\": [110.404425, 21.198227],\n  \"广东省-湛江市-坡头区\": [110.462567, 21.250377],\n  \"广东省-湛江市-麻章区\": [110.340579, 21.269189],\n  \"广东省-湛江市-遂溪县\": [110.256515, 21.383103],\n  \"广东省-湛江市-徐闻县\": [110.182473, 20.331724],\n  \"广东省-湛江市-廉江市\": [110.292448, 21.615816],\n  \"广东省-湛江市-雷州市\": [110.102581, 20.919881],\n  \"广东省-湛江市-吴川市\": [110.78645, 21.447263],\n  \"广东省-茂名市\": [110.931543, 21.669064],\n  \"广东省-茂名市-茂南区\": [110.925546, 21.647152],\n  \"广东省-茂名市-电白区\": [111.020471, 21.520351],\n  \"广东省-茂名市-高州市\": [110.859474, 21.924049],\n  \"广东省-茂名市-化州市\": [110.646431, 21.670231],\n  \"广东省-茂名市-信宜市\": [110.953582, 22.360093],\n  \"广东省-肇庆市\": [112.471489, 23.052889],\n  \"广东省-肇庆市-端州区\": [112.49156, 23.057564],\n  \"广东省-肇庆市-鼎湖区\": [112.574434, 23.164308],\n  \"广东省-肇庆市-高要区\": [112.464446, 23.031896],\n  \"广东省-肇庆市-广宁县\": [112.447424, 23.641036],\n  \"广东省-肇庆市-怀集县\": [112.191469, 23.917842],\n  \"广东省-肇庆市-封开县\": [111.518526, 23.429769],\n  \"广东省-肇庆市-德庆县\": [111.791554, 23.151373],\n  \"广东省-肇庆市-四会市\": [112.740579, 23.332381],\n  \"广东省-惠州市\": [114.423558, 23.116359],\n  \"广东省-惠州市-惠城区\": [114.38949, 23.089726],\n  \"广东省-惠州市-惠阳区\": [114.463464, 22.794721],\n  \"广东省-惠州市-博罗县\": [114.296573, 23.178806],\n  \"广东省-惠州市-惠东县\": [114.726426, 22.991443],\n  \"广东省-惠州市-龙门县\": [114.26143, 23.733838],\n  \"广东省-梅州市\": [116.129537, 24.294178],\n  \"广东省-梅州市-梅江区\": [116.123536, 24.315879],\n  \"广东省-梅州市-梅县区\": [116.088562, 24.270999],\n  \"广东省-梅州市-大埔县\": [116.701559, 24.353459],\n  \"广东省-梅州市-丰顺县\": [116.188454, 23.745738],\n  \"广东省-梅州市-五华县\": [115.782485, 23.938409],\n  \"广东省-梅州市-平远县\": [115.897477, 24.572414],\n  \"广东省-梅州市-蕉岭县\": [116.177439, 24.664993],\n  \"广东省-梅州市-兴宁市\": [115.737579, 24.142294],\n  \"广东省-汕尾市\": [115.381553, 22.791263],\n  \"广东省-汕尾市-城区\": [115.371531, 22.784552],\n  \"广东省-汕尾市-海丰县\": [115.329445, 22.972744],\n  \"广东省-汕尾市-陆河县\": [115.666483, 23.307677],\n  \"广东省-汕尾市-陆丰市\": [115.65849, 22.923636],\n  \"广东省-河源市\": [114.707446, 23.749684],\n  \"广东省-河源市-源城区\": [114.708439, 23.740298],\n  \"广东省-河源市-紫金县\": [115.190448, 23.64143],\n  \"广东省-河源市-龙川县\": [115.266555, 24.105851],\n  \"广东省-河源市-连平县\": [114.495444, 24.375808],\n  \"广东省-河源市-和平县\": [114.945449, 24.448253],\n  \"广东省-河源市-东源县\": [114.753508, 23.794258],\n  \"广东省-阳江市\": [111.988489, 21.86434],\n  \"广东省-阳江市-江城区\": [111.961455, 21.868128],\n  \"广东省-阳江市-阳东区\": [112.018579, 21.873997],\n  \"广东省-阳江市-阳西县\": [111.624481, 21.758701],\n  \"广东省-阳江市-阳春市\": [111.797536, 22.176015],\n  \"广东省-清远市\": [113.062468, 23.68823],\n  \"广东省-清远市-清城区\": [113.069477, 23.704022],\n  \"广东省-清远市-清新区\": [112.991558, 23.75427],\n  \"广东省-清远市-佛冈县\": [113.538441, 23.885475],\n  \"广东省-清远市-阳山县\": [112.64752, 24.470944],\n  \"广东省-清远市-连山壮族瑶族自治县\": [112.100426, 24.576846],\n  \"广东省-清远市-连南瑶族自治县\": [112.293517, 24.731549],\n  \"广东省-清远市-英德市\": [113.421443, 24.191939],\n  \"广东省-清远市-连州市\": [112.383573, 24.786467],\n  \"广东省-东莞市\": [113.75842, 23.027308],\n  \"广东省-中山市\": [113.399422, 22.522315],\n  \"广东省-潮州市\": [116.62947, 23.662623],\n  \"广东省-潮州市-湘桥区\": [116.634462, 23.680687],\n  \"广东省-潮州市-潮安区\": [116.684526, 23.468357],\n  \"广东省-潮州市-饶平县\": [117.010449, 23.670347],\n  \"广东省-揭阳市\": [116.378512, 23.55574],\n  \"广东省-揭阳市-榕城区\": [116.373516, 23.530746],\n  \"广东省-揭阳市-揭东区\": [116.418456, 23.572485],\n  \"广东省-揭阳市-揭西县\": [115.848561, 23.4373],\n  \"广东省-揭阳市-惠来县\": [116.301444, 23.039645],\n  \"广东省-揭阳市-普宁市\": [116.172449, 23.303635],\n  \"广东省-云浮市\": [112.051513, 22.920912],\n  \"广东省-云浮市-云城区\": [112.050529, 22.933898],\n  \"广东省-云浮市-云安区\": [112.009563, 23.076893],\n  \"广东省-云浮市-新兴县\": [112.231497, 22.70189],\n  \"广东省-云浮市-郁南县\": [111.541554, 23.240174],\n  \"广东省-云浮市-罗定市\": [111.57648, 22.774296],\n  \"广西壮族自治区\": [108.334521, 22.821269],\n  \"广西壮族自治区-南宁市\": [108.373451, 22.822607],\n  \"广西壮族自治区-南宁市-兴宁区\": [108.375445, 22.860291],\n  \"广西壮族自治区-南宁市-青秀区\": [108.501439, 22.792227],\n  \"广西壮族自治区-南宁市-江南区\": [108.279494, 22.787046],\n  \"广西壮族自治区-南宁市-西乡塘区\": [108.319572, 22.839652],\n  \"广西壮族自治区-南宁市-良庆区\": [108.327516, 22.762849],\n  \"广西壮族自治区-南宁市-邕宁区\": [108.49342, 22.7646],\n  \"广西壮族自治区-南宁市-武鸣区\": [108.281517, 23.164516],\n  \"广西壮族自治区-南宁市-隆安县\": [107.702574, 23.171585],\n  \"广西壮族自治区-南宁市-马山县\": [108.183562, 23.713878],\n  \"广西壮族自治区-南宁市-上林县\": [108.611451, 23.438519],\n  \"广西壮族自治区-南宁市-宾阳县\": [108.816502, 23.223701],\n  \"广西壮族自治区-南宁市-横县\": [109.267568, 22.685573],\n  \"广西壮族自治区-柳州市\": [109.434422, 24.331961],\n  \"广西壮族自治区-柳州市-城中区\": [109.417482, 24.321314],\n  \"广西壮族自治区-柳州市-鱼峰区\": [109.449416, 24.318522],\n  \"广西壮族自治区-柳州市-柳南区\": [109.391552, 24.341579],\n  \"广西壮族自治区-柳州市-柳北区\": [109.408532, 24.367867],\n  \"广西壮族自治区-柳州市-柳江区\": [109.332444, 24.260815],\n  \"广西壮族自治区-柳州市-柳城县\": [109.251562, 24.65637],\n  \"广西壮族自治区-柳州市-鹿寨县\": [109.757554, 24.478622],\n  \"广西壮族自治区-柳州市-融安县\": [109.404563, 25.230511],\n  \"广西壮族自治区-柳州市-融水苗族自治县\": [109.262561, 25.072077],\n  \"广西壮族自治区-柳州市-三江侗族自治县\": [109.614547, 25.78883],\n  \"广西壮族自治区-桂林市\": [110.203545, 25.242886],\n  \"广西壮族自治区-桂林市-秀峰区\": [110.270437, 25.279618],\n  \"广西壮族自治区-桂林市-叠彩区\": [110.308463, 25.320233],\n  \"广西壮族自治区-桂林市-象山区\": [110.287423, 25.26793],\n  \"广西壮族自治区-桂林市-七星区\": [110.324538, 25.258567],\n  \"广西壮族自治区-桂林市-雁山区\": [110.315479, 25.066214],\n  \"广西壮族自治区-桂林市-临桂区\": [110.218587, 25.244302],\n  \"广西壮族自治区-桂林市-阳朔县\": [110.503475, 24.784519],\n  \"广西壮族自治区-桂林市-灵川县\": [110.332537, 25.41555],\n  \"广西壮族自治区-桂林市-全州县\": [111.079569, 25.934343],\n  \"广西壮族自治区-桂林市-兴安县\": [110.678516, 25.617567],\n  \"广西壮族自治区-桂林市-永福县\": [109.989591, 24.985578],\n  \"广西壮族自治区-桂林市-灌阳县\": [111.167552, 25.495121],\n  \"广西壮族自治区-桂林市-龙胜各族自治县\": [110.017494, 25.804117],\n  \"广西壮族自治区-桂林市-资源县\": [110.658439, 26.048569],\n  \"广西壮族自治区-桂林市-平乐县\": [110.649446, 24.639632],\n  \"广西壮族自治区-桂林市-荔浦县\": [110.401437, 24.494122],\n  \"广西壮族自治区-桂林市-恭城瑶族自治县\": [110.83456, 24.837194],\n  \"广西壮族自治区-梧州市\": [111.285517, 23.482745],\n  \"广西壮族自治区-梧州市-万秀区\": [111.32752, 23.478846],\n  \"广西壮族自治区-梧州市-长洲区\": [111.281499, 23.49151],\n  \"广西壮族自治区-梧州市-龙圩区\": [111.285517, 23.482745],\n  \"广西壮族自治区-梧州市-苍梧县\": [111.555547, 23.845998],\n  \"广西壮族自治区-梧州市-藤县\": [110.921499, 23.38101],\n  \"广西壮族自治区-梧州市-蒙山县\": [110.531417, 24.200017],\n  \"广西壮族自治区-梧州市-岑溪市\": [111.001432, 22.924621],\n  \"广西壮族自治区-北海市\": [109.126533, 21.486836],\n  \"广西壮族自治区-北海市-海城区\": [109.124521, 21.481066],\n  \"广西壮族自治区-北海市-银海区\": [109.146545, 21.454769],\n  \"广西壮族自治区-北海市-铁山港区\": [109.428473, 21.535295],\n  \"广西壮族自治区-北海市-合浦县\": [109.213439, 21.667006],\n  \"广西壮族自治区-防城港市\": [108.360419, 21.693005],\n  \"广西壮族自治区-防城港市-港口区\": [108.386483, 21.649566],\n  \"广西壮族自治区-防城港市-防城区\": [108.360448, 21.775411],\n  \"广西壮族自治区-防城港市-上思县\": [107.990443, 22.159914],\n  \"广西壮族自治区-防城港市-东兴市\": [107.977489, 21.553615],\n  \"广西壮族自治区-钦州市\": [108.66058, 21.986594],\n  \"广西壮族自治区-钦州市-钦南区\": [108.664549, 21.945972],\n  \"广西壮族自治区-钦州市-钦北区\": [108.638513, 22.020367],\n  \"广西壮族自治区-钦州市-灵山县\": [109.297478, 22.422413],\n  \"广西壮族自治区-钦州市-浦北县\": [109.563423, 22.277822],\n  \"广西壮族自治区-贵港市\": [109.60552, 23.117448],\n  \"广西壮族自治区-贵港市-港北区\": [109.578433, 23.117564],\n  \"广西壮族自治区-贵港市-港南区\": [109.606553, 23.08124],\n  \"广西壮族自治区-贵港市-覃塘区\": [109.459427, 23.133251],\n  \"广西壮族自治区-贵港市-平南县\": [110.398452, 23.545506],\n  \"广西壮族自治区-贵港市-桂平市\": [110.085526, 23.400049],\n  \"广西壮族自治区-玉林市\": [110.188453, 22.659831],\n  \"广西壮族自治区-玉林市-玉州区\": [110.157431, 22.634493],\n  \"广西壮族自治区-玉林市-福绵区\": [110.157431, 22.634493],\n  \"广西壮族自治区-玉林市-容县\": [110.56453, 22.863666],\n  \"广西壮族自治区-玉林市-陆川县\": [110.270456, 22.327222],\n  \"广西壮族自治区-玉林市-博白县\": [109.982553, 22.278675],\n  \"广西壮族自治区-玉林市-兴业县\": [109.881552, 22.742268],\n  \"广西壮族自治区-玉林市-北流市\": [110.36057, 22.713958],\n  \"广西壮族自治区-百色市\": [106.624589, 23.908186],\n  \"广西壮族自治区-百色市-右江区\": [106.625589, 23.907085],\n  \"广西壮族自治区-百色市-田阳县\": [106.921413, 23.742006],\n  \"广西壮族自治区-百色市-田东县\": [107.132499, 23.60313],\n  \"广西壮族自治区-百色市-平果县\": [107.596571, 23.334923],\n  \"广西壮族自治区-百色市-德保县\": [106.621583, 23.328994],\n  \"广西壮族自治区-百色市-那坡县\": [105.839423, 23.393794],\n  \"广西壮族自治区-百色市-凌云县\": [106.568416, 24.354015],\n  \"广西壮族自治区-百色市-乐业县\": [106.56343, 24.783216],\n  \"广西壮族自治区-百色市-田林县\": [106.234498, 24.300535],\n  \"广西壮族自治区-百色市-西林县\": [105.100494, 24.495668],\n  \"广西壮族自治区-百色市-隆林各族自治县\": [105.350459, 24.776814],\n  \"广西壮族自治区-百色市-靖西市\": [106.424453, 23.140126],\n  \"广西壮族自治区-贺州市\": [111.573526, 24.409451],\n  \"广西壮族自治区-贺州市-八步区\": [111.558567, 24.417531],\n  \"广西壮族自治区-贺州市-平桂区\": [111.478414, 24.462001],\n  \"广西壮族自治区-贺州市-昭平县\": [110.817575, 24.175106],\n  \"广西壮族自治区-贺州市-钟山县\": [111.309586, 24.531673],\n  \"广西壮族自治区-贺州市-富川瑶族自治县\": [111.284511, 24.82016],\n  \"广西壮族自治区-河池市\": [108.0915, 24.698912],\n  \"广西壮族自治区-河池市-金城江区\": [108.043507, 24.695679],\n  \"广西壮族自治区-河池市-南丹县\": [107.54748, 24.98185],\n  \"广西壮族自治区-河池市-天峨县\": [107.178456, 25.005664],\n  \"广西壮族自治区-河池市-凤山县\": [107.04842, 24.553218],\n  \"广西壮族自治区-河池市-东兰县\": [107.380504, 24.516871],\n  \"广西壮族自治区-河池市-罗城仫佬族自治县\": [108.911574, 24.783085],\n  \"广西壮族自治区-河池市-环江毛南族自治县\": [108.264443, 24.832088],\n  \"广西壮族自治区-河池市-巴马瑶族自治县\": [107.266481, 24.147265],\n  \"广西壮族自治区-河池市-都安瑶族自治县\": [108.111458, 23.937331],\n  \"广西壮族自治区-河池市-大化瑶族自治县\": [108.004411, 23.742818],\n  \"广西壮族自治区-河池市-宜州市\": [108.643532, 24.491084],\n  \"广西壮族自治区-来宾市\": [109.227458, 23.756547],\n  \"广西壮族自治区-来宾市-兴宾区\": [109.241499, 23.733211],\n  \"广西壮族自治区-来宾市-忻城县\": [108.672562, 24.071889],\n  \"广西壮族自治区-来宾市-象州县\": [109.711462, 23.979681],\n  \"广西壮族自治区-来宾市-武宣县\": [109.669442, 23.600404],\n  \"广西壮族自治区-来宾市-金秀瑶族自治县\": [110.195506, 24.136319],\n  \"广西壮族自治区-来宾市-合山市\": [108.892566, 23.81226],\n  \"广西壮族自治区-崇左市\": [107.37152, 22.383117],\n  \"广西壮族自治区-崇左市-江州区\": [107.359533, 22.411246],\n  \"广西壮族自治区-崇左市-扶绥县\": [107.910465, 22.641097],\n  \"广西壮族自治区-崇左市-宁明县\": [107.083524, 22.145885],\n  \"广西壮族自治区-崇左市-龙州县\": [106.860582, 22.348299],\n  \"广西壮族自治区-崇左市-大新县\": [107.207557, 22.836229],\n  \"广西壮族自治区-崇左市-天等县\": [107.149473, 23.087506],\n  \"广西壮族自治区-崇左市-凭祥市\": [106.773524, 22.100153],\n  \"海南省\": [110.355537, 20.025802],\n  \"海南省-海口市\": [110.325525, 20.044049],\n  \"海南省-海口市-秀英区\": [110.300436, 20.013642],\n  \"海南省-海口市-龙华区\": [110.335541, 20.036321],\n  \"海南省-海口市-琼山区\": [110.360526, 20.009151],\n  \"海南省-海口市-美兰区\": [110.373498, 20.034646],\n  \"海南省-三亚市\": [109.518557, 18.258736],\n  \"海南省-三亚市-海棠区\": [109.7235, 18.337879],\n  \"海南省-三亚市-吉阳区\": [109.7235, 18.337879],\n  \"海南省-三亚市-天涯区\": [109.7235, 18.337879],\n  \"海南省-三亚市-崖州区\": [109.7235, 18.337879],\n  \"海南省-三沙市\": [111.673087, 16.497085],\n  \"海南省-儋州市\": [109.587456, 19.527146],\n  \"海南省-五指山市\": [109.52354, 18.780994],\n  \"海南省-琼海市\": [110.480545, 19.264254],\n  \"海南省-文昌市\": [110.804509, 19.549062],\n  \"海南省-万宁市\": [110.399434, 18.800107],\n  \"海南省-东方市\": [108.658567, 19.101105],\n  \"海南省-定安县\": [110.365533, 19.68712],\n  \"海南省-屯昌县\": [110.108577, 19.357375],\n  \"海南省-澄迈县\": [110.013511, 19.744349],\n  \"海南省-临高县\": [109.697443, 19.919475],\n  \"海南省-白沙黎族自治县\": [109.457471, 19.231379],\n  \"海南省-昌江黎族自治县\": [109.062464, 19.303998],\n  \"海南省-乐东黎族自治县\": [109.180508, 18.755871],\n  \"海南省-陵水黎族自治县\": [110.044464, 18.512332],\n  \"海南省-保亭黎族苗族自治县\": [109.703482, 18.64691],\n  \"海南省-琼中黎族苗族自治县\": [109.844511, 19.039164],\n  \"重庆市\": [106.558434, 29.568996],\n  \"重庆市-市辖区\": [106.558434, 29.568996],\n  \"重庆市-市辖区-万州区\": [108.415558, 30.813622],\n  \"重庆市-市辖区-涪陵区\": [107.39642, 29.709278],\n  \"重庆市-市辖区-渝中区\": [106.57544, 29.55909],\n  \"重庆市-市辖区-大渡口区\": [106.488534, 29.490107],\n  \"重庆市-市辖区-江北区\": [106.580415, 29.612832],\n  \"重庆市-市辖区-沙坪坝区\": [106.464465, 29.547193],\n  \"重庆市-市辖区-九龙坡区\": [106.517559, 29.507928],\n  \"重庆市-市辖区-南岸区\": [106.66843, 29.502683],\n  \"重庆市-市辖区-北碚区\": [106.403569, 29.811603],\n  \"重庆市-市辖区-綦江区\": [106.657484, 29.034114],\n  \"重庆市-市辖区-大足区\": [105.728405, 29.713114],\n  \"重庆市-市辖区-渝北区\": [106.637559, 29.723927],\n  \"重庆市-市辖区-巴南区\": [106.547454, 29.408475],\n  \"重庆市-市辖区-黔江区\": [108.777591, 29.538813],\n  \"重庆市-市辖区-长寿区\": [107.087531, 29.86352],\n  \"重庆市-市辖区-江津区\": [106.265598, 29.295884],\n  \"重庆市-市辖区-合川区\": [106.282541, 29.978181],\n  \"重庆市-市辖区-永川区\": [105.933499, 29.362046],\n  \"重庆市-市辖区-南川区\": [107.105585, 29.163479],\n  \"重庆市-市辖区-璧山区\": [106.233475, 29.598347],\n  \"重庆市-市辖区-铜梁区\": [106.063449, 29.850509],\n  \"重庆市-市辖区-潼南区\": [105.847399, 30.197314],\n  \"重庆市-市辖区-荣昌区\": [105.60142, 29.411307],\n  \"重庆市-市辖区-开州区\": [108.399498, 31.166644],\n  \"重庆市-县\": [108.120414, 30.006109],\n  \"重庆市-县-梁平县\": [107.7761, 30.660545],\n  \"重庆市-县-城口县\": [108.671612, 31.953391],\n  \"重庆市-县-丰都县\": [107.737481, 29.869413],\n  \"重庆市-县-垫江县\": [107.339566, 30.333294],\n  \"重庆市-县-武隆县\": [107.774902, 29.335005],\n  \"重庆市-县-忠县\": [107.478814, 30.278161],\n  \"重庆市-县-云阳县\": [108.703448, 30.936611],\n  \"重庆市-县-奉节县\": [109.470473, 31.024602],\n  \"重庆市-县-巫山县\": [109.885546, 31.080519],\n  \"重庆市-县-巫溪县\": [109.576403, 31.40488],\n  \"重庆市-县-石柱土家族自治县\": [109.576403, 31.40488],\n  \"重庆市-县-秀山土家族苗族自治县\": [109.013574, 28.453448],\n  \"重庆市-县-酉阳土家族苗族自治县\": [108.774586, 28.84704],\n  \"重庆市-县-彭水苗族土家族自治县\": [108.172578, 29.299462],\n  \"四川省\": [104.073467, 30.577543],\n  \"四川省-成都市\": [104.081534, 30.655822],\n  \"四川省-成都市-锦江区\": [104.089562, 30.661904],\n  \"四川省-成都市-青羊区\": [104.067445, 30.680038],\n  \"四川省-成都市-金牛区\": [104.057404, 30.697356],\n  \"四川省-成都市-武侯区\": [104.049424, 30.648713],\n  \"四川省-成都市-成华区\": [104.108592, 30.665589],\n  \"四川省-成都市-龙泉驿区\": [104.281397, 30.562698],\n  \"四川省-成都市-青白江区\": [104.257512, 30.884421],\n  \"四川省-成都市-新都区\": [104.165393, 30.829407],\n  \"四川省-成都市-温江区\": [103.863573, 30.688487],\n  \"四川省-成都市-双流区\": [103.930392, 30.580399],\n  \"四川省-成都市-金堂县\": [104.418443, 30.868358],\n  \"四川省-成都市-郫县\": [103.905446, 30.799538],\n  \"四川省-成都市-大邑县\": [103.52753, 30.593155],\n  \"四川省-成都市-蒲江县\": [103.512571, 30.2025],\n  \"四川省-成都市-新津县\": [103.817433, 30.416364],\n  \"四川省-成都市-都江堰市\": [103.653534, 30.994257],\n  \"四川省-成都市-彭州市\": [103.965561, 30.995564],\n  \"四川省-成都市-邛崃市\": [103.470481, 30.416399],\n  \"四川省-成都市-崇州市\": [103.679433, 30.636596],\n  \"四川省-成都市-简阳市\": [104.569516, 30.3766],\n  \"四川省-自贡市\": [104.784449, 29.345585],\n  \"四川省-自贡市-自流井区\": [104.783447, 29.343499],\n  \"四川省-自贡市-贡井区\": [104.721557, 29.351476],\n  \"四川省-自贡市-大安区\": [104.780416, 29.369929],\n  \"四川省-自贡市-沿滩区\": [104.880409, 29.278797],\n  \"四川省-自贡市-荣县\": [104.423458, 29.451801],\n  \"四川省-自贡市-富顺县\": [104.981494, 29.186886],\n  \"四川省-攀枝花市\": [101.725541, 26.588033],\n  \"四川省-攀枝花市-东区\": [101.710597, 26.552106],\n  \"四川省-攀枝花市-西区\": [101.637413, 26.603868],\n  \"四川省-攀枝花市-仁和区\": [101.74445, 26.504019],\n  \"四川省-攀枝花市-米易县\": [102.11644, 26.896968],\n  \"四川省-攀枝花市-盐边县\": [101.860499, 26.688767],\n  \"四川省-泸州市\": [105.448524, 28.877668],\n  \"四川省-泸州市-江阳区\": [105.441545, 28.884672],\n  \"四川省-泸州市-纳溪区\": [105.377409, 28.77936],\n  \"四川省-泸州市-龙马潭区\": [105.444544, 28.919012],\n  \"四川省-泸州市-泸县\": [105.388456, 29.157626],\n  \"四川省-泸州市-合江县\": [105.838432, 28.817793],\n  \"四川省-泸州市-叙永县\": [105.451508, 28.161714],\n  \"四川省-泸州市-古蔺县\": [105.819471, 28.044745],\n  \"四川省-德阳市\": [104.404419, 31.133115],\n  \"四川省-德阳市-旌阳区\": [104.423439, 31.148596],\n  \"四川省-德阳市-中江县\": [104.68553, 31.038954],\n  \"四川省-德阳市-罗江县\": [104.517414, 31.324179],\n  \"四川省-德阳市-广汉市\": [104.288422, 30.982415],\n  \"四川省-德阳市-什邡市\": [104.174427, 31.132889],\n  \"四川省-德阳市-绵竹市\": [104.227609, 31.343592],\n  \"四川省-绵阳市\": [104.685562, 31.473663],\n  \"四川省-绵阳市-涪城区\": [104.76342, 31.461314],\n  \"四川省-绵阳市-游仙区\": [104.772429, 31.479904],\n  \"四川省-绵阳市-安州区\": [104.573555, 31.540751],\n  \"四川省-绵阳市-三台县\": [105.10149, 31.101586],\n  \"四川省-绵阳市-盐亭县\": [105.395503, 31.214319],\n  \"四川省-绵阳市-梓潼县\": [105.177567, 31.648313],\n  \"四川省-绵阳市-北川羌族自治县\": [104.361586, 31.963084],\n  \"四川省-绵阳市-平武县\": [104.535422, 32.414682],\n  \"四川省-绵阳市-江油市\": [104.752412, 31.784128],\n  \"四川省-广元市\": [105.850423, 32.441616],\n  \"四川省-广元市-利州区\": [105.852426, 32.440208],\n  \"四川省-广元市-昭化区\": [105.969419, 32.329618],\n  \"四川省-广元市-朝天区\": [105.896589, 32.649726],\n  \"四川省-广元市-旺苍县\": [106.296491, 32.235097],\n  \"四川省-广元市-青川县\": [105.245407, 32.581617],\n  \"四川省-广元市-剑阁县\": [105.531576, 32.293479],\n  \"四川省-广元市-苍溪县\": [105.941483, 31.738684],\n  \"四川省-遂宁市\": [105.599422, 30.539098],\n  \"四川省-遂宁市-船山区\": [105.574523, 30.531471],\n  \"四川省-遂宁市-安居区\": [105.462467, 30.361496],\n  \"四川省-遂宁市-蓬溪县\": [105.713446, 30.763751],\n  \"四川省-遂宁市-射洪县\": [105.39451, 30.877139],\n  \"四川省-遂宁市-大英县\": [105.243404, 30.60081],\n  \"四川省-内江市\": [105.064588, 29.585887],\n  \"四川省-内江市-市中区\": [105.074574, 29.59271],\n  \"四川省-内江市-东兴区\": [105.082547, 29.598486],\n  \"四川省-内江市-威远县\": [104.674498, 29.533635],\n  \"四川省-内江市-资中县\": [104.858495, 29.770234],\n  \"四川省-内江市-隆昌县\": [105.294572, 29.345245],\n  \"四川省-乐山市\": [103.772538, 29.557941],\n  \"四川省-乐山市-市中区\": [103.767559, 29.561364],\n  \"四川省-乐山市-沙湾区\": [103.556436, 29.419272],\n  \"四川省-乐山市-五通桥区\": [103.824455, 29.413185],\n  \"四川省-乐山市-金口河区\": [103.085394, 29.250804],\n  \"四川省-乐山市-犍为县\": [103.955507, 29.214219],\n  \"四川省-乐山市-井研县\": [104.076511, 29.657303],\n  \"四川省-乐山市-夹江县\": [103.57841, 29.743846],\n  \"四川省-乐山市-沐川县\": [103.908467, 28.962888],\n  \"四川省-乐山市-峨边彝族自治县\": [103.268577, 29.236089],\n  \"四川省-乐山市-马边彝族自治县\": [103.552454, 28.841736],\n  \"四川省-乐山市-峨眉山市\": [103.491546, 29.606976],\n  \"四川省-南充市\": [106.117503, 30.843783],\n  \"四川省-南充市-顺庆区\": [106.098411, 30.802753],\n  \"四川省-南充市-高坪区\": [106.12554, 30.787255],\n  \"四川省-南充市-嘉陵区\": [106.078433, 30.764896],\n  \"四川省-南充市-南部县\": [106.043578, 31.353705],\n  \"四川省-南充市-营山县\": [106.572408, 31.083003],\n  \"四川省-南充市-蓬安县\": [106.418482, 31.034631],\n  \"四川省-南充市-仪陇县\": [106.30943, 31.277597],\n  \"四川省-南充市-西充县\": [105.907611, 31.000688],\n  \"四川省-南充市-阆中市\": [106.011565, 31.564075],\n  \"四川省-眉山市\": [103.856563, 30.082526],\n  \"四川省-眉山市-东坡区\": [103.838525, 30.048272],\n  \"四川省-眉山市-彭山区\": [103.879558, 30.198854],\n  \"四川省-眉山市-仁寿县\": [104.140477, 30.001664],\n  \"四川省-眉山市-洪雅县\": [103.379602, 29.910616],\n  \"四川省-眉山市-丹棱县\": [103.519583, 30.020363],\n  \"四川省-眉山市-青神县\": [103.853559, 29.837055],\n  \"四川省-宜宾市\": [104.649404, 28.758007],\n  \"四川省-宜宾市-翠屏区\": [104.626438, 28.772052],\n  \"四川省-宜宾市-南溪区\": [104.976513, 28.851504],\n  \"四川省-宜宾市-宜宾县\": [104.539443, 28.696246],\n  \"四川省-宜宾市-江安县\": [105.073595, 28.72961],\n  \"四川省-宜宾市-长宁县\": [104.927564, 28.588133],\n  \"四川省-宜宾市-高县\": [104.524411, 28.442511],\n  \"四川省-宜宾市-珙县\": [104.715575, 28.44432],\n  \"四川省-宜宾市-筠连县\": [104.517406, 28.170174],\n  \"四川省-宜宾市-兴文县\": [105.242402, 28.309905],\n  \"四川省-宜宾市-屏山县\": [104.05945, 28.707647],\n  \"四川省-广安市\": [106.639553, 30.461746],\n  \"四川省-广安市-广安区\": [106.648531, 30.479768],\n  \"四川省-广安市-前锋区\": [106.639553, 30.461746],\n  \"四川省-广安市-岳池县\": [106.446411, 30.54412],\n  \"四川省-广安市-武胜县\": [106.302462, 30.355496],\n  \"四川省-广安市-邻水县\": [106.936403, 30.341073],\n  \"四川省-广安市-华蓥市\": [106.789462, 30.396307],\n  \"四川省-达州市\": [107.474594, 31.214308],\n  \"四川省-达州市-通川区\": [107.511447, 31.220932],\n  \"四川省-达州市-达川区\": [107.518411, 31.202393],\n  \"四川省-达州市-宣汉县\": [107.733534, 31.359755],\n  \"四川省-达州市-开江县\": [107.875425, 31.089372],\n  \"四川省-达州市-大竹县\": [107.21158, 30.742077],\n  \"四川省-达州市-渠县\": [106.979583, 30.842299],\n  \"四川省-达州市-万源市\": [108.041541, 32.087421],\n  \"四川省-雅安市\": [103.049543, 30.016793],\n  \"四川省-雅安市-雨城区\": [103.039575, 30.011062],\n  \"四川省-雅安市-名山区\": [103.115486, 30.075914],\n  \"四川省-雅安市-荥经县\": [102.853436, 29.799194],\n  \"四川省-雅安市-汉源县\": [102.658576, 29.350217],\n  \"四川省-雅安市-石棉县\": [102.366405, 29.234305],\n  \"四川省-雅安市-天全县\": [102.76453, 30.072473],\n  \"四川省-雅安市-芦山县\": [102.934528, 30.149873],\n  \"四川省-雅安市-宝兴县\": [102.821484, 30.374082],\n  \"四川省-巴中市\": [106.751585, 31.872889],\n  \"四川省-巴中市-巴州区\": [106.775513, 31.857686],\n  \"四川省-巴中市-恩阳区\": [106.775513, 31.857686],\n  \"四川省-巴中市-通江县\": [107.251517, 31.917714],\n  \"四川省-巴中市-南江县\": [106.834483, 32.352532],\n  \"四川省-巴中市-平昌县\": [107.110593, 31.566186],\n  \"四川省-资阳市\": [104.634435, 30.134957],\n  \"四川省-资阳市-雁江区\": [104.658424, 30.123753],\n  \"四川省-资阳市-安岳县\": [105.342454, 30.103393],\n  \"四川省-资阳市-乐至县\": [105.027477, 30.282348],\n  \"四川省-阿坝藏族羌族自治州\": [102.231415, 31.905512],\n  \"四川省-阿坝藏族羌族自治州-马尔康市\": [102.213502, 31.911748],\n  \"四川省-阿坝藏族羌族自治州-汶川县\": [103.596518, 31.483005],\n  \"四川省-阿坝藏族羌族自治州-理县\": [103.173511, 31.44255],\n  \"四川省-阿坝藏族羌族自治州-茂县\": [103.85959, 31.686809],\n  \"四川省-阿坝藏族羌族自治州-松潘县\": [103.61058, 32.661797],\n  \"四川省-阿坝藏族羌族自治州-九寨沟县\": [104.249547, 33.257592],\n  \"四川省-阿坝藏族羌族自治州-金川县\": [102.07061, 31.482006],\n  \"四川省-阿坝藏族羌族自治州-小金县\": [102.369426, 31.002209],\n  \"四川省-阿坝藏族羌族自治州-黑水县\": [102.996517, 32.067805],\n  \"四川省-阿坝藏族羌族自治州-壤塘县\": [100.985583, 32.271093],\n  \"四川省-阿坝藏族羌族自治州-阿坝县\": [101.71361, 32.908221],\n  \"四川省-阿坝藏族羌族自治州-若尔盖县\": [102.974391, 33.584377],\n  \"四川省-阿坝藏族羌族自治州-红原县\": [102.550615, 32.796605],\n  \"四川省-甘孜藏族自治州\": [101.968547, 30.055279],\n  \"四川省-甘孜藏族自治州-康定市\": [101.963555, 30.004407],\n  \"四川省-甘孜藏族自治州-泸定县\": [102.241432, 29.920402],\n  \"四川省-甘孜藏族自治州-丹巴县\": [101.896437, 30.88477],\n  \"四川省-甘孜藏族自治州-九龙县\": [101.896437, 30.88477],\n  \"四川省-甘孜藏族自治州-雅江县\": [101.0205, 30.037569],\n  \"四川省-甘孜藏族自治州-道孚县\": [101.13154, 30.985326],\n  \"四川省-甘孜藏族自治州-炉霍县\": [100.682397, 31.397992],\n  \"四川省-甘孜藏族自治州-甘孜县\": [99.99921, 31.628957],\n  \"四川省-甘孜藏族自治州-新龙县\": [100.318398, 30.94547],\n  \"四川省-甘孜藏族自治州-德格县\": [98.587402, 31.812106],\n  \"四川省-甘孜藏族自治州-白玉县\": [98.8311, 31.215314],\n  \"四川省-甘孜藏族自治州-石渠县\": [98.109481, 32.984003],\n  \"四川省-甘孜藏族自治州-色达县\": [100.339414, 32.27433],\n  \"四川省-甘孜藏族自治州-理塘县\": [100.275575, 30.000031],\n  \"四川省-甘孜藏族自治州-巴塘县\": [99.116727, 30.011662],\n  \"四川省-甘孜藏族自治州-乡城县\": [99.80506, 28.936733],\n  \"四川省-甘孜藏族自治州-稻城县\": [100.304462, 29.043122],\n  \"四川省-甘孜藏族自治州-得荣县\": [99.292984, 28.71878],\n  \"四川省-凉山彝族自治州\": [102.273503, 27.887752],\n  \"四川省-凉山彝族自治州-西昌市\": [102.271484, 27.900581],\n  \"四川省-凉山彝族自治州-木里藏族自治县\": [101.286397, 27.934599],\n  \"四川省-凉山彝族自治州-盐源县\": [101.515429, 27.428155],\n  \"四川省-凉山彝族自治州-德昌县\": [102.182596, 27.408504],\n  \"四川省-凉山彝族自治州-会理县\": [102.251436, 26.6612],\n  \"四川省-凉山彝族自治州-会东县\": [102.584462, 26.640824],\n  \"四川省-凉山彝族自治州-宁南县\": [102.762526, 27.064605],\n  \"四川省-凉山彝族自治州-普格县\": [102.546597, 27.381996],\n  \"四川省-凉山彝族自治州-布拖县\": [102.818478, 27.712129],\n  \"四川省-凉山彝族自治州-金阳县\": [103.254549, 27.702145],\n  \"四川省-凉山彝族自治州-昭觉县\": [102.849423, 28.020506],\n  \"四川省-凉山彝族自治州-喜德县\": [102.419567, 28.31271],\n  \"四川省-凉山彝族自治州-冕宁县\": [102.183575, 28.555294],\n  \"四川省-凉山彝族自治州-越西县\": [102.514474, 28.645828],\n  \"四川省-凉山彝族自治州-甘洛县\": [102.778597, 28.964823],\n  \"四川省-凉山彝族自治州-美姑县\": [103.138586, 28.33402],\n  \"四川省-凉山彝族自治州-雷波县\": [103.578429, 28.268951],\n  \"贵州省\": [106.714476, 26.60403],\n  \"贵州省-贵阳市\": [106.714476, 26.60403],\n  \"贵州省-贵阳市-南明区\": [106.720528, 26.574336],\n  \"贵州省-贵阳市-云岩区\": [106.730535, 26.610381],\n  \"贵州省-贵阳市-花溪区\": [106.676441, 26.415879],\n  \"贵州省-贵阳市-乌当区\": [106.757558, 26.636529],\n  \"贵州省-贵阳市-白云区\": [106.629597, 26.683588],\n  \"贵州省-贵阳市-观山湖区\": [106.757558, 26.636529],\n  \"贵州省-贵阳市-开阳县\": [106.97156, 27.063674],\n  \"贵州省-贵阳市-息烽县\": [106.747562, 27.096475],\n  \"贵州省-贵阳市-修文县\": [106.598492, 26.844862],\n  \"贵州省-贵阳市-清镇市\": [106.477523, 26.561988],\n  \"贵州省-六盘水市\": [104.837555, 26.598833],\n  \"贵州省-六盘水市-钟山区\": [104.85053, 26.580704],\n  \"贵州省-六盘水市-六枝特区\": [105.483429, 26.219214],\n  \"贵州省-六盘水市-水城县\": [104.964566, 26.55372],\n  \"贵州省-六盘水市-盘县\": [104.478582, 25.715651],\n  \"贵州省-遵义市\": [106.933428, 27.731701],\n  \"贵州省-遵义市-红花岗区\": [106.900497, 27.65087],\n  \"贵州省-遵义市-汇川区\": [106.940458, 27.756343],\n  \"贵州省-遵义市-播州区\": [106.836504, 27.542501],\n  \"贵州省-遵义市-桐梓县\": [106.832489, 28.139468],\n  \"贵州省-遵义市-绥阳县\": [107.197492, 27.95308],\n  \"贵州省-遵义市-正安县\": [107.460575, 28.559092],\n  \"贵州省-遵义市-道真仡佬族苗族自治县\": [107.619484, 28.86865],\n  \"贵州省-遵义市-务川仡佬族苗族自治县\": [107.905456, 28.569077],\n  \"贵州省-遵义市-凤冈县\": [107.723548, 27.960695],\n  \"贵州省-遵义市-湄潭县\": [107.472599, 27.754498],\n  \"贵州省-遵义市-余庆县\": [107.91146, 27.221379],\n  \"贵州省-遵义市-习水县\": [106.203428, 28.339118],\n  \"贵州省-遵义市-赤水市\": [105.703489, 28.596119],\n  \"贵州省-遵义市-仁怀市\": [106.407527, 27.797752],\n  \"贵州省-安顺市\": [105.954417, 26.259252],\n  \"贵州省-安顺市-西秀区\": [105.972406, 26.251498],\n  \"贵州省-安顺市-平坝区\": [106.263584, 26.411186],\n  \"贵州省-安顺市-普定县\": [105.748486, 26.308233],\n  \"贵州省-安顺市-镇宁布依族苗族自治县\": [105.776583, 26.063829],\n  \"贵州省-安顺市-关岭布依族苗族自治县\": [105.625476, 25.949877],\n  \"贵州省-安顺市-紫云苗族布依族自治县\": [106.090414, 25.757409],\n  \"贵州省-毕节市\": [105.311581, 27.304095],\n  \"贵州省-毕节市-七星关区\": [105.311581, 27.304095],\n  \"贵州省-毕节市-大方县\": [105.611399, 27.165261],\n  \"贵州省-毕节市-黔西县\": [106.038574, 27.014345],\n  \"贵州省-毕节市-金沙县\": [106.226442, 27.465355],\n  \"贵州省-毕节市-织金县\": [105.77759, 26.669222],\n  \"贵州省-毕节市-纳雍县\": [105.389487, 26.783717],\n  \"贵州省-毕节市-威宁彝族回族苗族自治县\": [104.282508, 26.875711],\n  \"贵州省-毕节市-赫章县\": [104.733516, 27.129052],\n  \"贵州省-铜仁市\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-碧江区\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-万山区\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-江口县\": [108.857371, 27.699558],\n  \"贵州省-铜仁市-玉屏侗族自治县\": [109.024903, 27.455339],\n  \"贵州省-铜仁市-石阡县\": [108.230464, 27.519722],\n  \"贵州省-铜仁市-思南县\": [109.195295, 27.743042],\n  \"贵州省-铜仁市-印江土家族苗族自治县\": [108.415088, 27.999307],\n  \"贵州省-铜仁市-德江县\": [108.126401, 28.270733],\n  \"贵州省-铜仁市-沿河土家族自治县\": [108.50793, 28.570124],\n  \"贵州省-铜仁市-松桃苗族自治县\": [109.134326, 27.875214],\n  \"贵州省-黔西南布依族苗族自治州\": [104.912492, 25.093967],\n  \"贵州省-黔西南布依族苗族自治州-兴义市\": [104.902461, 25.098113],\n  \"贵州省-黔西南布依族苗族自治州-兴仁县\": [105.192568, 25.440899],\n  \"贵州省-黔西南布依族苗族自治州-普安县\": [104.959546, 25.789952],\n  \"贵州省-黔西南布依族苗族自治州-晴隆县\": [105.225484, 25.841048],\n  \"贵州省-黔西南布依族苗族自治州-贞丰县\": [105.65656, 25.392124],\n  \"贵州省-黔西南布依族苗族自治州-望谟县\": [106.106445, 25.184355],\n  \"贵州省-黔西南布依族苗族自治州-册亨县\": [105.818511, 24.989637],\n  \"贵州省-黔西南布依族苗族自治州-安龙县\": [105.449543, 25.10399],\n  \"贵州省-黔东南苗族侗族自治州\": [107.989446, 26.589703],\n  \"贵州省-黔东南苗族侗族自治州-凯里市\": [107.987469, 26.573079],\n  \"贵州省-黔东南苗族侗族自治州-黄平县\": [107.923548, 26.911289],\n  \"贵州省-黔东南苗族侗族自治州-施秉县\": [108.13044, 27.039822],\n  \"贵州省-黔东南苗族侗族自治州-三穗县\": [108.681545, 26.958666],\n  \"贵州省-黔东南苗族侗族自治州-镇远县\": [108.436581, 27.054821],\n  \"贵州省-黔东南苗族侗族自治州-岑巩县\": [108.822481, 27.179902],\n  \"贵州省-黔东南苗族侗族自治州-天柱县\": [109.214446, 26.915804],\n  \"贵州省-黔东南苗族侗族自治州-锦屏县\": [109.207438, 26.682632],\n  \"贵州省-黔东南苗族侗族自治州-剑河县\": [108.447517, 26.734048],\n  \"贵州省-黔东南苗族侗族自治州-台江县\": [108.328552, 26.672373],\n  \"贵州省-黔东南苗族侗族自治州-黎平县\": [109.143567, 26.236874],\n  \"贵州省-黔东南苗族侗族自治州-榕江县\": [108.527554, 25.937725],\n  \"贵州省-黔东南苗族侗族自治州-从江县\": [108.911561, 25.759881],\n  \"贵州省-黔东南苗族侗族自治州-雷山县\": [108.084529, 26.384205],\n  \"贵州省-黔东南苗族侗族自治州-麻江县\": [107.595551, 26.496808],\n  \"贵州省-黔东南苗族侗族自治州-丹寨县\": [107.795513, 26.204421],\n  \"贵州省-黔南布依族苗族自治州\": [107.528403, 26.260616],\n  \"贵州省-黔南布依族苗族自治州-都匀市\": [107.525404, 26.266118],\n  \"贵州省-黔南布依族苗族自治州-福泉市\": [107.526433, 26.692526],\n  \"贵州省-黔南布依族苗族自治州-荔波县\": [107.893409, 25.417098],\n  \"贵州省-黔南布依族苗族自治州-贵定县\": [107.240554, 26.59066],\n  \"贵州省-黔南布依族苗族自治州-瓮安县\": [107.477552, 27.084126],\n  \"贵州省-黔南布依族苗族自治州-独山县\": [107.551498, 25.828288],\n  \"贵州省-黔南布依族苗族自治州-平塘县\": [107.329567, 25.828202],\n  \"贵州省-黔南布依族苗族自治州-罗甸县\": [106.758548, 25.430838],\n  \"贵州省-黔南布依族苗族自治州-长顺县\": [106.458421, 26.028455],\n  \"贵州省-黔南布依族苗族自治州-龙里县\": [106.986586, 26.459081],\n  \"贵州省-黔南布依族苗族自治州-惠水县\": [106.663453, 26.13821],\n  \"贵州省-黔南布依族苗族自治州-三都水族自治县\": [107.876429, 25.989479],\n  \"云南省\": [102.716416, 25.051562],\n  \"云南省-昆明市\": [102.852448, 24.873998],\n  \"云南省-昆明市-五华区\": [102.713423, 25.049835],\n  \"云南省-昆明市-盘龙区\": [102.758526, 25.122372],\n  \"云南省-昆明市-官渡区\": [102.750482, 25.021196],\n  \"云南省-昆明市-西山区\": [102.671557, 25.043199],\n  \"云南省-昆明市-东川区\": [103.194452, 26.089054],\n  \"云南省-昆明市-呈贡区\": [102.827473, 24.891871],\n  \"云南省-昆明市-晋宁县\": [102.602418, 24.676099],\n  \"云南省-昆明市-富民县\": [102.504473, 25.228085],\n  \"云南省-昆明市-宜良县\": [103.147558, 24.925287],\n  \"云南省-昆明市-石林彝族自治县\": [103.296508, 24.777702],\n  \"云南省-昆明市-嵩明县\": [103.043564, 25.344409],\n  \"云南省-昆明市-禄劝彝族苗族自治县\": [102.477423, 25.557672],\n  \"云南省-昆明市-寻甸回族彝族自治县\": [103.263574, 25.563894],\n  \"云南省-昆明市-安宁市\": [102.484409, 24.925602],\n  \"云南省-曲靖市\": [103.802435, 25.496407],\n  \"云南省-曲靖市-麒麟区\": [103.81143, 25.502102],\n  \"云南省-曲靖市-沾益区\": [103.828485, 25.606631],\n  \"云南省-曲靖市-马龙县\": [103.585447, 25.433966],\n  \"云南省-曲靖市-陆良县\": [103.673432, 25.035639],\n  \"云南省-曲靖市-师宗县\": [103.991556, 24.827995],\n  \"云南省-曲靖市-罗平县\": [104.31551, 24.89052],\n  \"云南省-曲靖市-富源县\": [104.261474, 25.68028],\n  \"云南省-曲靖市-会泽县\": [103.303487, 26.424215],\n  \"云南省-曲靖市-宣威市\": [104.111576, 26.225598],\n  \"云南省-玉溪市\": [102.55356, 24.357711],\n  \"云南省-玉溪市-红塔区\": [102.551565, 24.359801],\n  \"云南省-玉溪市-江川区\": [102.760527, 24.293439],\n  \"云南省-玉溪市-澄江县\": [102.914555, 24.679415],\n  \"云南省-玉溪市-通海县\": [102.732423, 24.117891],\n  \"云南省-玉溪市-华宁县\": [102.935492, 24.198581],\n  \"云南省-玉溪市-易门县\": [102.169535, 24.677404],\n  \"云南省-玉溪市-峨山彝族自治县\": [102.412565, 24.174774],\n  \"云南省-玉溪市-新平彝族傣族自治县\": [101.996428, 24.076263],\n  \"云南省-玉溪市-元江哈尼族彝族傣族自治县\": [102.004415, 23.603001],\n  \"云南省-保山市\": [99.177273, 25.139039],\n  \"云南省-保山市-隆阳区\": [99.172071, 25.126888],\n  \"云南省-保山市-施甸县\": [99.195469, 24.728835],\n  \"云南省-保山市-龙陵县\": [98.69575, 24.592547],\n  \"云南省-保山市-昌宁县\": [99.611617, 24.833985],\n  \"云南省-保山市-腾冲市\": [98.497595, 25.026617],\n  \"云南省-昭通市\": [103.723512, 27.344084],\n  \"云南省-昭通市-昭阳区\": [103.71347, 27.326144],\n  \"云南省-昭通市-鲁甸县\": [103.564412, 27.193107],\n  \"云南省-昭通市-巧家县\": [102.936519, 26.914705],\n  \"云南省-昭通市-盐津县\": [104.241579, 28.114384],\n  \"云南省-昭通市-大关县\": [103.897515, 27.754021],\n  \"云南省-昭通市-永善县\": [103.644569, 28.234722],\n  \"云南省-昭通市-绥江县\": [103.964552, 28.604278],\n  \"云南省-昭通市-镇雄县\": [104.880404, 27.447795],\n  \"云南省-昭通市-彝良县\": [104.054443, 27.63169],\n  \"云南省-昭通市-威信县\": [105.055577, 27.852537],\n  \"云南省-昭通市-水富县\": [104.422433, 28.636107],\n  \"云南省-丽江市\": [100.232465, 26.860657],\n  \"云南省-丽江市-古城区\": [100.23248, 26.883162],\n  \"云南省-丽江市-玉龙纳西族自治县\": [100.243527, 26.827392],\n  \"云南省-丽江市-永胜县\": [100.757581, 26.68995],\n  \"云南省-丽江市-华坪县\": [101.27243, 26.635223],\n  \"云南省-丽江市-宁蒗彝族自治县\": [100.85859, 27.287728],\n  \"云南省-普洱市\": [100.97257, 22.830979],\n  \"云南省-普洱市-思茅区\": [100.983555, 22.792498],\n  \"云南省-普洱市-宁洱哈尼族彝族自治县\": [101.052442, 23.05459],\n  \"云南省-普洱市-墨江哈尼族自治县\": [101.698584, 23.437726],\n  \"云南省-普洱市-景东彝族自治县\": [100.838489, 24.451864],\n  \"云南省-普洱市-景谷傣族彝族自治县\": [100.838489, 24.451864],\n  \"云南省-普洱市-镇沅彝族哈尼族拉祜族自治县\": [101.115569, 24.010331],\n  \"云南省-普洱市-江城哈尼族彝族自治县\": [101.868479, 22.591684],\n  \"云南省-普洱市-孟连傣族拉祜族佤族自治县\": [99.590963, 22.335308],\n  \"云南省-普洱市-澜沧拉祜族自治县\": [99.938588, 22.561832],\n  \"云南省-普洱市-西盟佤族自治县\": [99.596622, 22.650656],\n  \"云南省-临沧市\": [100.09544, 23.890469],\n  \"云南省-临沧市-临翔区\": [100.088443, 23.901402],\n  \"云南省-临沧市-凤庆县\": [99.934989, 24.586472],\n  \"云南省-临沧市-云县\": [100.129531, 24.442807],\n  \"云南省-临沧市-永德县\": [99.265076, 24.024871],\n  \"云南省-临沧市-镇康县\": [98.831871, 23.768315],\n  \"云南省-临沧市-双江拉祜族佤族布朗族傣族自治县\": [99.834131, 23.479837],\n  \"云南省-临沧市-耿马傣族佤族自治县\": [99.403942, 23.543491],\n  \"云南省-临沧市-沧源佤族自治县\": [99.252722, 23.152879],\n  \"云南省-楚雄彝族自治州\": [101.534412, 25.051774],\n  \"云南省-楚雄彝族自治州-楚雄市\": [101.552472, 25.03886],\n  \"云南省-楚雄彝族自治州-双柏县\": [101.552472, 25.03886],\n  \"云南省-楚雄彝族自治州-牟定县\": [101.553481, 25.318846],\n  \"云南省-楚雄彝族自治州-南华县\": [101.280421, 25.198587],\n  \"云南省-楚雄彝族自治州-姚安县\": [101.248527, 25.509775],\n  \"云南省-楚雄彝族自治州-大姚县\": [101.330567, 25.727601],\n  \"云南省-楚雄彝族自治州-永仁县\": [101.672493, 26.055566],\n  \"云南省-楚雄彝族自治州-元谋县\": [101.880445, 25.710895],\n  \"云南省-楚雄彝族自治州-武定县\": [102.410532, 25.53609],\n  \"云南省-楚雄彝族自治州-禄丰县\": [102.085531, 25.155831],\n  \"云南省-红河哈尼族彝族自治州\": [103.381549, 23.369996],\n  \"云南省-红河哈尼族彝族自治州-个旧市\": [103.166519, 23.364942],\n  \"云南省-红河哈尼族彝族自治州-开远市\": [103.166519, 23.364942],\n  \"云南省-红河哈尼族彝族自治州-蒙自市\": [103.371546, 23.40208],\n  \"云南省-红河哈尼族彝族自治州-弥勒市\": [103.421489, 24.417982],\n  \"云南省-红河哈尼族彝族自治州-屏边苗族自治县\": [103.693432, 22.98999],\n  \"云南省-红河哈尼族彝族自治州-建水县\": [102.83344, 23.640939],\n  \"云南省-红河哈尼族彝族自治州-石屏县\": [102.502447, 23.712004],\n  \"云南省-红河哈尼族彝族自治州-泸西县\": [103.772523, 24.538037],\n  \"云南省-红河哈尼族彝族自治州-元阳县\": [102.841433, 23.226198],\n  \"云南省-红河哈尼族彝族自治州-红河县\": [102.427551, 23.374489],\n  \"云南省-红河哈尼族彝族自治州-金平苗族瑶族傣族自治县\": [102.427551, 23.374489],\n  \"云南省-红河哈尼族彝族自治州-绿春县\": [102.398494, 23.000165],\n  \"云南省-红河哈尼族彝族自治州-河口瑶族自治县\": [103.945444, 22.535466],\n  \"云南省-文山壮族苗族自治州\": [104.222569, 23.405994],\n  \"云南省-文山壮族苗族自治州-文山市\": [104.238544, 23.391944],\n  \"云南省-文山壮族苗族自治州-砚山县\": [104.343551, 23.611487],\n  \"云南省-文山壮族苗族自治州-西畴县\": [104.678525, 23.443271],\n  \"云南省-文山壮族苗族自治州-麻栗坡县\": [104.709549, 23.131586],\n  \"云南省-文山壮族苗族自治州-马关县\": [104.400415, 23.018994],\n  \"云南省-文山壮族苗族自治州-丘北县\": [104.173442, 24.056994],\n  \"云南省-文山壮族苗族自治州-广南县\": [105.061582, 24.052199],\n  \"云南省-文山壮族苗族自治州-富宁县\": [105.63749, 23.63138],\n  \"云南省-西双版纳傣族自治州\": [100.803447, 22.013601],\n  \"云南省-西双版纳傣族自治州-景洪市\": [100.806443, 22.017004],\n  \"云南省-西双版纳傣族自治州-勐海县\": [100.459446, 21.963434],\n  \"云南省-西双版纳傣族自治州-勐腊县\": [101.571528, 21.465281],\n  \"云南省-大理白族自治州\": [100.274583, 25.612128],\n  \"云南省-大理白族自治州-大理市\": [100.236519, 25.597605],\n  \"云南省-大理白族自治州-漾濞彝族自治县\": [100.236519, 25.597605],\n  \"云南省-大理白族自治州-祥云县\": [100.557447, 25.489873],\n  \"云南省-大理白族自治州-宾川县\": [100.578457, 25.835249],\n  \"云南省-大理白族自治州-弥渡县\": [100.497586, 25.349336],\n  \"云南省-大理白族自治州-南涧彝族自治县\": [100.497586, 25.349336],\n  \"云南省-大理白族自治州-巍山彝族回族自治县\": [100.31346, 25.233439],\n  \"云南省-大理白族自治州-永平县\": [99.547495, 25.470206],\n  \"云南省-大理白族自治州-云龙县\": [99.377416, 25.891945],\n  \"云南省-大理白族自治州-洱源县\": [99.96921, 26.120093],\n  \"云南省-大理白族自治州-剑川县\": [99.912091, 26.542517],\n  \"云南省-大理白族自治州-鹤庆县\": [100.182492, 26.566197],\n  \"云南省-德宏傣族景颇族自治州\": [98.591359, 24.438011],\n  \"云南省-德宏傣族景颇族自治州-瑞丽市\": [97.862486, 24.022817],\n  \"云南省-德宏傣族景颇族自治州-芒市\": [97.862486, 24.022817],\n  \"云南省-德宏傣族景颇族自治州-梁河县\": [98.303134, 24.810784],\n  \"云南省-德宏傣族景颇族自治州-盈江县\": [97.938427, 24.711534],\n  \"云南省-德宏傣族景颇族自治州-陇川县\": [97.79853, 24.189468],\n  \"云南省-怒江傈僳族自治州\": [98.863288, 25.823707],\n  \"云南省-怒江傈僳族自治州-泸水市\": [98.864586, 25.829027],\n  \"云南省-怒江傈僳族自治州-福贡县\": [98.875649, 26.908055],\n  \"云南省-怒江傈僳族自治州-贡山独龙族怒族自治县\": [98.672399, 27.747068],\n  \"云南省-怒江傈僳族自治州-兰坪白族普米族自治县\": [99.423285, 26.459208],\n  \"云南省-迪庆藏族自治州\": [99.70953, 27.825185],\n  \"云南省-迪庆藏族自治州-香格里拉市\": [99.707445, 27.83576],\n  \"云南省-迪庆藏族自治州-德钦县\": [98.924453, 28.470086],\n  \"云南省-迪庆藏族自治州-维西傈僳族自治县\": [99.293466, 27.18317],\n  \"西藏自治区\": [91.124342, 29.652894],\n  \"西藏自治区-拉萨市\": [91.120824, 29.65004],\n  \"西藏自治区-拉萨市-城关区\": [91.1451, 29.658331],\n  \"西藏自治区-拉萨市-堆龙德庆区\": [91.009963, 29.651626],\n  \"西藏自治区-拉萨市-林周县\": [91.269501, 29.898733],\n  \"西藏自治区-拉萨市-当雄县\": [91.107452, 30.479222],\n  \"西藏自治区-拉萨市-尼木县\": [90.17118, 29.437519],\n  \"西藏自治区-拉萨市-曲水县\": [90.749959, 29.358987],\n  \"西藏自治区-拉萨市-达孜县\": [91.356318, 29.675409],\n  \"西藏自治区-拉萨市-墨竹工卡县\": [91.737266, 29.839753],\n  \"西藏自治区-日喀则市\": [88.902952, 29.255583],\n  \"西藏自治区-日喀则市-桑珠孜区\": [88.902952, 29.255583],\n  \"西藏自治区-日喀则市-南木林县\": [89.108283, 29.688959],\n  \"西藏自治区-日喀则市-江孜县\": [89.614958, 28.916435],\n  \"西藏自治区-日喀则市-定日县\": [88.859425, 29.004648],\n  \"西藏自治区-日喀则市-萨迦县\": [88.02935, 28.907594],\n  \"西藏自治区-日喀则市-拉孜县\": [88.893863, 29.273927],\n  \"西藏自治区-日喀则市-昂仁县\": [88.88319, 29.271424],\n  \"西藏自治区-日喀则市-谢通门县\": [88.267177, 29.436132],\n  \"西藏自治区-日喀则市-白朗县\": [89.267941, 29.116209],\n  \"西藏自治区-日喀则市-仁布县\": [89.848427, 29.236361],\n  \"西藏自治区-日喀则市-康马县\": [89.688245, 28.561444],\n  \"西藏自治区-日喀则市-定结县\": [87.772377, 28.369911],\n  \"西藏自治区-日喀则市-仲巴县\": [84.038117, 29.775982],\n  \"西藏自治区-日喀则市-亚东县\": [88.896978, 29.275644],\n  \"西藏自治区-日喀则市-吉隆县\": [88.662548, 29.401862],\n  \"西藏自治区-日喀则市-聂拉木县\": [88.889064, 29.275236],\n  \"西藏自治区-日喀则市-萨嘎县\": [88.647947, 29.079969],\n  \"西藏自治区-日喀则市-岗巴县\": [89.322529, 29.277094],\n  \"西藏自治区-昌都市\": [97.186654, 31.144249],\n  \"西藏自治区-昌都市-卡若区\": [97.186654, 31.144249],\n  \"西藏自治区-昌都市-江达县\": [98.224424, 31.505147],\n  \"西藏自治区-昌都市-贡觉县\": [98.277334, 30.865967],\n  \"西藏自治区-昌都市-类乌齐县\": [96.608489, 31.22509],\n  \"西藏自治区-昌都市-丁青县\": [97.177402, 31.149643],\n  \"西藏自治区-昌都市-察雅县\": [97.575976, 30.660119],\n  \"西藏自治区-昌都市-八宿县\": [96.931495, 30.061833],\n  \"西藏自治区-昌都市-左贡县\": [97.847367, 29.676849],\n  \"西藏自治区-昌都市-芒康县\": [96.848134, 30.738561],\n  \"西藏自治区-昌都市-洛隆县\": [97.399916, 31.06774],\n  \"西藏自治区-昌都市-边坝县\": [94.714371, 30.939625],\n  \"西藏自治区-林芝市\": [94.368058, 29.654042],\n  \"西藏自治区-林芝市-巴宜区\": [94.367544, 29.641645],\n  \"西藏自治区-林芝市-工布江达县\": [93.25242, 29.891368],\n  \"西藏自治区-林芝市-米林县\": [94.219939, 29.220917],\n  \"西藏自治区-林芝市-墨脱县\": [95.339495, 29.330938],\n  \"西藏自治区-林芝市-波密县\": [95.7739, 29.86506],\n  \"西藏自治区-林芝市-察隅县\": [97.47327, 28.667444],\n  \"西藏自治区-林芝市-朗县\": [93.081368, 29.051902],\n  \"西藏自治区-山南市\": [91.778675, 29.243027],\n  \"西藏自治区-山南市-乃东区\": [91.778682, 29.234229],\n  \"西藏自治区-山南市-扎囊县\": [91.343627, 29.251164],\n  \"西藏自治区-山南市-贡嘎县\": [91.343627, 29.251164],\n  \"西藏自治区-山南市-桑日县\": [92.021252, 29.267104],\n  \"西藏自治区-山南市-琼结县\": [91.690101, 29.030866],\n  \"西藏自治区-山南市-曲松县\": [92.205435, 29.071107],\n  \"西藏自治区-山南市-措美县\": [91.439918, 28.444258],\n  \"西藏自治区-山南市-洛扎县\": [90.855029, 28.391993],\n  \"西藏自治区-山南市-加查县\": [92.601582, 29.144787],\n  \"西藏自治区-山南市-隆子县\": [92.469078, 28.414441],\n  \"西藏自治区-山南市-错那县\": [91.968115, 27.998343],\n  \"西藏自治区-山南市-浪卡子县\": [90.404647, 28.973992],\n  \"西藏自治区-那曲地区\": [92.057338, 31.482438],\n  \"西藏自治区-那曲地区-那曲县\": [92.059847, 31.476117],\n  \"西藏自治区-那曲地区-嘉黎县\": [93.238732, 30.647062],\n  \"西藏自治区-那曲地区-比如县\": [93.685966, 31.486357],\n  \"西藏自治区-那曲地区-聂荣县\": [92.308654, 32.113707],\n  \"西藏自治区-那曲地区-安多县\": [91.688891, 32.271268],\n  \"西藏自治区-那曲地区-申扎县\": [88.716481, 30.936393],\n  \"西藏自治区-那曲地区-索县\": [93.792173, 31.892424],\n  \"西藏自治区-那曲地区-班戈县\": [90.016708, 31.398728],\n  \"西藏自治区-那曲地区-巴青县\": [94.059882, 31.924549],\n  \"西藏自治区-那曲地区-尼玛县\": [87.243292, 31.790953],\n  \"西藏自治区-那曲地区-双湖县\": [87.243292, 31.790953],\n  \"西藏自治区-阿里地区\": [80.112777, 32.506866],\n  \"西藏自治区-阿里地区-普兰县\": [81.183095, 30.300163],\n  \"西藏自治区-阿里地区-札达县\": [79.809323, 31.485343],\n  \"西藏自治区-阿里地区-噶尔县\": [80.102877, 32.497157],\n  \"西藏自治区-阿里地区-日土县\": [79.739109, 33.387186],\n  \"西藏自治区-阿里地区-革吉县\": [81.151664, 32.393356],\n  \"西藏自治区-阿里地区-改则县\": [84.069113, 32.308357],\n  \"西藏自治区-阿里地区-措勤县\": [84.069113, 32.308357],\n  \"陕西省\": [108.960393, 34.275808],\n  \"陕西省-西安市\": [108.946466, 34.347269],\n  \"陕西省-西安市-新城区\": [108.967391, 34.272724],\n  \"陕西省-西安市-碑林区\": [108.940498, 34.236474],\n  \"陕西省-西安市-莲湖区\": [108.950426, 34.271017],\n  \"陕西省-西安市-灞桥区\": [109.071415, 34.279128],\n  \"陕西省-西安市-未央区\": [108.953401, 34.299148],\n  \"陕西省-西安市-雁塔区\": [108.95144, 34.220635],\n  \"陕西省-西安市-阎良区\": [109.232463, 34.668363],\n  \"陕西省-西安市-临潼区\": [109.220436, 34.372747],\n  \"陕西省-西安市-长安区\": [108.91358, 34.16329],\n  \"陕西省-西安市-高陵区\": [109.094387, 34.541093],\n  \"陕西省-西安市-蓝田县\": [109.329388, 34.157621],\n  \"陕西省-西安市-周至县\": [108.228422, 34.169385],\n  \"陕西省-西安市-户县\": [108.61142, 34.115021],\n  \"陕西省-铜川市\": [108.952404, 34.902637],\n  \"陕西省-铜川市-王益区\": [109.081417, 35.075322],\n  \"陕西省-铜川市-印台区\": [109.106434, 35.120859],\n  \"陕西省-铜川市-耀州区\": [108.986438, 34.91596],\n  \"陕西省-铜川市-宜君县\": [109.123537, 35.404582],\n  \"陕西省-宝鸡市\": [107.244575, 34.368916],\n  \"陕西省-宝鸡市-渭滨区\": [107.156419, 34.377481],\n  \"陕西省-宝鸡市-金台区\": [107.153424, 34.382351],\n  \"陕西省-宝鸡市-陈仓区\": [107.393438, 34.360756],\n  \"陕西省-宝鸡市-凤翔县\": [107.407379, 34.527616],\n  \"陕西省-宝鸡市-岐山县\": [107.627447, 34.449777],\n  \"陕西省-宝鸡市-扶风县\": [107.906453, 34.381463],\n  \"陕西省-宝鸡市-眉县\": [107.756398, 34.280376],\n  \"陕西省-宝鸡市-陇县\": [106.870584, 34.89878],\n  \"陕西省-宝鸡市-千阳县\": [107.139466, 34.648545],\n  \"陕西省-宝鸡市-麟游县\": [107.799514, 34.683749],\n  \"陕西省-宝鸡市-凤县\": [106.522558, 33.916583],\n  \"陕西省-宝鸡市-太白县\": [107.325529, 34.064248],\n  \"陕西省-咸阳市\": [108.715422, 34.335476],\n  \"陕西省-咸阳市-秦都区\": [108.712432, 34.335145],\n  \"陕西省-咸阳市-杨陵区\": [108.091515, 34.278013],\n  \"陕西省-咸阳市-渭城区\": [108.743451, 34.36811],\n  \"陕西省-咸阳市-三原县\": [108.947447, 34.623079],\n  \"陕西省-咸阳市-泾阳县\": [108.849379, 34.533317],\n  \"陕西省-咸阳市-乾县\": [108.245378, 34.534018],\n  \"陕西省-咸阳市-礼泉县\": [108.431615, 34.487391],\n  \"陕西省-咸阳市-永寿县\": [108.148469, 34.698036],\n  \"陕西省-咸阳市-彬县\": [108.084566, 35.049611],\n  \"陕西省-咸阳市-长武县\": [107.805561, 35.211657],\n  \"陕西省-咸阳市-旬邑县\": [108.340467, 35.117964],\n  \"陕西省-咸阳市-淳化县\": [108.587442, 34.804777],\n  \"陕西省-咸阳市-武功县\": [108.206551, 34.266138],\n  \"陕西省-咸阳市-兴平市\": [108.496394, 34.305477],\n  \"陕西省-渭南市\": [109.51659, 34.505716],\n  \"陕西省-渭南市-临渭区\": [109.498596, 34.504],\n  \"陕西省-渭南市-华州区\": [109.778477, 34.518731],\n  \"陕西省-渭南市-潼关县\": [110.252508, 34.550327],\n  \"陕西省-渭南市-大荔县\": [109.948453, 34.801833],\n  \"陕西省-渭南市-合阳县\": [110.155396, 35.243872],\n  \"陕西省-渭南市-澄城县\": [109.938434, 35.196573],\n  \"陕西省-渭南市-蒲城县\": [109.592497, 34.961274],\n  \"陕西省-渭南市-白水县\": [109.597521, 35.183288],\n  \"陕西省-渭南市-富平县\": [109.186437, 34.75726],\n  \"陕西省-渭南市-韩城市\": [110.449553, 35.482087],\n  \"陕西省-渭南市-华阴市\": [110.098601, 34.5718],\n  \"陕西省-延安市\": [109.496582, 36.591111],\n  \"陕西省-延安市-宝塔区\": [109.499594, 36.59689],\n  \"陕西省-延安市-安塞区\": [109.335419, 36.870098],\n  \"陕西省-延安市-延长县\": [110.018472, 36.585329],\n  \"陕西省-延安市-延川县\": [110.20054, 36.884137],\n  \"陕西省-延安市-子长县\": [109.68139, 37.148817],\n  \"陕西省-延安市-志丹县\": [108.775577, 36.828021],\n  \"陕西省-延安市-吴起县\": [108.18259, 36.932576],\n  \"陕西省-延安市-甘泉县\": [109.357524, 36.282689],\n  \"陕西省-延安市-富县\": [109.386597, 35.993368],\n  \"陕西省-延安市-洛川县\": [109.438404, 35.7683],\n  \"陕西省-延安市-宜川县\": [110.175413, 36.056397],\n  \"陕西省-延安市-黄龙县\": [109.846549, 35.590234],\n  \"陕西省-延安市-黄陵县\": [109.269606, 35.585076],\n  \"陕西省-汉中市\": [107.02943, 33.0738],\n  \"陕西省-汉中市-汉台区\": [107.038402, 33.074191],\n  \"陕西省-汉中市-南郑县\": [106.942433, 33.005615],\n  \"陕西省-汉中市-城固县\": [107.340613, 33.162399],\n  \"陕西省-汉中市-洋县\": [107.552464, 33.228863],\n  \"陕西省-汉中市-西乡县\": [107.773393, 32.989397],\n  \"陕西省-汉中市-勉县\": [106.679426, 33.159805],\n  \"陕西省-汉中市-宁强县\": [106.264589, 32.83538],\n  \"陕西省-汉中市-略阳县\": [106.163544, 33.333194],\n  \"陕西省-汉中市-镇巴县\": [107.901446, 32.542833],\n  \"陕西省-汉中市-留坝县\": [106.927414, 33.623825],\n  \"陕西省-汉中市-佛坪县\": [107.997424, 33.530693],\n  \"陕西省-榆林市\": [109.741616, 38.290884],\n  \"陕西省-榆林市-榆阳区\": [109.727559, 38.28242],\n  \"陕西省-榆林市-横山区\": [109.300491, 37.968573],\n  \"陕西省-榆林市-神木县\": [110.50543, 38.848544],\n  \"陕西省-榆林市-府谷县\": [111.073628, 39.033796],\n  \"陕西省-榆林市-靖边县\": [108.8006, 37.605063],\n  \"陕西省-榆林市-定边县\": [107.60757, 37.60046],\n  \"陕西省-榆林市-绥德县\": [110.269426, 37.508907],\n  \"陕西省-榆林市-米脂县\": [110.190451, 37.761398],\n  \"陕西省-榆林市-佳县\": [110.497477, 38.025612],\n  \"陕西省-榆林市-吴堡县\": [110.746455, 37.45827],\n  \"陕西省-榆林市-清涧县\": [110.127559, 37.094853],\n  \"陕西省-榆林市-子洲县\": [110.042398, 37.617026],\n  \"陕西省-安康市\": [109.035601, 32.690513],\n  \"陕西省-安康市-汉滨区\": [109.033596, 32.701196],\n  \"陕西省-安康市-汉阴县\": [108.515507, 32.899121],\n  \"陕西省-安康市-石泉县\": [108.254427, 33.044602],\n  \"陕西省-安康市-宁陕县\": [108.320564, 33.316555],\n  \"陕西省-安康市-紫阳县\": [108.541594, 32.525786],\n  \"陕西省-安康市-岚皋县\": [108.908615, 32.312881],\n  \"陕西省-安康市-平利县\": [109.368547, 32.394804],\n  \"陕西省-安康市-镇坪县\": [109.533497, 31.889643],\n  \"陕西省-安康市-旬阳县\": [109.371557, 32.839864],\n  \"陕西省-安康市-白河县\": [110.119587, 32.814846],\n  \"陕西省-商洛市\": [109.924418, 33.878634],\n  \"陕西省-商洛市-商州区\": [109.947472, 33.868855],\n  \"陕西省-商洛市-洛南县\": [110.154427, 34.097071],\n  \"陕西省-商洛市-丹凤县\": [110.33356, 33.701537],\n  \"陕西省-商洛市-商南县\": [110.888408, 33.537533],\n  \"陕西省-商洛市-山阳县\": [109.888549, 33.537968],\n  \"陕西省-商洛市-镇安县\": [109.159575, 33.429045],\n  \"陕西省-商洛市-柞水县\": [109.120502, 33.692026],\n  \"甘肃省\": [103.832478, 36.065465],\n  \"甘肃省-兰州市\": [103.840521, 36.067235],\n  \"甘肃省-兰州市-城关区\": [103.831475, 36.063181],\n  \"甘肃省-兰州市-七里河区\": [103.792414, 36.072129],\n  \"甘肃省-兰州市-西固区\": [103.63458, 36.094109],\n  \"甘肃省-兰州市-安宁区\": [103.725535, 36.109754],\n  \"甘肃省-兰州市-红古区\": [102.865428, 36.351863],\n  \"甘肃省-兰州市-永登县\": [103.266624, 36.742095],\n  \"甘肃省-兰州市-皋兰县\": [103.953464, 36.338142],\n  \"甘肃省-兰州市-榆中县\": [104.119566, 35.848851],\n  \"甘肃省-嘉峪关市\": [98.296204, 39.77796],\n  \"甘肃省-金昌市\": [102.194606, 38.52582],\n  \"甘肃省-金昌市-金川区\": [102.200586, 38.525772],\n  \"甘肃省-金昌市-永昌县\": [101.979464, 38.252941],\n  \"甘肃省-白银市\": [104.144451, 36.550825],\n  \"甘肃省-白银市-白银区\": [104.155413, 36.541464],\n  \"甘肃省-白银市-平川区\": [104.831614, 36.733499],\n  \"甘肃省-白银市-靖远县\": [104.682515, 36.577096],\n  \"甘肃省-白银市-会宁县\": [105.059607, 35.698508],\n  \"甘肃省-白银市-景泰县\": [104.069444, 37.187406],\n  \"甘肃省-天水市\": [105.731417, 34.587412],\n  \"甘肃省-天水市-秦州区\": [105.730415, 34.587316],\n  \"甘肃省-天水市-麦积区\": [105.895597, 34.576337],\n  \"甘肃省-天水市-清水县\": [106.143595, 34.753883],\n  \"甘肃省-天水市-秦安县\": [105.681575, 34.864876],\n  \"甘肃省-天水市-甘谷县\": [105.342475, 34.7383],\n  \"甘肃省-天水市-武山县\": [104.897428, 34.727669],\n  \"甘肃省-天水市-张家川回族自治县\": [106.21139, 34.994905],\n  \"甘肃省-武威市\": [102.644554, 37.934378],\n  \"甘肃省-武威市-凉州区\": [102.648575, 37.934122],\n  \"甘肃省-武威市-民勤县\": [103.1004, 38.630625],\n  \"甘肃省-武威市-古浪县\": [102.90363, 37.475802],\n  \"甘肃省-武威市-天祝藏族自治县\": [103.148621, 36.977596],\n  \"甘肃省-张掖市\": [100.456411, 38.932066],\n  \"甘肃省-张掖市-甘州区\": [100.484558, 38.934781],\n  \"甘肃省-张掖市-肃南裕固族自治县\": [99.621905, 38.8431],\n  \"甘肃省-张掖市-民乐县\": [100.819429, 38.436842],\n  \"甘肃省-张掖市-临泽县\": [100.170555, 39.158514],\n  \"甘肃省-张掖市-高台县\": [99.82576, 39.383646],\n  \"甘肃省-张掖市-山丹县\": [101.095616, 38.790453],\n  \"甘肃省-平凉市\": [106.671442, 35.549232],\n  \"甘肃省-平凉市-崆峒区\": [106.681415, 35.548815],\n  \"甘肃省-平凉市-泾川县\": [107.374518, 35.338669],\n  \"甘肃省-平凉市-灵台县\": [107.627461, 35.071582],\n  \"甘肃省-平凉市-崇信县\": [107.041415, 35.308616],\n  \"甘肃省-平凉市-华亭县\": [106.659486, 35.223551],\n  \"甘肃省-平凉市-庄浪县\": [106.042586, 35.208192],\n  \"甘肃省-平凉市-静宁县\": [105.738416, 35.528257],\n  \"甘肃省-酒泉市\": [98.500685, 39.738469],\n  \"甘肃省-酒泉市-肃州区\": [98.514322, 39.751246],\n  \"甘肃省-酒泉市-金塔县\": [98.908368, 39.990029],\n  \"甘肃省-酒泉市-瓜州县\": [95.788736, 40.526106],\n  \"甘肃省-酒泉市-肃北蒙古族自治县\": [94.883692, 39.51833],\n  \"甘肃省-酒泉市-阿克塞哈萨克族自治县\": [94.34676, 39.640045],\n  \"甘肃省-酒泉市-玉门市\": [97.051712, 40.29762],\n  \"甘肃省-酒泉市-敦煌市\": [94.668527, 40.147867],\n  \"甘肃省-庆阳市\": [107.649386, 35.715216],\n  \"甘肃省-庆阳市-西峰区\": [107.657391, 35.736864],\n  \"甘肃省-庆阳市-庆城县\": [107.888406, 36.021726],\n  \"甘肃省-庆阳市-环县\": [107.31447, 36.574427],\n  \"甘肃省-庆阳市-华池县\": [107.99639, 36.467575],\n  \"甘肃省-庆阳市-合水县\": [108.026447, 35.825262],\n  \"甘肃省-庆阳市-正宁县\": [108.366375, 35.498219],\n  \"甘肃省-庆阳市-宁县\": [107.934571, 35.507933],\n  \"甘肃省-庆阳市-镇原县\": [107.207576, 35.683231],\n  \"甘肃省-定西市\": [104.63242, 35.586833],\n  \"甘肃省-定西市-安定区\": [104.6165, 35.5856],\n  \"甘肃省-定西市-通渭县\": [105.248404, 35.217217],\n  \"甘肃省-定西市-陇西县\": [104.641381, 35.010197],\n  \"甘肃省-定西市-渭源县\": [104.221584, 35.142392],\n  \"甘肃省-定西市-临洮县\": [103.865601, 35.400587],\n  \"甘肃省-定西市-漳县\": [104.478595, 34.85425],\n  \"甘肃省-定西市-岷县\": [104.043396, 34.444408],\n  \"甘肃省-陇南市\": [104.928575, 33.40662],\n  \"甘肃省-陇南市-武都区\": [104.932593, 33.398072],\n  \"甘肃省-陇南市-成县\": [105.748478, 33.756635],\n  \"甘肃省-陇南市-文县\": [104.689558, 32.949601],\n  \"甘肃省-陇南市-宕昌县\": [104.399386, 34.053486],\n  \"甘肃省-陇南市-康县\": [105.615392, 33.335376],\n  \"甘肃省-陇南市-西和县\": [105.30761, 34.016787],\n  \"甘肃省-陇南市-礼县\": [105.183591, 34.194685],\n  \"甘肃省-陇南市-徽县\": [106.094418, 33.775194],\n  \"甘肃省-陇南市-两当县\": [106.311419, 33.915123],\n  \"甘肃省-临夏回族自治州\": [103.216391, 35.607562],\n  \"甘肃省-临夏回族自治州-临夏市\": [103.249549, 35.609899],\n  \"甘肃省-临夏回族自治州-临夏县\": [103.002514, 35.497398],\n  \"甘肃省-临夏回族自治州-康乐县\": [103.715476, 35.37611],\n  \"甘肃省-临夏回族自治州-永靖县\": [103.292507, 35.96333],\n  \"甘肃省-临夏回族自治州-广河县\": [103.58241, 35.494101],\n  \"甘肃省-临夏回族自治州-和政县\": [103.357524, 35.43059],\n  \"甘肃省-临夏回族自治州-东乡族自治县\": [103.395613, 35.66933],\n  \"甘肃省-临夏回族自治州-积石山保安族东乡族撒拉族自治县\": [\n    102.882518, 35.723499\n  ],\n  \"甘肃省-甘南藏族自治州\": [102.917585, 34.98914],\n  \"甘肃省-甘南藏族自治州-合作市\": [102.917572, 35.005935],\n  \"甘肃省-甘南藏族自治州-临潭县\": [103.360533, 34.698639],\n  \"甘肃省-甘南藏族自治州-卓尼县\": [103.513616, 34.594916],\n  \"甘肃省-甘南藏族自治州-舟曲县\": [104.37749, 33.790815],\n  \"甘肃省-甘南藏族自治州-迭部县\": [103.22844, 34.06202],\n  \"甘肃省-甘南藏族自治州-玛曲县\": [102.0786, 34.003358],\n  \"甘肃省-甘南藏族自治州-碌曲县\": [102.494424, 34.597087],\n  \"甘肃省-甘南藏族自治州-夏河县\": [102.528577, 35.208324],\n  \"青海省\": [101.786462, 36.627159],\n  \"青海省-西宁市\": [101.78445, 36.623385],\n  \"青海省-西宁市-城东区\": [101.809569, 36.605708],\n  \"青海省-西宁市-城中区\": [101.790484, 36.6288],\n  \"青海省-西宁市-城西区\": [101.772414, 36.634497],\n  \"青海省-西宁市-城北区\": [101.772405, 36.656294],\n  \"青海省-西宁市-大通回族土族自治县\": [101.692564, 36.932666],\n  \"青海省-西宁市-湟中县\": [101.578617, 36.506628],\n  \"青海省-西宁市-湟源县\": [101.262449, 36.688588],\n  \"青海省-海东市\": [102.110444, 36.508511],\n  \"青海省-海东市-乐都区\": [102.408566, 36.48782],\n  \"青海省-海东市-平安区\": [102.114428, 36.506554],\n  \"青海省-海东市-民和回族土族自治县\": [102.83639, 36.325561],\n  \"青海省-海东市-互助土族自治县\": [101.964569, 36.850022],\n  \"青海省-海东市-化隆回族自治县\": [102.270448, 36.100988],\n  \"青海省-海东市-循化撒拉族自治县\": [102.495385, 35.856667],\n  \"青海省-海北藏族自治州\": [100.907434, 36.960663],\n  \"青海省-海北藏族自治州-门源回族自治县\": [101.628438, 37.382181],\n  \"青海省-海北藏族自治州-祁连县\": [100.259622, 38.182925],\n  \"青海省-海北藏族自治州-海晏县\": [101.000586, 36.902376],\n  \"青海省-海北藏族自治州-刚察县\": [100.153606, 37.32732],\n  \"青海省-黄南藏族自治州\": [102.022428, 35.525805],\n  \"青海省-黄南藏族自治州-同仁县\": [102.025438, 35.521865],\n  \"青海省-黄南藏族自治州-尖扎县\": [102.037507, 35.944284],\n  \"青海省-黄南藏族自治州-泽库县\": [101.473595, 35.042014],\n  \"青海省-黄南藏族自治州-河南蒙古族自治县\": [101.622473, 34.740396],\n  \"青海省-海南藏族自治州\": [100.626621, 36.292102],\n  \"青海省-海南藏族自治州-共和县\": [100.626623, 36.288703],\n  \"青海省-海南藏族自治州-同德县\": [100.585424, 35.259858],\n  \"青海省-海南藏族自治州-贵德县\": [101.439533, 36.046158],\n  \"青海省-海南藏族自治州-兴海县\": [99.99438, 35.59463],\n  \"青海省-海南藏族自治州-贵南县\": [100.753593, 35.592415],\n  \"青海省-果洛藏族自治州\": [100.251592, 34.477194],\n  \"青海省-果洛藏族自治州-玛沁县\": [100.245564, 34.483569],\n  \"青海省-果洛藏族自治州-班玛县\": [100.743605, 32.938504],\n  \"青海省-果洛藏族自治州-甘德县\": [99.907511, 33.975004],\n  \"青海省-果洛藏族自治州-达日县\": [99.65801, 33.754937],\n  \"青海省-果洛藏族自治州-久治县\": [101.488532, 33.434773],\n  \"青海省-果洛藏族自治州-玛多县\": [98.215884, 34.920749],\n  \"青海省-玉树藏族自治州\": [97.013181, 33.01098],\n  \"青海省-玉树藏族自治州-玉树市\": [97.015376, 32.999556],\n  \"青海省-玉树藏族自治州-杂多县\": [95.306965, 32.899241],\n  \"青海省-玉树藏族自治州-称多县\": [97.115, 33.374226],\n  \"青海省-玉树藏族自治州-治多县\": [95.619794, 33.857953],\n  \"青海省-玉树藏族自治州-囊谦县\": [96.486918, 32.209194],\n  \"青海省-玉树藏族自治州-曲麻莱县\": [95.80375, 34.132299],\n  \"青海省-海西蒙古族藏族自治州\": [97.376299, 37.38275],\n  \"青海省-海西蒙古族藏族自治州-格尔木市\": [94.93331, 36.412371],\n  \"青海省-海西蒙古族藏族自治州-德令哈市\": [97.36747, 37.375346],\n  \"青海省-海西蒙古族藏族自治州-乌兰县\": [98.486736, 36.935748],\n  \"青海省-海西蒙古族藏族自治州-都兰县\": [98.102705, 36.307611],\n  \"青海省-海西蒙古族藏族自治州-天峻县\": [99.029243, 37.306903],\n  \"宁夏回族自治区\": [106.265605, 38.476878],\n  \"宁夏回族自治区-银川市\": [106.238494, 38.49246],\n  \"宁夏回族自治区-银川市-兴庆区\": [106.295494, 38.479579],\n  \"宁夏回族自治区-银川市-西夏区\": [106.156581, 38.496817],\n  \"宁夏回族自治区-银川市-金凤区\": [106.249561, 38.478695],\n  \"宁夏回族自治区-银川市-永宁县\": [106.259605, 38.283001],\n  \"宁夏回族自治区-银川市-贺兰县\": [106.356518, 38.560407],\n  \"宁夏回族自治区-银川市-灵武市\": [106.34644, 38.108659],\n  \"宁夏回族自治区-石嘴山市\": [106.3906, 38.989683],\n  \"宁夏回族自治区-石嘴山市-大武口区\": [106.37461, 39.024848],\n  \"宁夏回族自治区-石嘴山市-惠农区\": [106.78843, 39.245388],\n  \"宁夏回族自治区-石嘴山市-平罗县\": [106.536518, 38.919607],\n  \"宁夏回族自治区-吴忠市\": [106.205371, 38.003713],\n  \"宁夏回族自治区-吴忠市-利通区\": [106.219407, 37.990746],\n  \"宁夏回族自治区-吴忠市-红寺堡区\": [106.068421, 37.431882],\n  \"宁夏回族自治区-吴忠市-盐池县\": [107.41338, 37.789296],\n  \"宁夏回族自治区-吴忠市-同心县\": [105.920599, 36.98627],\n  \"宁夏回族自治区-吴忠市-青铜峡市\": [106.08537, 38.027412],\n  \"宁夏回族自治区-固原市\": [106.248577, 36.021617],\n  \"宁夏回族自治区-固原市-原州区\": [106.294515, 36.009368],\n  \"宁夏回族自治区-固原市-西吉县\": [105.735386, 35.970076],\n  \"宁夏回族自治区-固原市-隆德县\": [106.118498, 35.631762],\n  \"宁夏回族自治区-固原市-泾源县\": [106.337393, 35.504362],\n  \"宁夏回族自治区-固原市-彭阳县\": [106.644544, 35.855405],\n  \"宁夏回族自治区-中卫市\": [105.203571, 37.505701],\n  \"宁夏回族自治区-中卫市-沙坡头区\": [105.203571, 37.505701],\n  \"宁夏回族自治区-中卫市-中宁县\": [105.691537, 37.497421],\n  \"宁夏回族自治区-中卫市-海原县\": [105.650555, 36.570781],\n  \"新疆维吾尔自治区\": [87.633473, 43.799238],\n  \"新疆维吾尔自治区-乌鲁木齐市\": [87.62444, 43.830763],\n  \"新疆维吾尔自治区-乌鲁木齐市-天山区\": [87.638408, 43.800271],\n  \"新疆维吾尔自治区-乌鲁木齐市-沙依巴克区\": [87.60467, 43.807262],\n  \"新疆维吾尔自治区-乌鲁木齐市-新市区\": [87.575908, 43.861394],\n  \"新疆维吾尔自治区-乌鲁木齐市-水磨沟区\": [87.575908, 43.861394],\n  \"新疆维吾尔自治区-乌鲁木齐市-头屯河区\": [87.434507, 43.882653],\n  \"新疆维吾尔自治区-乌鲁木齐市-达坂城区\": [88.317398, 43.369943],\n  \"新疆维吾尔自治区-乌鲁木齐市-米东区\": [87.662134, 43.979247],\n  \"新疆维吾尔自治区-乌鲁木齐市-乌鲁木齐县\": [87.416029, 43.477086],\n  \"新疆维吾尔自治区-克拉玛依市\": [84.895901, 45.585675],\n  \"新疆维吾尔自治区-克拉玛依市-独山子区\": [84.893613, 44.334407],\n  \"新疆维吾尔自治区-克拉玛依市-克拉玛依区\": [84.866222, 45.596624],\n  \"新疆维吾尔自治区-克拉玛依市-白碱滩区\": [85.13951, 45.693952],\n  \"新疆维吾尔自治区-克拉玛依市-乌尔禾区\": [85.700305, 46.095295],\n  \"新疆维吾尔自治区-吐鲁番市\": [89.192459, 42.948549],\n  \"新疆维吾尔自治区-吐鲁番市-高昌区\": [89.192459, 42.948549],\n  \"新疆维吾尔自治区-吐鲁番市-鄯善县\": [90.220094, 42.874759],\n  \"新疆维吾尔自治区-吐鲁番市-托克逊县\": [88.660164, 42.798546],\n  \"新疆维吾尔自治区-哈密市\": [93.521308, 42.832856],\n  \"新疆维吾尔自治区-哈密市-伊州区\": [93.519883, 42.825878],\n  \"新疆维吾尔自治区-哈密市-巴里坤哈萨克自治县\": [93.022931, 43.605689],\n  \"新疆维吾尔自治区-哈密市-伊吾县\": [94.703826, 43.260677],\n  \"新疆维吾尔自治区-昌吉回族自治州\": [87.315002, 44.016854],\n  \"新疆维吾尔自治区-昌吉回族自治州-昌吉市\": [87.273865, 44.020127],\n  \"新疆维吾尔自治区-昌吉回族自治州-阜康市\": [87.273865, 44.020127],\n  \"新疆维吾尔自治区-昌吉回族自治州-呼图壁县\": [86.905144, 44.197655],\n  \"新疆维吾尔自治区-昌吉回族自治州-玛纳斯县\": [86.220643, 44.310063],\n  \"新疆维吾尔自治区-昌吉回族自治州-奇台县\": [89.601081, 44.026898],\n  \"新疆维吾尔自治区-昌吉回族自治州-吉木萨尔县\": [89.187123, 44.005718],\n  \"新疆维吾尔自治区-昌吉回族自治州-木垒哈萨克自治县\": [90.292515, 43.840308],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州\": [82.072915, 44.912196],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-博乐市\": [82.057972, 44.86001],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-阿拉山口市\": [82.057972, 44.86001],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-精河县\": [82.900655, 44.606646],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-温泉县\": [81.031146, 44.974857],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州\": [86.151714, 41.770287],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-库尔勒市\": [86.181494, 41.732373],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-轮台县\": [86.181494, 41.732373],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-尉犁县\": [86.266037, 41.350123],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-若羌县\": [88.175324, 39.028991],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-且末县\": [85.53599, 38.151388],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-焉耆回族自治县\": [86.581222, 42.064851],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-和静县\": [86.390398, 42.329365],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-和硕县\": [86.883689, 42.288065],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-博湖县\": [86.638469, 41.98643],\n  \"新疆维吾尔自治区-阿克苏地区\": [80.266943, 41.17503],\n  \"新疆维吾尔自治区-阿克苏地区-阿克苏市\": [80.269927, 41.17386],\n  \"新疆维吾尔自治区-阿克苏地区-温宿县\": [80.245564, 41.282567],\n  \"新疆维吾尔自治区-阿克苏地区-库车县\": [82.968459, 41.723448],\n  \"新疆维吾尔自治区-阿克苏地区-沙雅县\": [82.788824, 41.227749],\n  \"新疆维吾尔自治区-阿克苏地区-新和县\": [82.615823, 41.554],\n  \"新疆维吾尔自治区-阿克苏地区-拜城县\": [81.858516, 41.800707],\n  \"新疆维吾尔自治区-阿克苏地区-乌什县\": [79.230869, 41.220871],\n  \"新疆维吾尔自治区-阿克苏地区-阿瓦提县\": [80.381849, 40.649359],\n  \"新疆维吾尔自治区-阿克苏地区-柯坪县\": [79.053214, 40.514055],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州\": [76.174309, 39.720471],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿图什市\": [76.174906, 39.722079],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿克陶县\": [75.953725, 39.153889],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿合奇县\": [75.953725, 39.153889],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-乌恰县\": [75.265334, 39.725124],\n  \"新疆维吾尔自治区-喀什地区\": [75.996391, 39.476097],\n  \"新疆维吾尔自治区-喀什地区-喀什市\": [76.000313, 39.47365],\n  \"新疆维吾尔自治区-喀什地区-疏附县\": [75.869169, 39.381292],\n  \"新疆维吾尔自治区-喀什地区-疏勒县\": [76.056614, 39.406709],\n  \"新疆维吾尔自治区-喀什地区-英吉沙县\": [76.182075, 38.935671],\n  \"新疆维吾尔自治区-喀什地区-泽普县\": [77.266559, 38.190725],\n  \"新疆维吾尔自治区-喀什地区-莎车县\": [77.252437, 38.420157],\n  \"新疆维吾尔自治区-喀什地区-叶城县\": [77.420098, 37.889167],\n  \"新疆维吾尔自治区-喀什地区-麦盖提县\": [77.658824, 38.911194],\n  \"新疆维吾尔自治区-喀什地区-岳普湖县\": [76.784148, 39.239387],\n  \"新疆维吾尔自治区-喀什地区-伽师县\": [76.730386, 39.493852],\n  \"新疆维吾尔自治区-喀什地区-巴楚县\": [78.555701, 39.790788],\n  \"新疆维吾尔自治区-喀什地区-塔什库尔干塔吉克自治县\": [75.230805, 37.779046],\n  \"新疆维吾尔自治区-和田地区\": [79.928507, 37.120446],\n  \"新疆维吾尔自治区-和田地区-和田市\": [79.920212, 37.118336],\n  \"新疆维吾尔自治区-和田地区-和田县\": [79.866216, 37.090362],\n  \"新疆维吾尔自治区-和田地区-墨玉县\": [79.735479, 37.282993],\n  \"新疆维吾尔自治区-和田地区-皮山县\": [78.289871, 37.627249],\n  \"新疆维吾尔自治区-和田地区-洛浦县\": [80.195388, 37.079611],\n  \"新疆维吾尔自治区-和田地区-策勒县\": [80.813201, 37.004122],\n  \"新疆维吾尔自治区-和田地区-于田县\": [81.683783, 36.862954],\n  \"新疆维吾尔自治区-和田地区-民丰县\": [82.702713, 37.070257],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州\": [81.330538, 43.922723],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-伊宁市\": [81.284242, 43.915299],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-奎屯市\": [84.909449, 44.432057],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-霍尔果斯市\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-伊宁县\": [81.533906, 43.982909],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-察布查尔锡伯自治县\": [81.157925, 43.84669],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-霍城县\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-巩留县\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-新源县\": [83.267022, 43.435927],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-昭苏县\": [81.137378, 43.163497],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-特克斯县\": [81.842587, 43.224248],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-尼勒克县\": [82.518007, 43.804595],\n  \"新疆维吾尔自治区-塔城地区\": [82.987236, 46.750948],\n  \"新疆维吾尔自治区-塔城地区-塔城市\": [82.985532, 46.754347],\n  \"新疆维吾尔自治区-塔城地区-乌苏市\": [84.720088, 44.424048],\n  \"新疆维吾尔自治区-塔城地区-额敏县\": [83.633374, 46.531885],\n  \"新疆维吾尔自治区-塔城地区-沙湾县\": [85.626145, 44.331949],\n  \"新疆维吾尔自治区-塔城地区-托里县\": [83.612909, 45.942743],\n  \"新疆维吾尔自治区-塔城地区-裕民县\": [82.989439, 46.207454],\n  \"新疆维吾尔自治区-塔城地区-和布克赛尔蒙古自治县\": [85.735009, 46.798685],\n  \"新疆维吾尔自治区-阿勒泰地区\": [88.147926, 47.850728],\n  \"新疆维吾尔自治区-阿勒泰地区-阿勒泰市\": [88.139227, 47.832753],\n  \"新疆维吾尔自治区-阿勒泰地区-布尔津县\": [86.88136, 47.707952],\n  \"新疆维吾尔自治区-阿勒泰地区-富蕴县\": [89.531953, 46.999951],\n  \"新疆维吾尔自治区-阿勒泰地区-福海县\": [87.493157, 47.118141],\n  \"新疆维吾尔自治区-阿勒泰地区-哈巴河县\": [86.424818, 48.066149],\n  \"新疆维吾尔自治区-阿勒泰地区-青河县\": [90.389444, 46.680194],\n  \"新疆维吾尔自治区-阿勒泰地区-吉木乃县\": [85.880818, 47.449018],\n  \"新疆维吾尔自治区-石河子市\": [86.086886, 44.311976],\n  \"新疆维吾尔自治区-阿拉尔市\": [81.287354, 40.553264],\n  \"新疆维吾尔自治区-图木舒克市\": [79.075616, 39.871209],\n  \"新疆维吾尔自治区-五家渠市\": [87.549937, 44.172445],\n  \"新疆维吾尔自治区-铁门关市\": [86.181494, 41.732373],\n  \"香港特别行政区\": [114.173825, 22.337784],\n  \"香港特别行政区-中西區\": [114.159491, 22.291343],\n  \"香港特别行政区-灣仔區\": [114.18355, 22.283159],\n  \"香港特别行政区-東區\": [114.235426, 22.287684],\n  \"香港特别行政区-南區\": [114.165543, 22.251947],\n  \"香港特别行政区-油尖旺區\": [114.178545, 22.306584],\n  \"香港特别行政区-深水埗區\": [114.181574, 22.345029],\n  \"香港特别行政区-九龍城區\": [114.198554, 22.325723],\n  \"香港特别行政区-黃大仙區\": [114.205553, 22.344517],\n  \"香港特别行政区-觀塘區\": [114.237431, 22.316804],\n  \"香港特别行政区-荃灣區\": [114.126441, 22.378244],\n  \"香港特别行政区-屯門區\": [113.987456, 22.393585],\n  \"香港特别行政区-元朗區\": [114.03851, 22.448565],\n  \"香港特别行政区-北區\": [114.149484, 22.498024],\n  \"香港特别行政区-大埔區\": [114.175565, 22.453814],\n  \"香港特别行政区-西貢區\": [114.283525, 22.385077],\n  \"香港特别行政区-沙田區\": [114.198551, 22.388522],\n  \"香港特别行政区-葵青區\": [114.143475, 22.366619],\n  \"香港特别行政区-離島區\": [113.951547, 22.286066],\n  \"澳门特别行政区\": [113.560161, 22.214787],\n  \"澳门特别行政区-花地瑪堂區\": [113.55751, 22.212784],\n  \"澳门特别行政区-花王堂區\": [113.550294, 22.202058],\n  \"澳门特别行政区-望德堂區\": [113.561514, 22.202511],\n  \"澳门特别行政区-大堂區\": [113.561167, 22.192801],\n  \"澳门特别行政区-風順堂區\": [113.545451, 22.192783],\n  \"澳门特别行政区-嘉模堂區\": [113.565515, 22.163142],\n  \"澳门特别行政区-路氹填海區\": [113.570544, 22.146272],\n  \"台湾省\": [86.181494, 41.732373],\n  \"台湾省-台北市 \": [121.539414, 25.073653],\n  \"台湾省-高雄市\": [120.315994, 22.679904],\n  \"曾母暗沙\": [111.79862, 4.008237]\n}\n```\n","source":"_posts/20210908-中国城市坐标-包含市辖区.md","raw":"---\ntitle: 中国城市坐标(包含市辖区)\ndate: 2021-09-08 16:07:03\ntags:\n  - 资源\ncategories:\n  - 资源\n---\n\n================\n\n<!-- more -->\n\n原文地址：https://www.cnblogs.com/henuyuxiang/p/12981201.html\n\n```json\n{\n  \"全国\": [116.413384, 39.910925],\n  \"北京市\": [116.413384, 39.910925],\n  \"北京市-市辖区\": [116.413384, 39.910925],\n  \"北京市-市辖区-东城区\": [116.422401, 39.934827],\n  \"北京市-市辖区-西城区\": [116.372514, 39.918124],\n  \"北京市-市辖区-朝阳区\": [116.449559, 39.926375],\n  \"北京市-市辖区-丰台区\": [116.292402, 39.864937],\n  \"北京市-市辖区-石景山区\": [116.229613, 39.911354],\n  \"北京市-市辖区-海淀区\": [116.305434, 39.96549],\n  \"北京市-市辖区-门头沟区\": [116.107604, 39.946147],\n  \"北京市-市辖区-房山区\": [116.149444, 39.754326],\n  \"北京市-市辖区-通州区\": [116.663415, 39.916017],\n  \"北京市-市辖区-顺义区\": [116.661424, 40.136351],\n  \"北京市-市辖区-昌平区\": [116.237618, 40.226413],\n  \"北京市-市辖区-大兴区\": [116.348625, 39.732555],\n  \"北京市-市辖区-怀柔区\": [116.638386, 40.322618],\n  \"北京市-市辖区-平谷区\": [117.127379, 40.146951],\n  \"北京市-市辖区-密云区\": [116.849547, 40.382176],\n  \"北京市-市辖区-延庆区\": [115.981632, 40.462169],\n  \"天津市\": [117.209523, 39.093668],\n  \"天津市-市辖区\": [117.209523, 39.093668],\n  \"天津市-市辖区-和平区\": [117.221467, 39.12339],\n  \"天津市-市辖区-河东区\": [117.258413, 39.134487],\n  \"天津市-市辖区-河西区\": [117.229416, 39.115718],\n  \"天津市-市辖区-南开区\": [117.156515, 39.144105],\n  \"天津市-市辖区-河北区\": [117.203593, 39.153485],\n  \"天津市-市辖区-红桥区\": [117.157518, 39.173286],\n  \"天津市-市辖区-东丽区\": [117.320569, 39.092332],\n  \"天津市-市辖区-西青区\": [117.01441, 39.148727],\n  \"天津市-市辖区-津南区\": [117.363387, 38.944148],\n  \"天津市-市辖区-北辰区\": [117.141403, 39.230344],\n  \"天津市-市辖区-武清区\": [117.050597, 39.389871],\n  \"天津市-市辖区-宝坻区\": [117.316601, 39.723194],\n  \"天津市-市辖区-滨海新区\": [117.717399, 39.009416],\n  \"天津市-市辖区-宁河区\": [117.832393, 39.336956],\n  \"天津市-市辖区-静海区\": [116.980469, 38.953371],\n  \"天津市-市辖区-蓟州区\": [117.414579, 40.051509],\n  \"河北省\": [114.536596, 38.043202],\n  \"河北省-石家庄市\": [114.521532, 38.048312],\n  \"河北省-石家庄市-长安区\": [114.545612, 38.043256],\n  \"河北省-石家庄市-桥西区\": [114.46742, 38.010381],\n  \"河北省-石家庄市-新华区\": [114.469438, 38.05712],\n  \"河北省-石家庄市-井陉矿区\": [114.068632, 38.070566],\n  \"河北省-石家庄市-裕华区\": [114.537583, 38.012088],\n  \"河北省-石家庄市-藁城区\": [114.853378, 38.027817],\n  \"河北省-石家庄市-鹿泉区\": [114.320598, 38.091749],\n  \"河北省-石家庄市-栾城区\": [114.654576, 37.905816],\n  \"河北省-石家庄市-井陉县\": [114.151463, 38.038386],\n  \"河北省-石家庄市-正定县\": [114.577481, 38.151714],\n  \"河北省-石家庄市-行唐县\": [114.559607, 38.444239],\n  \"河北省-石家庄市-灵寿县\": [114.389478, 38.314629],\n  \"河北省-石家庄市-高邑县\": [114.618413, 37.62188],\n  \"河北省-石家庄市-深泽县\": [115.207404, 38.190451],\n  \"河北省-石家庄市-赞皇县\": [114.392464, 37.671667],\n  \"河北省-石家庄市-无极县\": [114.982439, 38.185436],\n  \"河北省-石家庄市-平山县\": [113.985435, 38.271951],\n  \"河北省-石家庄市-元氏县\": [114.532566, 37.772339],\n  \"河北省-石家庄市-赵县\": [114.782597, 37.761859],\n  \"河北省-石家庄市-晋州市\": [115.050529, 38.039491],\n  \"河北省-石家庄市-新乐市\": [114.690532, 38.349293],\n  \"河北省-唐山市\": [118.186459, 39.636584],\n  \"河北省-唐山市-路南区\": [118.160607, 39.631043],\n  \"河北省-唐山市-路北区\": [118.206399, 39.630661],\n  \"河北省-唐山市-古冶区\": [118.453401, 39.739736],\n  \"河北省-唐山市-开平区\": [118.268608, 39.677144],\n  \"河北省-唐山市-丰南区\": [118.090366, 39.58154],\n  \"河北省-唐山市-丰润区\": [118.168541, 39.838353],\n  \"河北省-唐山市-曹妃甸区\": [118.46646, 39.279284],\n  \"河北省-唐山市-滦县\": [118.71048, 39.747116],\n  \"河北省-唐山市-滦南县\": [118.680405, 39.510045],\n  \"河北省-唐山市-乐亭县\": [118.919384, 39.431931],\n  \"河北省-唐山市-迁西县\": [118.320384, 40.147837],\n  \"河北省-唐山市-玉田县\": [117.745434, 39.906592],\n  \"河北省-唐山市-遵化市\": [117.972375, 40.195533],\n  \"河北省-唐山市-迁安市\": [118.706457, 40.004184],\n  \"河北省-秦皇岛市\": [119.608531, 39.941748],\n  \"河北省-秦皇岛市-海港区\": [119.617475, 39.940413],\n  \"河北省-秦皇岛市-山海关区\": [119.782435, 39.984446],\n  \"河北省-秦皇岛市-北戴河区\": [119.491526, 39.841006],\n  \"河北省-秦皇岛市-抚宁区\": [119.251549, 39.881414],\n  \"河北省-秦皇岛市-青龙满族自治县\": [118.956481, 40.412794],\n  \"河北省-秦皇岛市-昌黎县\": [119.169375, 39.719051],\n  \"河北省-秦皇岛市-卢龙县\": [118.899489, 39.897958],\n  \"河北省-邯郸市\": [114.545628, 36.631263],\n  \"河北省-邯郸市-邯山区\": [114.496389, 36.586692],\n  \"河北省-邯郸市-丛台区\": [114.499433, 36.642673],\n  \"河北省-邯郸市-复兴区\": [114.479412, 36.623325],\n  \"河北省-邯郸市-峰峰矿区\": [114.219483, 36.425654],\n  \"河北省-邯郸市-邯郸县\": [114.537309, 36.599675],\n  \"河北省-邯郸市-临漳县\": [114.626427, 36.340766],\n  \"河北省-邯郸市-成安县\": [114.676577, 36.449796],\n  \"河北省-邯郸市-大名县\": [115.154613, 36.291288],\n  \"河北省-邯郸市-涉县\": [113.697584, 36.590692],\n  \"河北省-邯郸市-磁县\": [114.380432, 36.380359],\n  \"河北省-邯郸市-肥乡县\": [114.806547, 36.553825],\n  \"河北省-邯郸市-永年县\": [114.550625, 36.747569],\n  \"河北省-邯郸市-邱县\": [115.193395, 36.817362],\n  \"河北省-邯郸市-鸡泽县\": [114.896586, 36.916398],\n  \"河北省-邯郸市-广平县\": [114.954415, 36.48978],\n  \"河北省-邯郸市-馆陶县\": [115.288537, 36.553957],\n  \"河北省-邯郸市-魏县\": [114.94545, 36.366156],\n  \"河北省-邯郸市-曲周县\": [114.963404, 36.771545],\n  \"河北省-邯郸市-武安市\": [114.210516, 36.702488],\n  \"河北省-邢台市\": [114.511462, 37.076686],\n  \"河北省-邢台市-桥东区\": [114.513471, 37.07375],\n  \"河北省-邢台市-桥西区\": [114.474393, 37.066172],\n  \"河北省-邢台市-邢台县\": [114.143411, 37.177109],\n  \"河北省-邢台市-临城县\": [114.505443, 37.450789],\n  \"河北省-邢台市-内丘县\": [114.518493, 37.292858],\n  \"河北省-邢台市-柏乡县\": [114.699497, 37.488759],\n  \"河北省-邢台市-隆尧县\": [114.776616, 37.355908],\n  \"河北省-邢台市-任县\": [114.678606, 37.126727],\n  \"河北省-邢台市-南和县\": [114.690548, 37.010998],\n  \"河北省-邢台市-宁晋县\": [114.925562, 37.625612],\n  \"河北省-邢台市-巨鹿县\": [115.043587, 37.227088],\n  \"河北省-邢台市-新河县\": [115.248547, 37.534591],\n  \"河北省-邢台市-广宗县\": [115.149605, 37.080457],\n  \"河北省-邢台市-平乡县\": [115.036582, 37.069096],\n  \"河北省-邢台市-威县\": [115.273618, 36.981582],\n  \"河北省-邢台市-清河县\": [115.674394, 37.046375],\n  \"河北省-邢台市-临西县\": [115.507629, 36.87676],\n  \"河北省-邢台市-南宫市\": [115.414529, 37.364069],\n  \"河北省-邢台市-沙河市\": [114.509474, 36.861127],\n  \"河北省-保定市\": [115.471464, 38.879988],\n  \"河北省-保定市-竞秀区\": [115.465434, 38.883788],\n  \"河北省-保定市-莲池区\": [115.535488, 38.860676],\n  \"河北省-保定市-满城区\": [115.328375, 38.955441],\n  \"河北省-保定市-清苑区\": [115.496606, 38.771002],\n  \"河北省-保定市-徐水区\": [115.66248, 39.024713],\n  \"河北省-保定市-涞水县\": [115.720543, 39.400334],\n  \"河北省-保定市-阜平县\": [114.201563, 38.855351],\n  \"河北省-保定市-定兴县\": [115.81441, 39.269424],\n  \"河北省-保定市-唐县\": [114.989447, 38.75402],\n  \"河北省-保定市-高阳县\": [115.785447, 38.706258],\n  \"河北省-保定市-容城县\": [115.868631, 39.048559],\n  \"河北省-保定市-涞源县\": [114.700476, 39.366272],\n  \"河北省-保定市-望都县\": [115.161588, 38.700158],\n  \"河北省-保定市-安新县\": [115.942426, 38.941734],\n  \"河北省-保定市-易县\": [115.503607, 39.355054],\n  \"河北省-保定市-曲阳县\": [114.751455, 38.628384],\n  \"河北省-保定市-蠡县\": [115.590445, 38.494201],\n  \"河北省-保定市-顺平县\": [115.141597, 38.843261],\n  \"河北省-保定市-博野县\": [115.470467, 38.463408],\n  \"河北省-保定市-雄县\": [116.114601, 39.00018],\n  \"河北省-保定市-涿州市\": [115.98162, 39.491066],\n  \"河北省-保定市-安国市\": [115.333408, 38.424828],\n  \"河北省-保定市-高碑店市\": [115.880569, 39.332335],\n  \"河北省-张家口市\": [114.892572, 40.773237],\n  \"河北省-张家口市-桥东区\": [114.900606, 40.794268],\n  \"河北省-张家口市-桥西区\": [114.876516, 40.825606],\n  \"河北省-张家口市-宣化区\": [115.105444, 40.614592],\n  \"河北省-张家口市-下花园区\": [115.293517, 40.508145],\n  \"河北省-张家口市-万全区\": [114.747426, 40.77315],\n  \"河北省-张家口市-崇礼区\": [115.289549, 40.980478],\n  \"河北省-张家口市-张北县\": [114.726375, 41.164944],\n  \"河北省-张家口市-康保县\": [114.606356, 41.858637],\n  \"河北省-张家口市-沽源县\": [115.695407, 41.676016],\n  \"河北省-张家口市-尚义县\": [113.975524, 41.081888],\n  \"河北省-张家口市-蔚县\": [114.595401, 39.847089],\n  \"河北省-张家口市-阳原县\": [114.157524, 40.109588],\n  \"河北省-张家口市-怀安县\": [114.392469, 40.680369],\n  \"河北省-张家口市-怀来县\": [115.524553, 40.42029],\n  \"河北省-张家口市-涿鹿县\": [115.211383, 40.385834],\n  \"河北省-张家口市-赤城县\": [115.838506, 40.918761],\n  \"河北省-承德市\": [117.969398, 40.957856],\n  \"河北省-承德市-双桥区\": [117.949428, 40.980824],\n  \"河北省-承德市-双滦区\": [117.806578, 40.964729],\n  \"河北省-承德市-鹰手营子矿区\": [117.665609, 40.552043],\n  \"河北省-承德市-承德县\": [118.180456, 40.774367],\n  \"河北省-承德市-兴隆县\": [117.507427, 40.423454],\n  \"河北省-承德市-平泉县\": [118.707427, 41.023756],\n  \"河北省-承德市-滦平县\": [117.339498, 40.947561],\n  \"河北省-承德市-隆化县\": [117.745451, 41.319899],\n  \"河北省-承德市-丰宁满族自治县\": [116.652393, 41.215336],\n  \"河北省-承德市-宽城满族自治县\": [118.491594, 40.617152],\n  \"河北省-承德市-围场满族蒙古族自治县\": [117.766564, 41.944324],\n  \"河北省-沧州市\": [116.845581, 38.310215],\n  \"河北省-沧州市-新华区\": [116.872433, 38.320367],\n  \"河北省-沧州市-运河区\": [116.838612, 38.316523],\n  \"河北省-沧州市-沧县\": [116.884398, 38.299453],\n  \"河北省-沧州市-青县\": [116.810575, 38.588465],\n  \"河北省-沧州市-东光县\": [116.54341, 37.894514],\n  \"河北省-沧州市-海兴县\": [117.504418, 38.149402],\n  \"河北省-沧州市-盐山县\": [117.237414, 38.064318],\n  \"河北省-沧州市-肃宁县\": [115.836518, 38.428906],\n  \"河北省-沧州市-南皮县\": [116.715601, 38.045188],\n  \"河北省-沧州市-吴桥县\": [116.397392, 37.633909],\n  \"河北省-沧州市-献县\": [116.12956, 38.195981],\n  \"河北省-沧州市-孟村回族自治县\": [117.110436, 38.059839],\n  \"河北省-沧州市-泊头市\": [116.584628, 38.089257],\n  \"河北省-沧州市-任丘市\": [116.105605, 38.717349],\n  \"河北省-沧州市-黄骅市\": [117.336481, 38.377494],\n  \"河北省-沧州市-河间市\": [116.105628, 38.451357],\n  \"河北省-廊坊市\": [116.690582, 39.543367],\n  \"河北省-廊坊市-安次区\": [116.709633, 39.52616],\n  \"河北省-廊坊市-广阳区\": [116.717614, 39.528611],\n  \"河北省-廊坊市-固安县\": [116.30542, 39.444485],\n  \"河北省-廊坊市-永清县\": [116.505429, 39.327853],\n  \"河北省-廊坊市-香河县\": [117.012402, 39.767939],\n  \"河北省-廊坊市-大城县\": [116.660409, 38.710859],\n  \"河北省-廊坊市-文安县\": [116.464609, 38.87895],\n  \"河北省-廊坊市-大厂回族自治县\": [116.996409, 39.892208],\n  \"河北省-廊坊市-霸州市\": [116.398397, 39.130921],\n  \"河北省-廊坊市-三河市\": [117.084588, 39.9881],\n  \"河北省-衡水市\": [115.675406, 37.745191],\n  \"河北省-衡水市-桃城区\": [115.681395, 37.741637],\n  \"河北省-衡水市-冀州区\": [115.58543, 37.557086],\n  \"河北省-衡水市-枣强县\": [115.730563, 37.519364],\n  \"河北省-衡水市-武邑县\": [115.894514, 37.807764],\n  \"河北省-衡水市-武强县\": [115.989614, 38.046857],\n  \"河北省-衡水市-饶阳县\": [115.732572, 38.241038],\n  \"河北省-衡水市-安平县\": [115.525549, 38.240507],\n  \"河北省-衡水市-故城县\": [115.972602, 37.353348],\n  \"河北省-衡水市-景县\": [116.277411, 37.698815],\n  \"河北省-衡水市-阜城县\": [116.182422, 37.868732],\n  \"河北省-衡水市-深州市\": [115.566369, 38.006941],\n  \"河北省-定州市\": [114.996496, 38.522199],\n  \"河北省-辛集市\": [115.224451, 37.949309],\n  \"山西省\": [112.569376, 37.879829],\n  \"山西省-太原市\": [112.556391, 37.876989],\n  \"山西省-太原市-小店区\": [112.572396, 37.742323],\n  \"山西省-太原市-迎泽区\": [112.569385, 37.869532],\n  \"山西省-太原市-杏花岭区\": [112.576383, 37.900186],\n  \"山西省-太原市-尖草坪区\": [112.493605, 37.945943],\n  \"山西省-太原市-万柏林区\": [112.522577, 37.864974],\n  \"山西省-太原市-晋源区\": [112.484564, 37.721169],\n  \"山西省-太原市-清徐县\": [112.364558, 37.613067],\n  \"山西省-太原市-阳曲县\": [112.679409, 38.064621],\n  \"山西省-太原市-娄烦县\": [111.803591, 38.073195],\n  \"山西省-太原市-古交市\": [112.182453, 37.913],\n  \"山西省-大同市\": [113.306436, 40.082469],\n  \"山西省-大同市-城区\": [113.304425, 40.081998],\n  \"山西省-大同市-矿区\": [113.162402, 39.996839],\n  \"山西省-大同市-南郊区\": [113.162402, 39.996839],\n  \"山西省-大同市-新荣区\": [113.146444, 40.261971],\n  \"山西省-大同市-阳高县\": [113.755414, 40.367392],\n  \"山西省-大同市-天镇县\": [114.097478, 40.426412],\n  \"山西省-大同市-广灵县\": [114.288586, 39.766004],\n  \"山西省-大同市-灵丘县\": [114.241368, 39.448825],\n  \"山西省-大同市-浑源县\": [113.7056, 39.698953],\n  \"山西省-大同市-左云县\": [112.709463, 40.019623],\n  \"山西省-大同市-大同县\": [113.618471, 40.04623],\n  \"山西省-阳泉市\": [113.587617, 37.862361],\n  \"山西省-阳泉市-城区\": [113.606568, 37.853433],\n  \"山西省-阳泉市-矿区\": [113.561521, 37.874409],\n  \"山西省-阳泉市-郊区\": [113.600603, 37.950353],\n  \"山西省-阳泉市-平定县\": [113.664421, 37.792796],\n  \"山西省-阳泉市-盂县\": [113.41842, 38.09198],\n  \"山西省-长治市\": [113.122559, 36.201268],\n  \"山西省-长治市-城区\": [113.129521, 36.209472],\n  \"山西省-长治市-郊区\": [113.105622, 36.261066],\n  \"山西省-长治市-长治县\": [113.057416, 36.059286],\n  \"山西省-长治市-襄垣县\": [113.057413, 36.541686],\n  \"山西省-长治市-屯留县\": [112.898475, 36.321631],\n  \"山西省-长治市-平顺县\": [113.442517, 36.205989],\n  \"山西省-长治市-黎城县\": [113.393432, 36.50867],\n  \"山西省-长治市-壶关县\": [113.21358, 36.121335],\n  \"山西省-长治市-长子县\": [112.884566, 36.128002],\n  \"山西省-长治市-武乡县\": [112.870606, 36.843168],\n  \"山西省-长治市-沁县\": [112.705458, 36.76219],\n  \"山西省-长治市-沁源县\": [112.344452, 36.506103],\n  \"山西省-长治市-潞城市\": [113.235578, 36.339691],\n  \"山西省-晋城市\": [112.858578, 35.496285],\n  \"山西省-晋城市-城区\": [112.855303, 35.520559],\n  \"山西省-晋城市-沁水县\": [112.193426, 35.696364],\n  \"山西省-晋城市-阳城县\": [112.421454, 35.492181],\n  \"山西省-晋城市-陵川县\": [113.287407, 35.781744],\n  \"山西省-晋城市-泽州县\": [112.794401, 35.59977],\n  \"山西省-晋城市-高平市\": [112.930412, 35.804337],\n  \"山西省-朔州市\": [112.439371, 39.337108],\n  \"山西省-朔州市-朔城区\": [112.438376, 39.325303],\n  \"山西省-朔州市-平鲁区\": [112.295525, 39.517389],\n  \"山西省-朔州市-山阴县\": [112.822432, 39.53403],\n  \"山西省-朔州市-应县\": [113.197494, 39.560078],\n  \"山西省-朔州市-右玉县\": [112.4735, 39.99486],\n  \"山西省-朔州市-怀仁县\": [113.106608, 39.833757],\n  \"山西省-晋中市\": [112.759595, 37.692839],\n  \"山西省-晋中市-榆次区\": [112.714504, 37.70394],\n  \"山西省-晋中市-榆社县\": [112.981599, 37.07637],\n  \"山西省-晋中市-左权县\": [113.385452, 37.088555],\n  \"山西省-晋中市-和顺县\": [113.576606, 37.334808],\n  \"山西省-晋中市-昔阳县\": [113.713613, 37.617884],\n  \"山西省-晋中市-寿阳县\": [113.18341, 37.901308],\n  \"山西省-晋中市-太谷县\": [112.557384, 37.427396],\n  \"山西省-晋中市-祁县\": [112.342442, 37.364131],\n  \"山西省-晋中市-平遥县\": [112.182456, 37.195601],\n  \"山西省-晋中市-灵石县\": [111.785618, 36.853368],\n  \"山西省-晋中市-介休市\": [111.923563, 37.032686],\n  \"山西省-运城市\": [111.013389, 35.032707],\n  \"山西省-运城市-盐湖区\": [111.004377, 35.021425],\n  \"山西省-运城市-临猗县\": [110.780407, 35.149542],\n  \"山西省-运城市-万荣县\": [110.844576, 35.421109],\n  \"山西省-运城市-闻喜县\": [111.23141, 35.362931],\n  \"山西省-运城市-稷山县\": [110.989415, 35.610403],\n  \"山西省-运城市-新绛县\": [111.231406, 35.62263],\n  \"山西省-运城市-绛县\": [111.575487, 35.497276],\n  \"山西省-运城市-垣曲县\": [111.676607, 35.303015],\n  \"山西省-运城市-夏县\": [111.226431, 35.147462],\n  \"山西省-运城市-平陆县\": [111.22348, 34.842925],\n  \"山西省-运城市-芮城县\": [110.700612, 34.699388],\n  \"山西省-运城市-永济市\": [110.454578, 34.87283],\n  \"山西省-运城市-河津市\": [110.718572, 35.601927],\n  \"山西省-忻州市\": [112.740624, 38.422383],\n  \"山西省-忻州市-忻府区\": [112.752614, 38.40988],\n  \"山西省-忻州市-定襄县\": [112.963529, 38.479974],\n  \"山西省-忻州市-五台县\": [113.261451, 38.734182],\n  \"山西省-忻州市-代县\": [112.966552, 39.072728],\n  \"山西省-忻州市-繁峙县\": [113.271408, 39.195237],\n  \"山西省-忻州市-宁武县\": [112.326398, 39.024342],\n  \"山西省-忻州市-静乐县\": [111.945432, 38.365147],\n  \"山西省-忻州市-神池县\": [112.217383, 39.096876],\n  \"山西省-忻州市-五寨县\": [111.85341, 38.91702],\n  \"山西省-忻州市-岢岚县\": [111.579478, 38.710151],\n  \"山西省-忻州市-河曲县\": [111.144449, 39.390702],\n  \"山西省-忻州市-保德县\": [111.092542, 39.028337],\n  \"山西省-忻州市-偏关县\": [111.514474, 39.44223],\n  \"山西省-忻州市-原平市\": [112.717487, 38.736476],\n  \"山西省-临汾市\": [111.52553, 36.093742],\n  \"山西省-临汾市-尧都区\": [111.58643, 36.084562],\n  \"山西省-临汾市-曲沃县\": [111.482396, 35.647327],\n  \"山西省-临汾市-翼城县\": [111.725376, 35.744429],\n  \"山西省-临汾市-襄汾县\": [111.44854, 35.882063],\n  \"山西省-临汾市-洪洞县\": [111.681589, 36.259467],\n  \"山西省-临汾市-古县\": [111.926573, 36.272338],\n  \"山西省-临汾市-安泽县\": [112.256613, 36.153514],\n  \"山西省-临汾市-浮山县\": [111.855385, 35.974393],\n  \"山西省-临汾市-吉县\": [110.688546, 36.103999],\n  \"山西省-临汾市-乡宁县\": [110.853498, 35.976442],\n  \"山西省-临汾市-大宁县\": [110.759384, 36.471306],\n  \"山西省-临汾市-隰县\": [110.947591, 36.699061],\n  \"山西省-临汾市-永和县\": [110.638416, 36.765909],\n  \"山西省-临汾市-蒲县\": [111.102474, 36.418005],\n  \"山西省-临汾市-汾西县\": [111.569546, 36.658782],\n  \"山西省-临汾市-侯马市\": [111.378397, 35.625365],\n  \"山西省-临汾市-霍州市\": [111.761509, 36.574607],\n  \"山西省-吕梁市\": [111.15045, 37.524498],\n  \"山西省-吕梁市-离石区\": [111.157491, 37.523577],\n  \"山西省-吕梁市-文水县\": [112.035599, 37.4443],\n  \"山西省-吕梁市-交城县\": [112.162568, 37.557772],\n  \"山西省-吕梁市-兴县\": [111.134392, 38.468804],\n  \"山西省-吕梁市-临县\": [110.998415, 37.957211],\n  \"山西省-吕梁市-柳林县\": [110.89539, 37.435493],\n  \"山西省-吕梁市-石楼县\": [110.841596, 37.004471],\n  \"山西省-吕梁市-岚县\": [111.678592, 38.285029],\n  \"山西省-吕梁市-方山县\": [111.25037, 37.90102],\n  \"山西省-吕梁市-中阳县\": [111.18563, 37.362873],\n  \"山西省-吕梁市-交口县\": [111.187628, 36.987873],\n  \"山西省-吕梁市-孝义市\": [111.785606, 37.151063],\n  \"山西省-吕梁市-汾阳市\": [111.794597, 37.271292],\n  \"内蒙古自治区\": [111.772606, 40.823156],\n  \"内蒙古自治区-呼和浩特市\": [111.755509, 40.848423],\n  \"内蒙古自治区-呼和浩特市-新城区\": [111.67162, 40.863877],\n  \"内蒙古自治区-呼和浩特市-回民区\": [111.63047, 40.814506],\n  \"内蒙古自治区-呼和浩特市-玉泉区\": [111.681575, 40.758059],\n  \"内蒙古自治区-呼和浩特市-赛罕区\": [111.708421, 40.798394],\n  \"内蒙古自治区-呼和浩特市-土默特左旗\": [111.169587, 40.735294],\n  \"内蒙古自治区-呼和浩特市-托克托县\": [111.200575, 40.283147],\n  \"内蒙古自治区-呼和浩特市-和林格尔县\": [111.82843, 40.384798],\n  \"内蒙古自治区-呼和浩特市-清水河县\": [111.653576, 39.926334],\n  \"内蒙古自治区-呼和浩特市-武川县\": [111.457497, 41.102419],\n  \"内蒙古自治区-包头市\": [109.846544, 40.662929],\n  \"内蒙古自治区-包头市-东河区\": [110.050395, 40.582228],\n  \"内蒙古自治区-包头市-昆都仑区\": [109.845538, 40.647644],\n  \"内蒙古自治区-包头市-青山区\": [109.907416, 40.649473],\n  \"内蒙古自治区-包头市-石拐区\": [110.278381, 40.678299],\n  \"内蒙古自治区-包头市-白云鄂博矿区\": [109.979626, 41.774995],\n  \"内蒙古自治区-包头市-九原区\": [109.969588, 40.613397],\n  \"内蒙古自治区-包头市-土默特右旗\": [110.530389, 40.575127],\n  \"内蒙古自治区-包头市-固阳县\": [110.066433, 41.040163],\n  \"内蒙古自治区-包头市-达尔罕茂明安联合旗\": [110.439521, 41.704549],\n  \"内蒙古自治区-乌海市\": [106.800391, 39.662006],\n  \"内蒙古自治区-乌海市-海勃湾区\": [106.829439, 39.696908],\n  \"内蒙古自治区-乌海市-海南区\": [106.898471, 39.446828],\n  \"内蒙古自治区-乌海市-乌达区\": [106.732606, 39.511469],\n  \"内蒙古自治区-赤峰市\": [118.89552, 42.261686],\n  \"内蒙古自治区-赤峰市-红山区\": [118.963564, 42.270478],\n  \"内蒙古自治区-赤峰市-元宝山区\": [119.295405, 42.045125],\n  \"内蒙古自治区-赤峰市-松山区\": [118.939414, 42.292482],\n  \"内蒙古自治区-赤峰市-阿鲁科尔沁旗\": [120.072614, 43.877953],\n  \"内蒙古自治区-赤峰市-巴林左旗\": [119.386443, 43.976383],\n  \"内蒙古自治区-赤峰市-巴林右旗\": [118.670394, 43.540132],\n  \"内蒙古自治区-赤峰市-林西县\": [118.062461, 43.62421],\n  \"内蒙古自治区-赤峰市-克什克腾旗\": [117.55162, 43.270758],\n  \"内蒙古自治区-赤峰市-翁牛特旗\": [119.012509, 42.942019],\n  \"内蒙古自治区-赤峰市-喀喇沁旗\": [118.710474, 41.932214],\n  \"内蒙古自治区-赤峰市-宁城县\": [119.350609, 41.600245],\n  \"内蒙古自治区-赤峰市-敖汉旗\": [119.927578, 42.296507],\n  \"内蒙古自治区-通辽市\": [122.250522, 43.65798],\n  \"内蒙古自治区-通辽市-科尔沁区\": [122.262457, 43.628712],\n  \"内蒙古自治区-通辽市-科尔沁左翼中旗\": [123.318589, 44.132294],\n  \"内蒙古自治区-通辽市-科尔沁左翼后旗\": [122.363563, 42.939562],\n  \"内蒙古自治区-通辽市-开鲁县\": [121.325386, 43.606369],\n  \"内蒙古自治区-通辽市-库伦旗\": [121.817406, 42.741211],\n  \"内蒙古自治区-通辽市-奈曼旗\": [120.664646, 42.871846],\n  \"内蒙古自治区-通辽市-扎鲁特旗\": [120.918626, 44.562213],\n  \"内蒙古自治区-通辽市-霍林郭勒市\": [119.670466, 45.537513],\n  \"内蒙古自治区-鄂尔多斯市\": [109.787443, 39.614482],\n  \"内蒙古自治区-鄂尔多斯市-东胜区\": [109.96956, 39.827987],\n  \"内蒙古自治区-鄂尔多斯市-康巴什区\": [109.869627, 39.616378],\n  \"内蒙古自治区-鄂尔多斯市-达拉特旗\": [110.040366, 40.418907],\n  \"内蒙古自治区-鄂尔多斯市-准格尔旗\": [111.246398, 39.87054],\n  \"内蒙古自治区-鄂尔多斯市-鄂托克前旗\": [107.484585, 38.188217],\n  \"内蒙古自治区-鄂尔多斯市-鄂托克旗\": [107.982445, 39.095293],\n  \"内蒙古自治区-鄂尔多斯市-杭锦旗\": [108.742413, 39.838816],\n  \"内蒙古自治区-鄂尔多斯市-乌审旗\": [108.824435, 38.610027],\n  \"内蒙古自治区-鄂尔多斯市-伊金霍洛旗\": [109.75459, 39.570093],\n  \"内蒙古自治区-呼伦贝尔市\": [119.77237, 49.218446],\n  \"内蒙古自治区-呼伦贝尔市-海拉尔区\": [119.742465, 49.218216],\n  \"内蒙古自治区-呼伦贝尔市-扎赉诺尔区\": [117.385436, 49.604099],\n  \"内蒙古自治区-呼伦贝尔市-阿荣旗\": [123.46544, 48.131971],\n  \"内蒙古自治区-呼伦贝尔市-莫力达瓦达斡尔族自治旗\": [124.525576, 48.482896],\n  \"内蒙古自治区-呼伦贝尔市-鄂伦春自治旗\": [123.732345, 50.597948],\n  \"内蒙古自治区-呼伦贝尔市-鄂温克族自治旗\": [119.761351, 49.153045],\n  \"内蒙古自治区-呼伦贝尔市-陈巴尔虎旗\": [119.430462, 49.334914],\n  \"内蒙古自治区-呼伦贝尔市-新巴尔虎左旗\": [118.276608, 48.223787],\n  \"内蒙古自治区-呼伦贝尔市-新巴尔虎右旗\": [116.830632, 48.677054],\n  \"内蒙古自治区-呼伦贝尔市-满洲里市\": [117.385436, 49.604099],\n  \"内蒙古自治区-呼伦贝尔市-牙克石市\": [120.718347, 49.292024],\n  \"内蒙古自治区-呼伦贝尔市-扎兰屯市\": [122.744454, 48.019956],\n  \"内蒙古自治区-呼伦贝尔市-额尔古纳市\": [120.186634, 50.248132],\n  \"内蒙古自治区-呼伦贝尔市-根河市\": [121.527585, 50.78614],\n  \"内蒙古自治区-巴彦淖尔市\": [107.394398, 40.749359],\n  \"内蒙古自治区-巴彦淖尔市-临河区\": [107.369534, 40.756681],\n  \"内蒙古自治区-巴彦淖尔市-五原县\": [108.273491, 41.094455],\n  \"内蒙古自治区-巴彦淖尔市-磴口县\": [107.014522, 40.33647],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特前旗\": [108.658615, 40.742104],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特中旗\": [108.519512, 41.593346],\n  \"内蒙古自治区-巴彦淖尔市-乌拉特后旗\": [107.081546, 41.089422],\n  \"内蒙古自治区-巴彦淖尔市-杭锦后旗\": [107.157372, 40.892179],\n  \"内蒙古自治区-乌兰察布市\": [113.139468, 41.000748],\n  \"内蒙古自治区-乌兰察布市-集宁区\": [113.120587, 41.041146],\n  \"内蒙古自治区-乌兰察布市-卓资县\": [112.58441, 40.900292],\n  \"内蒙古自治区-乌兰察布市-化德县\": [114.016409, 41.909603],\n  \"内蒙古自治区-乌兰察布市-商都县\": [113.584639, 41.567567],\n  \"内蒙古自治区-乌兰察布市-兴和县\": [113.840579, 40.879342],\n  \"内蒙古自治区-乌兰察布市-凉城县\": [112.5106, 40.537163],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼前旗\": [113.221605, 40.791267],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼中旗\": [112.64258, 41.283273],\n  \"内蒙古自治区-乌兰察布市-察哈尔右翼后旗\": [113.198531, 41.441771],\n  \"内蒙古自治区-乌兰察布市-四子王旗\": [111.712419, 41.539353],\n  \"内蒙古自治区-乌兰察布市-丰镇市\": [113.116601, 40.441805],\n  \"内蒙古自治区-兴安盟\": [122.044365, 46.088464],\n  \"内蒙古自治区-兴安盟-乌兰浩特市\": [122.099622, 46.078654],\n  \"内蒙古自治区-兴安盟-阿尔山市\": [119.950653, 47.183054],\n  \"内蒙古自治区-兴安盟-科尔沁右翼前旗\": [121.964553, 46.082649],\n  \"内蒙古自治区-兴安盟-科尔沁右翼中旗\": [121.483548, 45.066471],\n  \"内蒙古自治区-兴安盟-扎赉特旗\": [122.906444, 46.72919],\n  \"内蒙古自治区-兴安盟-突泉县\": [121.600545, 45.38783],\n  \"内蒙古自治区-锡林郭勒盟\": [116.054391, 43.939423],\n  \"内蒙古自治区-锡林郭勒盟-二连浩特市\": [111.958363, 43.6488],\n  \"内蒙古自治区-锡林郭勒盟-锡林浩特市\": [116.093614, 43.938334],\n  \"内蒙古自治区-锡林郭勒盟-阿巴嘎旗\": [114.957367, 44.028102],\n  \"内蒙古自治区-锡林郭勒盟-苏尼特左旗\": [113.67348, 43.865554],\n  \"内蒙古自治区-锡林郭勒盟-苏尼特右旗\": [112.648569, 42.747369],\n  \"内蒙古自治区-锡林郭勒盟-东乌珠穆沁旗\": [116.978504, 45.515743],\n  \"内蒙古自治区-锡林郭勒盟-西乌珠穆沁旗\": [117.616377, 44.593803],\n  \"内蒙古自治区-锡林郭勒盟-太仆寺旗\": [115.290535, 41.882292],\n  \"内蒙古自治区-锡林郭勒盟-镶黄旗\": [113.854505, 42.237661],\n  \"内蒙古自治区-锡林郭勒盟-正镶白旗\": [115.036622, 42.292605],\n  \"内蒙古自治区-锡林郭勒盟-正蓝旗\": [115.998604, 42.247119],\n  \"内蒙古自治区-锡林郭勒盟-多伦县\": [116.492509, 42.208921],\n  \"内蒙古自治区-阿拉善盟\": [105.735377, 38.858276],\n  \"内蒙古自治区-阿拉善盟-阿拉善左旗\": [105.672599, 38.839094],\n  \"内蒙古自治区-阿拉善盟-阿拉善右旗\": [101.673464, 39.222241],\n  \"内蒙古自治区-阿拉善盟-额济纳旗\": [101.062403, 41.960298],\n  \"辽宁省\": [123.435598, 41.841465],\n  \"辽宁省-沈阳市\": [123.466452, 41.68879],\n  \"辽宁省-沈阳市-和平区\": [123.426644, 41.795236],\n  \"辽宁省-沈阳市-沈河区\": [123.465461, 41.802274],\n  \"辽宁省-沈阳市-大东区\": [123.476405, 41.811425],\n  \"辽宁省-沈阳市-皇姑区\": [123.431621, 41.826042],\n  \"辽宁省-沈阳市-铁西区\": [123.383436, 41.809038],\n  \"辽宁省-沈阳市-苏家屯区\": [123.350435, 41.671254],\n  \"辽宁省-沈阳市-浑南区\": [123.567539, 41.849226],\n  \"辽宁省-沈阳市-沈北新区\": [123.533605, 42.058914],\n  \"辽宁省-沈阳市-于洪区\": [123.314633, 41.799668],\n  \"辽宁省-沈阳市-辽中区\": [122.772378, 41.523149],\n  \"辽宁省-沈阳市-康平县\": [123.337511, 42.749925],\n  \"辽宁省-沈阳市-法库县\": [123.414621, 42.509607],\n  \"辽宁省-沈阳市-新民市\": [122.875395, 42.007109],\n  \"辽宁省-大连市\": [121.621631, 38.918954],\n  \"辽宁省-大连市-中山区\": [121.651547, 38.924511],\n  \"辽宁省-大连市-西岗区\": [121.618625, 38.920473],\n  \"辽宁省-大连市-沙河口区\": [121.594507, 38.913544],\n  \"辽宁省-大连市-甘井子区\": [121.531519, 38.958002],\n  \"辽宁省-大连市-旅顺口区\": [121.268597, 38.856832],\n  \"辽宁省-大连市-金州区\": [121.789436, 39.056433],\n  \"辽宁省-大连市-普兰店区\": [121.94646, 39.398089],\n  \"辽宁省-大连市-长海县\": [122.594627, 39.27827],\n  \"辽宁省-大连市-瓦房店市\": [121.985638, 39.632741],\n  \"辽宁省-大连市-庄河市\": [122.974495, 39.686956],\n  \"辽宁省-鞍山市\": [123.001373, 41.115054],\n  \"辽宁省-鞍山市-铁东区\": [122.9974, 41.096332],\n  \"辽宁省-鞍山市-铁西区\": [122.97549, 41.125475],\n  \"辽宁省-鞍山市-立山区\": [123.035484, 41.156116],\n  \"辽宁省-鞍山市-千山区\": [122.967574, 41.080939],\n  \"辽宁省-鞍山市-台安县\": [122.44255, 41.41859],\n  \"辽宁省-鞍山市-岫岩满族自治县\": [123.287547, 40.295892],\n  \"辽宁省-鞍山市-海城市\": [122.691569, 40.887634],\n  \"辽宁省-抚顺市\": [123.964375, 41.88597],\n  \"辽宁省-抚顺市-新抚区\": [123.919582, 41.867806],\n  \"辽宁省-抚顺市-东洲区\": [124.04555, 41.859191],\n  \"辽宁省-抚顺市-望花区\": [123.790604, 41.85903],\n  \"辽宁省-抚顺市-顺城区\": [123.951414, 41.889164],\n  \"辽宁省-抚顺市-抚顺县\": [123.92159, 41.887037],\n  \"辽宁省-抚顺市-新宾满族自治县\": [125.046356, 41.739969],\n  \"辽宁省-抚顺市-清原满族自治县\": [124.93036, 42.106761],\n  \"辽宁省-本溪市\": [123.692507, 41.492916],\n  \"辽宁省-本溪市-平山区\": [123.774614, 41.301604],\n  \"辽宁省-本溪市-溪湖区\": [123.774611, 41.334803],\n  \"辽宁省-本溪市-明山区\": [123.823474, 41.314939],\n  \"辽宁省-本溪市-南芬区\": [123.751467, 41.107096],\n  \"辽宁省-本溪市-本溪满族自治县\": [124.127585, 41.307903],\n  \"辽宁省-本溪市-桓仁满族自治县\": [125.367544, 41.272925],\n  \"辽宁省-丹东市\": [124.361547, 40.006409],\n  \"辽宁省-丹东市-元宝区\": [124.402584, 40.142251],\n  \"辽宁省-丹东市-振兴区\": [124.366579, 40.110719],\n  \"辽宁省-丹东市-振安区\": [124.434387, 40.164697],\n  \"辽宁省-丹东市-宽甸满族自治县\": [124.790427, 40.737553],\n  \"辽宁省-丹东市-东港市\": [124.15961, 39.867716],\n  \"辽宁省-丹东市-凤城市\": [124.072422, 40.45918],\n  \"辽宁省-锦州市\": [121.132596, 41.100931],\n  \"辽宁省-锦州市-古塔区\": [121.134585, 41.122901],\n  \"辽宁省-锦州市-凌河区\": [121.15759, 41.120691],\n  \"辽宁省-锦州市-太和区\": [121.110453, 41.115109],\n  \"辽宁省-锦州市-黑山县\": [122.130557, 41.671593],\n  \"辽宁省-锦州市-义县\": [121.245569, 41.538939],\n  \"辽宁省-锦州市-凌海市\": [121.362539, 41.166488],\n  \"辽宁省-锦州市-北镇市\": [121.783447, 41.594428],\n  \"辽宁省-营口市\": [122.241575, 40.673137],\n  \"辽宁省-营口市-站前区\": [122.265437, 40.678764],\n  \"辽宁省-营口市-西市区\": [122.213582, 40.672111],\n  \"辽宁省-营口市-鲅鱼圈区\": [122.127573, 40.23234],\n  \"辽宁省-营口市-老边区\": [122.386439, 40.686384],\n  \"辽宁省-营口市-盖州市\": [122.355591, 40.406167],\n  \"辽宁省-营口市-大石桥市\": [122.51538, 40.650802],\n  \"辽宁省-阜新市\": [121.676408, 42.028022],\n  \"辽宁省-阜新市-海州区\": [121.669436, 42.023735],\n  \"辽宁省-阜新市-新邱区\": [121.799363, 42.093935],\n  \"辽宁省-阜新市-太平区\": [121.685384, 42.016968],\n  \"辽宁省-阜新市-清河门区\": [121.422479, 41.789319],\n  \"辽宁省-阜新市-细河区\": [121.686392, 42.031871],\n  \"辽宁省-阜新市-阜新蒙古族自治县\": [121.763574, 42.071368],\n  \"辽宁省-阜新市-彰武县\": [122.545449, 42.392707],\n  \"辽宁省-辽阳市\": [123.243366, 41.274161],\n  \"辽宁省-辽阳市-白塔区\": [123.180608, 41.275845],\n  \"辽宁省-辽阳市-文圣区\": [123.191605, 41.268438],\n  \"辽宁省-辽阳市-宏伟区\": [123.20358, 41.223368],\n  \"辽宁省-辽阳市-弓长岭区\": [123.426615, 41.157327],\n  \"辽宁省-辽阳市-太子河区\": [123.188604, 41.259226],\n  \"辽宁省-辽阳市-辽阳县\": [123.112421, 41.211679],\n  \"辽宁省-辽阳市-灯塔市\": [123.345462, 41.432474],\n  \"辽宁省-盘锦市\": [122.07749, 41.125875],\n  \"辽宁省-盘锦市-双台子区\": [122.046393, 41.206072],\n  \"辽宁省-盘锦市-兴隆台区\": [122.076499, 41.164499],\n  \"辽宁省-盘锦市-大洼区\": [122.088555, 41.008179],\n  \"辽宁省-盘锦市-盘山县\": [122.00356, 41.248264],\n  \"辽宁省-铁岭市\": [123.732365, 42.229948],\n  \"辽宁省-铁岭市-银州区\": [123.848386, 42.292574],\n  \"辽宁省-铁岭市-清河区\": [124.165563, 42.552495],\n  \"辽宁省-铁岭市-铁岭县\": [123.735372, 42.229226],\n  \"辽宁省-铁岭市-西丰县\": [124.733615, 42.744014],\n  \"辽宁省-铁岭市-昌图县\": [124.117501, 42.792178],\n  \"辽宁省-铁岭市-调兵山市\": [123.573509, 42.473738],\n  \"辽宁省-铁岭市-开原市\": [124.044569, 42.552079],\n  \"辽宁省-朝阳市\": [120.457499, 41.579821],\n  \"辽宁省-朝阳市-双塔区\": [120.460487, 41.571779],\n  \"辽宁省-朝阳市-龙城区\": [120.443567, 41.598469],\n  \"辽宁省-朝阳市-朝阳县\": [120.259391, 41.241076],\n  \"辽宁省-朝阳市-建平县\": [119.64938, 41.409456],\n  \"辽宁省-朝阳市-喀喇沁左翼蒙古族自治县\": [119.747414, 41.133689],\n  \"辽宁省-朝阳市-北票市\": [120.777628, 41.806483],\n  \"辽宁省-朝阳市-凌源市\": [119.407358, 41.251651],\n  \"辽宁省-葫芦岛市\": [120.843398, 40.717364],\n  \"辽宁省-葫芦岛市-连山区\": [120.876482, 40.780894],\n  \"辽宁省-葫芦岛市-龙港区\": [120.900621, 40.741057],\n  \"辽宁省-葫芦岛市-南票区\": [120.756493, 41.113098],\n  \"辽宁省-葫芦岛市-绥中县\": [120.350425, 40.331843],\n  \"辽宁省-葫芦岛市-建昌县\": [119.843595, 40.83038],\n  \"辽宁省-葫芦岛市-兴城市\": [120.764558, 40.616556],\n  \"吉林省\": [125.33258, 43.901714],\n  \"吉林省-长春市\": [125.330602, 43.821954],\n  \"吉林省-长春市-南关区\": [125.35661, 43.869873],\n  \"吉林省-长春市-宽城区\": [125.334625, 43.949502],\n  \"吉林省-长春市-朝阳区\": [125.295401, 43.840641],\n  \"吉林省-长春市-二道区\": [125.380468, 43.871277],\n  \"吉林省-长春市-绿园区\": [125.262443, 43.88681],\n  \"吉林省-长春市-双阳区\": [125.671448, 43.531091],\n  \"吉林省-长春市-九台区\": [125.845564, 44.157792],\n  \"吉林省-长春市-农安县\": [125.191484, 44.438904],\n  \"吉林省-长春市-榆树市\": [126.539609, 44.84544],\n  \"吉林省-长春市-德惠市\": [125.734515, 44.527161],\n  \"吉林省-吉林市\": [126.555635, 43.843568],\n  \"吉林省-吉林市-昌邑区\": [126.581449, 43.887992],\n  \"吉林省-吉林市-龙潭区\": [126.568545, 43.916343],\n  \"吉林省-吉林市-船营区\": [126.54765, 43.839927],\n  \"吉林省-吉林市-丰满区\": [126.56857, 43.827152],\n  \"吉林省-吉林市-永吉县\": [126.504416, 43.678721],\n  \"吉林省-吉林市-蛟河市\": [127.35148, 43.730004],\n  \"吉林省-吉林市-桦甸市\": [126.752484, 42.977983],\n  \"吉林省-吉林市-舒兰市\": [126.971377, 44.41227],\n  \"吉林省-吉林市-磐石市\": [126.066616, 42.951817],\n  \"吉林省-四平市\": [124.356482, 43.171994],\n  \"吉林省-四平市-铁西区\": [124.352467, 43.152575],\n  \"吉林省-四平市-铁东区\": [124.416483, 43.167994],\n  \"吉林省-四平市-梨树县\": [124.342401, 43.313346],\n  \"吉林省-四平市-伊通满族自治县\": [125.311485, 43.351104],\n  \"吉林省-四平市-公主岭市\": [124.829449, 43.510833],\n  \"吉林省-四平市-双辽市\": [123.509438, 43.524527],\n  \"吉林省-辽源市\": [125.150425, 42.894055],\n  \"吉林省-辽源市-龙山区\": [125.143452, 42.907634],\n  \"吉林省-辽源市-西安区\": [125.155373, 42.933308],\n  \"吉林省-辽源市-东丰县\": [125.537378, 42.683311],\n  \"吉林省-辽源市-东辽县\": [124.997589, 42.931879],\n  \"吉林省-通化市\": [125.946606, 41.733816],\n  \"吉林省-通化市-东昌区\": [125.933595, 41.708405],\n  \"吉林省-通化市-二道江区\": [126.049592, 41.779966],\n  \"吉林省-通化市-通化县\": [125.765392, 41.685682],\n  \"吉林省-通化市-辉南县\": [126.053581, 42.6907],\n  \"吉林省-通化市-柳河县\": [125.751424, 42.290871],\n  \"吉林省-通化市-梅河口市\": [125.717608, 42.544884],\n  \"吉林省-通化市-集安市\": [126.199577, 41.1313],\n  \"吉林省-白山市\": [126.42963, 41.939627],\n  \"吉林省-白山市-浑江区\": [126.42362, 41.950424],\n  \"吉林省-白山市-江源区\": [126.597391, 42.062939],\n  \"吉林省-白山市-抚松县\": [127.455371, 42.227335],\n  \"吉林省-白山市-靖宇县\": [126.819499, 42.394766],\n  \"吉林省-白山市-长白朝鲜族自治县\": [128.207584, 41.425896],\n  \"吉林省-白山市-临江市\": [126.924582, 41.817679],\n  \"吉林省-松原市\": [124.831482, 45.147404],\n  \"吉林省-松原市-宁江区\": [124.823423, 45.178039],\n  \"吉林省-松原市-前郭尔罗斯蒙古族自治县\": [124.830456, 45.123416],\n  \"吉林省-松原市-长岭县\": [123.974374, 44.281638],\n  \"吉林省-松原市-乾安县\": [124.047564, 45.008434],\n  \"吉林省-松原市-扶余市\": [126.056606, 44.994168],\n  \"吉林省-白城市\": [122.845591, 45.625504],\n  \"吉林省-白城市-洮北区\": [122.85751, 45.627525],\n  \"吉林省-白城市-镇赉县\": [123.206576, 45.853117],\n  \"吉林省-白城市-通榆县\": [123.094521, 44.818964],\n  \"吉林省-白城市-洮南市\": [122.794468, 45.341132],\n  \"吉林省-白城市-大安市\": [124.298504, 45.513045],\n  \"吉林省-延边朝鲜族自治州\": [129.477376, 42.915743],\n  \"吉林省-延边朝鲜族自治州-延吉市\": [129.52052, 42.912717],\n  \"吉林省-延边朝鲜族自治州-图们市\": [129.850382, 42.974283],\n  \"吉林省-延边朝鲜族自治州-敦化市\": [128.238612, 43.378291],\n  \"吉林省-延边朝鲜族自治州-珲春市\": [130.372613, 42.868515],\n  \"吉林省-延边朝鲜族自治州-龙井市\": [129.432635, 42.771535],\n  \"吉林省-延边朝鲜族自治州-和龙市\": [129.017387, 42.552323],\n  \"吉林省-延边朝鲜族自治州-汪清县\": [129.777609, 43.318451],\n  \"吉林省-延边朝鲜族自治州-安图县\": [128.905448, 43.117917],\n  \"黑龙江省\": [126.669653, 45.74793],\n  \"黑龙江省-哈尔滨市\": [126.541615, 45.808826],\n  \"黑龙江省-哈尔滨市-道里区\": [126.623432, 45.761844],\n  \"黑龙江省-哈尔滨市-南岗区\": [126.675638, 45.765866],\n  \"黑龙江省-哈尔滨市-道外区\": [126.655604, 45.797776],\n  \"黑龙江省-哈尔滨市-平房区\": [126.643547, 45.603862],\n  \"黑龙江省-哈尔滨市-松北区\": [126.516483, 45.808593],\n  \"黑龙江省-哈尔滨市-香坊区\": [126.669624, 45.71362],\n  \"黑龙江省-哈尔滨市-呼兰区\": [126.594399, 45.89521],\n  \"黑龙江省-哈尔滨市-阿城区\": [126.964356, 45.554275],\n  \"黑龙江省-哈尔滨市-双城区\": [126.319623, 45.388112],\n  \"黑龙江省-哈尔滨市-依兰县\": [129.57452, 46.33126],\n  \"黑龙江省-哈尔滨市-方正县\": [128.835634, 45.857758],\n  \"黑龙江省-哈尔滨市-宾县\": [127.473497, 45.752465],\n  \"黑龙江省-哈尔滨市-巴彦县\": [127.410548, 46.091283],\n  \"黑龙江省-哈尔滨市-木兰县\": [128.050356, 45.956871],\n  \"黑龙江省-哈尔滨市-通河县\": [128.752416, 45.996393],\n  \"黑龙江省-哈尔滨市-延寿县\": [128.338606, 45.457641],\n  \"黑龙江省-哈尔滨市-尚志市\": [128.015488, 45.215474],\n  \"黑龙江省-哈尔滨市-五常市\": [127.173529, 44.937843],\n  \"黑龙江省-齐齐哈尔市\": [123.924571, 47.359977],\n  \"黑龙江省-齐齐哈尔市-龙沙区\": [123.964376, 47.323577],\n  \"黑龙江省-齐齐哈尔市-建华区\": [123.96135, 47.360555],\n  \"黑龙江省-齐齐哈尔市-铁锋区\": [123.984416, 47.347019],\n  \"黑龙江省-齐齐哈尔市-昂昂溪区\": [123.829406, 47.161332],\n  \"黑龙江省-齐齐哈尔市-富拉尔基区\": [123.63651, 47.215504],\n  \"黑龙江省-齐齐哈尔市-碾子山区\": [122.894367, 47.523236],\n  \"黑龙江省-齐齐哈尔市-梅里斯达斡尔族区\": [123.759541, 47.31555],\n  \"黑龙江省-齐齐哈尔市-龙江县\": [123.211539, 47.343606],\n  \"黑龙江省-齐齐哈尔市-依安县\": [125.312482, 47.899484],\n  \"黑龙江省-齐齐哈尔市-泰来县\": [123.423626, 46.397829],\n  \"黑龙江省-齐齐哈尔市-甘南县\": [123.512486, 47.926884],\n  \"黑龙江省-齐齐哈尔市-富裕县\": [124.480542, 47.780228],\n  \"黑龙江省-齐齐哈尔市-克山县\": [125.881378, 48.043172],\n  \"黑龙江省-齐齐哈尔市-克东县\": [126.255387, 48.048244],\n  \"黑龙江省-齐齐哈尔市-拜泉县\": [126.105421, 47.601867],\n  \"黑龙江省-齐齐哈尔市-讷河市\": [124.890549, 48.490087],\n  \"黑龙江省-鸡西市\": [130.975619, 45.300872],\n  \"黑龙江省-鸡西市-鸡冠区\": [130.987632, 45.309806],\n  \"黑龙江省-鸡西市-恒山区\": [130.911385, 45.216972],\n  \"黑龙江省-鸡西市-滴道区\": [130.85058, 45.354434],\n  \"黑龙江省-鸡西市-梨树区\": [130.703396, 45.098242],\n  \"黑龙江省-鸡西市-城子河区\": [131.018469, 45.344435],\n  \"黑龙江省-鸡西市-麻山区\": [130.484536, 45.217935],\n  \"黑龙江省-鸡西市-鸡东县\": [131.130558, 45.266185],\n  \"黑龙江省-鸡西市-虎林市\": [132.943466, 45.768947],\n  \"黑龙江省-鸡西市-密山市\": [131.853531, 45.535641],\n  \"黑龙江省-鹤岗市\": [130.304433, 47.356056],\n  \"黑龙江省-鹤岗市-向阳区\": [130.300468, 47.348581],\n  \"黑龙江省-鹤岗市-工农区\": [130.281617, 47.32443],\n  \"黑龙江省-鹤岗市-南山区\": [130.29354, 47.321246],\n  \"黑龙江省-鹤岗市-兴安区\": [130.245546, 47.258716],\n  \"黑龙江省-鹤岗市-东山区\": [130.323361, 47.344987],\n  \"黑龙江省-鹤岗市-兴山区\": [130.317364, 47.396045],\n  \"黑龙江省-鹤岗市-萝北县\": [130.835495, 47.583422],\n  \"黑龙江省-鹤岗市-绥滨县\": [131.859487, 47.295265],\n  \"黑龙江省-双鸭山市\": [131.165342, 46.653186],\n  \"黑龙江省-双鸭山市-尖山区\": [131.165342, 46.652586],\n  \"黑龙江省-双鸭山市-岭东区\": [131.164377, 46.464596],\n  \"黑龙江省-双鸭山市-四方台区\": [131.345657, 46.602012],\n  \"黑龙江省-双鸭山市-宝山区\": [131.407375, 46.583598],\n  \"黑龙江省-双鸭山市-集贤县\": [131.147434, 46.734518],\n  \"黑龙江省-双鸭山市-友谊县\": [131.814595, 46.772973],\n  \"黑龙江省-双鸭山市-宝清县\": [132.203594, 46.332652],\n  \"黑龙江省-双鸭山市-饶河县\": [134.020469, 46.804183],\n  \"黑龙江省-大庆市\": [125.108658, 46.593633],\n  \"黑龙江省-大庆市-萨尔图区\": [125.13351, 46.638936],\n  \"黑龙江省-大庆市-龙凤区\": [125.140473, 46.567678],\n  \"黑龙江省-大庆市-让胡路区\": [124.877599, 46.658078],\n  \"黑龙江省-大庆市-红岗区\": [124.897477, 46.404313],\n  \"黑龙江省-大庆市-大同区\": [124.819377, 46.045584],\n  \"黑龙江省-大庆市-肇州县\": [125.275368, 45.705108],\n  \"黑龙江省-大庆市-肇源县\": [125.084573, 45.524153],\n  \"黑龙江省-大庆市-林甸县\": [124.86965, 47.177234],\n  \"黑龙江省-大庆市-杜尔伯特蒙古族自治县\": [124.449359, 46.868768],\n  \"黑龙江省-伊春市\": [128.847546, 47.733318],\n  \"黑龙江省-伊春市-伊春区\": [128.913459, 47.733954],\n  \"黑龙江省-伊春市-南岔区\": [129.289572, 47.14375],\n  \"黑龙江省-伊春市-友好区\": [128.842579, 47.846436],\n  \"黑龙江省-伊春市-西林区\": [129.319594, 47.486393],\n  \"黑龙江省-伊春市-翠峦区\": [128.676482, 47.732894],\n  \"黑龙江省-伊春市-新青区\": [129.540647, 48.296135],\n  \"黑龙江省-伊春市-美溪区\": [129.135368, 47.641344],\n  \"黑龙江省-伊春市-金山屯区\": [129.435639, 47.418759],\n  \"黑龙江省-伊春市-五营区\": [129.25135, 48.114271],\n  \"黑龙江省-伊春市-乌马河区\": [128.805546, 47.733619],\n  \"黑龙江省-伊春市-汤旺河区\": [129.577474, 48.460614],\n  \"黑龙江省-伊春市-带岭区\": [129.027425, 47.034572],\n  \"黑龙江省-伊春市-乌伊岭区\": [129.444577, 48.596169],\n  \"黑龙江省-伊春市-红星区\": [129.397507, 48.24548],\n  \"黑龙江省-伊春市-上甘岭区\": [129.030437, 47.980914],\n  \"黑龙江省-伊春市-嘉荫县\": [130.410555, 48.894983],\n  \"黑龙江省-伊春市-铁力市\": [128.038365, 46.992949],\n  \"黑龙江省-佳木斯市\": [130.327359, 46.80569],\n  \"黑龙江省-佳木斯市-向阳区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-前进区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-东风区\": [130.372612, 46.813512],\n  \"黑龙江省-佳木斯市-郊区\": [130.333378, 46.816168],\n  \"黑龙江省-佳木斯市-桦南县\": [130.560385, 46.245077],\n  \"黑龙江省-佳木斯市-桦川县\": [130.725549, 47.028817],\n  \"黑龙江省-佳木斯市-汤原县\": [129.911645, 46.735327],\n  \"黑龙江省-佳木斯市-同江市\": [132.517509, 47.647981],\n  \"黑龙江省-佳木斯市-富锦市\": [132.044539, 47.255933],\n  \"黑龙江省-佳木斯市-抚远市\": [134.31449, 48.370945],\n  \"黑龙江省-七台河市\": [131.011545, 45.7763],\n  \"黑龙江省-七台河市-新兴区\": [130.938371, 45.82231],\n  \"黑龙江省-七台河市-桃山区\": [131.026444, 45.7718],\n  \"黑龙江省-七台河市-茄子河区\": [131.074481, 45.791238],\n  \"黑龙江省-七台河市-勃利县\": [130.598533, 45.760964],\n  \"黑龙江省-牡丹江市\": [129.63954, 44.556246],\n  \"黑龙江省-牡丹江市-东安区\": [129.633478, 44.58746],\n  \"黑龙江省-牡丹江市-阳明区\": [129.642527, 44.601775],\n  \"黑龙江省-牡丹江市-爱民区\": [129.598364, 44.60235],\n  \"黑龙江省-牡丹江市-西安区\": [129.622413, 44.583861],\n  \"黑龙江省-牡丹江市-林口县\": [130.287579, 45.284129],\n  \"黑龙江省-牡丹江市-绥芬河市\": [131.157392, 44.418154],\n  \"黑龙江省-牡丹江市-海林市\": [129.387427, 44.599872],\n  \"黑龙江省-牡丹江市-宁安市\": [129.489368, 44.346984],\n  \"黑龙江省-牡丹江市-穆棱市\": [130.530559, 44.924785],\n  \"黑龙江省-牡丹江市-东宁市\": [131.131544, 44.096101],\n  \"黑龙江省-黑河市\": [127.53549, 50.251272],\n  \"黑龙江省-黑河市-爱辉区\": [127.506632, 50.25771],\n  \"黑龙江省-黑河市-嫩江县\": [125.227635, 49.19132],\n  \"黑龙江省-黑河市-逊克县\": [128.485585, 49.569491],\n  \"黑龙江省-黑河市-孙吴县\": [127.342388, 49.431451],\n  \"黑龙江省-黑河市-北安市\": [126.49738, 48.24742],\n  \"黑龙江省-黑河市-五大连池市\": [126.211555, 48.52261],\n  \"黑龙江省-绥化市\": [126.975357, 46.660032],\n  \"黑龙江省-绥化市-北林区\": [126.991449, 46.643493],\n  \"黑龙江省-绥化市-望奎县\": [126.492385, 46.839168],\n  \"黑龙江省-绥化市-兰西县\": [126.29462, 46.258095],\n  \"黑龙江省-绥化市-青冈县\": [126.100489, 46.710685],\n  \"黑龙江省-绥化市-庆安县\": [127.514612, 46.885744],\n  \"黑龙江省-绥化市-明水县\": [125.912483, 47.179483],\n  \"黑龙江省-绥化市-绥棱县\": [127.120515, 47.242516],\n  \"黑龙江省-绥化市-安达市\": [125.348622, 46.425719],\n  \"黑龙江省-绥化市-肇东市\": [125.968537, 46.056938],\n  \"黑龙江省-绥化市-海伦市\": [126.936509, 47.456904],\n  \"黑龙江省-大兴安岭地区\": [123.644559, 52.510947],\n  \"黑龙江省-大兴安岭地区-呼玛县\": [126.65965, 51.730947],\n  \"黑龙江省-大兴安岭地区-塔河县\": [124.716513, 52.340305],\n  \"黑龙江省-大兴安岭地区-漠河县\": [122.545421, 52.978304],\n  \"上海市\": [121.480539, 31.235929],\n  \"上海市-市辖区\": [121.480539, 31.235929],\n  \"上海市-市辖区-黄浦区\": [121.491586, 31.237247],\n  \"上海市-市辖区-徐汇区\": [121.443396, 31.194557],\n  \"上海市-市辖区-长宁区\": [121.430454, 31.226848],\n  \"上海市-市辖区-静安区\": [121.453432, 31.233845],\n  \"上海市-市辖区-普陀区\": [121.403569, 31.254973],\n  \"上海市-市辖区-虹口区\": [121.511586, 31.269747],\n  \"上海市-市辖区-杨浦区\": [121.53252, 31.265524],\n  \"上海市-市辖区-闵行区\": [121.388612, 31.118843],\n  \"上海市-市辖区-宝山区\": [121.496563, 31.410279],\n  \"上海市-市辖区-嘉定区\": [121.272595, 31.380155],\n  \"上海市-市辖区-浦东新区\": [121.550455, 31.227348],\n  \"上海市-市辖区-金山区\": [121.34848, 30.747852],\n  \"上海市-市辖区-松江区\": [121.23448, 31.037135],\n  \"上海市-市辖区-青浦区\": [121.130553, 31.155454],\n  \"上海市-市辖区-奉贤区\": [121.480504, 30.92372],\n  \"上海市-市辖区-崇明区\": [121.403557, 31.62857],\n  \"江苏省\": [118.769552, 32.066777],\n  \"江苏省-南京市\": [118.802422, 32.064653],\n  \"江苏省-南京市-玄武区\": [118.804413, 32.054757],\n  \"江苏省-南京市-秦淮区\": [118.800407, 32.045139],\n  \"江苏省-南京市-建邺区\": [118.738569, 32.00937],\n  \"江苏省-南京市-鼓楼区\": [118.776519, 32.072405],\n  \"江苏省-南京市-浦口区\": [118.634604, 32.064679],\n  \"江苏省-南京市-栖霞区\": [118.915423, 32.1026],\n  \"江苏省-南京市-雨花台区\": [118.785445, 31.997859],\n  \"江苏省-南京市-江宁区\": [118.846567, 31.958527],\n  \"江苏省-南京市-六合区\": [118.827471, 32.328666],\n  \"江苏省-南京市-溧水区\": [119.034404, 31.657284],\n  \"江苏省-南京市-高淳区\": [118.898498, 31.333639],\n  \"江苏省-无锡市\": [120.318583, 31.49881],\n  \"江苏省-无锡市-锡山区\": [120.363426, 31.594762],\n  \"江苏省-无锡市-惠山区\": [120.304596, 31.686741],\n  \"江苏省-无锡市-滨湖区\": [120.291548, 31.53464],\n  \"江苏省-无锡市-梁溪区\": [120.3096, 31.571645],\n  \"江苏省-无锡市-新吴区\": [120.370396, 31.55485],\n  \"江苏省-无锡市-江阴市\": [120.370396, 31.55485],\n  \"江苏省-无锡市-宜兴市\": [119.831606, 31.342957],\n  \"江苏省-徐州市\": [117.290575, 34.212667],\n  \"江苏省-徐州市-鼓楼区\": [117.192579, 34.29376],\n  \"江苏省-徐州市-云龙区\": [117.258424, 34.259087],\n  \"江苏省-徐州市-贾汪区\": [117.46943, 34.44162],\n  \"江苏省-徐州市-泉山区\": [117.20059, 34.249943],\n  \"江苏省-徐州市-铜山区\": [117.17557, 34.1861],\n  \"江苏省-徐州市-丰县\": [116.602582, 34.69977],\n  \"江苏省-徐州市-沛县\": [116.942586, 34.765152],\n  \"江苏省-徐州市-睢宁县\": [117.947433, 33.918789],\n  \"江苏省-徐州市-新沂市\": [118.361537, 34.375611],\n  \"江苏省-徐州市-邳州市\": [117.963411, 34.339753],\n  \"江苏省-常州市\": [119.981485, 31.815796],\n  \"江苏省-常州市-天宁区\": [119.980463, 31.78557],\n  \"江苏省-常州市-钟楼区\": [119.908463, 31.807647],\n  \"江苏省-常州市-新北区\": [119.977514, 31.836324],\n  \"江苏省-常州市-武进区\": [119.948612, 31.706447],\n  \"江苏省-常州市-金坛区\": [119.604571, 31.728893],\n  \"江苏省-常州市-溧阳市\": [119.491506, 31.422102],\n  \"江苏省-苏州市\": [120.592412, 31.303564],\n  \"江苏省-苏州市-虎丘区\": [120.578472, 31.301933],\n  \"江苏省-苏州市-吴中区\": [120.638508, 31.268261],\n  \"江苏省-苏州市-相城区\": [120.648566, 31.37469],\n  \"江苏省-苏州市-姑苏区\": [120.623455, 31.341831],\n  \"江苏省-苏州市-吴江区\": [120.651567, 31.144644],\n  \"江苏省-苏州市-常熟市\": [120.759496, 31.659538],\n  \"江苏省-苏州市-张家港市\": [120.561554, 31.881141],\n  \"江苏省-苏州市-昆山市\": [120.987452, 31.390863],\n  \"江苏省-苏州市-太仓市\": [121.135595, 31.464599],\n  \"江苏省-南通市\": [120.901592, 31.986549],\n  \"江苏省-南通市-崇川区\": [120.86342, 32.015923],\n  \"江苏省-南通市-港闸区\": [120.824452, 32.037345],\n  \"江苏省-南通市-通州区\": [121.081425, 32.070356],\n  \"江苏省-南通市-海安县\": [120.474433, 32.539196],\n  \"江苏省-南通市-如东县\": [121.192438, 32.335873],\n  \"江苏省-南通市-启东市\": [121.663474, 31.814233],\n  \"江苏省-南通市-如皋市\": [120.579466, 32.377851],\n  \"江苏省-南通市-海门市\": [121.188436, 31.873612],\n  \"江苏省-连云港市\": [119.228621, 34.60225],\n  \"江苏省-连云港市-连云区\": [119.346588, 34.765337],\n  \"江苏省-连云港市-海州区\": [119.169408, 34.577456],\n  \"江苏省-连云港市-赣榆区\": [119.179435, 34.847682],\n  \"江苏省-连云港市-东海县\": [118.759565, 34.547919],\n  \"江苏省-连云港市-灌云县\": [119.246534, 34.288616],\n  \"江苏省-连云港市-灌南县\": [119.322538, 34.092591],\n  \"江苏省-淮安市\": [119.021484, 33.616295],\n  \"江苏省-淮安市-淮安区\": [119.147463, 33.509],\n  \"江苏省-淮安市-淮阴区\": [119.041422, 33.63815],\n  \"江苏省-淮安市-清江浦区\": [119.032414, 33.558562],\n  \"江苏省-淮安市-洪泽区\": [118.879584, 33.299625],\n  \"江苏省-淮安市-涟水县\": [119.266448, 33.787079],\n  \"江苏省-淮安市-盱眙县\": [118.551441, 33.018255],\n  \"江苏省-淮安市-金湖县\": [119.026469, 33.031284],\n  \"江苏省-盐城市\": [120.167544, 33.355101],\n  \"江苏省-盐城市-亭湖区\": [120.204578, 33.395893],\n  \"江苏省-盐城市-盐都区\": [120.160503, 33.34402],\n  \"江苏省-盐城市-大丰区\": [120.507439, 33.20476],\n  \"江苏省-盐城市-响水县\": [119.584601, 34.204743],\n  \"江苏省-盐城市-滨海县\": [119.827621, 33.995647],\n  \"江苏省-盐城市-阜宁县\": [119.809581, 33.765079],\n  \"江苏省-盐城市-射阳县\": [120.264446, 33.781014],\n  \"江苏省-盐城市-建湖县\": [119.805531, 33.469833],\n  \"江苏省-盐城市-东台市\": [120.326537, 32.872716],\n  \"江苏省-扬州市\": [119.419419, 32.400677],\n  \"江苏省-扬州市-广陵区\": [119.438505, 32.400661],\n  \"江苏省-扬州市-邗江区\": [119.404385, 32.382751],\n  \"江苏省-扬州市-江都区\": [119.576603, 32.440295],\n  \"江苏省-扬州市-宝应县\": [119.365556, 33.247205],\n  \"江苏省-扬州市-仪征市\": [119.191467, 32.27809],\n  \"江苏省-扬州市-高邮市\": [119.465616, 32.787147],\n  \"江苏省-镇江市\": [119.430489, 32.194716],\n  \"江苏省-镇江市-京口区\": [119.475604, 32.203785],\n  \"江苏省-镇江市-润州区\": [119.41844, 32.201495],\n  \"江苏省-镇江市-丹徒区\": [119.440501, 32.13792],\n  \"江苏省-镇江市-丹阳市\": [119.612501, 32.01592],\n  \"江苏省-镇江市-扬中市\": [119.80352, 32.242967],\n  \"江苏省-镇江市-句容市\": [119.175433, 31.950923],\n  \"江苏省-泰州市\": [119.929566, 32.460675],\n  \"江苏省-泰州市-海陵区\": [119.925525, 32.496732],\n  \"江苏省-泰州市-高港区\": [119.888421, 32.324862],\n  \"江苏省-泰州市-姜堰区\": [120.133398, 32.515234],\n  \"江苏省-泰州市-兴化市\": [119.857514, 32.917824],\n  \"江苏省-泰州市-靖江市\": [120.283532, 31.98817],\n  \"江苏省-泰州市-泰兴市\": [120.058599, 32.177474],\n  \"江苏省-宿迁市\": [118.281574, 33.96775],\n  \"江苏省-宿迁市-宿城区\": [118.249567, 33.968678],\n  \"江苏省-宿迁市-宿豫区\": [118.336401, 33.954804],\n  \"江苏省-宿迁市-沭阳县\": [118.810419, 34.117454],\n  \"江苏省-宿迁市-泗阳县\": [118.709466, 33.728328],\n  \"江苏省-宿迁市-泗洪县\": [118.222416, 33.465733],\n  \"浙江省\": [120.159533, 30.271548],\n  \"浙江省-杭州市\": [120.215512, 30.253083],\n  \"浙江省-杭州市-上城区\": [120.175579, 30.248398],\n  \"浙江省-杭州市-下城区\": [120.187607, 30.286744],\n  \"浙江省-杭州市-江干区\": [120.211539, 30.263311],\n  \"浙江省-杭州市-拱墅区\": [120.148447, 30.324643],\n  \"浙江省-杭州市-西湖区\": [120.136438, 30.265916],\n  \"浙江省-杭州市-滨江区\": [120.218471, 30.214333],\n  \"浙江省-杭州市-萧山区\": [120.218471, 30.214333],\n  \"浙江省-杭州市-余杭区\": [120.306592, 30.424739],\n  \"浙江省-杭州市-富阳区\": [119.966556, 30.054723],\n  \"浙江省-杭州市-桐庐县\": [119.697599, 29.798585],\n  \"浙江省-杭州市-淳安县\": [119.048392, 29.61495],\n  \"浙江省-杭州市-建德市\": [119.287398, 29.481154],\n  \"浙江省-杭州市-临安市\": [119.731517, 30.239806],\n  \"浙江省-宁波市\": [121.628572, 29.866033],\n  \"浙江省-宁波市-海曙区\": [121.557403, 29.865721],\n  \"浙江省-宁波市-江东区\": [121.576533, 29.8733],\n  \"浙江省-宁波市-江北区\": [121.560421, 29.892948],\n  \"浙江省-宁波市-北仑区\": [121.850576, 29.904659],\n  \"浙江省-宁波市-镇海区\": [121.722519, 29.954885],\n  \"浙江省-宁波市-鄞州区\": [121.555427, 29.824206],\n  \"浙江省-宁波市-象山县\": [121.875564, 29.482271],\n  \"浙江省-宁波市-宁海县\": [121.436432, 29.294317],\n  \"浙江省-宁波市-余姚市\": [121.160585, 30.042735],\n  \"浙江省-宁波市-慈溪市\": [121.272596, 30.175257],\n  \"浙江省-宁波市-奉化市\": [121.413528, 29.661146],\n  \"浙江省-温州市\": [120.706477, 28.001085],\n  \"浙江省-温州市-鹿城区\": [120.661586, 28.020352],\n  \"浙江省-温州市-龙湾区\": [120.819468, 27.938652],\n  \"浙江省-温州市-瓯海区\": [120.621447, 27.972857],\n  \"浙江省-温州市-洞头区\": [121.163549, 27.84187],\n  \"浙江省-温州市-永嘉县\": [120.688524, 28.15645],\n  \"浙江省-温州市-平阳县\": [120.572515, 27.667724],\n  \"浙江省-温州市-苍南县\": [120.433595, 27.523067],\n  \"浙江省-温州市-文成县\": [120.097488, 27.793217],\n  \"浙江省-温州市-泰顺县\": [119.723537, 27.562171],\n  \"浙江省-温州市-瑞安市\": [120.661582, 27.783951],\n  \"浙江省-温州市-乐清市\": [120.992502, 28.11818],\n  \"浙江省-嘉兴市\": [120.763552, 30.750975],\n  \"浙江省-嘉兴市-南湖区\": [120.78961, 30.751547],\n  \"浙江省-嘉兴市-秀洲区\": [120.715437, 30.770207],\n  \"浙江省-嘉兴市-嘉善县\": [120.932511, 30.837122],\n  \"浙江省-嘉兴市-海盐县\": [120.952445, 30.531873],\n  \"浙江省-嘉兴市-海宁市\": [120.686565, 30.517924],\n  \"浙江省-嘉兴市-平湖市\": [121.022575, 30.682241],\n  \"浙江省-嘉兴市-桐乡市\": [120.571543, 30.636311],\n  \"浙江省-湖州市\": [120.094517, 30.898964],\n  \"浙江省-湖州市-吴兴区\": [120.191605, 30.862955],\n  \"浙江省-湖州市-南浔区\": [120.424601, 30.855243],\n  \"浙江省-湖州市-德清县\": [119.983465, 30.548628],\n  \"浙江省-湖州市-长兴县\": [119.917498, 31.032579],\n  \"浙江省-湖州市-安吉县\": [119.686563, 30.644425],\n  \"浙江省-绍兴市\": [120.585478, 30.036369],\n  \"浙江省-绍兴市-越城区\": [120.588437, 29.99531],\n  \"浙江省-绍兴市-柯桥区\": [120.451511, 30.079004],\n  \"浙江省-绍兴市-上虞区\": [120.87451, 30.038243],\n  \"浙江省-绍兴市-新昌县\": [120.91057, 29.505541],\n  \"浙江省-绍兴市-诸暨市\": [120.253408, 29.714935],\n  \"浙江省-绍兴市-嵊州市\": [120.837437, 29.567327],\n  \"浙江省-金华市\": [119.653436, 29.084639],\n  \"浙江省-金华市-婺城区\": [119.578593, 29.091775],\n  \"浙江省-金华市-金东区\": [119.699582, 29.104765],\n  \"浙江省-金华市-武义县\": [119.822566, 28.898244],\n  \"浙江省-金华市-浦江县\": [119.898436, 29.458693],\n  \"浙江省-金华市-磐安县\": [120.456513, 29.060103],\n  \"浙江省-金华市-兰溪市\": [119.466599, 29.214044],\n  \"浙江省-金华市-义乌市\": [120.081581, 29.31115],\n  \"浙江省-金华市-东阳市\": [120.248422, 29.295861],\n  \"浙江省-金华市-永康市\": [120.054551, 28.894204],\n  \"浙江省-衢州市\": [118.866597, 28.975546],\n  \"浙江省-衢州市-柯城区\": [118.877584, 28.974204],\n  \"浙江省-衢州市-衢江区\": [118.965539, 28.986238],\n  \"浙江省-衢州市-常山县\": [118.517557, 28.906998],\n  \"浙江省-衢州市-开化县\": [118.421459, 29.143188],\n  \"浙江省-衢州市-龙游县\": [119.178418, 29.034487],\n  \"浙江省-衢州市-江山市\": [118.633583, 28.742868],\n  \"浙江省-舟山市\": [122.213556, 29.990912],\n  \"浙江省-舟山市-定海区\": [122.113601, 30.025462],\n  \"浙江省-舟山市-普陀区\": [122.331544, 29.976836],\n  \"浙江省-舟山市-岱山县\": [122.232605, 30.269656],\n  \"浙江省-舟山市-嵊泗县\": [122.457588, 30.731274],\n  \"浙江省-台州市\": [121.427435, 28.662194],\n  \"浙江省-台州市-椒江区\": [121.449408, 28.679258],\n  \"浙江省-台州市-黄岩区\": [121.268566, 28.655334],\n  \"浙江省-台州市-路桥区\": [121.371578, 28.586947],\n  \"浙江省-台州市-玉环县\": [121.238513, 28.141863],\n  \"浙江省-台州市-三门县\": [121.402554, 29.110355],\n  \"浙江省-台州市-天台县\": [121.013553, 29.149514],\n  \"浙江省-台州市-仙居县\": [120.735435, 28.853226],\n  \"浙江省-台州市-温岭市\": [121.392589, 28.377655],\n  \"浙江省-台州市-临海市\": [121.151585, 28.864049],\n  \"浙江省-丽水市\": [119.929573, 28.473278],\n  \"浙江省-丽水市-莲都区\": [119.919519, 28.451745],\n  \"浙江省-丽水市-青田县\": [120.296573, 28.145488],\n  \"浙江省-丽水市-缙云县\": [120.097478, 28.665215],\n  \"浙江省-丽水市-遂昌县\": [119.282435, 28.598455],\n  \"浙江省-丽水市-松阳县\": [119.488544, 28.455056],\n  \"浙江省-丽水市-云和县\": [119.579597, 28.12147],\n  \"浙江省-丽水市-庆元县\": [119.069487, 27.625432],\n  \"浙江省-丽水市-景宁畲族自治县\": [119.64243, 27.979554],\n  \"浙江省-丽水市-龙泉市\": [119.148445, 28.080509],\n  \"安徽省\": [117.33054, 31.734294],\n  \"安徽省-合肥市\": [117.233443, 31.826578],\n  \"安徽省-合肥市-瑶海区\": [117.315587, 31.863787],\n  \"安徽省-合肥市-庐阳区\": [117.271459, 31.884887],\n  \"安徽省-合肥市-蜀山区\": [117.266461, 31.857378],\n  \"安徽省-合肥市-包河区\": [117.316576, 31.799293],\n  \"安徽省-合肥市-长丰县\": [117.17356, 32.483723],\n  \"安徽省-合肥市-肥东县\": [117.475401, 31.89389],\n  \"安徽省-合肥市-肥西县\": [117.164558, 31.712962],\n  \"安徽省-合肥市-庐江县\": [117.293577, 31.261328],\n  \"安徽省-合肥市-巢湖市\": [117.895576, 31.629002],\n  \"安徽省-芜湖市\": [118.439431, 31.358537],\n  \"安徽省-芜湖市-镜湖区\": [118.392606, 31.345867],\n  \"安徽省-芜湖市-弋江区\": [118.37958, 31.317566],\n  \"安徽省-芜湖市-鸠江区\": [118.397588, 31.375805],\n  \"安徽省-芜湖市-三山区\": [118.274602, 31.22528],\n  \"安徽省-芜湖市-芜湖县\": [118.582443, 31.141239],\n  \"安徽省-芜湖市-繁昌县\": [118.205424, 31.107959],\n  \"安徽省-芜湖市-南陵县\": [118.340418, 30.92026],\n  \"安徽省-芜湖市-无为县\": [118.071407, 31.340204],\n  \"安徽省-蚌埠市\": [117.395513, 32.921524],\n  \"安徽省-蚌埠市-龙子湖区\": [117.399513, 32.948644],\n  \"安徽省-蚌埠市-蚌山区\": [117.379441, 32.923379],\n  \"安徽省-蚌埠市-禹会区\": [117.348452, 32.93531],\n  \"安徽省-蚌埠市-淮上区\": [117.366383, 32.970547],\n  \"安徽省-蚌埠市-怀远县\": [117.211506, 32.976004],\n  \"安徽省-蚌埠市-五河县\": [117.887561, 33.132709],\n  \"安徽省-蚌埠市-固镇县\": [117.323548, 33.323274],\n  \"安徽省-淮南市\": [117.006389, 32.631847],\n  \"安徽省-淮南市-大通区\": [117.059583, 32.63727],\n  \"安徽省-淮南市-田家庵区\": [117.023445, 32.653323],\n  \"安徽省-淮南市-谢家集区\": [116.865439, 32.606255],\n  \"安徽省-淮南市-八公山区\": [116.840564, 32.637137],\n  \"安徽省-淮南市-潘集区\": [116.841581, 32.777955],\n  \"安徽省-淮南市-凤台县\": [116.717573, 32.715104],\n  \"安徽省-淮南市-寿县\": [116.805563, 32.561546],\n  \"安徽省-马鞍山市\": [118.51358, 31.676266],\n  \"安徽省-马鞍山市-花山区\": [118.499606, 31.725473],\n  \"安徽省-马鞍山市-雨山区\": [118.505597, 31.687745],\n  \"安徽省-马鞍山市-博望区\": [118.504605, 31.576649],\n  \"安徽省-马鞍山市-当涂县\": [118.504605, 31.576649],\n  \"安徽省-马鞍山市-含山县\": [118.129204, 31.740485],\n  \"安徽省-马鞍山市-和县\": [118.359513, 31.748244],\n  \"安徽省-淮北市\": [116.804537, 33.961656],\n  \"安徽省-淮北市-杜集区\": [116.834612, 33.997285],\n  \"安徽省-淮北市-相山区\": [116.800521, 33.965827],\n  \"安徽省-淮北市-烈山区\": [116.819599, 33.901574],\n  \"安徽省-淮北市-濉溪县\": [116.772389, 33.921629],\n  \"安徽省-铜陵市\": [117.818477, 30.951233],\n  \"安徽省-铜陵市-铜官区\": [117.821457, 30.940386],\n  \"安徽省-铜陵市-义安区\": [117.798568, 30.958512],\n  \"安徽省-铜陵市-郊区\": [117.80755, 30.897741],\n  \"安徽省-铜陵市-枞阳县\": [117.226437, 30.705671],\n  \"安徽省-安庆市\": [117.063604, 30.530957],\n  \"安徽省-安庆市-迎江区\": [117.097514, 30.517523],\n  \"安徽省-安庆市-大观区\": [117.040538, 30.518232],\n  \"安徽省-安庆市-宜秀区\": [116.993441, 30.619676],\n  \"安徽省-安庆市-怀宁县\": [116.836593, 30.7394],\n  \"安徽省-安庆市-潜山县\": [116.587611, 30.636756],\n  \"安徽省-安庆市-太湖县\": [116.315476, 30.460113],\n  \"安徽省-安庆市-宿松县\": [116.135524, 30.159787],\n  \"安徽省-安庆市-望江县\": [116.70059, 30.129968],\n  \"安徽省-安庆市-岳西县\": [116.366555, 30.855228],\n  \"安徽省-安庆市-桐城市\": [116.980466, 31.041969],\n  \"安徽省-黄山市\": [118.345437, 29.72189],\n  \"安徽省-黄山市-屯溪区\": [118.321418, 29.702144],\n  \"安徽省-黄山市-黄山区\": [118.14761, 30.278651],\n  \"安徽省-黄山市-徽州区\": [118.343436, 29.834221],\n  \"安徽省-黄山市-歙县\": [118.42146, 29.866288],\n  \"安徽省-黄山市-休宁县\": [118.20543, 29.795459],\n  \"安徽省-黄山市-黟县\": [117.944477, 29.931047],\n  \"安徽省-黄山市-祁门县\": [117.723393, 29.860344],\n  \"安徽省-滁州市\": [118.339406, 32.261271],\n  \"安徽省-滁州市-琅琊区\": [118.312441, 32.300867],\n  \"安徽省-滁州市-南谯区\": [118.423482, 32.206132],\n  \"安徽省-滁州市-来安县\": [118.442412, 32.45845],\n  \"安徽省-滁州市-全椒县\": [118.280584, 32.09194],\n  \"安徽省-滁州市-定远县\": [117.704471, 32.537047],\n  \"安徽省-滁州市-凤阳县\": [117.538585, 32.880977],\n  \"安徽省-滁州市-天长市\": [118.950489, 32.794116],\n  \"安徽省-滁州市-明光市\": [117.99551, 32.783023],\n  \"安徽省-阜阳市\": [115.820436, 32.896061],\n  \"安徽省-阜阳市-颍州区\": [115.813411, 32.889625],\n  \"安徽省-阜阳市-颍东区\": [115.863617, 32.917362],\n  \"安徽省-阜阳市-颍泉区\": [115.815426, 32.931314],\n  \"安徽省-阜阳市-临泉县\": [115.267616, 33.04596],\n  \"安徽省-阜阳市-太和县\": [115.628615, 33.16596],\n  \"安徽省-阜阳市-阜南县\": [115.602546, 32.664097],\n  \"安徽省-阜阳市-颍上县\": [116.263477, 32.659028],\n  \"安徽省-阜阳市-界首市\": [115.38061, 33.262775],\n  \"安徽省-宿州市\": [116.970544, 33.652095],\n  \"安徽省-宿州市-埇桥区\": [116.98348, 33.646131],\n  \"安徽省-宿州市-砀山县\": [116.372524, 34.448428],\n  \"安徽省-宿州市-萧县\": [116.953585, 34.194269],\n  \"安徽省-宿州市-灵璧县\": [117.564557, 33.547892],\n  \"安徽省-宿州市-泗县\": [117.91659, 33.488695],\n  \"安徽省-六安市\": [116.52641, 31.741451],\n  \"安徽省-六安市-金安区\": [116.545438, 31.756288],\n  \"安徽省-六安市-裕安区\": [116.48655, 31.743626],\n  \"安徽省-六安市-叶集区\": [115.947476, 31.835263],\n  \"安徽省-六安市-霍邱县\": [115.947476, 31.835263],\n  \"安徽省-六安市-舒城县\": [116.955602, 31.467692],\n  \"安徽省-六安市-金寨县\": [115.940441, 31.733462],\n  \"安徽省-六安市-霍山县\": [116.339576, 31.398571],\n  \"安徽省-亳州市\": [115.784463, 33.850643],\n  \"安徽省-亳州市-谯城区\": [115.785472, 33.882663],\n  \"安徽省-亳州市-涡阳县\": [116.221609, 33.498567],\n  \"安徽省-亳州市-蒙城县\": [116.571589, 33.271658],\n  \"安徽省-亳州市-利辛县\": [116.191494, 33.155596],\n  \"安徽省-池州市\": [117.498421, 30.670884],\n  \"安徽省-池州市-贵池区\": [117.57449, 30.693858],\n  \"安徽省-池州市-东至县\": [117.034481, 30.116535],\n  \"安徽省-池州市-石台县\": [117.492394, 30.21653],\n  \"安徽省-池州市-青阳县\": [117.853431, 30.645634],\n  \"安徽省-宣城市\": [118.765534, 30.946602],\n  \"安徽省-宣城市-宣州区\": [118.762549, 30.952158],\n  \"安徽省-宣城市-郎溪县\": [119.186466, 31.132682],\n  \"安徽省-宣城市-广德县\": [119.427476, 30.883667],\n  \"安徽省-宣城市-泾县\": [118.426435, 30.694672],\n  \"安徽省-宣城市-绩溪县\": [118.585444, 30.073292],\n  \"安徽省-宣城市-旌德县\": [118.546467, 30.292481],\n  \"安徽省-宣城市-宁国市\": [118.98961, 30.639352],\n  \"福建省\": [119.302447, 26.106339],\n  \"福建省-福州市\": [119.30347, 26.080429],\n  \"福建省-福州市-鼓楼区\": [119.310492, 26.088114],\n  \"福建省-福州市-台江区\": [119.320528, 26.058528],\n  \"福建省-福州市-仓山区\": [119.280432, 26.052842],\n  \"福建省-福州市-马尾区\": [119.445519, 26.004534],\n  \"福建省-福州市-晋安区\": [119.334579, 26.087214],\n  \"福建省-福州市-闽侯县\": [119.138482, 26.156035],\n  \"福建省-福州市-连江县\": [119.546479, 26.203583],\n  \"福建省-福州市-罗源县\": [119.55648, 26.495496],\n  \"福建省-福州市-闽清县\": [118.869577, 26.226848],\n  \"福建省-福州市-永泰县\": [118.938431, 25.872787],\n  \"福建省-福州市-平潭县\": [119.796501, 25.5047],\n  \"福建省-福州市-福清市\": [119.390465, 25.726343],\n  \"福建省-福州市-长乐市\": [119.529438, 25.969257],\n  \"福建省-厦门市\": [118.096435, 24.485407],\n  \"福建省-厦门市-思明区\": [118.088408, 24.451948],\n  \"福建省-厦门市-海沧区\": [118.039562, 24.490326],\n  \"福建省-厦门市-湖里区\": [118.153588, 24.517573],\n  \"福建省-厦门市-集美区\": [118.103435, 24.582019],\n  \"福建省-厦门市-同安区\": [118.158563, 24.729114],\n  \"福建省-厦门市-翔安区\": [118.254576, 24.624216],\n  \"福建省-莆田市\": [119.014521, 25.459865],\n  \"福建省-莆田市-城厢区\": [119.001536, 25.424344],\n  \"福建省-莆田市-涵江区\": [119.122567, 25.464464],\n  \"福建省-莆田市-荔城区\": [119.019482, 25.439754],\n  \"福建省-莆田市-秀屿区\": [119.111571, 25.323654],\n  \"福建省-莆田市-仙游县\": [118.698454, 25.368291],\n  \"福建省-三明市\": [117.645521, 26.269737],\n  \"福建省-三明市-梅列区\": [117.65255, 26.277336],\n  \"福建省-三明市-三元区\": [117.614415, 26.240219],\n  \"福建省-三明市-明溪县\": [117.208518, 26.361854],\n  \"福建省-三明市-清流县\": [116.823593, 26.183357],\n  \"福建省-三明市-宁化县\": [116.660426, 26.267956],\n  \"福建省-三明市-大田县\": [117.85344, 25.698933],\n  \"福建省-三明市-尤溪县\": [118.19744, 26.176218],\n  \"福建省-三明市-沙县\": [117.798561, 26.402813],\n  \"福建省-三明市-将乐县\": [117.477409, 26.73521],\n  \"福建省-三明市-泰宁县\": [117.182596, 26.90566],\n  \"福建省-三明市-建宁县\": [116.852506, 26.836825],\n  \"福建省-三明市-永安市\": [117.371443, 25.948144],\n  \"福建省-泉州市\": [118.682446, 24.879952],\n  \"福建省-泉州市-鲤城区\": [118.593481, 24.913354],\n  \"福建省-泉州市-丰泽区\": [118.61958, 24.89497],\n  \"福建省-泉州市-洛江区\": [118.677416, 24.946214],\n  \"福建省-泉州市-泉港区\": [118.922433, 25.13965],\n  \"福建省-泉州市-惠安县\": [118.803416, 25.03695],\n  \"福建省-泉州市-安溪县\": [118.192425, 25.06176],\n  \"福建省-泉州市-永春县\": [118.300486, 25.327974],\n  \"福建省-泉州市-德化县\": [118.24755, 25.497309],\n  \"福建省-泉州市-金门县\": [118.330415, 24.440445],\n  \"福建省-泉州市-石狮市\": [118.654519, 24.737665],\n  \"福建省-泉州市-晋江市\": [118.558431, 24.787825],\n  \"福建省-泉州市-南安市\": [118.392572, 24.966362],\n  \"福建省-漳州市\": [117.653576, 24.51893],\n  \"福建省-漳州市-芗城区\": [117.66059, 24.516268],\n  \"福建省-漳州市-龙文区\": [117.716455, 24.50951],\n  \"福建省-漳州市-云霄县\": [117.346448, 23.964073],\n  \"福建省-漳州市-漳浦县\": [117.620443, 24.123462],\n  \"福建省-漳州市-诏安县\": [117.182559, 23.717054],\n  \"福建省-漳州市-长泰县\": [117.765553, 24.631244],\n  \"福建省-漳州市-东山县\": [117.43656, 23.706895],\n  \"福建省-漳州市-南靖县\": [117.363446, 24.520852],\n  \"福建省-漳州市-平和县\": [117.322552, 24.368365],\n  \"福建省-漳州市-华安县\": [117.540586, 25.010068],\n  \"福建省-漳州市-龙海市\": [117.824451, 24.45294],\n  \"福建省-南平市\": [118.0595, 27.292158],\n  \"福建省-南平市-延平区\": [118.188451, 26.643808],\n  \"福建省-南平市-建阳区\": [118.127525, 27.337502],\n  \"福建省-南平市-顺昌县\": [117.816519, 26.799104],\n  \"福建省-南平市-浦城县\": [118.547439, 27.92339],\n  \"福建省-南平市-光泽县\": [117.340482, 27.547273],\n  \"福建省-南平市-松溪县\": [118.791454, 27.532555],\n  \"福建省-南平市-政和县\": [118.863587, 27.371749],\n  \"福建省-南平市-邵武市\": [117.49942, 27.34647],\n  \"福建省-南平市-武夷山市\": [118.041577, 27.762554],\n  \"福建省-南平市-建瓯市\": [118.311461, 27.028955],\n  \"福建省-龙岩市\": [117.023448, 25.08122],\n  \"福建省-龙岩市-新罗区\": [117.043543, 25.104078],\n  \"福建省-龙岩市-永定区\": [116.892447, 24.869137],\n  \"福建省-龙岩市-长汀县\": [116.363568, 25.839185],\n  \"福建省-龙岩市-上杭县\": [116.426443, 25.05557],\n  \"福建省-龙岩市-武平县\": [116.107589, 25.100855],\n  \"福建省-龙岩市-连城县\": [116.760446, 25.716337],\n  \"福建省-龙岩市-漳平市\": [117.426556, 25.295743],\n  \"福建省-宁德市\": [119.554511, 26.672242],\n  \"福建省-宁德市-蕉城区\": [119.533442, 26.666739],\n  \"福建省-宁德市-霞浦县\": [120.011427, 26.891349],\n  \"福建省-宁德市-古田县\": [118.752578, 26.583262],\n  \"福建省-宁德市-屏南县\": [118.992596, 26.914265],\n  \"福建省-宁德市-寿宁县\": [119.511425, 27.46665],\n  \"福建省-宁德市-周宁县\": [119.345567, 27.110239],\n  \"福建省-宁德市-柘荣县\": [119.907457, 27.239962],\n  \"福建省-宁德市-福安市\": [119.654406, 27.094324],\n  \"福建省-宁德市-福鼎市\": [120.223452, 27.330525],\n  \"江西省\": [115.915423, 28.681691],\n  \"江西省-南昌市\": [115.864589, 28.689455],\n  \"江西省-南昌市-东湖区\": [115.905466, 28.691259],\n  \"江西省-南昌市-西湖区\": [115.883536, 28.661977],\n  \"江西省-南昌市-青云谱区\": [115.931416, 28.627236],\n  \"江西省-南昌市-湾里区\": [115.737596, 28.720195],\n  \"江西省-南昌市-青山湖区\": [115.968552, 28.687596],\n  \"江西省-南昌市-新建区\": [115.821451, 28.698749],\n  \"江西省-南昌市-南昌县\": [115.95046, 28.551604],\n  \"江西省-南昌市-安义县\": [115.555441, 28.850794],\n  \"江西省-南昌市-进贤县\": [116.248538, 28.382759],\n  \"江西省-景德镇市\": [117.184576, 29.274248],\n  \"江西省-景德镇市-昌江区\": [117.190579, 29.278854],\n  \"江西省-景德镇市-珠山区\": [117.209548, 29.305778],\n  \"江西省-景德镇市-浮梁县\": [117.221466, 29.357788],\n  \"江西省-景德镇市-乐平市\": [117.158511, 28.984364],\n  \"江西省-萍乡市\": [113.861496, 27.628393],\n  \"江西省-萍乡市-安源区\": [113.87744, 27.621308],\n  \"江西省-萍乡市-湘东区\": [113.7405, 27.645875],\n  \"江西省-萍乡市-莲花县\": [113.968541, 27.133463],\n  \"江西省-萍乡市-上栗县\": [113.801538, 27.886416],\n  \"江西省-萍乡市-芦溪县\": [114.036519, 27.636605],\n  \"江西省-九江市\": [116.007535, 29.711341],\n  \"江西省-九江市-濂溪区\": [115.995599, 29.677495],\n  \"江西省-九江市-浔阳区\": [115.996558, 29.733094],\n  \"江西省-九江市-九江县\": [115.917402, 29.614805],\n  \"江西省-九江市-武宁县\": [115.107442, 29.262352],\n  \"江西省-九江市-修水县\": [114.553568, 29.031176],\n  \"江西省-九江市-永修县\": [115.815407, 29.028006],\n  \"江西省-九江市-德安县\": [115.762578, 29.319172],\n  \"江西省-九江市-都昌县\": [116.210552, 29.278965],\n  \"江西省-九江市-湖口县\": [116.258471, 29.737132],\n  \"江西省-九江市-彭泽县\": [116.55551, 29.902122],\n  \"江西省-九江市-瑞昌市\": [115.68743, 29.681951],\n  \"江西省-九江市-共青城市\": [115.762578, 29.319172],\n  \"江西省-九江市-庐山市\": [116.051426, 29.454539],\n  \"江西省-新余市\": [114.923535, 27.823579],\n  \"江西省-新余市-渝水区\": [114.951424, 27.80684],\n  \"江西省-新余市-分宜县\": [114.698472, 27.820731],\n  \"江西省-鹰潭市\": [117.075575, 28.265787],\n  \"江西省-鹰潭市-月湖区\": [117.043548, 28.245078],\n  \"江西省-鹰潭市-余江县\": [116.824594, 28.215354],\n  \"江西省-鹰潭市-贵溪市\": [117.251399, 28.298735],\n  \"江西省-赣州市\": [114.940503, 25.835176],\n  \"江西省-赣州市-章贡区\": [114.927551, 25.823747],\n  \"江西省-赣州市-南康区\": [114.771538, 25.667053],\n  \"江西省-赣州市-赣县\": [115.01857, 25.866385],\n  \"江西省-赣州市-信丰县\": [114.929521, 25.391975],\n  \"江西省-赣州市-大余县\": [114.368407, 25.407637],\n  \"江西省-赣州市-上犹县\": [114.558549, 25.790519],\n  \"江西省-赣州市-崇义县\": [114.314572, 25.687687],\n  \"江西省-赣州市-安远县\": [115.400559, 25.142743],\n  \"江西省-赣州市-龙南县\": [114.796554, 24.916599],\n  \"江西省-赣州市-定南县\": [115.034564, 24.789784],\n  \"江西省-赣州市-全南县\": [114.536582, 24.748206],\n  \"江西省-赣州市-宁都县\": [116.015494, 26.47598],\n  \"江西省-赣州市-于都县\": [115.421499, 25.957894],\n  \"江西省-赣州市-兴国县\": [115.369552, 26.343883],\n  \"江西省-赣州市-会昌县\": [115.79246, 25.606662],\n  \"江西省-赣州市-寻乌县\": [115.653515, 24.969447],\n  \"江西省-赣州市-石城县\": [116.352594, 26.318972],\n  \"江西省-赣州市-瑞金市\": [116.033421, 25.891666],\n  \"江西省-吉安市\": [115.000511, 27.119727],\n  \"江西省-吉安市-吉州区\": [115.001539, 27.149315],\n  \"江西省-吉安市-青原区\": [115.021561, 27.087663],\n  \"江西省-吉安市-吉安县\": [114.914591, 27.044989],\n  \"江西省-吉安市-吉水县\": [115.14257, 27.23526],\n  \"江西省-吉安市-峡江县\": [115.322403, 27.588235],\n  \"江西省-吉安市-新干县\": [115.393595, 27.746081],\n  \"江西省-吉安市-永丰县\": [115.447402, 27.324342],\n  \"江西省-吉安市-泰和县\": [114.915591, 26.795697],\n  \"江西省-吉安市-遂川县\": [114.527562, 26.319517],\n  \"江西省-吉安市-万安县\": [114.792577, 26.464073],\n  \"江西省-吉安市-安福县\": [114.626478, 27.399076],\n  \"江西省-吉安市-永新县\": [114.249415, 26.951537],\n  \"江西省-吉安市-井冈山市\": [114.295556, 26.75371],\n  \"江西省-宜春市\": [114.423564, 27.820856],\n  \"江西省-宜春市-袁州区\": [114.434561, 27.802583],\n  \"江西省-宜春市-奉新县\": [115.406551, 28.694029],\n  \"江西省-宜春市-万载县\": [114.452537, 28.112133],\n  \"江西省-宜春市-上高县\": [114.931541, 28.238815],\n  \"江西省-宜春市-宜丰县\": [114.700858, 28.400373],\n  \"江西省-宜春市-靖安县\": [115.369553, 28.867082],\n  \"江西省-宜春市-铜鼓县\": [114.377411, 28.527083],\n  \"江西省-宜春市-丰城市\": [115.777478, 28.166614],\n  \"江西省-宜春市-樟树市\": [115.552419, 28.062153],\n  \"江西省-宜春市-高安市\": [115.382565, 28.422857],\n  \"江西省-抚州市\": [116.364539, 27.954892],\n  \"江西省-抚州市-临川区\": [116.31849, 27.940459],\n  \"江西省-抚州市-南城县\": [116.643399, 27.576241],\n  \"江西省-抚州市-黎川县\": [116.914507, 27.28834],\n  \"江西省-抚州市-南丰县\": [116.531404, 27.224734],\n  \"江西省-抚州市-崇仁县\": [116.083549, 27.75908],\n  \"江西省-抚州市-乐安县\": [115.837496, 27.43408],\n  \"江西省-抚州市-宜黄县\": [116.242542, 27.560563],\n  \"江西省-抚州市-金溪县\": [116.760404, 27.925329],\n  \"江西省-抚州市-资溪县\": [117.06657, 27.711846],\n  \"江西省-抚州市-东乡县\": [116.609542, 28.253977],\n  \"江西省-抚州市-广昌县\": [116.342561, 26.848454],\n  \"江西省-上饶市\": [117.94946, 28.460626],\n  \"江西省-上饶市-信州区\": [117.973412, 28.437628],\n  \"江西省-上饶市-广丰区\": [118.19742, 28.442615],\n  \"江西省-上饶市-上饶县\": [117.915584, 28.454187],\n  \"江西省-上饶市-玉山县\": [118.251563, 28.68775],\n  \"江西省-上饶市-铅山县\": [117.716422, 28.321505],\n  \"江西省-上饶市-横峰县\": [117.602397, 28.41344],\n  \"江西省-上饶市-弋阳县\": [117.455506, 28.384082],\n  \"江西省-上饶市-余干县\": [116.701601, 28.707866],\n  \"江西省-上饶市-鄱阳县\": [116.710566, 29.011453],\n  \"江西省-上饶市-万年县\": [117.064599, 28.700054],\n  \"江西省-上饶市-婺源县\": [117.868445, 29.254039],\n  \"江西省-上饶市-德兴市\": [117.58548, 28.952565],\n  \"山东省\": [117.027442, 36.674857],\n  \"山东省-济南市\": [117.126399, 36.656554],\n  \"山东省-济南市-历下区\": [117.082567, 36.672163],\n  \"山东省-济南市-市中区\": [117.004399, 36.657552],\n  \"山东省-济南市-槐荫区\": [116.907458, 36.657562],\n  \"山东省-济南市-天桥区\": [116.993399, 36.684068],\n  \"山东省-济南市-历城区\": [117.07159, 36.685656],\n  \"山东省-济南市-长清区\": [116.758387, 36.560216],\n  \"山东省-济南市-平阴县\": [116.462617, 36.294861],\n  \"山东省-济南市-济阳县\": [117.180621, 36.983971],\n  \"山东省-济南市-商河县\": [117.16353, 37.314971],\n  \"山东省-济南市-章丘市\": [117.532565, 36.685533],\n  \"山东省-青岛市\": [120.389455, 36.072227],\n  \"山东省-青岛市-市南区\": [120.418585, 36.081466],\n  \"山东省-青岛市-市北区\": [120.381404, 36.09345],\n  \"山东省-青岛市-黄岛区\": [120.204547, 35.966383],\n  \"山东省-青岛市-崂山区\": [120.475397, 36.113499],\n  \"山东省-青岛市-李沧区\": [120.439603, 36.151025],\n  \"山东省-青岛市-城阳区\": [120.402527, 36.312886],\n  \"山东省-青岛市-胶州市\": [120.039535, 36.270349],\n  \"山东省-青岛市-即墨市\": [120.453536, 36.394749],\n  \"山东省-青岛市-平度市\": [119.994414, 36.782692],\n  \"山东省-青岛市-莱西市\": [120.524556, 36.893956],\n  \"山东省-淄博市\": [118.061453, 36.819086],\n  \"山东省-淄博市-淄川区\": [117.973412, 36.649835],\n  \"山东省-淄博市-张店区\": [118.024591, 36.811942],\n  \"山东省-淄博市-博山区\": [117.868469, 36.500848],\n  \"山东省-淄博市-临淄区\": [118.315395, 36.832294],\n  \"山东省-淄博市-周村区\": [117.876482, 36.808994],\n  \"山东省-淄博市-桓台县\": [118.104434, 36.965608],\n  \"山东省-淄博市-高青县\": [117.833394, 37.177269],\n  \"山东省-淄博市-沂源县\": [118.177489, 36.190917],\n  \"山东省-枣庄市\": [117.330542, 34.815994],\n  \"山东省-枣庄市-市中区\": [117.562566, 34.869963],\n  \"山东省-枣庄市-薛城区\": [117.269458, 34.801125],\n  \"山东省-枣庄市-峄城区\": [117.596391, 34.7786],\n  \"山东省-枣庄市-台儿庄区\": [117.740425, 34.568763],\n  \"山东省-枣庄市-山亭区\": [117.467443, 35.105692],\n  \"山东省-枣庄市-滕州市\": [117.172565, 35.120035],\n  \"山东省-东营市\": [118.681385, 37.439642],\n  \"山东省-东营市-东营区\": [118.588463, 37.454847],\n  \"山东省-东营市-河口区\": [118.532505, 37.89112],\n  \"山东省-东营市-垦利区\": [118.581432, 37.578555],\n  \"山东省-东营市-利津县\": [118.261618, 37.49586],\n  \"山东省-东营市-广饶县\": [118.413499, 37.059638],\n  \"山东省-烟台市\": [121.454415, 37.470038],\n  \"山东省-烟台市-芝罘区\": [121.40654, 37.546313],\n  \"山东省-烟台市-福山区\": [121.274605, 37.503668],\n  \"山东省-烟台市-牟平区\": [121.606549, 37.392915],\n  \"山东省-烟台市-莱山区\": [121.451381, 37.517649],\n  \"山东省-烟台市-长岛县\": [120.74343, 37.927628],\n  \"山东省-烟台市-龙口市\": [120.485369, 37.652555],\n  \"山东省-烟台市-莱阳市\": [120.718414, 36.984636],\n  \"山东省-烟台市-莱州市\": [119.948593, 37.182637],\n  \"山东省-烟台市-蓬莱市\": [120.765562, 37.816439],\n  \"山东省-烟台市-招远市\": [120.440602, 37.361137],\n  \"山东省-烟台市-栖霞市\": [120.856417, 37.341418],\n  \"山东省-烟台市-海阳市\": [121.180458, 36.69327],\n  \"山东省-潍坊市\": [119.168378, 36.712652],\n  \"山东省-潍坊市-潍城区\": [119.031429, 36.732854],\n  \"山东省-潍坊市-寒亭区\": [119.226615, 36.780744],\n  \"山东省-潍坊市-坊子区\": [119.172401, 36.660742],\n  \"山东省-潍坊市-奎文区\": [119.139471, 36.712752],\n  \"山东省-潍坊市-临朐县\": [118.54945, 36.51913],\n  \"山东省-潍坊市-昌乐县\": [118.836488, 36.712996],\n  \"山东省-潍坊市-青州市\": [118.486537, 36.690417],\n  \"山东省-潍坊市-诸城市\": [119.416402, 36.002009],\n  \"山东省-潍坊市-寿光市\": [118.797415, 36.861922],\n  \"山东省-潍坊市-安丘市\": [119.225608, 36.483842],\n  \"山东省-潍坊市-高密市\": [119.762411, 36.388957],\n  \"山东省-潍坊市-昌邑市\": [119.404406, 36.865161],\n  \"山东省-济宁市\": [116.593612, 35.420177],\n  \"山东省-济宁市-任城区\": [116.55447, 35.493731],\n  \"山东省-济宁市-兖州区\": [116.805536, 35.599737],\n  \"山东省-济宁市-微山县\": [117.135414, 34.813315],\n  \"山东省-济宁市-鱼台县\": [116.657393, 35.017888],\n  \"山东省-济宁市-金乡县\": [116.31853, 35.072569],\n  \"山东省-济宁市-嘉祥县\": [116.348613, 35.413255],\n  \"山东省-济宁市-汶上县\": [116.505441, 35.717055],\n  \"山东省-济宁市-泗水县\": [117.257429, 35.6706],\n  \"山东省-济宁市-梁山县\": [116.10262, 35.808064],\n  \"山东省-济宁市-曲阜市\": [116.993416, 35.587372],\n  \"山东省-济宁市-邹城市\": [117.014404, 35.407521],\n  \"山东省-泰安市\": [117.094495, 36.205858],\n  \"山东省-泰安市-泰山区\": [117.141411, 36.199445],\n  \"山东省-泰安市-岱岳区\": [117.048556, 36.193291],\n  \"山东省-泰安市-宁阳县\": [116.812579, 35.764539],\n  \"山东省-泰安市-东平县\": [116.477594, 35.941908],\n  \"山东省-泰安市-新泰市\": [117.774606, 35.91462],\n  \"山东省-泰安市-肥城市\": [116.775401, 36.188811],\n  \"山东省-威海市\": [122.127541, 37.516431],\n  \"山东省-威海市-环翠区\": [122.129538, 37.507968],\n  \"山东省-威海市-文登区\": [122.064428, 37.200113],\n  \"山东省-威海市-荣成市\": [122.492505, 37.171318],\n  \"山东省-威海市-乳山市\": [121.546429, 36.925177],\n  \"山东省-日照市\": [119.533415, 35.422839],\n  \"山东省-日照市-东港区\": [119.468624, 35.431049],\n  \"山东省-日照市-岚山区\": [119.32553, 35.127432],\n  \"山东省-日照市-五莲县\": [119.21558, 35.755697],\n  \"山东省-日照市-莒县\": [118.843538, 35.585872],\n  \"山东省-莱芜市\": [117.68355, 36.219472],\n  \"山东省-莱芜市-莱城区\": [117.666591, 36.208841],\n  \"山东省-莱芜市-钢城区\": [117.817496, 36.064719],\n  \"山东省-临沂市\": [118.363533, 35.110671],\n  \"山东省-临沂市-兰山区\": [118.3545, 35.05734],\n  \"山东省-临沂市-罗庄区\": [118.291513, 35.002504],\n  \"山东省-临沂市-河东区\": [118.409547, 35.095676],\n  \"山东省-临沂市-沂南县\": [118.471492, 35.556098],\n  \"山东省-临沂市-郯城县\": [118.373587, 34.619226],\n  \"山东省-临沂市-沂水县\": [118.634617, 35.796181],\n  \"山东省-临沂市-兰陵县\": [118.077409, 34.863616],\n  \"山东省-临沂市-费县\": [117.984425, 35.272304],\n  \"山东省-临沂市-平邑县\": [117.646541, 35.51202],\n  \"山东省-临沂市-莒南县\": [118.841541, 35.180812],\n  \"山东省-临沂市-蒙阴县\": [117.951415, 35.716347],\n  \"山东省-临沂市-临沭县\": [118.657495, 34.926019],\n  \"山东省-德州市\": [116.365557, 37.441308],\n  \"山东省-德州市-德城区\": [116.305449, 37.456993],\n  \"山东省-德州市-陵城区\": [116.77141, 37.476844],\n  \"山东省-德州市-宁津县\": [116.806538, 37.658019],\n  \"山东省-德州市-庆云县\": [117.391452, 37.781585],\n  \"山东省-德州市-临邑县\": [116.873404, 37.196169],\n  \"山东省-德州市-齐河县\": [116.769387, 36.789945],\n  \"山东省-德州市-平原县\": [116.440505, 37.171221],\n  \"山东省-德州市-夏津县\": [116.008534, 36.954155],\n  \"山东省-德州市-武城县\": [116.075506, 37.219222],\n  \"山东省-德州市-乐陵市\": [117.238406, 37.735925],\n  \"山东省-德州市-禹城市\": [116.644371, 36.940242],\n  \"山东省-聊城市\": [115.991588, 36.462758],\n  \"山东省-聊城市-东昌府区\": [115.994587, 36.440378],\n  \"山东省-聊城市-阳谷县\": [115.798396, 36.120816],\n  \"山东省-聊城市-莘县\": [115.677397, 36.239907],\n  \"山东省-聊城市-茌平县\": [116.261455, 36.586785],\n  \"山东省-聊城市-东阿县\": [116.254493, 36.340958],\n  \"山东省-聊城市-冠县\": [115.449396, 36.490243],\n  \"山东省-聊城市-高唐县\": [116.235604, 36.851591],\n  \"山东省-聊城市-临清市\": [115.71147, 36.844289],\n  \"山东省-滨州市\": [117.977404, 37.388196],\n  \"山东省-滨州市-滨城区\": [118.026604, 37.436843],\n  \"山东省-滨州市-沾化区\": [118.105454, 37.705298],\n  \"山东省-滨州市-惠民县\": [117.51651, 37.495803],\n  \"山东省-滨州市-阳信县\": [117.584437, 37.647338],\n  \"山东省-滨州市-无棣县\": [117.632457, 37.777567],\n  \"山东省-滨州市-博兴县\": [118.117493, 37.160477],\n  \"山东省-滨州市-邹平县\": [117.749478, 36.870032],\n  \"山东省-菏泽市\": [115.487545, 35.239407],\n  \"山东省-菏泽市-牡丹区\": [115.423443, 35.257018],\n  \"山东省-菏泽市-定陶区\": [115.579437, 35.077275],\n  \"山东省-菏泽市-曹县\": [115.548457, 34.831809],\n  \"山东省-菏泽市-单县\": [116.111584, 34.784658],\n  \"山东省-菏泽市-成武县\": [115.896519, 34.958606],\n  \"山东省-菏泽市-巨野县\": [116.210258, 35.402062],\n  \"山东省-菏泽市-郓城县\": [115.950451, 35.605902],\n  \"山东省-菏泽市-鄄城县\": [115.516607, 35.569204],\n  \"山东省-菏泽市-东明县\": [115.096417, 35.295702],\n  \"河南省\": [113.759384, 34.771713],\n  \"河南省-郑州市\": [113.631419, 34.753439],\n  \"河南省-郑州市-中原区\": [113.619476, 34.754451],\n  \"河南省-郑州市-二七区\": [113.64641, 34.731045],\n  \"河南省-郑州市-管城回族区\": [113.683525, 34.759674],\n  \"河南省-郑州市-金水区\": [113.666448, 34.80607],\n  \"河南省-郑州市-上街区\": [113.315497, 34.808819],\n  \"河南省-郑州市-惠济区\": [113.623455, 34.87352],\n  \"河南省-郑州市-中牟县\": [113.982485, 34.725011],\n  \"河南省-郑州市-巩义市\": [113.028431, 34.754097],\n  \"河南省-郑州市-荥阳市\": [113.389423, 34.793811],\n  \"河南省-郑州市-新密市\": [113.397391, 34.545898],\n  \"河南省-郑州市-新郑市\": [113.746434, 34.401766],\n  \"河南省-郑州市-登封市\": [113.056423, 34.459697],\n  \"河南省-开封市\": [114.314593, 34.802886],\n  \"河南省-开封市-龙亭区\": [114.361413, 34.822036],\n  \"河南省-开封市-顺河回族区\": [114.361413, 34.822036],\n  \"河南省-开封市-鼓楼区\": [114.361413, 34.822036],\n  \"河南省-开封市-禹王台区\": [114.361413, 34.822036],\n  \"河南省-开封市-金明区\": [114.229635, 34.798756],\n  \"河南省-开封市-祥符区\": [114.452186, 34.726004],\n  \"河南省-开封市-杞县\": [114.789592, 34.554857],\n  \"河南省-开封市-通许县\": [114.473436, 34.486772],\n  \"河南省-开封市-尉氏县\": [114.199561, 34.417228],\n  \"河南省-开封市-兰考县\": [114.827461, 34.828493],\n  \"河南省-洛阳市\": [112.459421, 34.624263],\n  \"河南省-洛阳市-老城区\": [112.476504, 34.689601],\n  \"河南省-洛阳市-西工区\": [112.4344, 34.666768],\n  \"河南省-洛阳市-瀍河回族区\": [112.506604, 34.685462],\n  \"河南省-洛阳市-涧西区\": [112.402552, 34.663469],\n  \"河南省-洛阳市-吉利区\": [112.595478, 34.907013],\n  \"河南省-洛阳市-洛龙区\": [112.470469, 34.624705],\n  \"河南省-洛阳市-孟津县\": [112.451418, 34.831732],\n  \"河南省-洛阳市-新安县\": [112.14061, 34.734383],\n  \"河南省-洛阳市-栾川县\": [111.622427, 33.791822],\n  \"河南省-洛阳市-嵩县\": [112.092408, 34.140722],\n  \"河南省-洛阳市-汝阳县\": [112.479503, 34.159843],\n  \"河南省-洛阳市-宜阳县\": [112.179465, 34.541047],\n  \"河南省-洛阳市-洛宁县\": [111.659587, 34.394985],\n  \"河南省-洛阳市-伊川县\": [112.432407, 34.427646],\n  \"河南省-洛阳市-偃师市\": [112.796421, 34.733797],\n  \"河南省-平顶山市\": [113.199529, 33.772051],\n  \"河南省-平顶山市-新华区\": [113.30044, 33.743657],\n  \"河南省-平顶山市-卫东区\": [113.341611, 33.740376],\n  \"河南省-平顶山市-石龙区\": [112.905455, 33.904754],\n  \"河南省-平顶山市-湛河区\": [113.250515, 33.68579],\n  \"河南省-平顶山市-宝丰县\": [113.061447, 33.874746],\n  \"河南省-平顶山市-叶县\": [113.363582, 33.632492],\n  \"河南省-平顶山市-鲁山县\": [112.914434, 33.744879],\n  \"河南省-平顶山市-郏县\": [113.219606, 33.977486],\n  \"河南省-平顶山市-舞钢市\": [113.53141, 33.299431],\n  \"河南省-平顶山市-汝州市\": [112.85055, 34.172768],\n  \"河南省-安阳市\": [114.3995, 36.105941],\n  \"河南省-安阳市-文峰区\": [114.363374, 36.096833],\n  \"河南省-安阳市-北关区\": [114.362382, 36.113132],\n  \"河南省-安阳市-殷都区\": [114.309598, 36.115758],\n  \"河南省-安阳市-龙安区\": [114.307593, 36.082753],\n  \"河南省-安阳市-安阳县\": [114.238382, 36.218907],\n  \"河南省-安阳市-汤阴县\": [114.363409, 35.927644],\n  \"河南省-安阳市-滑县\": [114.525553, 35.581045],\n  \"河南省-安阳市-内黄县\": [114.907589, 35.97695],\n  \"河南省-安阳市-林州市\": [113.82559, 36.088853],\n  \"河南省-鹤壁市\": [114.303594, 35.752357],\n  \"河南省-鹤壁市-鹤山区\": [114.169555, 35.96028],\n  \"河南省-鹤壁市-山城区\": [114.190621, 35.90337],\n  \"河南省-鹤壁市-淇滨区\": [114.305591, 35.746953],\n  \"河南省-鹤壁市-浚县\": [114.557608, 35.681917],\n  \"河南省-鹤壁市-淇县\": [114.21549, 35.627277],\n  \"河南省-新乡市\": [113.9336, 35.30964],\n  \"河南省-新乡市-红旗区\": [113.881416, 35.310136],\n  \"河南省-新乡市-卫滨区\": [113.872439, 35.308459],\n  \"河南省-新乡市-凤泉区\": [113.912459, 35.375665],\n  \"河南省-新乡市-牧野区\": [113.915513, 35.321023],\n  \"河南省-新乡市-新乡县\": [113.811594, 35.196564],\n  \"河南省-新乡市-获嘉县\": [113.663417, 35.265809],\n  \"河南省-新乡市-原阳县\": [113.946624, 35.071164],\n  \"河南省-新乡市-延津县\": [114.211512, 35.147807],\n  \"河南省-新乡市-封丘县\": [114.425606, 35.046858],\n  \"河南省-新乡市-长垣县\": [114.67561, 35.207198],\n  \"河南省-新乡市-卫辉市\": [114.071601, 35.404069],\n  \"河南省-新乡市-辉县市\": [113.811573, 35.467958],\n  \"河南省-焦作市\": [113.248548, 35.220963],\n  \"河南省-焦作市-解放区\": [113.237572, 35.24631],\n  \"河南省-焦作市-中站区\": [113.189448, 35.242617],\n  \"河南省-焦作市-马村区\": [113.328544, 35.261894],\n  \"河南省-焦作市-山阳区\": [113.260484, 35.220272],\n  \"河南省-焦作市-修武县\": [113.454582, 35.229323],\n  \"河南省-焦作市-博爱县\": [113.070478, 35.177308],\n  \"河南省-焦作市-武陟县\": [113.408396, 35.105838],\n  \"河南省-焦作市-温县\": [113.086569, 34.946135],\n  \"河南省-焦作市-沁阳市\": [112.957517, 35.093786],\n  \"河南省-焦作市-孟州市\": [112.797395, 34.913598],\n  \"河南省-濮阳市\": [115.035597, 35.767593],\n  \"河南省-濮阳市-华龙区\": [115.080413, 35.783633],\n  \"河南省-濮阳市-清丰县\": [115.110472, 35.891308],\n  \"河南省-濮阳市-南乐县\": [115.211386, 36.076031],\n  \"河南省-濮阳市-范县\": [115.510586, 35.857655],\n  \"河南省-濮阳市-台前县\": [115.878568, 35.975013],\n  \"河南省-濮阳市-濮阳县\": [115.035584, 35.717889],\n  \"河南省-许昌市\": [113.858476, 34.041432],\n  \"河南省-许昌市-魏都区\": [113.829596, 34.030861],\n  \"河南省-许昌市-许昌县\": [113.829615, 34.129967],\n  \"河南省-许昌市-鄢陵县\": [114.18562, 34.107963],\n  \"河南省-许昌市-襄城县\": [113.513431, 33.856968],\n  \"河南省-许昌市-禹州市\": [113.495505, 34.146082],\n  \"河南省-许昌市-长葛市\": [113.774421, 34.223016],\n  \"河南省-漯河市\": [114.023421, 33.587711],\n  \"河南省-漯河市-源汇区\": [113.990414, 33.578423],\n  \"河南省-漯河市-郾城区\": [114.013394, 33.593416],\n  \"河南省-漯河市-召陵区\": [114.100467, 33.592468],\n  \"河南省-漯河市-舞阳县\": [113.61549, 33.443578],\n  \"河南省-漯河市-临颍县\": [113.937578, 33.832692],\n  \"河南省-三门峡市\": [111.206533, 34.778327],\n  \"河南省-三门峡市-湖滨区\": [111.195574, 34.775997],\n  \"河南省-三门峡市-陕州区\": [111.109451, 34.726915],\n  \"河南省-三门峡市-渑池县\": [111.768542, 34.773197],\n  \"河南省-三门峡市-卢氏县\": [111.054564, 34.059925],\n  \"河南省-三门峡市-义马市\": [111.880515, 34.753028],\n  \"河南省-三门峡市-灵宝市\": [110.900408, 34.523143],\n  \"河南省-南阳市\": [112.534501, 32.996562],\n  \"河南省-南阳市-宛城区\": [112.546454, 33.00987],\n  \"河南省-南阳市-卧龙区\": [112.541462, 32.992484],\n  \"河南省-南阳市-南召县\": [112.435425, 33.496186],\n  \"河南省-南阳市-方城县\": [113.018503, 33.260539],\n  \"河南省-南阳市-西峡县\": [111.480398, 33.313316],\n  \"河南省-南阳市-镇平县\": [112.241544, 33.039719],\n  \"河南省-南阳市-内乡县\": [111.855425, 33.051203],\n  \"河南省-南阳市-淅川县\": [111.497432, 33.144185],\n  \"河南省-南阳市-社旗县\": [112.954493, 33.062237],\n  \"河南省-南阳市-唐河县\": [112.813424, 32.687721],\n  \"河南省-南阳市-新野县\": [112.36655, 32.526632],\n  \"河南省-南阳市-桐柏县\": [113.434473, 32.385131],\n  \"河南省-南阳市-邓州市\": [112.09342, 32.693917],\n  \"河南省-商丘市\": [115.662449, 34.420202],\n  \"河南省-商丘市-梁园区\": [115.620602, 34.449471],\n  \"河南省-商丘市-睢阳区\": [115.659476, 34.394152],\n  \"河南省-商丘市-民权县\": [115.154576, 34.652479],\n  \"河南省-商丘市-睢县\": [115.078411, 34.451617],\n  \"河南省-商丘市-宁陵县\": [115.320418, 34.466634],\n  \"河南省-商丘市-柘城县\": [115.312435, 34.09736],\n  \"河南省-商丘市-虞城县\": [115.834473, 34.405332],\n  \"河南省-商丘市-夏邑县\": [116.137512, 34.243523],\n  \"河南省-商丘市-永城市\": [116.455566, 33.934801],\n  \"河南省-信阳市\": [114.097483, 32.153015],\n  \"河南省-信阳市-浉河区\": [114.065581, 32.122554],\n  \"河南省-信阳市-平桥区\": [114.132407, 32.107325],\n  \"河南省-信阳市-罗山县\": [114.51953, 32.20915],\n  \"河南省-信阳市-光山县\": [114.925533, 32.015907],\n  \"河南省-信阳市-新县\": [114.885525, 31.649738],\n  \"河南省-信阳市-商城县\": [115.413513, 31.804345],\n  \"河南省-信阳市-固始县\": [115.660488, 32.174174],\n  \"河南省-信阳市-潢川县\": [115.058471, 32.137531],\n  \"河南省-信阳市-淮滨县\": [115.426439, 32.47947],\n  \"河南省-信阳市-息县\": [114.747453, 32.348956],\n  \"河南省-周口市\": [114.703483, 33.631829],\n  \"河南省-周口市-川汇区\": [114.657602, 33.652997],\n  \"河南省-周口市-扶沟县\": [114.40151, 34.065906],\n  \"河南省-周口市-西华县\": [114.535597, 33.773215],\n  \"河南省-周口市-商水县\": [114.618416, 33.548877],\n  \"河南省-周口市-沈丘县\": [115.105455, 33.415691],\n  \"河南省-周口市-郸城县\": [115.183478, 33.650828],\n  \"河南省-周口市-淮阳县\": [114.892586, 33.737347],\n  \"河南省-周口市-太康县\": [114.844384, 34.070038],\n  \"河南省-周口市-鹿邑县\": [115.490585, 33.867173],\n  \"河南省-周口市-项城市\": [114.881514, 33.473007],\n  \"河南省-驻马店市\": [114.028471, 33.017842],\n  \"河南省-驻马店市-驿城区\": [114.000387, 32.97952],\n  \"河南省-驻马店市-西平县\": [114.027474, 33.393861],\n  \"河南省-驻马店市-上蔡县\": [114.270487, 33.268511],\n  \"河南省-驻马店市-平舆县\": [114.625429, 32.967982],\n  \"河南省-驻马店市-正阳县\": [114.399497, 32.611641],\n  \"河南省-驻马店市-确山县\": [114.032495, 32.808176],\n  \"河南省-驻马店市-泌阳县\": [113.333558, 32.729731],\n  \"河南省-驻马店市-汝南县\": [114.369409, 33.013141],\n  \"河南省-驻马店市-遂平县\": [114.019441, 33.151971],\n  \"河南省-驻马店市-新蔡县\": [114.992469, 32.755269],\n  \"河南省-济源市\": [112.608581, 35.072907],\n  \"湖北省\": [114.348441, 30.5516],\n  \"湖北省-武汉市\": [114.311582, 30.598467],\n  \"湖北省-武汉市-江岸区\": [114.316579, 30.605403],\n  \"湖北省-武汉市-江汉区\": [114.277506, 30.607282],\n  \"湖北省-武汉市-硚口区\": [114.22146, 30.587584],\n  \"湖北省-武汉市-汉阳区\": [114.225446, 30.560052],\n  \"湖北省-武汉市-武昌区\": [114.322549, 30.559567],\n  \"湖北省-武汉市-青山区\": [114.391493, 30.646593],\n  \"湖北省-武汉市-洪山区\": [114.350456, 30.506334],\n  \"湖北省-武汉市-东西湖区\": [114.143459, 30.62592],\n  \"湖北省-武汉市-汉南区\": [114.091515, 30.314809],\n  \"湖北省-武汉市-蔡甸区\": [114.03548, 30.588114],\n  \"湖北省-武汉市-江夏区\": [114.328551, 30.381564],\n  \"湖北省-武汉市-黄陂区\": [114.382454, 30.887534],\n  \"湖北省-武汉市-新洲区\": [114.807543, 30.847244],\n  \"湖北省-黄石市\": [115.045533, 30.205208],\n  \"湖北省-黄石市-黄石港区\": [115.072417, 30.229053],\n  \"湖北省-黄石市-西塞山区\": [115.116481, 30.210695],\n  \"湖北省-黄石市-下陆区\": [114.967416, 30.180046],\n  \"湖北省-黄石市-铁山区\": [114.907571, 30.212251],\n  \"湖北省-黄石市-阳新县\": [115.221427, 29.836542],\n  \"湖北省-黄石市-大冶市\": [114.986436, 30.101668],\n  \"湖北省-十堰市\": [110.80453, 32.635062],\n  \"湖北省-十堰市-茅箭区\": [110.81958, 32.597287],\n  \"湖北省-十堰市-张湾区\": [110.775424, 32.6584],\n  \"湖北省-十堰市-郧阳区\": [110.818577, 32.840592],\n  \"湖北省-十堰市-郧西县\": [110.432473, 32.999167],\n  \"湖北省-十堰市-竹山县\": [110.235582, 32.230304],\n  \"湖北省-十堰市-竹溪县\": [109.721542, 32.32412],\n  \"湖北省-十堰市-房县\": [110.747462, 32.061685],\n  \"湖北省-十堰市-丹江口市\": [111.519532, 32.546253],\n  \"湖北省-宜昌市\": [111.292549, 30.697446],\n  \"湖北省-宜昌市-西陵区\": [111.29256, 30.716749],\n  \"湖北省-宜昌市-伍家岗区\": [111.367422, 30.650737],\n  \"湖北省-宜昌市-点军区\": [111.274471, 30.69933],\n  \"湖北省-宜昌市-猇亭区\": [111.441574, 30.536466],\n  \"湖北省-宜昌市-夷陵区\": [111.33253, 30.774833],\n  \"湖北省-宜昌市-远安县\": [111.64653, 31.066628],\n  \"湖北省-宜昌市-兴山县\": [110.753446, 31.354464],\n  \"湖北省-宜昌市-秭归县\": [110.984449, 30.831932],\n  \"湖北省-宜昌市-长阳土家族自治县\": [111.213507, 30.478646],\n  \"湖北省-宜昌市-五峰土家族自治县\": [111.052581, 30.171156],\n  \"湖北省-宜昌市-宜都市\": [111.456516, 30.384404],\n  \"湖北省-宜昌市-当阳市\": [111.794569, 30.826989],\n  \"湖北省-宜昌市-枝江市\": [111.76654, 30.431731],\n  \"湖北省-襄阳市\": [112.128537, 32.014797],\n  \"湖北省-襄阳市-襄城区\": [112.140572, 32.016175],\n  \"湖北省-襄阳市-樊城区\": [112.142599, 32.050572],\n  \"湖北省-襄阳市-襄州区\": [112.218434, 32.093376],\n  \"湖北省-襄阳市-南漳县\": [111.845386, 31.78113],\n  \"湖北省-襄阳市-谷城县\": [111.659576, 32.268983],\n  \"湖北省-襄阳市-保康县\": [111.267441, 31.883847],\n  \"湖北省-襄阳市-老河口市\": [111.681556, 32.39246],\n  \"湖北省-襄阳市-枣阳市\": [112.778471, 32.13473],\n  \"湖北省-襄阳市-宜城市\": [112.264611, 31.72547],\n  \"湖北省-鄂州市\": [114.901607, 30.396572],\n  \"湖北省-鄂州市-梁子湖区\": [114.691507, 30.105907],\n  \"湖北省-鄂州市-华容区\": [114.736426, 30.5406],\n  \"湖北省-鄂州市-鄂城区\": [114.8986, 30.406389],\n  \"湖北省-荆门市\": [112.206393, 31.041733],\n  \"湖北省-荆门市-东宝区\": [112.208388, 31.058429],\n  \"湖北省-荆门市-掇刀区\": [112.214428, 30.979911],\n  \"湖北省-荆门市-京山县\": [113.126548, 31.024331],\n  \"湖北省-荆门市-沙洋县\": [112.595485, 30.715315],\n  \"湖北省-荆门市-钟祥市\": [112.594471, 31.17403],\n  \"湖北省-孝感市\": [113.92251, 30.930689],\n  \"湖北省-孝感市-孝南区\": [113.91749, 30.922978],\n  \"湖北省-孝感市-孝昌县\": [114.004409, 31.26454],\n  \"湖北省-孝感市-大悟县\": [114.133413, 31.56722],\n  \"湖北省-孝感市-云梦县\": [113.759412, 31.027218],\n  \"湖北省-孝感市-应城市\": [113.579567, 30.933977],\n  \"湖北省-孝感市-安陆市\": [113.695583, 31.261415],\n  \"湖北省-孝感市-汉川市\": [113.845549, 30.666914],\n  \"湖北省-荆州市\": [112.245523, 30.340842],\n  \"湖北省-荆州市-沙市区\": [112.261577, 30.316572],\n  \"湖北省-荆州市-荆州区\": [112.196414, 30.358989],\n  \"湖北省-荆州市-公安县\": [112.236502, 30.064401],\n  \"湖北省-荆州市-监利县\": [112.91142, 29.845735],\n  \"湖北省-荆州市-江陵县\": [112.431452, 30.048043],\n  \"湖北省-荆州市-石首市\": [112.43142, 29.727034],\n  \"湖北省-荆州市-洪湖市\": [113.482553, 29.83277],\n  \"湖北省-荆州市-松滋市\": [111.77358, 30.175342],\n  \"湖北省-黄冈市\": [114.87849, 30.459359],\n  \"湖北省-黄冈市-黄州区\": [114.886532, 30.440224],\n  \"湖北省-黄冈市-团风县\": [114.878524, 30.649368],\n  \"湖北省-黄冈市-红安县\": [114.624426, 31.294297],\n  \"湖北省-黄冈市-罗田县\": [115.405547, 30.78891],\n  \"湖北省-黄冈市-英山县\": [115.687422, 30.74135],\n  \"湖北省-黄冈市-浠水县\": [115.271569, 30.457461],\n  \"湖北省-黄冈市-蕲春县\": [115.442399, 30.232535],\n  \"湖北省-黄冈市-黄梅县\": [115.950462, 30.076605],\n  \"湖北省-黄冈市-麻城市\": [115.016562, 31.176996],\n  \"湖北省-黄冈市-武穴市\": [115.567392, 29.850441],\n  \"湖北省-咸宁市\": [114.328519, 29.847056],\n  \"湖北省-咸宁市-咸安区\": [114.30457, 29.858154],\n  \"湖北省-咸宁市-嘉鱼县\": [113.94557, 29.976354],\n  \"湖北省-咸宁市-通城县\": [113.823568, 29.250858],\n  \"湖北省-咸宁市-崇阳县\": [114.046563, 29.561334],\n  \"湖北省-咸宁市-通山县\": [114.489393, 29.612634],\n  \"湖北省-咸宁市-赤壁市\": [113.906437, 29.730666],\n  \"湖北省-随州市\": [113.38945, 31.696517],\n  \"湖北省-随州市-曾都区\": [113.377513, 31.722123],\n  \"湖北省-随州市-随县\": [113.377513, 31.722123],\n  \"湖北省-随州市-广水市\": [113.832593, 31.622476],\n  \"湖北省-恩施土家族苗族自治州\": [109.494593, 30.27794],\n  \"湖北省-恩施土家族苗族自治州-恩施市\": [109.48655, 30.301037],\n  \"湖北省-恩施土家族苗族自治州-利川市\": [108.942481, 30.297203],\n  \"湖北省-恩施土家族苗族自治州-建始县\": [109.728556, 30.607907],\n  \"湖北省-恩施土家族苗族自治州-巴东县\": [110.347575, 31.048064],\n  \"湖北省-恩施土家族苗族自治州-宣恩县\": [109.497568, 29.992604],\n  \"湖北省-恩施土家族苗族自治州-咸丰县\": [109.146608, 29.671078],\n  \"湖北省-恩施土家族苗族自治州-来凤县\": [109.413495, 29.499444],\n  \"湖北省-恩施土家族苗族自治州-鹤峰县\": [110.040424, 29.896116],\n  \"湖北省-仙桃市\": [113.461591, 30.368272],\n  \"湖北省-潜江市\": [112.905474, 30.408358],\n  \"湖北省-天门市\": [113.172409, 30.669622],\n  \"湖北省-神农架林区\": [110.682525, 31.750496],\n  \"湖南省\": [112.989603, 28.11827],\n  \"湖南省-长沙市\": [112.945473, 28.234889],\n  \"湖南省-长沙市-芙蓉区\": [113.039408, 28.191913],\n  \"湖南省-长沙市-天心区\": [112.996592, 28.118211],\n  \"湖南省-长沙市-岳麓区\": [112.937448, 28.241489],\n  \"湖南省-长沙市-开福区\": [112.992585, 28.261379],\n  \"湖南省-长沙市-雨花区\": [113.042422, 28.142233],\n  \"湖南省-长沙市-望城区\": [112.824466, 28.367403],\n  \"湖南省-长沙市-长沙县\": [113.087559, 28.251818],\n  \"湖南省-长沙市-宁乡县\": [112.558407, 28.284105],\n  \"湖南省-长沙市-浏阳市\": [113.649398, 28.169832],\n  \"湖南省-株洲市\": [113.140471, 27.833568],\n  \"湖南省-株洲市-荷塘区\": [113.180452, 27.862156],\n  \"湖南省-株洲市-芦淞区\": [113.158419, 27.791509],\n  \"湖南省-株洲市-石峰区\": [113.124568, 27.880705],\n  \"湖南省-株洲市-天元区\": [113.089541, 27.833084],\n  \"湖南省-株洲市-株洲县\": [113.150427, 27.704323],\n  \"湖南省-株洲市-攸县\": [113.351578, 27.005772],\n  \"湖南省-株洲市-茶陵县\": [113.545472, 26.783589],\n  \"湖南省-株洲市-炎陵县\": [113.779419, 26.496061],\n  \"湖南省-株洲市-醴陵市\": [113.503483, 27.652325],\n  \"湖南省-湘潭市\": [112.950464, 27.835702],\n  \"湖南省-湘潭市-雨湖区\": [112.91345, 27.862467],\n  \"湖南省-湘潭市-岳塘区\": [112.975589, 27.877721],\n  \"湖南省-湘潭市-湘潭县\": [112.957505, 27.784983],\n  \"湖南省-湘潭市-湘乡市\": [112.541492, 27.740191],\n  \"湖南省-湘潭市-韶山市\": [112.533499, 27.921044],\n  \"湖南省-衡阳市\": [112.578447, 26.899576],\n  \"湖南省-衡阳市-珠晖区\": [112.626594, 26.900265],\n  \"湖南省-衡阳市-雁峰区\": [112.623588, 26.894368],\n  \"湖南省-衡阳市-石鼓区\": [112.60453, 26.948962],\n  \"湖南省-衡阳市-蒸湘区\": [112.573444, 26.91772],\n  \"湖南省-衡阳市-南岳区\": [112.745574, 27.23836],\n  \"湖南省-衡阳市-衡阳县\": [112.377553, 26.975295],\n  \"湖南省-衡阳市-衡南县\": [112.684403, 26.744532],\n  \"湖南省-衡阳市-衡山县\": [112.875563, 27.235996],\n  \"湖南省-衡阳市-衡东县\": [112.959495, 27.087043],\n  \"湖南省-衡阳市-祁东县\": [112.096447, 26.805995],\n  \"湖南省-衡阳市-耒阳市\": [112.866597, 26.428066],\n  \"湖南省-衡阳市-常宁市\": [112.405561, 26.42672],\n  \"湖南省-邵阳市\": [111.474433, 27.24527],\n  \"湖南省-邵阳市-双清区\": [111.503442, 27.239109],\n  \"湖南省-邵阳市-大祥区\": [111.445528, 27.227014],\n  \"湖南省-邵阳市-北塔区\": [111.458497, 27.251536],\n  \"湖南省-邵阳市-邵东县\": [111.750491, 27.264507],\n  \"湖南省-邵阳市-新邵县\": [111.464449, 27.327132],\n  \"湖南省-邵阳市-邵阳县\": [111.280508, 26.996528],\n  \"湖南省-邵阳市-隆回县\": [111.039507, 27.119946],\n  \"湖南省-邵阳市-洞口县\": [110.582579, 27.065975],\n  \"湖南省-邵阳市-绥宁县\": [110.16242, 26.588423],\n  \"湖南省-邵阳市-新宁县\": [110.863491, 26.439724],\n  \"湖南省-邵阳市-城步苗族自治县\": [110.328537, 26.396203],\n  \"湖南省-邵阳市-武冈市\": [110.638408, 26.732899],\n  \"湖南省-岳阳市\": [113.135489, 29.363178],\n  \"湖南省-岳阳市-岳阳楼区\": [113.136481, 29.377995],\n  \"湖南省-岳阳市-云溪区\": [113.278407, 29.479907],\n  \"湖南省-岳阳市-君山区\": [113.012517, 29.467129],\n  \"湖南省-岳阳市-岳阳县\": [113.122544, 29.150269],\n  \"湖南省-岳阳市-华容县\": [112.547462, 29.536286],\n  \"湖南省-岳阳市-湘阴县\": [112.889522, 28.676676],\n  \"湖南省-岳阳市-平江县\": [113.587604, 28.707564],\n  \"湖南省-岳阳市-汨罗市\": [113.073493, 28.812455],\n  \"湖南省-岳阳市-临湘市\": [113.456562, 29.482801],\n  \"湖南省-常德市\": [111.705452, 29.03775],\n  \"湖南省-常德市-武陵区\": [111.689545, 29.060783],\n  \"湖南省-常德市-鼎城区\": [111.687522, 29.024443],\n  \"湖南省-常德市-安乡县\": [112.177506, 29.41732],\n  \"湖南省-常德市-汉寿县\": [111.976412, 28.912288],\n  \"湖南省-常德市-澧县\": [111.765534, 29.638946],\n  \"湖南省-常德市-临澧县\": [111.653585, 29.446544],\n  \"湖南省-常德市-桃源县\": [111.495407, 28.908694],\n  \"湖南省-常德市-石门县\": [111.386451, 29.590366],\n  \"湖南省-常德市-津市市\": [111.884517, 29.611259],\n  \"湖南省-张家界市\": [110.485533, 29.122816],\n  \"湖南省-张家界市-永定区\": [110.544432, 29.126191],\n  \"湖南省-张家界市-武陵源区\": [110.557499, 29.351681],\n  \"湖南省-张家界市-慈利县\": [111.145471, 29.435987],\n  \"湖南省-张家界市-桑植县\": [110.170413, 29.405923],\n  \"湖南省-益阳市\": [112.361516, 28.559711],\n  \"湖南省-益阳市-资阳区\": [112.330435, 28.597235],\n  \"湖南省-益阳市-赫山区\": [112.380598, 28.584984],\n  \"湖南省-益阳市-南县\": [112.402542, 29.36707],\n  \"湖南省-益阳市-桃江县\": [112.162541, 28.523871],\n  \"湖南省-益阳市-安化县\": [111.219493, 28.380054],\n  \"湖南省-益阳市-沅江市\": [112.360532, 28.850234],\n  \"湖南省-郴州市\": [113.02146, 25.776683],\n  \"湖南省-郴州市-北湖区\": [113.017482, 25.790815],\n  \"湖南省-郴州市-苏仙区\": [113.048423, 25.806737],\n  \"湖南省-郴州市-桂阳县\": [112.74056, 25.759775],\n  \"湖南省-郴州市-宜章县\": [112.955479, 25.405714],\n  \"湖南省-郴州市-永兴县\": [113.122533, 26.132968],\n  \"湖南省-郴州市-嘉禾县\": [112.375584, 25.593422],\n  \"湖南省-郴州市-临武县\": [112.570411, 25.282527],\n  \"湖南省-郴州市-汝城县\": [113.691545, 25.556057],\n  \"湖南省-郴州市-桂东县\": [113.951594, 26.083174],\n  \"湖南省-郴州市-安仁县\": [113.275424, 26.715683],\n  \"湖南省-郴州市-资兴市\": [113.242556, 25.981874],\n  \"湖南省-永州市\": [111.619455, 26.425864],\n  \"湖南省-永州市-零陵区\": [111.637502, 26.227682],\n  \"湖南省-永州市-冷水滩区\": [111.598426, 26.467706],\n  \"湖南省-永州市-祁阳县\": [111.84742, 26.586435],\n  \"湖南省-永州市-东安县\": [111.323542, 26.398288],\n  \"湖南省-永州市-双牌县\": [111.667594, 25.967169],\n  \"湖南省-永州市-道县\": [111.607404, 25.53253],\n  \"湖南省-永州市-江永县\": [111.350437, 25.279721],\n  \"湖南省-永州市-宁远县\": [111.952453, 25.577052],\n  \"湖南省-永州市-蓝山县\": [112.203435, 25.375935],\n  \"湖南省-永州市-新田县\": [112.210409, 25.909826],\n  \"湖南省-永州市-江华瑶族自治县\": [111.585452, 25.191349],\n  \"湖南省-怀化市\": [110.008514, 27.575161],\n  \"湖南省-怀化市-鹤城区\": [110.0464, 27.585226],\n  \"湖南省-怀化市-中方县\": [109.951462, 27.446081],\n  \"湖南省-怀化市-沅陵县\": [110.400431, 28.459018],\n  \"湖南省-怀化市-辰溪县\": [110.190487, 28.012605],\n  \"湖南省-怀化市-溆浦县\": [110.601551, 27.913963],\n  \"湖南省-怀化市-会同县\": [109.741586, 26.893384],\n  \"湖南省-怀化市-麻阳苗族自治县\": [109.809436, 27.87193],\n  \"湖南省-怀化市-新晃侗族自治县\": [109.181472, 27.358783],\n  \"湖南省-怀化市-芷江侗族自治县\": [109.691402, 27.449513],\n  \"湖南省-怀化市-靖州苗族侗族自治县\": [109.702452, 26.581321],\n  \"湖南省-怀化市-通道侗族自治县\": [109.790445, 26.16422],\n  \"湖南省-怀化市-洪江市\": [109.84351, 27.215077],\n  \"湖南省-娄底市\": [112.001503, 27.703209],\n  \"湖南省-娄底市-娄星区\": [112.008558, 27.735605],\n  \"湖南省-娄底市-双峰县\": [112.18146, 27.462983],\n  \"湖南省-娄底市-新化县\": [111.334515, 27.732667],\n  \"湖南省-娄底市-冷水江市\": [111.44154, 27.692059],\n  \"湖南省-娄底市-涟源市\": [111.670562, 27.698168],\n  \"湖南省-湘西土家族苗族自治州\": [109.745577, 28.317369],\n  \"湖南省-湘西土家族苗族自治州-吉首市\": [109.704449, 28.267493],\n  \"湖南省-湘西土家族苗族自治州-泸溪县\": [110.226599, 28.221873],\n  \"湖南省-湘西土家族苗族自治州-凤凰县\": [109.605527, 27.953848],\n  \"湖南省-湘西土家族苗族自治州-花垣县\": [109.488562, 28.57791],\n  \"湖南省-湘西土家族苗族自治州-保靖县\": [109.666474, 28.705969],\n  \"湖南省-湘西土家族苗族自治州-古丈县\": [109.957507, 28.623084],\n  \"湖南省-湘西土家族苗族自治州-永顺县\": [109.863586, 28.985774],\n  \"湖南省-湘西土家族苗族自治州-龙山县\": [109.450416, 29.464122],\n  \"广东省\": [113.272429, 23.137949],\n  \"广东省-广州市\": [113.271431, 23.135336],\n  \"广东省-广州市-荔湾区\": [113.250502, 23.131791],\n  \"广东省-广州市-越秀区\": [113.273426, 23.13526],\n  \"广东省-广州市-海珠区\": [113.32354, 23.088981],\n  \"广东省-广州市-天河区\": [113.368509, 23.130358],\n  \"广东省-广州市-白云区\": [113.279433, 23.164317],\n  \"广东省-广州市-黄埔区\": [113.466563, 23.112058],\n  \"广东省-广州市-番禺区\": [113.39047, 22.943831],\n  \"广东省-广州市-花都区\": [113.226576, 23.411162],\n  \"广东省-广州市-南沙区\": [113.531436, 22.807929],\n  \"广东省-广州市-从化区\": [113.593585, 23.553986],\n  \"广东省-广州市-增城区\": [113.817546, 23.266592],\n  \"广东省-韶关市\": [113.603527, 24.815881],\n  \"广东省-韶关市-武江区\": [113.594556, 24.798486],\n  \"广东省-韶关市-浈江区\": [113.617477, 24.810414],\n  \"广东省-韶关市-曲江区\": [113.611501, 24.688408],\n  \"广东省-韶关市-始兴县\": [114.068567, 24.958558],\n  \"广东省-韶关市-仁化县\": [113.755443, 25.092288],\n  \"广东省-韶关市-翁源县\": [114.136427, 24.356594],\n  \"广东省-韶关市-乳源瑶族自治县\": [113.282431, 24.782333],\n  \"广东省-韶关市-新丰县\": [114.213512, 24.065547],\n  \"广东省-韶关市-乐昌市\": [113.354579, 25.135592],\n  \"广东省-韶关市-南雄市\": [114.318579, 25.123527],\n  \"广东省-深圳市\": [114.064552, 22.548457],\n  \"广东省-深圳市-罗湖区\": [114.137432, 22.554485],\n  \"广东省-深圳市-福田区\": [114.061547, 22.528466],\n  \"广东省-深圳市-南山区\": [113.936539, 22.5385],\n  \"广东省-深圳市-宝安区\": [113.890427, 22.560033],\n  \"广东省-深圳市-龙岗区\": [114.254455, 22.726017],\n  \"广东省-深圳市-盐田区\": [114.24343, 22.563438],\n  \"广东省-珠海市\": [113.582555, 22.276565],\n  \"广东省-珠海市-香洲区\": [113.550472, 22.273004],\n  \"广东省-珠海市-斗门区\": [113.303467, 22.215516],\n  \"广东省-珠海市-金湾区\": [113.369517, 22.152577],\n  \"广东省-汕头市\": [116.688529, 23.359092],\n  \"广东省-汕头市-龙湖区\": [116.723525, 23.377776],\n  \"广东省-汕头市-金平区\": [116.70955, 23.37175],\n  \"广东省-汕头市-濠江区\": [116.733517, 23.291546],\n  \"广东省-汕头市-潮阳区\": [116.608515, 23.270855],\n  \"广东省-汕头市-潮南区\": [116.439491, 23.256341],\n  \"广东省-汕头市-澄海区\": [116.762425, 23.472341],\n  \"广东省-汕头市-南澳县\": [117.030496, 23.427812],\n  \"广东省-佛山市\": [113.128512, 23.027759],\n  \"广东省-佛山市-禅城区\": [113.129505, 23.015374],\n  \"广东省-佛山市-南海区\": [113.149446, 23.035011],\n  \"广东省-佛山市-顺德区\": [113.300453, 22.810453],\n  \"广东省-佛山市-三水区\": [112.903471, 23.16192],\n  \"广东省-佛山市-高明区\": [112.899472, 22.90635],\n  \"广东省-江门市\": [113.088556, 22.584604],\n  \"广东省-江门市-蓬江区\": [113.084546, 22.601066],\n  \"广东省-江门市-江海区\": [113.117557, 22.566115],\n  \"广东省-江门市-新会区\": [113.038455, 22.465113],\n  \"广东省-江门市-台山市\": [112.800445, 22.257923],\n  \"广东省-江门市-开平市\": [112.704464, 22.382499],\n  \"广东省-江门市-鹤山市\": [112.970527, 22.771169],\n  \"广东省-江门市-恩平市\": [112.311438, 22.189035],\n  \"广东省-湛江市\": [110.365554, 21.276723],\n  \"广东省-湛江市-赤坎区\": [110.372533, 21.272135],\n  \"广东省-湛江市-霞山区\": [110.404425, 21.198227],\n  \"广东省-湛江市-坡头区\": [110.462567, 21.250377],\n  \"广东省-湛江市-麻章区\": [110.340579, 21.269189],\n  \"广东省-湛江市-遂溪县\": [110.256515, 21.383103],\n  \"广东省-湛江市-徐闻县\": [110.182473, 20.331724],\n  \"广东省-湛江市-廉江市\": [110.292448, 21.615816],\n  \"广东省-湛江市-雷州市\": [110.102581, 20.919881],\n  \"广东省-湛江市-吴川市\": [110.78645, 21.447263],\n  \"广东省-茂名市\": [110.931543, 21.669064],\n  \"广东省-茂名市-茂南区\": [110.925546, 21.647152],\n  \"广东省-茂名市-电白区\": [111.020471, 21.520351],\n  \"广东省-茂名市-高州市\": [110.859474, 21.924049],\n  \"广东省-茂名市-化州市\": [110.646431, 21.670231],\n  \"广东省-茂名市-信宜市\": [110.953582, 22.360093],\n  \"广东省-肇庆市\": [112.471489, 23.052889],\n  \"广东省-肇庆市-端州区\": [112.49156, 23.057564],\n  \"广东省-肇庆市-鼎湖区\": [112.574434, 23.164308],\n  \"广东省-肇庆市-高要区\": [112.464446, 23.031896],\n  \"广东省-肇庆市-广宁县\": [112.447424, 23.641036],\n  \"广东省-肇庆市-怀集县\": [112.191469, 23.917842],\n  \"广东省-肇庆市-封开县\": [111.518526, 23.429769],\n  \"广东省-肇庆市-德庆县\": [111.791554, 23.151373],\n  \"广东省-肇庆市-四会市\": [112.740579, 23.332381],\n  \"广东省-惠州市\": [114.423558, 23.116359],\n  \"广东省-惠州市-惠城区\": [114.38949, 23.089726],\n  \"广东省-惠州市-惠阳区\": [114.463464, 22.794721],\n  \"广东省-惠州市-博罗县\": [114.296573, 23.178806],\n  \"广东省-惠州市-惠东县\": [114.726426, 22.991443],\n  \"广东省-惠州市-龙门县\": [114.26143, 23.733838],\n  \"广东省-梅州市\": [116.129537, 24.294178],\n  \"广东省-梅州市-梅江区\": [116.123536, 24.315879],\n  \"广东省-梅州市-梅县区\": [116.088562, 24.270999],\n  \"广东省-梅州市-大埔县\": [116.701559, 24.353459],\n  \"广东省-梅州市-丰顺县\": [116.188454, 23.745738],\n  \"广东省-梅州市-五华县\": [115.782485, 23.938409],\n  \"广东省-梅州市-平远县\": [115.897477, 24.572414],\n  \"广东省-梅州市-蕉岭县\": [116.177439, 24.664993],\n  \"广东省-梅州市-兴宁市\": [115.737579, 24.142294],\n  \"广东省-汕尾市\": [115.381553, 22.791263],\n  \"广东省-汕尾市-城区\": [115.371531, 22.784552],\n  \"广东省-汕尾市-海丰县\": [115.329445, 22.972744],\n  \"广东省-汕尾市-陆河县\": [115.666483, 23.307677],\n  \"广东省-汕尾市-陆丰市\": [115.65849, 22.923636],\n  \"广东省-河源市\": [114.707446, 23.749684],\n  \"广东省-河源市-源城区\": [114.708439, 23.740298],\n  \"广东省-河源市-紫金县\": [115.190448, 23.64143],\n  \"广东省-河源市-龙川县\": [115.266555, 24.105851],\n  \"广东省-河源市-连平县\": [114.495444, 24.375808],\n  \"广东省-河源市-和平县\": [114.945449, 24.448253],\n  \"广东省-河源市-东源县\": [114.753508, 23.794258],\n  \"广东省-阳江市\": [111.988489, 21.86434],\n  \"广东省-阳江市-江城区\": [111.961455, 21.868128],\n  \"广东省-阳江市-阳东区\": [112.018579, 21.873997],\n  \"广东省-阳江市-阳西县\": [111.624481, 21.758701],\n  \"广东省-阳江市-阳春市\": [111.797536, 22.176015],\n  \"广东省-清远市\": [113.062468, 23.68823],\n  \"广东省-清远市-清城区\": [113.069477, 23.704022],\n  \"广东省-清远市-清新区\": [112.991558, 23.75427],\n  \"广东省-清远市-佛冈县\": [113.538441, 23.885475],\n  \"广东省-清远市-阳山县\": [112.64752, 24.470944],\n  \"广东省-清远市-连山壮族瑶族自治县\": [112.100426, 24.576846],\n  \"广东省-清远市-连南瑶族自治县\": [112.293517, 24.731549],\n  \"广东省-清远市-英德市\": [113.421443, 24.191939],\n  \"广东省-清远市-连州市\": [112.383573, 24.786467],\n  \"广东省-东莞市\": [113.75842, 23.027308],\n  \"广东省-中山市\": [113.399422, 22.522315],\n  \"广东省-潮州市\": [116.62947, 23.662623],\n  \"广东省-潮州市-湘桥区\": [116.634462, 23.680687],\n  \"广东省-潮州市-潮安区\": [116.684526, 23.468357],\n  \"广东省-潮州市-饶平县\": [117.010449, 23.670347],\n  \"广东省-揭阳市\": [116.378512, 23.55574],\n  \"广东省-揭阳市-榕城区\": [116.373516, 23.530746],\n  \"广东省-揭阳市-揭东区\": [116.418456, 23.572485],\n  \"广东省-揭阳市-揭西县\": [115.848561, 23.4373],\n  \"广东省-揭阳市-惠来县\": [116.301444, 23.039645],\n  \"广东省-揭阳市-普宁市\": [116.172449, 23.303635],\n  \"广东省-云浮市\": [112.051513, 22.920912],\n  \"广东省-云浮市-云城区\": [112.050529, 22.933898],\n  \"广东省-云浮市-云安区\": [112.009563, 23.076893],\n  \"广东省-云浮市-新兴县\": [112.231497, 22.70189],\n  \"广东省-云浮市-郁南县\": [111.541554, 23.240174],\n  \"广东省-云浮市-罗定市\": [111.57648, 22.774296],\n  \"广西壮族自治区\": [108.334521, 22.821269],\n  \"广西壮族自治区-南宁市\": [108.373451, 22.822607],\n  \"广西壮族自治区-南宁市-兴宁区\": [108.375445, 22.860291],\n  \"广西壮族自治区-南宁市-青秀区\": [108.501439, 22.792227],\n  \"广西壮族自治区-南宁市-江南区\": [108.279494, 22.787046],\n  \"广西壮族自治区-南宁市-西乡塘区\": [108.319572, 22.839652],\n  \"广西壮族自治区-南宁市-良庆区\": [108.327516, 22.762849],\n  \"广西壮族自治区-南宁市-邕宁区\": [108.49342, 22.7646],\n  \"广西壮族自治区-南宁市-武鸣区\": [108.281517, 23.164516],\n  \"广西壮族自治区-南宁市-隆安县\": [107.702574, 23.171585],\n  \"广西壮族自治区-南宁市-马山县\": [108.183562, 23.713878],\n  \"广西壮族自治区-南宁市-上林县\": [108.611451, 23.438519],\n  \"广西壮族自治区-南宁市-宾阳县\": [108.816502, 23.223701],\n  \"广西壮族自治区-南宁市-横县\": [109.267568, 22.685573],\n  \"广西壮族自治区-柳州市\": [109.434422, 24.331961],\n  \"广西壮族自治区-柳州市-城中区\": [109.417482, 24.321314],\n  \"广西壮族自治区-柳州市-鱼峰区\": [109.449416, 24.318522],\n  \"广西壮族自治区-柳州市-柳南区\": [109.391552, 24.341579],\n  \"广西壮族自治区-柳州市-柳北区\": [109.408532, 24.367867],\n  \"广西壮族自治区-柳州市-柳江区\": [109.332444, 24.260815],\n  \"广西壮族自治区-柳州市-柳城县\": [109.251562, 24.65637],\n  \"广西壮族自治区-柳州市-鹿寨县\": [109.757554, 24.478622],\n  \"广西壮族自治区-柳州市-融安县\": [109.404563, 25.230511],\n  \"广西壮族自治区-柳州市-融水苗族自治县\": [109.262561, 25.072077],\n  \"广西壮族自治区-柳州市-三江侗族自治县\": [109.614547, 25.78883],\n  \"广西壮族自治区-桂林市\": [110.203545, 25.242886],\n  \"广西壮族自治区-桂林市-秀峰区\": [110.270437, 25.279618],\n  \"广西壮族自治区-桂林市-叠彩区\": [110.308463, 25.320233],\n  \"广西壮族自治区-桂林市-象山区\": [110.287423, 25.26793],\n  \"广西壮族自治区-桂林市-七星区\": [110.324538, 25.258567],\n  \"广西壮族自治区-桂林市-雁山区\": [110.315479, 25.066214],\n  \"广西壮族自治区-桂林市-临桂区\": [110.218587, 25.244302],\n  \"广西壮族自治区-桂林市-阳朔县\": [110.503475, 24.784519],\n  \"广西壮族自治区-桂林市-灵川县\": [110.332537, 25.41555],\n  \"广西壮族自治区-桂林市-全州县\": [111.079569, 25.934343],\n  \"广西壮族自治区-桂林市-兴安县\": [110.678516, 25.617567],\n  \"广西壮族自治区-桂林市-永福县\": [109.989591, 24.985578],\n  \"广西壮族自治区-桂林市-灌阳县\": [111.167552, 25.495121],\n  \"广西壮族自治区-桂林市-龙胜各族自治县\": [110.017494, 25.804117],\n  \"广西壮族自治区-桂林市-资源县\": [110.658439, 26.048569],\n  \"广西壮族自治区-桂林市-平乐县\": [110.649446, 24.639632],\n  \"广西壮族自治区-桂林市-荔浦县\": [110.401437, 24.494122],\n  \"广西壮族自治区-桂林市-恭城瑶族自治县\": [110.83456, 24.837194],\n  \"广西壮族自治区-梧州市\": [111.285517, 23.482745],\n  \"广西壮族自治区-梧州市-万秀区\": [111.32752, 23.478846],\n  \"广西壮族自治区-梧州市-长洲区\": [111.281499, 23.49151],\n  \"广西壮族自治区-梧州市-龙圩区\": [111.285517, 23.482745],\n  \"广西壮族自治区-梧州市-苍梧县\": [111.555547, 23.845998],\n  \"广西壮族自治区-梧州市-藤县\": [110.921499, 23.38101],\n  \"广西壮族自治区-梧州市-蒙山县\": [110.531417, 24.200017],\n  \"广西壮族自治区-梧州市-岑溪市\": [111.001432, 22.924621],\n  \"广西壮族自治区-北海市\": [109.126533, 21.486836],\n  \"广西壮族自治区-北海市-海城区\": [109.124521, 21.481066],\n  \"广西壮族自治区-北海市-银海区\": [109.146545, 21.454769],\n  \"广西壮族自治区-北海市-铁山港区\": [109.428473, 21.535295],\n  \"广西壮族自治区-北海市-合浦县\": [109.213439, 21.667006],\n  \"广西壮族自治区-防城港市\": [108.360419, 21.693005],\n  \"广西壮族自治区-防城港市-港口区\": [108.386483, 21.649566],\n  \"广西壮族自治区-防城港市-防城区\": [108.360448, 21.775411],\n  \"广西壮族自治区-防城港市-上思县\": [107.990443, 22.159914],\n  \"广西壮族自治区-防城港市-东兴市\": [107.977489, 21.553615],\n  \"广西壮族自治区-钦州市\": [108.66058, 21.986594],\n  \"广西壮族自治区-钦州市-钦南区\": [108.664549, 21.945972],\n  \"广西壮族自治区-钦州市-钦北区\": [108.638513, 22.020367],\n  \"广西壮族自治区-钦州市-灵山县\": [109.297478, 22.422413],\n  \"广西壮族自治区-钦州市-浦北县\": [109.563423, 22.277822],\n  \"广西壮族自治区-贵港市\": [109.60552, 23.117448],\n  \"广西壮族自治区-贵港市-港北区\": [109.578433, 23.117564],\n  \"广西壮族自治区-贵港市-港南区\": [109.606553, 23.08124],\n  \"广西壮族自治区-贵港市-覃塘区\": [109.459427, 23.133251],\n  \"广西壮族自治区-贵港市-平南县\": [110.398452, 23.545506],\n  \"广西壮族自治区-贵港市-桂平市\": [110.085526, 23.400049],\n  \"广西壮族自治区-玉林市\": [110.188453, 22.659831],\n  \"广西壮族自治区-玉林市-玉州区\": [110.157431, 22.634493],\n  \"广西壮族自治区-玉林市-福绵区\": [110.157431, 22.634493],\n  \"广西壮族自治区-玉林市-容县\": [110.56453, 22.863666],\n  \"广西壮族自治区-玉林市-陆川县\": [110.270456, 22.327222],\n  \"广西壮族自治区-玉林市-博白县\": [109.982553, 22.278675],\n  \"广西壮族自治区-玉林市-兴业县\": [109.881552, 22.742268],\n  \"广西壮族自治区-玉林市-北流市\": [110.36057, 22.713958],\n  \"广西壮族自治区-百色市\": [106.624589, 23.908186],\n  \"广西壮族自治区-百色市-右江区\": [106.625589, 23.907085],\n  \"广西壮族自治区-百色市-田阳县\": [106.921413, 23.742006],\n  \"广西壮族自治区-百色市-田东县\": [107.132499, 23.60313],\n  \"广西壮族自治区-百色市-平果县\": [107.596571, 23.334923],\n  \"广西壮族自治区-百色市-德保县\": [106.621583, 23.328994],\n  \"广西壮族自治区-百色市-那坡县\": [105.839423, 23.393794],\n  \"广西壮族自治区-百色市-凌云县\": [106.568416, 24.354015],\n  \"广西壮族自治区-百色市-乐业县\": [106.56343, 24.783216],\n  \"广西壮族自治区-百色市-田林县\": [106.234498, 24.300535],\n  \"广西壮族自治区-百色市-西林县\": [105.100494, 24.495668],\n  \"广西壮族自治区-百色市-隆林各族自治县\": [105.350459, 24.776814],\n  \"广西壮族自治区-百色市-靖西市\": [106.424453, 23.140126],\n  \"广西壮族自治区-贺州市\": [111.573526, 24.409451],\n  \"广西壮族自治区-贺州市-八步区\": [111.558567, 24.417531],\n  \"广西壮族自治区-贺州市-平桂区\": [111.478414, 24.462001],\n  \"广西壮族自治区-贺州市-昭平县\": [110.817575, 24.175106],\n  \"广西壮族自治区-贺州市-钟山县\": [111.309586, 24.531673],\n  \"广西壮族自治区-贺州市-富川瑶族自治县\": [111.284511, 24.82016],\n  \"广西壮族自治区-河池市\": [108.0915, 24.698912],\n  \"广西壮族自治区-河池市-金城江区\": [108.043507, 24.695679],\n  \"广西壮族自治区-河池市-南丹县\": [107.54748, 24.98185],\n  \"广西壮族自治区-河池市-天峨县\": [107.178456, 25.005664],\n  \"广西壮族自治区-河池市-凤山县\": [107.04842, 24.553218],\n  \"广西壮族自治区-河池市-东兰县\": [107.380504, 24.516871],\n  \"广西壮族自治区-河池市-罗城仫佬族自治县\": [108.911574, 24.783085],\n  \"广西壮族自治区-河池市-环江毛南族自治县\": [108.264443, 24.832088],\n  \"广西壮族自治区-河池市-巴马瑶族自治县\": [107.266481, 24.147265],\n  \"广西壮族自治区-河池市-都安瑶族自治县\": [108.111458, 23.937331],\n  \"广西壮族自治区-河池市-大化瑶族自治县\": [108.004411, 23.742818],\n  \"广西壮族自治区-河池市-宜州市\": [108.643532, 24.491084],\n  \"广西壮族自治区-来宾市\": [109.227458, 23.756547],\n  \"广西壮族自治区-来宾市-兴宾区\": [109.241499, 23.733211],\n  \"广西壮族自治区-来宾市-忻城县\": [108.672562, 24.071889],\n  \"广西壮族自治区-来宾市-象州县\": [109.711462, 23.979681],\n  \"广西壮族自治区-来宾市-武宣县\": [109.669442, 23.600404],\n  \"广西壮族自治区-来宾市-金秀瑶族自治县\": [110.195506, 24.136319],\n  \"广西壮族自治区-来宾市-合山市\": [108.892566, 23.81226],\n  \"广西壮族自治区-崇左市\": [107.37152, 22.383117],\n  \"广西壮族自治区-崇左市-江州区\": [107.359533, 22.411246],\n  \"广西壮族自治区-崇左市-扶绥县\": [107.910465, 22.641097],\n  \"广西壮族自治区-崇左市-宁明县\": [107.083524, 22.145885],\n  \"广西壮族自治区-崇左市-龙州县\": [106.860582, 22.348299],\n  \"广西壮族自治区-崇左市-大新县\": [107.207557, 22.836229],\n  \"广西壮族自治区-崇左市-天等县\": [107.149473, 23.087506],\n  \"广西壮族自治区-崇左市-凭祥市\": [106.773524, 22.100153],\n  \"海南省\": [110.355537, 20.025802],\n  \"海南省-海口市\": [110.325525, 20.044049],\n  \"海南省-海口市-秀英区\": [110.300436, 20.013642],\n  \"海南省-海口市-龙华区\": [110.335541, 20.036321],\n  \"海南省-海口市-琼山区\": [110.360526, 20.009151],\n  \"海南省-海口市-美兰区\": [110.373498, 20.034646],\n  \"海南省-三亚市\": [109.518557, 18.258736],\n  \"海南省-三亚市-海棠区\": [109.7235, 18.337879],\n  \"海南省-三亚市-吉阳区\": [109.7235, 18.337879],\n  \"海南省-三亚市-天涯区\": [109.7235, 18.337879],\n  \"海南省-三亚市-崖州区\": [109.7235, 18.337879],\n  \"海南省-三沙市\": [111.673087, 16.497085],\n  \"海南省-儋州市\": [109.587456, 19.527146],\n  \"海南省-五指山市\": [109.52354, 18.780994],\n  \"海南省-琼海市\": [110.480545, 19.264254],\n  \"海南省-文昌市\": [110.804509, 19.549062],\n  \"海南省-万宁市\": [110.399434, 18.800107],\n  \"海南省-东方市\": [108.658567, 19.101105],\n  \"海南省-定安县\": [110.365533, 19.68712],\n  \"海南省-屯昌县\": [110.108577, 19.357375],\n  \"海南省-澄迈县\": [110.013511, 19.744349],\n  \"海南省-临高县\": [109.697443, 19.919475],\n  \"海南省-白沙黎族自治县\": [109.457471, 19.231379],\n  \"海南省-昌江黎族自治县\": [109.062464, 19.303998],\n  \"海南省-乐东黎族自治县\": [109.180508, 18.755871],\n  \"海南省-陵水黎族自治县\": [110.044464, 18.512332],\n  \"海南省-保亭黎族苗族自治县\": [109.703482, 18.64691],\n  \"海南省-琼中黎族苗族自治县\": [109.844511, 19.039164],\n  \"重庆市\": [106.558434, 29.568996],\n  \"重庆市-市辖区\": [106.558434, 29.568996],\n  \"重庆市-市辖区-万州区\": [108.415558, 30.813622],\n  \"重庆市-市辖区-涪陵区\": [107.39642, 29.709278],\n  \"重庆市-市辖区-渝中区\": [106.57544, 29.55909],\n  \"重庆市-市辖区-大渡口区\": [106.488534, 29.490107],\n  \"重庆市-市辖区-江北区\": [106.580415, 29.612832],\n  \"重庆市-市辖区-沙坪坝区\": [106.464465, 29.547193],\n  \"重庆市-市辖区-九龙坡区\": [106.517559, 29.507928],\n  \"重庆市-市辖区-南岸区\": [106.66843, 29.502683],\n  \"重庆市-市辖区-北碚区\": [106.403569, 29.811603],\n  \"重庆市-市辖区-綦江区\": [106.657484, 29.034114],\n  \"重庆市-市辖区-大足区\": [105.728405, 29.713114],\n  \"重庆市-市辖区-渝北区\": [106.637559, 29.723927],\n  \"重庆市-市辖区-巴南区\": [106.547454, 29.408475],\n  \"重庆市-市辖区-黔江区\": [108.777591, 29.538813],\n  \"重庆市-市辖区-长寿区\": [107.087531, 29.86352],\n  \"重庆市-市辖区-江津区\": [106.265598, 29.295884],\n  \"重庆市-市辖区-合川区\": [106.282541, 29.978181],\n  \"重庆市-市辖区-永川区\": [105.933499, 29.362046],\n  \"重庆市-市辖区-南川区\": [107.105585, 29.163479],\n  \"重庆市-市辖区-璧山区\": [106.233475, 29.598347],\n  \"重庆市-市辖区-铜梁区\": [106.063449, 29.850509],\n  \"重庆市-市辖区-潼南区\": [105.847399, 30.197314],\n  \"重庆市-市辖区-荣昌区\": [105.60142, 29.411307],\n  \"重庆市-市辖区-开州区\": [108.399498, 31.166644],\n  \"重庆市-县\": [108.120414, 30.006109],\n  \"重庆市-县-梁平县\": [107.7761, 30.660545],\n  \"重庆市-县-城口县\": [108.671612, 31.953391],\n  \"重庆市-县-丰都县\": [107.737481, 29.869413],\n  \"重庆市-县-垫江县\": [107.339566, 30.333294],\n  \"重庆市-县-武隆县\": [107.774902, 29.335005],\n  \"重庆市-县-忠县\": [107.478814, 30.278161],\n  \"重庆市-县-云阳县\": [108.703448, 30.936611],\n  \"重庆市-县-奉节县\": [109.470473, 31.024602],\n  \"重庆市-县-巫山县\": [109.885546, 31.080519],\n  \"重庆市-县-巫溪县\": [109.576403, 31.40488],\n  \"重庆市-县-石柱土家族自治县\": [109.576403, 31.40488],\n  \"重庆市-县-秀山土家族苗族自治县\": [109.013574, 28.453448],\n  \"重庆市-县-酉阳土家族苗族自治县\": [108.774586, 28.84704],\n  \"重庆市-县-彭水苗族土家族自治县\": [108.172578, 29.299462],\n  \"四川省\": [104.073467, 30.577543],\n  \"四川省-成都市\": [104.081534, 30.655822],\n  \"四川省-成都市-锦江区\": [104.089562, 30.661904],\n  \"四川省-成都市-青羊区\": [104.067445, 30.680038],\n  \"四川省-成都市-金牛区\": [104.057404, 30.697356],\n  \"四川省-成都市-武侯区\": [104.049424, 30.648713],\n  \"四川省-成都市-成华区\": [104.108592, 30.665589],\n  \"四川省-成都市-龙泉驿区\": [104.281397, 30.562698],\n  \"四川省-成都市-青白江区\": [104.257512, 30.884421],\n  \"四川省-成都市-新都区\": [104.165393, 30.829407],\n  \"四川省-成都市-温江区\": [103.863573, 30.688487],\n  \"四川省-成都市-双流区\": [103.930392, 30.580399],\n  \"四川省-成都市-金堂县\": [104.418443, 30.868358],\n  \"四川省-成都市-郫县\": [103.905446, 30.799538],\n  \"四川省-成都市-大邑县\": [103.52753, 30.593155],\n  \"四川省-成都市-蒲江县\": [103.512571, 30.2025],\n  \"四川省-成都市-新津县\": [103.817433, 30.416364],\n  \"四川省-成都市-都江堰市\": [103.653534, 30.994257],\n  \"四川省-成都市-彭州市\": [103.965561, 30.995564],\n  \"四川省-成都市-邛崃市\": [103.470481, 30.416399],\n  \"四川省-成都市-崇州市\": [103.679433, 30.636596],\n  \"四川省-成都市-简阳市\": [104.569516, 30.3766],\n  \"四川省-自贡市\": [104.784449, 29.345585],\n  \"四川省-自贡市-自流井区\": [104.783447, 29.343499],\n  \"四川省-自贡市-贡井区\": [104.721557, 29.351476],\n  \"四川省-自贡市-大安区\": [104.780416, 29.369929],\n  \"四川省-自贡市-沿滩区\": [104.880409, 29.278797],\n  \"四川省-自贡市-荣县\": [104.423458, 29.451801],\n  \"四川省-自贡市-富顺县\": [104.981494, 29.186886],\n  \"四川省-攀枝花市\": [101.725541, 26.588033],\n  \"四川省-攀枝花市-东区\": [101.710597, 26.552106],\n  \"四川省-攀枝花市-西区\": [101.637413, 26.603868],\n  \"四川省-攀枝花市-仁和区\": [101.74445, 26.504019],\n  \"四川省-攀枝花市-米易县\": [102.11644, 26.896968],\n  \"四川省-攀枝花市-盐边县\": [101.860499, 26.688767],\n  \"四川省-泸州市\": [105.448524, 28.877668],\n  \"四川省-泸州市-江阳区\": [105.441545, 28.884672],\n  \"四川省-泸州市-纳溪区\": [105.377409, 28.77936],\n  \"四川省-泸州市-龙马潭区\": [105.444544, 28.919012],\n  \"四川省-泸州市-泸县\": [105.388456, 29.157626],\n  \"四川省-泸州市-合江县\": [105.838432, 28.817793],\n  \"四川省-泸州市-叙永县\": [105.451508, 28.161714],\n  \"四川省-泸州市-古蔺县\": [105.819471, 28.044745],\n  \"四川省-德阳市\": [104.404419, 31.133115],\n  \"四川省-德阳市-旌阳区\": [104.423439, 31.148596],\n  \"四川省-德阳市-中江县\": [104.68553, 31.038954],\n  \"四川省-德阳市-罗江县\": [104.517414, 31.324179],\n  \"四川省-德阳市-广汉市\": [104.288422, 30.982415],\n  \"四川省-德阳市-什邡市\": [104.174427, 31.132889],\n  \"四川省-德阳市-绵竹市\": [104.227609, 31.343592],\n  \"四川省-绵阳市\": [104.685562, 31.473663],\n  \"四川省-绵阳市-涪城区\": [104.76342, 31.461314],\n  \"四川省-绵阳市-游仙区\": [104.772429, 31.479904],\n  \"四川省-绵阳市-安州区\": [104.573555, 31.540751],\n  \"四川省-绵阳市-三台县\": [105.10149, 31.101586],\n  \"四川省-绵阳市-盐亭县\": [105.395503, 31.214319],\n  \"四川省-绵阳市-梓潼县\": [105.177567, 31.648313],\n  \"四川省-绵阳市-北川羌族自治县\": [104.361586, 31.963084],\n  \"四川省-绵阳市-平武县\": [104.535422, 32.414682],\n  \"四川省-绵阳市-江油市\": [104.752412, 31.784128],\n  \"四川省-广元市\": [105.850423, 32.441616],\n  \"四川省-广元市-利州区\": [105.852426, 32.440208],\n  \"四川省-广元市-昭化区\": [105.969419, 32.329618],\n  \"四川省-广元市-朝天区\": [105.896589, 32.649726],\n  \"四川省-广元市-旺苍县\": [106.296491, 32.235097],\n  \"四川省-广元市-青川县\": [105.245407, 32.581617],\n  \"四川省-广元市-剑阁县\": [105.531576, 32.293479],\n  \"四川省-广元市-苍溪县\": [105.941483, 31.738684],\n  \"四川省-遂宁市\": [105.599422, 30.539098],\n  \"四川省-遂宁市-船山区\": [105.574523, 30.531471],\n  \"四川省-遂宁市-安居区\": [105.462467, 30.361496],\n  \"四川省-遂宁市-蓬溪县\": [105.713446, 30.763751],\n  \"四川省-遂宁市-射洪县\": [105.39451, 30.877139],\n  \"四川省-遂宁市-大英县\": [105.243404, 30.60081],\n  \"四川省-内江市\": [105.064588, 29.585887],\n  \"四川省-内江市-市中区\": [105.074574, 29.59271],\n  \"四川省-内江市-东兴区\": [105.082547, 29.598486],\n  \"四川省-内江市-威远县\": [104.674498, 29.533635],\n  \"四川省-内江市-资中县\": [104.858495, 29.770234],\n  \"四川省-内江市-隆昌县\": [105.294572, 29.345245],\n  \"四川省-乐山市\": [103.772538, 29.557941],\n  \"四川省-乐山市-市中区\": [103.767559, 29.561364],\n  \"四川省-乐山市-沙湾区\": [103.556436, 29.419272],\n  \"四川省-乐山市-五通桥区\": [103.824455, 29.413185],\n  \"四川省-乐山市-金口河区\": [103.085394, 29.250804],\n  \"四川省-乐山市-犍为县\": [103.955507, 29.214219],\n  \"四川省-乐山市-井研县\": [104.076511, 29.657303],\n  \"四川省-乐山市-夹江县\": [103.57841, 29.743846],\n  \"四川省-乐山市-沐川县\": [103.908467, 28.962888],\n  \"四川省-乐山市-峨边彝族自治县\": [103.268577, 29.236089],\n  \"四川省-乐山市-马边彝族自治县\": [103.552454, 28.841736],\n  \"四川省-乐山市-峨眉山市\": [103.491546, 29.606976],\n  \"四川省-南充市\": [106.117503, 30.843783],\n  \"四川省-南充市-顺庆区\": [106.098411, 30.802753],\n  \"四川省-南充市-高坪区\": [106.12554, 30.787255],\n  \"四川省-南充市-嘉陵区\": [106.078433, 30.764896],\n  \"四川省-南充市-南部县\": [106.043578, 31.353705],\n  \"四川省-南充市-营山县\": [106.572408, 31.083003],\n  \"四川省-南充市-蓬安县\": [106.418482, 31.034631],\n  \"四川省-南充市-仪陇县\": [106.30943, 31.277597],\n  \"四川省-南充市-西充县\": [105.907611, 31.000688],\n  \"四川省-南充市-阆中市\": [106.011565, 31.564075],\n  \"四川省-眉山市\": [103.856563, 30.082526],\n  \"四川省-眉山市-东坡区\": [103.838525, 30.048272],\n  \"四川省-眉山市-彭山区\": [103.879558, 30.198854],\n  \"四川省-眉山市-仁寿县\": [104.140477, 30.001664],\n  \"四川省-眉山市-洪雅县\": [103.379602, 29.910616],\n  \"四川省-眉山市-丹棱县\": [103.519583, 30.020363],\n  \"四川省-眉山市-青神县\": [103.853559, 29.837055],\n  \"四川省-宜宾市\": [104.649404, 28.758007],\n  \"四川省-宜宾市-翠屏区\": [104.626438, 28.772052],\n  \"四川省-宜宾市-南溪区\": [104.976513, 28.851504],\n  \"四川省-宜宾市-宜宾县\": [104.539443, 28.696246],\n  \"四川省-宜宾市-江安县\": [105.073595, 28.72961],\n  \"四川省-宜宾市-长宁县\": [104.927564, 28.588133],\n  \"四川省-宜宾市-高县\": [104.524411, 28.442511],\n  \"四川省-宜宾市-珙县\": [104.715575, 28.44432],\n  \"四川省-宜宾市-筠连县\": [104.517406, 28.170174],\n  \"四川省-宜宾市-兴文县\": [105.242402, 28.309905],\n  \"四川省-宜宾市-屏山县\": [104.05945, 28.707647],\n  \"四川省-广安市\": [106.639553, 30.461746],\n  \"四川省-广安市-广安区\": [106.648531, 30.479768],\n  \"四川省-广安市-前锋区\": [106.639553, 30.461746],\n  \"四川省-广安市-岳池县\": [106.446411, 30.54412],\n  \"四川省-广安市-武胜县\": [106.302462, 30.355496],\n  \"四川省-广安市-邻水县\": [106.936403, 30.341073],\n  \"四川省-广安市-华蓥市\": [106.789462, 30.396307],\n  \"四川省-达州市\": [107.474594, 31.214308],\n  \"四川省-达州市-通川区\": [107.511447, 31.220932],\n  \"四川省-达州市-达川区\": [107.518411, 31.202393],\n  \"四川省-达州市-宣汉县\": [107.733534, 31.359755],\n  \"四川省-达州市-开江县\": [107.875425, 31.089372],\n  \"四川省-达州市-大竹县\": [107.21158, 30.742077],\n  \"四川省-达州市-渠县\": [106.979583, 30.842299],\n  \"四川省-达州市-万源市\": [108.041541, 32.087421],\n  \"四川省-雅安市\": [103.049543, 30.016793],\n  \"四川省-雅安市-雨城区\": [103.039575, 30.011062],\n  \"四川省-雅安市-名山区\": [103.115486, 30.075914],\n  \"四川省-雅安市-荥经县\": [102.853436, 29.799194],\n  \"四川省-雅安市-汉源县\": [102.658576, 29.350217],\n  \"四川省-雅安市-石棉县\": [102.366405, 29.234305],\n  \"四川省-雅安市-天全县\": [102.76453, 30.072473],\n  \"四川省-雅安市-芦山县\": [102.934528, 30.149873],\n  \"四川省-雅安市-宝兴县\": [102.821484, 30.374082],\n  \"四川省-巴中市\": [106.751585, 31.872889],\n  \"四川省-巴中市-巴州区\": [106.775513, 31.857686],\n  \"四川省-巴中市-恩阳区\": [106.775513, 31.857686],\n  \"四川省-巴中市-通江县\": [107.251517, 31.917714],\n  \"四川省-巴中市-南江县\": [106.834483, 32.352532],\n  \"四川省-巴中市-平昌县\": [107.110593, 31.566186],\n  \"四川省-资阳市\": [104.634435, 30.134957],\n  \"四川省-资阳市-雁江区\": [104.658424, 30.123753],\n  \"四川省-资阳市-安岳县\": [105.342454, 30.103393],\n  \"四川省-资阳市-乐至县\": [105.027477, 30.282348],\n  \"四川省-阿坝藏族羌族自治州\": [102.231415, 31.905512],\n  \"四川省-阿坝藏族羌族自治州-马尔康市\": [102.213502, 31.911748],\n  \"四川省-阿坝藏族羌族自治州-汶川县\": [103.596518, 31.483005],\n  \"四川省-阿坝藏族羌族自治州-理县\": [103.173511, 31.44255],\n  \"四川省-阿坝藏族羌族自治州-茂县\": [103.85959, 31.686809],\n  \"四川省-阿坝藏族羌族自治州-松潘县\": [103.61058, 32.661797],\n  \"四川省-阿坝藏族羌族自治州-九寨沟县\": [104.249547, 33.257592],\n  \"四川省-阿坝藏族羌族自治州-金川县\": [102.07061, 31.482006],\n  \"四川省-阿坝藏族羌族自治州-小金县\": [102.369426, 31.002209],\n  \"四川省-阿坝藏族羌族自治州-黑水县\": [102.996517, 32.067805],\n  \"四川省-阿坝藏族羌族自治州-壤塘县\": [100.985583, 32.271093],\n  \"四川省-阿坝藏族羌族自治州-阿坝县\": [101.71361, 32.908221],\n  \"四川省-阿坝藏族羌族自治州-若尔盖县\": [102.974391, 33.584377],\n  \"四川省-阿坝藏族羌族自治州-红原县\": [102.550615, 32.796605],\n  \"四川省-甘孜藏族自治州\": [101.968547, 30.055279],\n  \"四川省-甘孜藏族自治州-康定市\": [101.963555, 30.004407],\n  \"四川省-甘孜藏族自治州-泸定县\": [102.241432, 29.920402],\n  \"四川省-甘孜藏族自治州-丹巴县\": [101.896437, 30.88477],\n  \"四川省-甘孜藏族自治州-九龙县\": [101.896437, 30.88477],\n  \"四川省-甘孜藏族自治州-雅江县\": [101.0205, 30.037569],\n  \"四川省-甘孜藏族自治州-道孚县\": [101.13154, 30.985326],\n  \"四川省-甘孜藏族自治州-炉霍县\": [100.682397, 31.397992],\n  \"四川省-甘孜藏族自治州-甘孜县\": [99.99921, 31.628957],\n  \"四川省-甘孜藏族自治州-新龙县\": [100.318398, 30.94547],\n  \"四川省-甘孜藏族自治州-德格县\": [98.587402, 31.812106],\n  \"四川省-甘孜藏族自治州-白玉县\": [98.8311, 31.215314],\n  \"四川省-甘孜藏族自治州-石渠县\": [98.109481, 32.984003],\n  \"四川省-甘孜藏族自治州-色达县\": [100.339414, 32.27433],\n  \"四川省-甘孜藏族自治州-理塘县\": [100.275575, 30.000031],\n  \"四川省-甘孜藏族自治州-巴塘县\": [99.116727, 30.011662],\n  \"四川省-甘孜藏族自治州-乡城县\": [99.80506, 28.936733],\n  \"四川省-甘孜藏族自治州-稻城县\": [100.304462, 29.043122],\n  \"四川省-甘孜藏族自治州-得荣县\": [99.292984, 28.71878],\n  \"四川省-凉山彝族自治州\": [102.273503, 27.887752],\n  \"四川省-凉山彝族自治州-西昌市\": [102.271484, 27.900581],\n  \"四川省-凉山彝族自治州-木里藏族自治县\": [101.286397, 27.934599],\n  \"四川省-凉山彝族自治州-盐源县\": [101.515429, 27.428155],\n  \"四川省-凉山彝族自治州-德昌县\": [102.182596, 27.408504],\n  \"四川省-凉山彝族自治州-会理县\": [102.251436, 26.6612],\n  \"四川省-凉山彝族自治州-会东县\": [102.584462, 26.640824],\n  \"四川省-凉山彝族自治州-宁南县\": [102.762526, 27.064605],\n  \"四川省-凉山彝族自治州-普格县\": [102.546597, 27.381996],\n  \"四川省-凉山彝族自治州-布拖县\": [102.818478, 27.712129],\n  \"四川省-凉山彝族自治州-金阳县\": [103.254549, 27.702145],\n  \"四川省-凉山彝族自治州-昭觉县\": [102.849423, 28.020506],\n  \"四川省-凉山彝族自治州-喜德县\": [102.419567, 28.31271],\n  \"四川省-凉山彝族自治州-冕宁县\": [102.183575, 28.555294],\n  \"四川省-凉山彝族自治州-越西县\": [102.514474, 28.645828],\n  \"四川省-凉山彝族自治州-甘洛县\": [102.778597, 28.964823],\n  \"四川省-凉山彝族自治州-美姑县\": [103.138586, 28.33402],\n  \"四川省-凉山彝族自治州-雷波县\": [103.578429, 28.268951],\n  \"贵州省\": [106.714476, 26.60403],\n  \"贵州省-贵阳市\": [106.714476, 26.60403],\n  \"贵州省-贵阳市-南明区\": [106.720528, 26.574336],\n  \"贵州省-贵阳市-云岩区\": [106.730535, 26.610381],\n  \"贵州省-贵阳市-花溪区\": [106.676441, 26.415879],\n  \"贵州省-贵阳市-乌当区\": [106.757558, 26.636529],\n  \"贵州省-贵阳市-白云区\": [106.629597, 26.683588],\n  \"贵州省-贵阳市-观山湖区\": [106.757558, 26.636529],\n  \"贵州省-贵阳市-开阳县\": [106.97156, 27.063674],\n  \"贵州省-贵阳市-息烽县\": [106.747562, 27.096475],\n  \"贵州省-贵阳市-修文县\": [106.598492, 26.844862],\n  \"贵州省-贵阳市-清镇市\": [106.477523, 26.561988],\n  \"贵州省-六盘水市\": [104.837555, 26.598833],\n  \"贵州省-六盘水市-钟山区\": [104.85053, 26.580704],\n  \"贵州省-六盘水市-六枝特区\": [105.483429, 26.219214],\n  \"贵州省-六盘水市-水城县\": [104.964566, 26.55372],\n  \"贵州省-六盘水市-盘县\": [104.478582, 25.715651],\n  \"贵州省-遵义市\": [106.933428, 27.731701],\n  \"贵州省-遵义市-红花岗区\": [106.900497, 27.65087],\n  \"贵州省-遵义市-汇川区\": [106.940458, 27.756343],\n  \"贵州省-遵义市-播州区\": [106.836504, 27.542501],\n  \"贵州省-遵义市-桐梓县\": [106.832489, 28.139468],\n  \"贵州省-遵义市-绥阳县\": [107.197492, 27.95308],\n  \"贵州省-遵义市-正安县\": [107.460575, 28.559092],\n  \"贵州省-遵义市-道真仡佬族苗族自治县\": [107.619484, 28.86865],\n  \"贵州省-遵义市-务川仡佬族苗族自治县\": [107.905456, 28.569077],\n  \"贵州省-遵义市-凤冈县\": [107.723548, 27.960695],\n  \"贵州省-遵义市-湄潭县\": [107.472599, 27.754498],\n  \"贵州省-遵义市-余庆县\": [107.91146, 27.221379],\n  \"贵州省-遵义市-习水县\": [106.203428, 28.339118],\n  \"贵州省-遵义市-赤水市\": [105.703489, 28.596119],\n  \"贵州省-遵义市-仁怀市\": [106.407527, 27.797752],\n  \"贵州省-安顺市\": [105.954417, 26.259252],\n  \"贵州省-安顺市-西秀区\": [105.972406, 26.251498],\n  \"贵州省-安顺市-平坝区\": [106.263584, 26.411186],\n  \"贵州省-安顺市-普定县\": [105.748486, 26.308233],\n  \"贵州省-安顺市-镇宁布依族苗族自治县\": [105.776583, 26.063829],\n  \"贵州省-安顺市-关岭布依族苗族自治县\": [105.625476, 25.949877],\n  \"贵州省-安顺市-紫云苗族布依族自治县\": [106.090414, 25.757409],\n  \"贵州省-毕节市\": [105.311581, 27.304095],\n  \"贵州省-毕节市-七星关区\": [105.311581, 27.304095],\n  \"贵州省-毕节市-大方县\": [105.611399, 27.165261],\n  \"贵州省-毕节市-黔西县\": [106.038574, 27.014345],\n  \"贵州省-毕节市-金沙县\": [106.226442, 27.465355],\n  \"贵州省-毕节市-织金县\": [105.77759, 26.669222],\n  \"贵州省-毕节市-纳雍县\": [105.389487, 26.783717],\n  \"贵州省-毕节市-威宁彝族回族苗族自治县\": [104.282508, 26.875711],\n  \"贵州省-毕节市-赫章县\": [104.733516, 27.129052],\n  \"贵州省-铜仁市\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-碧江区\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-万山区\": [109.187435, 27.696773],\n  \"贵州省-铜仁市-江口县\": [108.857371, 27.699558],\n  \"贵州省-铜仁市-玉屏侗族自治县\": [109.024903, 27.455339],\n  \"贵州省-铜仁市-石阡县\": [108.230464, 27.519722],\n  \"贵州省-铜仁市-思南县\": [109.195295, 27.743042],\n  \"贵州省-铜仁市-印江土家族苗族自治县\": [108.415088, 27.999307],\n  \"贵州省-铜仁市-德江县\": [108.126401, 28.270733],\n  \"贵州省-铜仁市-沿河土家族自治县\": [108.50793, 28.570124],\n  \"贵州省-铜仁市-松桃苗族自治县\": [109.134326, 27.875214],\n  \"贵州省-黔西南布依族苗族自治州\": [104.912492, 25.093967],\n  \"贵州省-黔西南布依族苗族自治州-兴义市\": [104.902461, 25.098113],\n  \"贵州省-黔西南布依族苗族自治州-兴仁县\": [105.192568, 25.440899],\n  \"贵州省-黔西南布依族苗族自治州-普安县\": [104.959546, 25.789952],\n  \"贵州省-黔西南布依族苗族自治州-晴隆县\": [105.225484, 25.841048],\n  \"贵州省-黔西南布依族苗族自治州-贞丰县\": [105.65656, 25.392124],\n  \"贵州省-黔西南布依族苗族自治州-望谟县\": [106.106445, 25.184355],\n  \"贵州省-黔西南布依族苗族自治州-册亨县\": [105.818511, 24.989637],\n  \"贵州省-黔西南布依族苗族自治州-安龙县\": [105.449543, 25.10399],\n  \"贵州省-黔东南苗族侗族自治州\": [107.989446, 26.589703],\n  \"贵州省-黔东南苗族侗族自治州-凯里市\": [107.987469, 26.573079],\n  \"贵州省-黔东南苗族侗族自治州-黄平县\": [107.923548, 26.911289],\n  \"贵州省-黔东南苗族侗族自治州-施秉县\": [108.13044, 27.039822],\n  \"贵州省-黔东南苗族侗族自治州-三穗县\": [108.681545, 26.958666],\n  \"贵州省-黔东南苗族侗族自治州-镇远县\": [108.436581, 27.054821],\n  \"贵州省-黔东南苗族侗族自治州-岑巩县\": [108.822481, 27.179902],\n  \"贵州省-黔东南苗族侗族自治州-天柱县\": [109.214446, 26.915804],\n  \"贵州省-黔东南苗族侗族自治州-锦屏县\": [109.207438, 26.682632],\n  \"贵州省-黔东南苗族侗族自治州-剑河县\": [108.447517, 26.734048],\n  \"贵州省-黔东南苗族侗族自治州-台江县\": [108.328552, 26.672373],\n  \"贵州省-黔东南苗族侗族自治州-黎平县\": [109.143567, 26.236874],\n  \"贵州省-黔东南苗族侗族自治州-榕江县\": [108.527554, 25.937725],\n  \"贵州省-黔东南苗族侗族自治州-从江县\": [108.911561, 25.759881],\n  \"贵州省-黔东南苗族侗族自治州-雷山县\": [108.084529, 26.384205],\n  \"贵州省-黔东南苗族侗族自治州-麻江县\": [107.595551, 26.496808],\n  \"贵州省-黔东南苗族侗族自治州-丹寨县\": [107.795513, 26.204421],\n  \"贵州省-黔南布依族苗族自治州\": [107.528403, 26.260616],\n  \"贵州省-黔南布依族苗族自治州-都匀市\": [107.525404, 26.266118],\n  \"贵州省-黔南布依族苗族自治州-福泉市\": [107.526433, 26.692526],\n  \"贵州省-黔南布依族苗族自治州-荔波县\": [107.893409, 25.417098],\n  \"贵州省-黔南布依族苗族自治州-贵定县\": [107.240554, 26.59066],\n  \"贵州省-黔南布依族苗族自治州-瓮安县\": [107.477552, 27.084126],\n  \"贵州省-黔南布依族苗族自治州-独山县\": [107.551498, 25.828288],\n  \"贵州省-黔南布依族苗族自治州-平塘县\": [107.329567, 25.828202],\n  \"贵州省-黔南布依族苗族自治州-罗甸县\": [106.758548, 25.430838],\n  \"贵州省-黔南布依族苗族自治州-长顺县\": [106.458421, 26.028455],\n  \"贵州省-黔南布依族苗族自治州-龙里县\": [106.986586, 26.459081],\n  \"贵州省-黔南布依族苗族自治州-惠水县\": [106.663453, 26.13821],\n  \"贵州省-黔南布依族苗族自治州-三都水族自治县\": [107.876429, 25.989479],\n  \"云南省\": [102.716416, 25.051562],\n  \"云南省-昆明市\": [102.852448, 24.873998],\n  \"云南省-昆明市-五华区\": [102.713423, 25.049835],\n  \"云南省-昆明市-盘龙区\": [102.758526, 25.122372],\n  \"云南省-昆明市-官渡区\": [102.750482, 25.021196],\n  \"云南省-昆明市-西山区\": [102.671557, 25.043199],\n  \"云南省-昆明市-东川区\": [103.194452, 26.089054],\n  \"云南省-昆明市-呈贡区\": [102.827473, 24.891871],\n  \"云南省-昆明市-晋宁县\": [102.602418, 24.676099],\n  \"云南省-昆明市-富民县\": [102.504473, 25.228085],\n  \"云南省-昆明市-宜良县\": [103.147558, 24.925287],\n  \"云南省-昆明市-石林彝族自治县\": [103.296508, 24.777702],\n  \"云南省-昆明市-嵩明县\": [103.043564, 25.344409],\n  \"云南省-昆明市-禄劝彝族苗族自治县\": [102.477423, 25.557672],\n  \"云南省-昆明市-寻甸回族彝族自治县\": [103.263574, 25.563894],\n  \"云南省-昆明市-安宁市\": [102.484409, 24.925602],\n  \"云南省-曲靖市\": [103.802435, 25.496407],\n  \"云南省-曲靖市-麒麟区\": [103.81143, 25.502102],\n  \"云南省-曲靖市-沾益区\": [103.828485, 25.606631],\n  \"云南省-曲靖市-马龙县\": [103.585447, 25.433966],\n  \"云南省-曲靖市-陆良县\": [103.673432, 25.035639],\n  \"云南省-曲靖市-师宗县\": [103.991556, 24.827995],\n  \"云南省-曲靖市-罗平县\": [104.31551, 24.89052],\n  \"云南省-曲靖市-富源县\": [104.261474, 25.68028],\n  \"云南省-曲靖市-会泽县\": [103.303487, 26.424215],\n  \"云南省-曲靖市-宣威市\": [104.111576, 26.225598],\n  \"云南省-玉溪市\": [102.55356, 24.357711],\n  \"云南省-玉溪市-红塔区\": [102.551565, 24.359801],\n  \"云南省-玉溪市-江川区\": [102.760527, 24.293439],\n  \"云南省-玉溪市-澄江县\": [102.914555, 24.679415],\n  \"云南省-玉溪市-通海县\": [102.732423, 24.117891],\n  \"云南省-玉溪市-华宁县\": [102.935492, 24.198581],\n  \"云南省-玉溪市-易门县\": [102.169535, 24.677404],\n  \"云南省-玉溪市-峨山彝族自治县\": [102.412565, 24.174774],\n  \"云南省-玉溪市-新平彝族傣族自治县\": [101.996428, 24.076263],\n  \"云南省-玉溪市-元江哈尼族彝族傣族自治县\": [102.004415, 23.603001],\n  \"云南省-保山市\": [99.177273, 25.139039],\n  \"云南省-保山市-隆阳区\": [99.172071, 25.126888],\n  \"云南省-保山市-施甸县\": [99.195469, 24.728835],\n  \"云南省-保山市-龙陵县\": [98.69575, 24.592547],\n  \"云南省-保山市-昌宁县\": [99.611617, 24.833985],\n  \"云南省-保山市-腾冲市\": [98.497595, 25.026617],\n  \"云南省-昭通市\": [103.723512, 27.344084],\n  \"云南省-昭通市-昭阳区\": [103.71347, 27.326144],\n  \"云南省-昭通市-鲁甸县\": [103.564412, 27.193107],\n  \"云南省-昭通市-巧家县\": [102.936519, 26.914705],\n  \"云南省-昭通市-盐津县\": [104.241579, 28.114384],\n  \"云南省-昭通市-大关县\": [103.897515, 27.754021],\n  \"云南省-昭通市-永善县\": [103.644569, 28.234722],\n  \"云南省-昭通市-绥江县\": [103.964552, 28.604278],\n  \"云南省-昭通市-镇雄县\": [104.880404, 27.447795],\n  \"云南省-昭通市-彝良县\": [104.054443, 27.63169],\n  \"云南省-昭通市-威信县\": [105.055577, 27.852537],\n  \"云南省-昭通市-水富县\": [104.422433, 28.636107],\n  \"云南省-丽江市\": [100.232465, 26.860657],\n  \"云南省-丽江市-古城区\": [100.23248, 26.883162],\n  \"云南省-丽江市-玉龙纳西族自治县\": [100.243527, 26.827392],\n  \"云南省-丽江市-永胜县\": [100.757581, 26.68995],\n  \"云南省-丽江市-华坪县\": [101.27243, 26.635223],\n  \"云南省-丽江市-宁蒗彝族自治县\": [100.85859, 27.287728],\n  \"云南省-普洱市\": [100.97257, 22.830979],\n  \"云南省-普洱市-思茅区\": [100.983555, 22.792498],\n  \"云南省-普洱市-宁洱哈尼族彝族自治县\": [101.052442, 23.05459],\n  \"云南省-普洱市-墨江哈尼族自治县\": [101.698584, 23.437726],\n  \"云南省-普洱市-景东彝族自治县\": [100.838489, 24.451864],\n  \"云南省-普洱市-景谷傣族彝族自治县\": [100.838489, 24.451864],\n  \"云南省-普洱市-镇沅彝族哈尼族拉祜族自治县\": [101.115569, 24.010331],\n  \"云南省-普洱市-江城哈尼族彝族自治县\": [101.868479, 22.591684],\n  \"云南省-普洱市-孟连傣族拉祜族佤族自治县\": [99.590963, 22.335308],\n  \"云南省-普洱市-澜沧拉祜族自治县\": [99.938588, 22.561832],\n  \"云南省-普洱市-西盟佤族自治县\": [99.596622, 22.650656],\n  \"云南省-临沧市\": [100.09544, 23.890469],\n  \"云南省-临沧市-临翔区\": [100.088443, 23.901402],\n  \"云南省-临沧市-凤庆县\": [99.934989, 24.586472],\n  \"云南省-临沧市-云县\": [100.129531, 24.442807],\n  \"云南省-临沧市-永德县\": [99.265076, 24.024871],\n  \"云南省-临沧市-镇康县\": [98.831871, 23.768315],\n  \"云南省-临沧市-双江拉祜族佤族布朗族傣族自治县\": [99.834131, 23.479837],\n  \"云南省-临沧市-耿马傣族佤族自治县\": [99.403942, 23.543491],\n  \"云南省-临沧市-沧源佤族自治县\": [99.252722, 23.152879],\n  \"云南省-楚雄彝族自治州\": [101.534412, 25.051774],\n  \"云南省-楚雄彝族自治州-楚雄市\": [101.552472, 25.03886],\n  \"云南省-楚雄彝族自治州-双柏县\": [101.552472, 25.03886],\n  \"云南省-楚雄彝族自治州-牟定县\": [101.553481, 25.318846],\n  \"云南省-楚雄彝族自治州-南华县\": [101.280421, 25.198587],\n  \"云南省-楚雄彝族自治州-姚安县\": [101.248527, 25.509775],\n  \"云南省-楚雄彝族自治州-大姚县\": [101.330567, 25.727601],\n  \"云南省-楚雄彝族自治州-永仁县\": [101.672493, 26.055566],\n  \"云南省-楚雄彝族自治州-元谋县\": [101.880445, 25.710895],\n  \"云南省-楚雄彝族自治州-武定县\": [102.410532, 25.53609],\n  \"云南省-楚雄彝族自治州-禄丰县\": [102.085531, 25.155831],\n  \"云南省-红河哈尼族彝族自治州\": [103.381549, 23.369996],\n  \"云南省-红河哈尼族彝族自治州-个旧市\": [103.166519, 23.364942],\n  \"云南省-红河哈尼族彝族自治州-开远市\": [103.166519, 23.364942],\n  \"云南省-红河哈尼族彝族自治州-蒙自市\": [103.371546, 23.40208],\n  \"云南省-红河哈尼族彝族自治州-弥勒市\": [103.421489, 24.417982],\n  \"云南省-红河哈尼族彝族自治州-屏边苗族自治县\": [103.693432, 22.98999],\n  \"云南省-红河哈尼族彝族自治州-建水县\": [102.83344, 23.640939],\n  \"云南省-红河哈尼族彝族自治州-石屏县\": [102.502447, 23.712004],\n  \"云南省-红河哈尼族彝族自治州-泸西县\": [103.772523, 24.538037],\n  \"云南省-红河哈尼族彝族自治州-元阳县\": [102.841433, 23.226198],\n  \"云南省-红河哈尼族彝族自治州-红河县\": [102.427551, 23.374489],\n  \"云南省-红河哈尼族彝族自治州-金平苗族瑶族傣族自治县\": [102.427551, 23.374489],\n  \"云南省-红河哈尼族彝族自治州-绿春县\": [102.398494, 23.000165],\n  \"云南省-红河哈尼族彝族自治州-河口瑶族自治县\": [103.945444, 22.535466],\n  \"云南省-文山壮族苗族自治州\": [104.222569, 23.405994],\n  \"云南省-文山壮族苗族自治州-文山市\": [104.238544, 23.391944],\n  \"云南省-文山壮族苗族自治州-砚山县\": [104.343551, 23.611487],\n  \"云南省-文山壮族苗族自治州-西畴县\": [104.678525, 23.443271],\n  \"云南省-文山壮族苗族自治州-麻栗坡县\": [104.709549, 23.131586],\n  \"云南省-文山壮族苗族自治州-马关县\": [104.400415, 23.018994],\n  \"云南省-文山壮族苗族自治州-丘北县\": [104.173442, 24.056994],\n  \"云南省-文山壮族苗族自治州-广南县\": [105.061582, 24.052199],\n  \"云南省-文山壮族苗族自治州-富宁县\": [105.63749, 23.63138],\n  \"云南省-西双版纳傣族自治州\": [100.803447, 22.013601],\n  \"云南省-西双版纳傣族自治州-景洪市\": [100.806443, 22.017004],\n  \"云南省-西双版纳傣族自治州-勐海县\": [100.459446, 21.963434],\n  \"云南省-西双版纳傣族自治州-勐腊县\": [101.571528, 21.465281],\n  \"云南省-大理白族自治州\": [100.274583, 25.612128],\n  \"云南省-大理白族自治州-大理市\": [100.236519, 25.597605],\n  \"云南省-大理白族自治州-漾濞彝族自治县\": [100.236519, 25.597605],\n  \"云南省-大理白族自治州-祥云县\": [100.557447, 25.489873],\n  \"云南省-大理白族自治州-宾川县\": [100.578457, 25.835249],\n  \"云南省-大理白族自治州-弥渡县\": [100.497586, 25.349336],\n  \"云南省-大理白族自治州-南涧彝族自治县\": [100.497586, 25.349336],\n  \"云南省-大理白族自治州-巍山彝族回族自治县\": [100.31346, 25.233439],\n  \"云南省-大理白族自治州-永平县\": [99.547495, 25.470206],\n  \"云南省-大理白族自治州-云龙县\": [99.377416, 25.891945],\n  \"云南省-大理白族自治州-洱源县\": [99.96921, 26.120093],\n  \"云南省-大理白族自治州-剑川县\": [99.912091, 26.542517],\n  \"云南省-大理白族自治州-鹤庆县\": [100.182492, 26.566197],\n  \"云南省-德宏傣族景颇族自治州\": [98.591359, 24.438011],\n  \"云南省-德宏傣族景颇族自治州-瑞丽市\": [97.862486, 24.022817],\n  \"云南省-德宏傣族景颇族自治州-芒市\": [97.862486, 24.022817],\n  \"云南省-德宏傣族景颇族自治州-梁河县\": [98.303134, 24.810784],\n  \"云南省-德宏傣族景颇族自治州-盈江县\": [97.938427, 24.711534],\n  \"云南省-德宏傣族景颇族自治州-陇川县\": [97.79853, 24.189468],\n  \"云南省-怒江傈僳族自治州\": [98.863288, 25.823707],\n  \"云南省-怒江傈僳族自治州-泸水市\": [98.864586, 25.829027],\n  \"云南省-怒江傈僳族自治州-福贡县\": [98.875649, 26.908055],\n  \"云南省-怒江傈僳族自治州-贡山独龙族怒族自治县\": [98.672399, 27.747068],\n  \"云南省-怒江傈僳族自治州-兰坪白族普米族自治县\": [99.423285, 26.459208],\n  \"云南省-迪庆藏族自治州\": [99.70953, 27.825185],\n  \"云南省-迪庆藏族自治州-香格里拉市\": [99.707445, 27.83576],\n  \"云南省-迪庆藏族自治州-德钦县\": [98.924453, 28.470086],\n  \"云南省-迪庆藏族自治州-维西傈僳族自治县\": [99.293466, 27.18317],\n  \"西藏自治区\": [91.124342, 29.652894],\n  \"西藏自治区-拉萨市\": [91.120824, 29.65004],\n  \"西藏自治区-拉萨市-城关区\": [91.1451, 29.658331],\n  \"西藏自治区-拉萨市-堆龙德庆区\": [91.009963, 29.651626],\n  \"西藏自治区-拉萨市-林周县\": [91.269501, 29.898733],\n  \"西藏自治区-拉萨市-当雄县\": [91.107452, 30.479222],\n  \"西藏自治区-拉萨市-尼木县\": [90.17118, 29.437519],\n  \"西藏自治区-拉萨市-曲水县\": [90.749959, 29.358987],\n  \"西藏自治区-拉萨市-达孜县\": [91.356318, 29.675409],\n  \"西藏自治区-拉萨市-墨竹工卡县\": [91.737266, 29.839753],\n  \"西藏自治区-日喀则市\": [88.902952, 29.255583],\n  \"西藏自治区-日喀则市-桑珠孜区\": [88.902952, 29.255583],\n  \"西藏自治区-日喀则市-南木林县\": [89.108283, 29.688959],\n  \"西藏自治区-日喀则市-江孜县\": [89.614958, 28.916435],\n  \"西藏自治区-日喀则市-定日县\": [88.859425, 29.004648],\n  \"西藏自治区-日喀则市-萨迦县\": [88.02935, 28.907594],\n  \"西藏自治区-日喀则市-拉孜县\": [88.893863, 29.273927],\n  \"西藏自治区-日喀则市-昂仁县\": [88.88319, 29.271424],\n  \"西藏自治区-日喀则市-谢通门县\": [88.267177, 29.436132],\n  \"西藏自治区-日喀则市-白朗县\": [89.267941, 29.116209],\n  \"西藏自治区-日喀则市-仁布县\": [89.848427, 29.236361],\n  \"西藏自治区-日喀则市-康马县\": [89.688245, 28.561444],\n  \"西藏自治区-日喀则市-定结县\": [87.772377, 28.369911],\n  \"西藏自治区-日喀则市-仲巴县\": [84.038117, 29.775982],\n  \"西藏自治区-日喀则市-亚东县\": [88.896978, 29.275644],\n  \"西藏自治区-日喀则市-吉隆县\": [88.662548, 29.401862],\n  \"西藏自治区-日喀则市-聂拉木县\": [88.889064, 29.275236],\n  \"西藏自治区-日喀则市-萨嘎县\": [88.647947, 29.079969],\n  \"西藏自治区-日喀则市-岗巴县\": [89.322529, 29.277094],\n  \"西藏自治区-昌都市\": [97.186654, 31.144249],\n  \"西藏自治区-昌都市-卡若区\": [97.186654, 31.144249],\n  \"西藏自治区-昌都市-江达县\": [98.224424, 31.505147],\n  \"西藏自治区-昌都市-贡觉县\": [98.277334, 30.865967],\n  \"西藏自治区-昌都市-类乌齐县\": [96.608489, 31.22509],\n  \"西藏自治区-昌都市-丁青县\": [97.177402, 31.149643],\n  \"西藏自治区-昌都市-察雅县\": [97.575976, 30.660119],\n  \"西藏自治区-昌都市-八宿县\": [96.931495, 30.061833],\n  \"西藏自治区-昌都市-左贡县\": [97.847367, 29.676849],\n  \"西藏自治区-昌都市-芒康县\": [96.848134, 30.738561],\n  \"西藏自治区-昌都市-洛隆县\": [97.399916, 31.06774],\n  \"西藏自治区-昌都市-边坝县\": [94.714371, 30.939625],\n  \"西藏自治区-林芝市\": [94.368058, 29.654042],\n  \"西藏自治区-林芝市-巴宜区\": [94.367544, 29.641645],\n  \"西藏自治区-林芝市-工布江达县\": [93.25242, 29.891368],\n  \"西藏自治区-林芝市-米林县\": [94.219939, 29.220917],\n  \"西藏自治区-林芝市-墨脱县\": [95.339495, 29.330938],\n  \"西藏自治区-林芝市-波密县\": [95.7739, 29.86506],\n  \"西藏自治区-林芝市-察隅县\": [97.47327, 28.667444],\n  \"西藏自治区-林芝市-朗县\": [93.081368, 29.051902],\n  \"西藏自治区-山南市\": [91.778675, 29.243027],\n  \"西藏自治区-山南市-乃东区\": [91.778682, 29.234229],\n  \"西藏自治区-山南市-扎囊县\": [91.343627, 29.251164],\n  \"西藏自治区-山南市-贡嘎县\": [91.343627, 29.251164],\n  \"西藏自治区-山南市-桑日县\": [92.021252, 29.267104],\n  \"西藏自治区-山南市-琼结县\": [91.690101, 29.030866],\n  \"西藏自治区-山南市-曲松县\": [92.205435, 29.071107],\n  \"西藏自治区-山南市-措美县\": [91.439918, 28.444258],\n  \"西藏自治区-山南市-洛扎县\": [90.855029, 28.391993],\n  \"西藏自治区-山南市-加查县\": [92.601582, 29.144787],\n  \"西藏自治区-山南市-隆子县\": [92.469078, 28.414441],\n  \"西藏自治区-山南市-错那县\": [91.968115, 27.998343],\n  \"西藏自治区-山南市-浪卡子县\": [90.404647, 28.973992],\n  \"西藏自治区-那曲地区\": [92.057338, 31.482438],\n  \"西藏自治区-那曲地区-那曲县\": [92.059847, 31.476117],\n  \"西藏自治区-那曲地区-嘉黎县\": [93.238732, 30.647062],\n  \"西藏自治区-那曲地区-比如县\": [93.685966, 31.486357],\n  \"西藏自治区-那曲地区-聂荣县\": [92.308654, 32.113707],\n  \"西藏自治区-那曲地区-安多县\": [91.688891, 32.271268],\n  \"西藏自治区-那曲地区-申扎县\": [88.716481, 30.936393],\n  \"西藏自治区-那曲地区-索县\": [93.792173, 31.892424],\n  \"西藏自治区-那曲地区-班戈县\": [90.016708, 31.398728],\n  \"西藏自治区-那曲地区-巴青县\": [94.059882, 31.924549],\n  \"西藏自治区-那曲地区-尼玛县\": [87.243292, 31.790953],\n  \"西藏自治区-那曲地区-双湖县\": [87.243292, 31.790953],\n  \"西藏自治区-阿里地区\": [80.112777, 32.506866],\n  \"西藏自治区-阿里地区-普兰县\": [81.183095, 30.300163],\n  \"西藏自治区-阿里地区-札达县\": [79.809323, 31.485343],\n  \"西藏自治区-阿里地区-噶尔县\": [80.102877, 32.497157],\n  \"西藏自治区-阿里地区-日土县\": [79.739109, 33.387186],\n  \"西藏自治区-阿里地区-革吉县\": [81.151664, 32.393356],\n  \"西藏自治区-阿里地区-改则县\": [84.069113, 32.308357],\n  \"西藏自治区-阿里地区-措勤县\": [84.069113, 32.308357],\n  \"陕西省\": [108.960393, 34.275808],\n  \"陕西省-西安市\": [108.946466, 34.347269],\n  \"陕西省-西安市-新城区\": [108.967391, 34.272724],\n  \"陕西省-西安市-碑林区\": [108.940498, 34.236474],\n  \"陕西省-西安市-莲湖区\": [108.950426, 34.271017],\n  \"陕西省-西安市-灞桥区\": [109.071415, 34.279128],\n  \"陕西省-西安市-未央区\": [108.953401, 34.299148],\n  \"陕西省-西安市-雁塔区\": [108.95144, 34.220635],\n  \"陕西省-西安市-阎良区\": [109.232463, 34.668363],\n  \"陕西省-西安市-临潼区\": [109.220436, 34.372747],\n  \"陕西省-西安市-长安区\": [108.91358, 34.16329],\n  \"陕西省-西安市-高陵区\": [109.094387, 34.541093],\n  \"陕西省-西安市-蓝田县\": [109.329388, 34.157621],\n  \"陕西省-西安市-周至县\": [108.228422, 34.169385],\n  \"陕西省-西安市-户县\": [108.61142, 34.115021],\n  \"陕西省-铜川市\": [108.952404, 34.902637],\n  \"陕西省-铜川市-王益区\": [109.081417, 35.075322],\n  \"陕西省-铜川市-印台区\": [109.106434, 35.120859],\n  \"陕西省-铜川市-耀州区\": [108.986438, 34.91596],\n  \"陕西省-铜川市-宜君县\": [109.123537, 35.404582],\n  \"陕西省-宝鸡市\": [107.244575, 34.368916],\n  \"陕西省-宝鸡市-渭滨区\": [107.156419, 34.377481],\n  \"陕西省-宝鸡市-金台区\": [107.153424, 34.382351],\n  \"陕西省-宝鸡市-陈仓区\": [107.393438, 34.360756],\n  \"陕西省-宝鸡市-凤翔县\": [107.407379, 34.527616],\n  \"陕西省-宝鸡市-岐山县\": [107.627447, 34.449777],\n  \"陕西省-宝鸡市-扶风县\": [107.906453, 34.381463],\n  \"陕西省-宝鸡市-眉县\": [107.756398, 34.280376],\n  \"陕西省-宝鸡市-陇县\": [106.870584, 34.89878],\n  \"陕西省-宝鸡市-千阳县\": [107.139466, 34.648545],\n  \"陕西省-宝鸡市-麟游县\": [107.799514, 34.683749],\n  \"陕西省-宝鸡市-凤县\": [106.522558, 33.916583],\n  \"陕西省-宝鸡市-太白县\": [107.325529, 34.064248],\n  \"陕西省-咸阳市\": [108.715422, 34.335476],\n  \"陕西省-咸阳市-秦都区\": [108.712432, 34.335145],\n  \"陕西省-咸阳市-杨陵区\": [108.091515, 34.278013],\n  \"陕西省-咸阳市-渭城区\": [108.743451, 34.36811],\n  \"陕西省-咸阳市-三原县\": [108.947447, 34.623079],\n  \"陕西省-咸阳市-泾阳县\": [108.849379, 34.533317],\n  \"陕西省-咸阳市-乾县\": [108.245378, 34.534018],\n  \"陕西省-咸阳市-礼泉县\": [108.431615, 34.487391],\n  \"陕西省-咸阳市-永寿县\": [108.148469, 34.698036],\n  \"陕西省-咸阳市-彬县\": [108.084566, 35.049611],\n  \"陕西省-咸阳市-长武县\": [107.805561, 35.211657],\n  \"陕西省-咸阳市-旬邑县\": [108.340467, 35.117964],\n  \"陕西省-咸阳市-淳化县\": [108.587442, 34.804777],\n  \"陕西省-咸阳市-武功县\": [108.206551, 34.266138],\n  \"陕西省-咸阳市-兴平市\": [108.496394, 34.305477],\n  \"陕西省-渭南市\": [109.51659, 34.505716],\n  \"陕西省-渭南市-临渭区\": [109.498596, 34.504],\n  \"陕西省-渭南市-华州区\": [109.778477, 34.518731],\n  \"陕西省-渭南市-潼关县\": [110.252508, 34.550327],\n  \"陕西省-渭南市-大荔县\": [109.948453, 34.801833],\n  \"陕西省-渭南市-合阳县\": [110.155396, 35.243872],\n  \"陕西省-渭南市-澄城县\": [109.938434, 35.196573],\n  \"陕西省-渭南市-蒲城县\": [109.592497, 34.961274],\n  \"陕西省-渭南市-白水县\": [109.597521, 35.183288],\n  \"陕西省-渭南市-富平县\": [109.186437, 34.75726],\n  \"陕西省-渭南市-韩城市\": [110.449553, 35.482087],\n  \"陕西省-渭南市-华阴市\": [110.098601, 34.5718],\n  \"陕西省-延安市\": [109.496582, 36.591111],\n  \"陕西省-延安市-宝塔区\": [109.499594, 36.59689],\n  \"陕西省-延安市-安塞区\": [109.335419, 36.870098],\n  \"陕西省-延安市-延长县\": [110.018472, 36.585329],\n  \"陕西省-延安市-延川县\": [110.20054, 36.884137],\n  \"陕西省-延安市-子长县\": [109.68139, 37.148817],\n  \"陕西省-延安市-志丹县\": [108.775577, 36.828021],\n  \"陕西省-延安市-吴起县\": [108.18259, 36.932576],\n  \"陕西省-延安市-甘泉县\": [109.357524, 36.282689],\n  \"陕西省-延安市-富县\": [109.386597, 35.993368],\n  \"陕西省-延安市-洛川县\": [109.438404, 35.7683],\n  \"陕西省-延安市-宜川县\": [110.175413, 36.056397],\n  \"陕西省-延安市-黄龙县\": [109.846549, 35.590234],\n  \"陕西省-延安市-黄陵县\": [109.269606, 35.585076],\n  \"陕西省-汉中市\": [107.02943, 33.0738],\n  \"陕西省-汉中市-汉台区\": [107.038402, 33.074191],\n  \"陕西省-汉中市-南郑县\": [106.942433, 33.005615],\n  \"陕西省-汉中市-城固县\": [107.340613, 33.162399],\n  \"陕西省-汉中市-洋县\": [107.552464, 33.228863],\n  \"陕西省-汉中市-西乡县\": [107.773393, 32.989397],\n  \"陕西省-汉中市-勉县\": [106.679426, 33.159805],\n  \"陕西省-汉中市-宁强县\": [106.264589, 32.83538],\n  \"陕西省-汉中市-略阳县\": [106.163544, 33.333194],\n  \"陕西省-汉中市-镇巴县\": [107.901446, 32.542833],\n  \"陕西省-汉中市-留坝县\": [106.927414, 33.623825],\n  \"陕西省-汉中市-佛坪县\": [107.997424, 33.530693],\n  \"陕西省-榆林市\": [109.741616, 38.290884],\n  \"陕西省-榆林市-榆阳区\": [109.727559, 38.28242],\n  \"陕西省-榆林市-横山区\": [109.300491, 37.968573],\n  \"陕西省-榆林市-神木县\": [110.50543, 38.848544],\n  \"陕西省-榆林市-府谷县\": [111.073628, 39.033796],\n  \"陕西省-榆林市-靖边县\": [108.8006, 37.605063],\n  \"陕西省-榆林市-定边县\": [107.60757, 37.60046],\n  \"陕西省-榆林市-绥德县\": [110.269426, 37.508907],\n  \"陕西省-榆林市-米脂县\": [110.190451, 37.761398],\n  \"陕西省-榆林市-佳县\": [110.497477, 38.025612],\n  \"陕西省-榆林市-吴堡县\": [110.746455, 37.45827],\n  \"陕西省-榆林市-清涧县\": [110.127559, 37.094853],\n  \"陕西省-榆林市-子洲县\": [110.042398, 37.617026],\n  \"陕西省-安康市\": [109.035601, 32.690513],\n  \"陕西省-安康市-汉滨区\": [109.033596, 32.701196],\n  \"陕西省-安康市-汉阴县\": [108.515507, 32.899121],\n  \"陕西省-安康市-石泉县\": [108.254427, 33.044602],\n  \"陕西省-安康市-宁陕县\": [108.320564, 33.316555],\n  \"陕西省-安康市-紫阳县\": [108.541594, 32.525786],\n  \"陕西省-安康市-岚皋县\": [108.908615, 32.312881],\n  \"陕西省-安康市-平利县\": [109.368547, 32.394804],\n  \"陕西省-安康市-镇坪县\": [109.533497, 31.889643],\n  \"陕西省-安康市-旬阳县\": [109.371557, 32.839864],\n  \"陕西省-安康市-白河县\": [110.119587, 32.814846],\n  \"陕西省-商洛市\": [109.924418, 33.878634],\n  \"陕西省-商洛市-商州区\": [109.947472, 33.868855],\n  \"陕西省-商洛市-洛南县\": [110.154427, 34.097071],\n  \"陕西省-商洛市-丹凤县\": [110.33356, 33.701537],\n  \"陕西省-商洛市-商南县\": [110.888408, 33.537533],\n  \"陕西省-商洛市-山阳县\": [109.888549, 33.537968],\n  \"陕西省-商洛市-镇安县\": [109.159575, 33.429045],\n  \"陕西省-商洛市-柞水县\": [109.120502, 33.692026],\n  \"甘肃省\": [103.832478, 36.065465],\n  \"甘肃省-兰州市\": [103.840521, 36.067235],\n  \"甘肃省-兰州市-城关区\": [103.831475, 36.063181],\n  \"甘肃省-兰州市-七里河区\": [103.792414, 36.072129],\n  \"甘肃省-兰州市-西固区\": [103.63458, 36.094109],\n  \"甘肃省-兰州市-安宁区\": [103.725535, 36.109754],\n  \"甘肃省-兰州市-红古区\": [102.865428, 36.351863],\n  \"甘肃省-兰州市-永登县\": [103.266624, 36.742095],\n  \"甘肃省-兰州市-皋兰县\": [103.953464, 36.338142],\n  \"甘肃省-兰州市-榆中县\": [104.119566, 35.848851],\n  \"甘肃省-嘉峪关市\": [98.296204, 39.77796],\n  \"甘肃省-金昌市\": [102.194606, 38.52582],\n  \"甘肃省-金昌市-金川区\": [102.200586, 38.525772],\n  \"甘肃省-金昌市-永昌县\": [101.979464, 38.252941],\n  \"甘肃省-白银市\": [104.144451, 36.550825],\n  \"甘肃省-白银市-白银区\": [104.155413, 36.541464],\n  \"甘肃省-白银市-平川区\": [104.831614, 36.733499],\n  \"甘肃省-白银市-靖远县\": [104.682515, 36.577096],\n  \"甘肃省-白银市-会宁县\": [105.059607, 35.698508],\n  \"甘肃省-白银市-景泰县\": [104.069444, 37.187406],\n  \"甘肃省-天水市\": [105.731417, 34.587412],\n  \"甘肃省-天水市-秦州区\": [105.730415, 34.587316],\n  \"甘肃省-天水市-麦积区\": [105.895597, 34.576337],\n  \"甘肃省-天水市-清水县\": [106.143595, 34.753883],\n  \"甘肃省-天水市-秦安县\": [105.681575, 34.864876],\n  \"甘肃省-天水市-甘谷县\": [105.342475, 34.7383],\n  \"甘肃省-天水市-武山县\": [104.897428, 34.727669],\n  \"甘肃省-天水市-张家川回族自治县\": [106.21139, 34.994905],\n  \"甘肃省-武威市\": [102.644554, 37.934378],\n  \"甘肃省-武威市-凉州区\": [102.648575, 37.934122],\n  \"甘肃省-武威市-民勤县\": [103.1004, 38.630625],\n  \"甘肃省-武威市-古浪县\": [102.90363, 37.475802],\n  \"甘肃省-武威市-天祝藏族自治县\": [103.148621, 36.977596],\n  \"甘肃省-张掖市\": [100.456411, 38.932066],\n  \"甘肃省-张掖市-甘州区\": [100.484558, 38.934781],\n  \"甘肃省-张掖市-肃南裕固族自治县\": [99.621905, 38.8431],\n  \"甘肃省-张掖市-民乐县\": [100.819429, 38.436842],\n  \"甘肃省-张掖市-临泽县\": [100.170555, 39.158514],\n  \"甘肃省-张掖市-高台县\": [99.82576, 39.383646],\n  \"甘肃省-张掖市-山丹县\": [101.095616, 38.790453],\n  \"甘肃省-平凉市\": [106.671442, 35.549232],\n  \"甘肃省-平凉市-崆峒区\": [106.681415, 35.548815],\n  \"甘肃省-平凉市-泾川县\": [107.374518, 35.338669],\n  \"甘肃省-平凉市-灵台县\": [107.627461, 35.071582],\n  \"甘肃省-平凉市-崇信县\": [107.041415, 35.308616],\n  \"甘肃省-平凉市-华亭县\": [106.659486, 35.223551],\n  \"甘肃省-平凉市-庄浪县\": [106.042586, 35.208192],\n  \"甘肃省-平凉市-静宁县\": [105.738416, 35.528257],\n  \"甘肃省-酒泉市\": [98.500685, 39.738469],\n  \"甘肃省-酒泉市-肃州区\": [98.514322, 39.751246],\n  \"甘肃省-酒泉市-金塔县\": [98.908368, 39.990029],\n  \"甘肃省-酒泉市-瓜州县\": [95.788736, 40.526106],\n  \"甘肃省-酒泉市-肃北蒙古族自治县\": [94.883692, 39.51833],\n  \"甘肃省-酒泉市-阿克塞哈萨克族自治县\": [94.34676, 39.640045],\n  \"甘肃省-酒泉市-玉门市\": [97.051712, 40.29762],\n  \"甘肃省-酒泉市-敦煌市\": [94.668527, 40.147867],\n  \"甘肃省-庆阳市\": [107.649386, 35.715216],\n  \"甘肃省-庆阳市-西峰区\": [107.657391, 35.736864],\n  \"甘肃省-庆阳市-庆城县\": [107.888406, 36.021726],\n  \"甘肃省-庆阳市-环县\": [107.31447, 36.574427],\n  \"甘肃省-庆阳市-华池县\": [107.99639, 36.467575],\n  \"甘肃省-庆阳市-合水县\": [108.026447, 35.825262],\n  \"甘肃省-庆阳市-正宁县\": [108.366375, 35.498219],\n  \"甘肃省-庆阳市-宁县\": [107.934571, 35.507933],\n  \"甘肃省-庆阳市-镇原县\": [107.207576, 35.683231],\n  \"甘肃省-定西市\": [104.63242, 35.586833],\n  \"甘肃省-定西市-安定区\": [104.6165, 35.5856],\n  \"甘肃省-定西市-通渭县\": [105.248404, 35.217217],\n  \"甘肃省-定西市-陇西县\": [104.641381, 35.010197],\n  \"甘肃省-定西市-渭源县\": [104.221584, 35.142392],\n  \"甘肃省-定西市-临洮县\": [103.865601, 35.400587],\n  \"甘肃省-定西市-漳县\": [104.478595, 34.85425],\n  \"甘肃省-定西市-岷县\": [104.043396, 34.444408],\n  \"甘肃省-陇南市\": [104.928575, 33.40662],\n  \"甘肃省-陇南市-武都区\": [104.932593, 33.398072],\n  \"甘肃省-陇南市-成县\": [105.748478, 33.756635],\n  \"甘肃省-陇南市-文县\": [104.689558, 32.949601],\n  \"甘肃省-陇南市-宕昌县\": [104.399386, 34.053486],\n  \"甘肃省-陇南市-康县\": [105.615392, 33.335376],\n  \"甘肃省-陇南市-西和县\": [105.30761, 34.016787],\n  \"甘肃省-陇南市-礼县\": [105.183591, 34.194685],\n  \"甘肃省-陇南市-徽县\": [106.094418, 33.775194],\n  \"甘肃省-陇南市-两当县\": [106.311419, 33.915123],\n  \"甘肃省-临夏回族自治州\": [103.216391, 35.607562],\n  \"甘肃省-临夏回族自治州-临夏市\": [103.249549, 35.609899],\n  \"甘肃省-临夏回族自治州-临夏县\": [103.002514, 35.497398],\n  \"甘肃省-临夏回族自治州-康乐县\": [103.715476, 35.37611],\n  \"甘肃省-临夏回族自治州-永靖县\": [103.292507, 35.96333],\n  \"甘肃省-临夏回族自治州-广河县\": [103.58241, 35.494101],\n  \"甘肃省-临夏回族自治州-和政县\": [103.357524, 35.43059],\n  \"甘肃省-临夏回族自治州-东乡族自治县\": [103.395613, 35.66933],\n  \"甘肃省-临夏回族自治州-积石山保安族东乡族撒拉族自治县\": [\n    102.882518, 35.723499\n  ],\n  \"甘肃省-甘南藏族自治州\": [102.917585, 34.98914],\n  \"甘肃省-甘南藏族自治州-合作市\": [102.917572, 35.005935],\n  \"甘肃省-甘南藏族自治州-临潭县\": [103.360533, 34.698639],\n  \"甘肃省-甘南藏族自治州-卓尼县\": [103.513616, 34.594916],\n  \"甘肃省-甘南藏族自治州-舟曲县\": [104.37749, 33.790815],\n  \"甘肃省-甘南藏族自治州-迭部县\": [103.22844, 34.06202],\n  \"甘肃省-甘南藏族自治州-玛曲县\": [102.0786, 34.003358],\n  \"甘肃省-甘南藏族自治州-碌曲县\": [102.494424, 34.597087],\n  \"甘肃省-甘南藏族自治州-夏河县\": [102.528577, 35.208324],\n  \"青海省\": [101.786462, 36.627159],\n  \"青海省-西宁市\": [101.78445, 36.623385],\n  \"青海省-西宁市-城东区\": [101.809569, 36.605708],\n  \"青海省-西宁市-城中区\": [101.790484, 36.6288],\n  \"青海省-西宁市-城西区\": [101.772414, 36.634497],\n  \"青海省-西宁市-城北区\": [101.772405, 36.656294],\n  \"青海省-西宁市-大通回族土族自治县\": [101.692564, 36.932666],\n  \"青海省-西宁市-湟中县\": [101.578617, 36.506628],\n  \"青海省-西宁市-湟源县\": [101.262449, 36.688588],\n  \"青海省-海东市\": [102.110444, 36.508511],\n  \"青海省-海东市-乐都区\": [102.408566, 36.48782],\n  \"青海省-海东市-平安区\": [102.114428, 36.506554],\n  \"青海省-海东市-民和回族土族自治县\": [102.83639, 36.325561],\n  \"青海省-海东市-互助土族自治县\": [101.964569, 36.850022],\n  \"青海省-海东市-化隆回族自治县\": [102.270448, 36.100988],\n  \"青海省-海东市-循化撒拉族自治县\": [102.495385, 35.856667],\n  \"青海省-海北藏族自治州\": [100.907434, 36.960663],\n  \"青海省-海北藏族自治州-门源回族自治县\": [101.628438, 37.382181],\n  \"青海省-海北藏族自治州-祁连县\": [100.259622, 38.182925],\n  \"青海省-海北藏族自治州-海晏县\": [101.000586, 36.902376],\n  \"青海省-海北藏族自治州-刚察县\": [100.153606, 37.32732],\n  \"青海省-黄南藏族自治州\": [102.022428, 35.525805],\n  \"青海省-黄南藏族自治州-同仁县\": [102.025438, 35.521865],\n  \"青海省-黄南藏族自治州-尖扎县\": [102.037507, 35.944284],\n  \"青海省-黄南藏族自治州-泽库县\": [101.473595, 35.042014],\n  \"青海省-黄南藏族自治州-河南蒙古族自治县\": [101.622473, 34.740396],\n  \"青海省-海南藏族自治州\": [100.626621, 36.292102],\n  \"青海省-海南藏族自治州-共和县\": [100.626623, 36.288703],\n  \"青海省-海南藏族自治州-同德县\": [100.585424, 35.259858],\n  \"青海省-海南藏族自治州-贵德县\": [101.439533, 36.046158],\n  \"青海省-海南藏族自治州-兴海县\": [99.99438, 35.59463],\n  \"青海省-海南藏族自治州-贵南县\": [100.753593, 35.592415],\n  \"青海省-果洛藏族自治州\": [100.251592, 34.477194],\n  \"青海省-果洛藏族自治州-玛沁县\": [100.245564, 34.483569],\n  \"青海省-果洛藏族自治州-班玛县\": [100.743605, 32.938504],\n  \"青海省-果洛藏族自治州-甘德县\": [99.907511, 33.975004],\n  \"青海省-果洛藏族自治州-达日县\": [99.65801, 33.754937],\n  \"青海省-果洛藏族自治州-久治县\": [101.488532, 33.434773],\n  \"青海省-果洛藏族自治州-玛多县\": [98.215884, 34.920749],\n  \"青海省-玉树藏族自治州\": [97.013181, 33.01098],\n  \"青海省-玉树藏族自治州-玉树市\": [97.015376, 32.999556],\n  \"青海省-玉树藏族自治州-杂多县\": [95.306965, 32.899241],\n  \"青海省-玉树藏族自治州-称多县\": [97.115, 33.374226],\n  \"青海省-玉树藏族自治州-治多县\": [95.619794, 33.857953],\n  \"青海省-玉树藏族自治州-囊谦县\": [96.486918, 32.209194],\n  \"青海省-玉树藏族自治州-曲麻莱县\": [95.80375, 34.132299],\n  \"青海省-海西蒙古族藏族自治州\": [97.376299, 37.38275],\n  \"青海省-海西蒙古族藏族自治州-格尔木市\": [94.93331, 36.412371],\n  \"青海省-海西蒙古族藏族自治州-德令哈市\": [97.36747, 37.375346],\n  \"青海省-海西蒙古族藏族自治州-乌兰县\": [98.486736, 36.935748],\n  \"青海省-海西蒙古族藏族自治州-都兰县\": [98.102705, 36.307611],\n  \"青海省-海西蒙古族藏族自治州-天峻县\": [99.029243, 37.306903],\n  \"宁夏回族自治区\": [106.265605, 38.476878],\n  \"宁夏回族自治区-银川市\": [106.238494, 38.49246],\n  \"宁夏回族自治区-银川市-兴庆区\": [106.295494, 38.479579],\n  \"宁夏回族自治区-银川市-西夏区\": [106.156581, 38.496817],\n  \"宁夏回族自治区-银川市-金凤区\": [106.249561, 38.478695],\n  \"宁夏回族自治区-银川市-永宁县\": [106.259605, 38.283001],\n  \"宁夏回族自治区-银川市-贺兰县\": [106.356518, 38.560407],\n  \"宁夏回族自治区-银川市-灵武市\": [106.34644, 38.108659],\n  \"宁夏回族自治区-石嘴山市\": [106.3906, 38.989683],\n  \"宁夏回族自治区-石嘴山市-大武口区\": [106.37461, 39.024848],\n  \"宁夏回族自治区-石嘴山市-惠农区\": [106.78843, 39.245388],\n  \"宁夏回族自治区-石嘴山市-平罗县\": [106.536518, 38.919607],\n  \"宁夏回族自治区-吴忠市\": [106.205371, 38.003713],\n  \"宁夏回族自治区-吴忠市-利通区\": [106.219407, 37.990746],\n  \"宁夏回族自治区-吴忠市-红寺堡区\": [106.068421, 37.431882],\n  \"宁夏回族自治区-吴忠市-盐池县\": [107.41338, 37.789296],\n  \"宁夏回族自治区-吴忠市-同心县\": [105.920599, 36.98627],\n  \"宁夏回族自治区-吴忠市-青铜峡市\": [106.08537, 38.027412],\n  \"宁夏回族自治区-固原市\": [106.248577, 36.021617],\n  \"宁夏回族自治区-固原市-原州区\": [106.294515, 36.009368],\n  \"宁夏回族自治区-固原市-西吉县\": [105.735386, 35.970076],\n  \"宁夏回族自治区-固原市-隆德县\": [106.118498, 35.631762],\n  \"宁夏回族自治区-固原市-泾源县\": [106.337393, 35.504362],\n  \"宁夏回族自治区-固原市-彭阳县\": [106.644544, 35.855405],\n  \"宁夏回族自治区-中卫市\": [105.203571, 37.505701],\n  \"宁夏回族自治区-中卫市-沙坡头区\": [105.203571, 37.505701],\n  \"宁夏回族自治区-中卫市-中宁县\": [105.691537, 37.497421],\n  \"宁夏回族自治区-中卫市-海原县\": [105.650555, 36.570781],\n  \"新疆维吾尔自治区\": [87.633473, 43.799238],\n  \"新疆维吾尔自治区-乌鲁木齐市\": [87.62444, 43.830763],\n  \"新疆维吾尔自治区-乌鲁木齐市-天山区\": [87.638408, 43.800271],\n  \"新疆维吾尔自治区-乌鲁木齐市-沙依巴克区\": [87.60467, 43.807262],\n  \"新疆维吾尔自治区-乌鲁木齐市-新市区\": [87.575908, 43.861394],\n  \"新疆维吾尔自治区-乌鲁木齐市-水磨沟区\": [87.575908, 43.861394],\n  \"新疆维吾尔自治区-乌鲁木齐市-头屯河区\": [87.434507, 43.882653],\n  \"新疆维吾尔自治区-乌鲁木齐市-达坂城区\": [88.317398, 43.369943],\n  \"新疆维吾尔自治区-乌鲁木齐市-米东区\": [87.662134, 43.979247],\n  \"新疆维吾尔自治区-乌鲁木齐市-乌鲁木齐县\": [87.416029, 43.477086],\n  \"新疆维吾尔自治区-克拉玛依市\": [84.895901, 45.585675],\n  \"新疆维吾尔自治区-克拉玛依市-独山子区\": [84.893613, 44.334407],\n  \"新疆维吾尔自治区-克拉玛依市-克拉玛依区\": [84.866222, 45.596624],\n  \"新疆维吾尔自治区-克拉玛依市-白碱滩区\": [85.13951, 45.693952],\n  \"新疆维吾尔自治区-克拉玛依市-乌尔禾区\": [85.700305, 46.095295],\n  \"新疆维吾尔自治区-吐鲁番市\": [89.192459, 42.948549],\n  \"新疆维吾尔自治区-吐鲁番市-高昌区\": [89.192459, 42.948549],\n  \"新疆维吾尔自治区-吐鲁番市-鄯善县\": [90.220094, 42.874759],\n  \"新疆维吾尔自治区-吐鲁番市-托克逊县\": [88.660164, 42.798546],\n  \"新疆维吾尔自治区-哈密市\": [93.521308, 42.832856],\n  \"新疆维吾尔自治区-哈密市-伊州区\": [93.519883, 42.825878],\n  \"新疆维吾尔自治区-哈密市-巴里坤哈萨克自治县\": [93.022931, 43.605689],\n  \"新疆维吾尔自治区-哈密市-伊吾县\": [94.703826, 43.260677],\n  \"新疆维吾尔自治区-昌吉回族自治州\": [87.315002, 44.016854],\n  \"新疆维吾尔自治区-昌吉回族自治州-昌吉市\": [87.273865, 44.020127],\n  \"新疆维吾尔自治区-昌吉回族自治州-阜康市\": [87.273865, 44.020127],\n  \"新疆维吾尔自治区-昌吉回族自治州-呼图壁县\": [86.905144, 44.197655],\n  \"新疆维吾尔自治区-昌吉回族自治州-玛纳斯县\": [86.220643, 44.310063],\n  \"新疆维吾尔自治区-昌吉回族自治州-奇台县\": [89.601081, 44.026898],\n  \"新疆维吾尔自治区-昌吉回族自治州-吉木萨尔县\": [89.187123, 44.005718],\n  \"新疆维吾尔自治区-昌吉回族自治州-木垒哈萨克自治县\": [90.292515, 43.840308],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州\": [82.072915, 44.912196],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-博乐市\": [82.057972, 44.86001],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-阿拉山口市\": [82.057972, 44.86001],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-精河县\": [82.900655, 44.606646],\n  \"新疆维吾尔自治区-博尔塔拉蒙古自治州-温泉县\": [81.031146, 44.974857],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州\": [86.151714, 41.770287],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-库尔勒市\": [86.181494, 41.732373],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-轮台县\": [86.181494, 41.732373],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-尉犁县\": [86.266037, 41.350123],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-若羌县\": [88.175324, 39.028991],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-且末县\": [85.53599, 38.151388],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-焉耆回族自治县\": [86.581222, 42.064851],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-和静县\": [86.390398, 42.329365],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-和硕县\": [86.883689, 42.288065],\n  \"新疆维吾尔自治区-巴音郭楞蒙古自治州-博湖县\": [86.638469, 41.98643],\n  \"新疆维吾尔自治区-阿克苏地区\": [80.266943, 41.17503],\n  \"新疆维吾尔自治区-阿克苏地区-阿克苏市\": [80.269927, 41.17386],\n  \"新疆维吾尔自治区-阿克苏地区-温宿县\": [80.245564, 41.282567],\n  \"新疆维吾尔自治区-阿克苏地区-库车县\": [82.968459, 41.723448],\n  \"新疆维吾尔自治区-阿克苏地区-沙雅县\": [82.788824, 41.227749],\n  \"新疆维吾尔自治区-阿克苏地区-新和县\": [82.615823, 41.554],\n  \"新疆维吾尔自治区-阿克苏地区-拜城县\": [81.858516, 41.800707],\n  \"新疆维吾尔自治区-阿克苏地区-乌什县\": [79.230869, 41.220871],\n  \"新疆维吾尔自治区-阿克苏地区-阿瓦提县\": [80.381849, 40.649359],\n  \"新疆维吾尔自治区-阿克苏地区-柯坪县\": [79.053214, 40.514055],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州\": [76.174309, 39.720471],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿图什市\": [76.174906, 39.722079],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿克陶县\": [75.953725, 39.153889],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿合奇县\": [75.953725, 39.153889],\n  \"新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-乌恰县\": [75.265334, 39.725124],\n  \"新疆维吾尔自治区-喀什地区\": [75.996391, 39.476097],\n  \"新疆维吾尔自治区-喀什地区-喀什市\": [76.000313, 39.47365],\n  \"新疆维吾尔自治区-喀什地区-疏附县\": [75.869169, 39.381292],\n  \"新疆维吾尔自治区-喀什地区-疏勒县\": [76.056614, 39.406709],\n  \"新疆维吾尔自治区-喀什地区-英吉沙县\": [76.182075, 38.935671],\n  \"新疆维吾尔自治区-喀什地区-泽普县\": [77.266559, 38.190725],\n  \"新疆维吾尔自治区-喀什地区-莎车县\": [77.252437, 38.420157],\n  \"新疆维吾尔自治区-喀什地区-叶城县\": [77.420098, 37.889167],\n  \"新疆维吾尔自治区-喀什地区-麦盖提县\": [77.658824, 38.911194],\n  \"新疆维吾尔自治区-喀什地区-岳普湖县\": [76.784148, 39.239387],\n  \"新疆维吾尔自治区-喀什地区-伽师县\": [76.730386, 39.493852],\n  \"新疆维吾尔自治区-喀什地区-巴楚县\": [78.555701, 39.790788],\n  \"新疆维吾尔自治区-喀什地区-塔什库尔干塔吉克自治县\": [75.230805, 37.779046],\n  \"新疆维吾尔自治区-和田地区\": [79.928507, 37.120446],\n  \"新疆维吾尔自治区-和田地区-和田市\": [79.920212, 37.118336],\n  \"新疆维吾尔自治区-和田地区-和田县\": [79.866216, 37.090362],\n  \"新疆维吾尔自治区-和田地区-墨玉县\": [79.735479, 37.282993],\n  \"新疆维吾尔自治区-和田地区-皮山县\": [78.289871, 37.627249],\n  \"新疆维吾尔自治区-和田地区-洛浦县\": [80.195388, 37.079611],\n  \"新疆维吾尔自治区-和田地区-策勒县\": [80.813201, 37.004122],\n  \"新疆维吾尔自治区-和田地区-于田县\": [81.683783, 36.862954],\n  \"新疆维吾尔自治区-和田地区-民丰县\": [82.702713, 37.070257],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州\": [81.330538, 43.922723],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-伊宁市\": [81.284242, 43.915299],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-奎屯市\": [84.909449, 44.432057],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-霍尔果斯市\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-伊宁县\": [81.533906, 43.982909],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-察布查尔锡伯自治县\": [81.157925, 43.84669],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-霍城县\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-巩留县\": [80.885281, 44.06225],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-新源县\": [83.267022, 43.435927],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-昭苏县\": [81.137378, 43.163497],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-特克斯县\": [81.842587, 43.224248],\n  \"新疆维吾尔自治区-伊犁哈萨克自治州-尼勒克县\": [82.518007, 43.804595],\n  \"新疆维吾尔自治区-塔城地区\": [82.987236, 46.750948],\n  \"新疆维吾尔自治区-塔城地区-塔城市\": [82.985532, 46.754347],\n  \"新疆维吾尔自治区-塔城地区-乌苏市\": [84.720088, 44.424048],\n  \"新疆维吾尔自治区-塔城地区-额敏县\": [83.633374, 46.531885],\n  \"新疆维吾尔自治区-塔城地区-沙湾县\": [85.626145, 44.331949],\n  \"新疆维吾尔自治区-塔城地区-托里县\": [83.612909, 45.942743],\n  \"新疆维吾尔自治区-塔城地区-裕民县\": [82.989439, 46.207454],\n  \"新疆维吾尔自治区-塔城地区-和布克赛尔蒙古自治县\": [85.735009, 46.798685],\n  \"新疆维吾尔自治区-阿勒泰地区\": [88.147926, 47.850728],\n  \"新疆维吾尔自治区-阿勒泰地区-阿勒泰市\": [88.139227, 47.832753],\n  \"新疆维吾尔自治区-阿勒泰地区-布尔津县\": [86.88136, 47.707952],\n  \"新疆维吾尔自治区-阿勒泰地区-富蕴县\": [89.531953, 46.999951],\n  \"新疆维吾尔自治区-阿勒泰地区-福海县\": [87.493157, 47.118141],\n  \"新疆维吾尔自治区-阿勒泰地区-哈巴河县\": [86.424818, 48.066149],\n  \"新疆维吾尔自治区-阿勒泰地区-青河县\": [90.389444, 46.680194],\n  \"新疆维吾尔自治区-阿勒泰地区-吉木乃县\": [85.880818, 47.449018],\n  \"新疆维吾尔自治区-石河子市\": [86.086886, 44.311976],\n  \"新疆维吾尔自治区-阿拉尔市\": [81.287354, 40.553264],\n  \"新疆维吾尔自治区-图木舒克市\": [79.075616, 39.871209],\n  \"新疆维吾尔自治区-五家渠市\": [87.549937, 44.172445],\n  \"新疆维吾尔自治区-铁门关市\": [86.181494, 41.732373],\n  \"香港特别行政区\": [114.173825, 22.337784],\n  \"香港特别行政区-中西區\": [114.159491, 22.291343],\n  \"香港特别行政区-灣仔區\": [114.18355, 22.283159],\n  \"香港特别行政区-東區\": [114.235426, 22.287684],\n  \"香港特别行政区-南區\": [114.165543, 22.251947],\n  \"香港特别行政区-油尖旺區\": [114.178545, 22.306584],\n  \"香港特别行政区-深水埗區\": [114.181574, 22.345029],\n  \"香港特别行政区-九龍城區\": [114.198554, 22.325723],\n  \"香港特别行政区-黃大仙區\": [114.205553, 22.344517],\n  \"香港特别行政区-觀塘區\": [114.237431, 22.316804],\n  \"香港特别行政区-荃灣區\": [114.126441, 22.378244],\n  \"香港特别行政区-屯門區\": [113.987456, 22.393585],\n  \"香港特别行政区-元朗區\": [114.03851, 22.448565],\n  \"香港特别行政区-北區\": [114.149484, 22.498024],\n  \"香港特别行政区-大埔區\": [114.175565, 22.453814],\n  \"香港特别行政区-西貢區\": [114.283525, 22.385077],\n  \"香港特别行政区-沙田區\": [114.198551, 22.388522],\n  \"香港特别行政区-葵青區\": [114.143475, 22.366619],\n  \"香港特别行政区-離島區\": [113.951547, 22.286066],\n  \"澳门特别行政区\": [113.560161, 22.214787],\n  \"澳门特别行政区-花地瑪堂區\": [113.55751, 22.212784],\n  \"澳门特别行政区-花王堂區\": [113.550294, 22.202058],\n  \"澳门特别行政区-望德堂區\": [113.561514, 22.202511],\n  \"澳门特别行政区-大堂區\": [113.561167, 22.192801],\n  \"澳门特别行政区-風順堂區\": [113.545451, 22.192783],\n  \"澳门特别行政区-嘉模堂區\": [113.565515, 22.163142],\n  \"澳门特别行政区-路氹填海區\": [113.570544, 22.146272],\n  \"台湾省\": [86.181494, 41.732373],\n  \"台湾省-台北市 \": [121.539414, 25.073653],\n  \"台湾省-高雄市\": [120.315994, 22.679904],\n  \"曾母暗沙\": [111.79862, 4.008237]\n}\n```\n","slug":"中国城市坐标-包含市辖区","published":1,"updated":"2022-04-07T17:25:27.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1d0011y4w1ccg5glpy","content":"<p>================</p>\n<span id=\"more\"></span>\n\n<p>原文地址：<a href=\"https://www.cnblogs.com/henuyuxiang/p/12981201.html\">https://www.cnblogs.com/henuyuxiang/p/12981201.html</a></p>\n<pre><code class=\"json\">&#123;\n  &quot;全国&quot;: [116.413384, 39.910925],\n  &quot;北京市&quot;: [116.413384, 39.910925],\n  &quot;北京市-市辖区&quot;: [116.413384, 39.910925],\n  &quot;北京市-市辖区-东城区&quot;: [116.422401, 39.934827],\n  &quot;北京市-市辖区-西城区&quot;: [116.372514, 39.918124],\n  &quot;北京市-市辖区-朝阳区&quot;: [116.449559, 39.926375],\n  &quot;北京市-市辖区-丰台区&quot;: [116.292402, 39.864937],\n  &quot;北京市-市辖区-石景山区&quot;: [116.229613, 39.911354],\n  &quot;北京市-市辖区-海淀区&quot;: [116.305434, 39.96549],\n  &quot;北京市-市辖区-门头沟区&quot;: [116.107604, 39.946147],\n  &quot;北京市-市辖区-房山区&quot;: [116.149444, 39.754326],\n  &quot;北京市-市辖区-通州区&quot;: [116.663415, 39.916017],\n  &quot;北京市-市辖区-顺义区&quot;: [116.661424, 40.136351],\n  &quot;北京市-市辖区-昌平区&quot;: [116.237618, 40.226413],\n  &quot;北京市-市辖区-大兴区&quot;: [116.348625, 39.732555],\n  &quot;北京市-市辖区-怀柔区&quot;: [116.638386, 40.322618],\n  &quot;北京市-市辖区-平谷区&quot;: [117.127379, 40.146951],\n  &quot;北京市-市辖区-密云区&quot;: [116.849547, 40.382176],\n  &quot;北京市-市辖区-延庆区&quot;: [115.981632, 40.462169],\n  &quot;天津市&quot;: [117.209523, 39.093668],\n  &quot;天津市-市辖区&quot;: [117.209523, 39.093668],\n  &quot;天津市-市辖区-和平区&quot;: [117.221467, 39.12339],\n  &quot;天津市-市辖区-河东区&quot;: [117.258413, 39.134487],\n  &quot;天津市-市辖区-河西区&quot;: [117.229416, 39.115718],\n  &quot;天津市-市辖区-南开区&quot;: [117.156515, 39.144105],\n  &quot;天津市-市辖区-河北区&quot;: [117.203593, 39.153485],\n  &quot;天津市-市辖区-红桥区&quot;: [117.157518, 39.173286],\n  &quot;天津市-市辖区-东丽区&quot;: [117.320569, 39.092332],\n  &quot;天津市-市辖区-西青区&quot;: [117.01441, 39.148727],\n  &quot;天津市-市辖区-津南区&quot;: [117.363387, 38.944148],\n  &quot;天津市-市辖区-北辰区&quot;: [117.141403, 39.230344],\n  &quot;天津市-市辖区-武清区&quot;: [117.050597, 39.389871],\n  &quot;天津市-市辖区-宝坻区&quot;: [117.316601, 39.723194],\n  &quot;天津市-市辖区-滨海新区&quot;: [117.717399, 39.009416],\n  &quot;天津市-市辖区-宁河区&quot;: [117.832393, 39.336956],\n  &quot;天津市-市辖区-静海区&quot;: [116.980469, 38.953371],\n  &quot;天津市-市辖区-蓟州区&quot;: [117.414579, 40.051509],\n  &quot;河北省&quot;: [114.536596, 38.043202],\n  &quot;河北省-石家庄市&quot;: [114.521532, 38.048312],\n  &quot;河北省-石家庄市-长安区&quot;: [114.545612, 38.043256],\n  &quot;河北省-石家庄市-桥西区&quot;: [114.46742, 38.010381],\n  &quot;河北省-石家庄市-新华区&quot;: [114.469438, 38.05712],\n  &quot;河北省-石家庄市-井陉矿区&quot;: [114.068632, 38.070566],\n  &quot;河北省-石家庄市-裕华区&quot;: [114.537583, 38.012088],\n  &quot;河北省-石家庄市-藁城区&quot;: [114.853378, 38.027817],\n  &quot;河北省-石家庄市-鹿泉区&quot;: [114.320598, 38.091749],\n  &quot;河北省-石家庄市-栾城区&quot;: [114.654576, 37.905816],\n  &quot;河北省-石家庄市-井陉县&quot;: [114.151463, 38.038386],\n  &quot;河北省-石家庄市-正定县&quot;: [114.577481, 38.151714],\n  &quot;河北省-石家庄市-行唐县&quot;: [114.559607, 38.444239],\n  &quot;河北省-石家庄市-灵寿县&quot;: [114.389478, 38.314629],\n  &quot;河北省-石家庄市-高邑县&quot;: [114.618413, 37.62188],\n  &quot;河北省-石家庄市-深泽县&quot;: [115.207404, 38.190451],\n  &quot;河北省-石家庄市-赞皇县&quot;: [114.392464, 37.671667],\n  &quot;河北省-石家庄市-无极县&quot;: [114.982439, 38.185436],\n  &quot;河北省-石家庄市-平山县&quot;: [113.985435, 38.271951],\n  &quot;河北省-石家庄市-元氏县&quot;: [114.532566, 37.772339],\n  &quot;河北省-石家庄市-赵县&quot;: [114.782597, 37.761859],\n  &quot;河北省-石家庄市-晋州市&quot;: [115.050529, 38.039491],\n  &quot;河北省-石家庄市-新乐市&quot;: [114.690532, 38.349293],\n  &quot;河北省-唐山市&quot;: [118.186459, 39.636584],\n  &quot;河北省-唐山市-路南区&quot;: [118.160607, 39.631043],\n  &quot;河北省-唐山市-路北区&quot;: [118.206399, 39.630661],\n  &quot;河北省-唐山市-古冶区&quot;: [118.453401, 39.739736],\n  &quot;河北省-唐山市-开平区&quot;: [118.268608, 39.677144],\n  &quot;河北省-唐山市-丰南区&quot;: [118.090366, 39.58154],\n  &quot;河北省-唐山市-丰润区&quot;: [118.168541, 39.838353],\n  &quot;河北省-唐山市-曹妃甸区&quot;: [118.46646, 39.279284],\n  &quot;河北省-唐山市-滦县&quot;: [118.71048, 39.747116],\n  &quot;河北省-唐山市-滦南县&quot;: [118.680405, 39.510045],\n  &quot;河北省-唐山市-乐亭县&quot;: [118.919384, 39.431931],\n  &quot;河北省-唐山市-迁西县&quot;: [118.320384, 40.147837],\n  &quot;河北省-唐山市-玉田县&quot;: [117.745434, 39.906592],\n  &quot;河北省-唐山市-遵化市&quot;: [117.972375, 40.195533],\n  &quot;河北省-唐山市-迁安市&quot;: [118.706457, 40.004184],\n  &quot;河北省-秦皇岛市&quot;: [119.608531, 39.941748],\n  &quot;河北省-秦皇岛市-海港区&quot;: [119.617475, 39.940413],\n  &quot;河北省-秦皇岛市-山海关区&quot;: [119.782435, 39.984446],\n  &quot;河北省-秦皇岛市-北戴河区&quot;: [119.491526, 39.841006],\n  &quot;河北省-秦皇岛市-抚宁区&quot;: [119.251549, 39.881414],\n  &quot;河北省-秦皇岛市-青龙满族自治县&quot;: [118.956481, 40.412794],\n  &quot;河北省-秦皇岛市-昌黎县&quot;: [119.169375, 39.719051],\n  &quot;河北省-秦皇岛市-卢龙县&quot;: [118.899489, 39.897958],\n  &quot;河北省-邯郸市&quot;: [114.545628, 36.631263],\n  &quot;河北省-邯郸市-邯山区&quot;: [114.496389, 36.586692],\n  &quot;河北省-邯郸市-丛台区&quot;: [114.499433, 36.642673],\n  &quot;河北省-邯郸市-复兴区&quot;: [114.479412, 36.623325],\n  &quot;河北省-邯郸市-峰峰矿区&quot;: [114.219483, 36.425654],\n  &quot;河北省-邯郸市-邯郸县&quot;: [114.537309, 36.599675],\n  &quot;河北省-邯郸市-临漳县&quot;: [114.626427, 36.340766],\n  &quot;河北省-邯郸市-成安县&quot;: [114.676577, 36.449796],\n  &quot;河北省-邯郸市-大名县&quot;: [115.154613, 36.291288],\n  &quot;河北省-邯郸市-涉县&quot;: [113.697584, 36.590692],\n  &quot;河北省-邯郸市-磁县&quot;: [114.380432, 36.380359],\n  &quot;河北省-邯郸市-肥乡县&quot;: [114.806547, 36.553825],\n  &quot;河北省-邯郸市-永年县&quot;: [114.550625, 36.747569],\n  &quot;河北省-邯郸市-邱县&quot;: [115.193395, 36.817362],\n  &quot;河北省-邯郸市-鸡泽县&quot;: [114.896586, 36.916398],\n  &quot;河北省-邯郸市-广平县&quot;: [114.954415, 36.48978],\n  &quot;河北省-邯郸市-馆陶县&quot;: [115.288537, 36.553957],\n  &quot;河北省-邯郸市-魏县&quot;: [114.94545, 36.366156],\n  &quot;河北省-邯郸市-曲周县&quot;: [114.963404, 36.771545],\n  &quot;河北省-邯郸市-武安市&quot;: [114.210516, 36.702488],\n  &quot;河北省-邢台市&quot;: [114.511462, 37.076686],\n  &quot;河北省-邢台市-桥东区&quot;: [114.513471, 37.07375],\n  &quot;河北省-邢台市-桥西区&quot;: [114.474393, 37.066172],\n  &quot;河北省-邢台市-邢台县&quot;: [114.143411, 37.177109],\n  &quot;河北省-邢台市-临城县&quot;: [114.505443, 37.450789],\n  &quot;河北省-邢台市-内丘县&quot;: [114.518493, 37.292858],\n  &quot;河北省-邢台市-柏乡县&quot;: [114.699497, 37.488759],\n  &quot;河北省-邢台市-隆尧县&quot;: [114.776616, 37.355908],\n  &quot;河北省-邢台市-任县&quot;: [114.678606, 37.126727],\n  &quot;河北省-邢台市-南和县&quot;: [114.690548, 37.010998],\n  &quot;河北省-邢台市-宁晋县&quot;: [114.925562, 37.625612],\n  &quot;河北省-邢台市-巨鹿县&quot;: [115.043587, 37.227088],\n  &quot;河北省-邢台市-新河县&quot;: [115.248547, 37.534591],\n  &quot;河北省-邢台市-广宗县&quot;: [115.149605, 37.080457],\n  &quot;河北省-邢台市-平乡县&quot;: [115.036582, 37.069096],\n  &quot;河北省-邢台市-威县&quot;: [115.273618, 36.981582],\n  &quot;河北省-邢台市-清河县&quot;: [115.674394, 37.046375],\n  &quot;河北省-邢台市-临西县&quot;: [115.507629, 36.87676],\n  &quot;河北省-邢台市-南宫市&quot;: [115.414529, 37.364069],\n  &quot;河北省-邢台市-沙河市&quot;: [114.509474, 36.861127],\n  &quot;河北省-保定市&quot;: [115.471464, 38.879988],\n  &quot;河北省-保定市-竞秀区&quot;: [115.465434, 38.883788],\n  &quot;河北省-保定市-莲池区&quot;: [115.535488, 38.860676],\n  &quot;河北省-保定市-满城区&quot;: [115.328375, 38.955441],\n  &quot;河北省-保定市-清苑区&quot;: [115.496606, 38.771002],\n  &quot;河北省-保定市-徐水区&quot;: [115.66248, 39.024713],\n  &quot;河北省-保定市-涞水县&quot;: [115.720543, 39.400334],\n  &quot;河北省-保定市-阜平县&quot;: [114.201563, 38.855351],\n  &quot;河北省-保定市-定兴县&quot;: [115.81441, 39.269424],\n  &quot;河北省-保定市-唐县&quot;: [114.989447, 38.75402],\n  &quot;河北省-保定市-高阳县&quot;: [115.785447, 38.706258],\n  &quot;河北省-保定市-容城县&quot;: [115.868631, 39.048559],\n  &quot;河北省-保定市-涞源县&quot;: [114.700476, 39.366272],\n  &quot;河北省-保定市-望都县&quot;: [115.161588, 38.700158],\n  &quot;河北省-保定市-安新县&quot;: [115.942426, 38.941734],\n  &quot;河北省-保定市-易县&quot;: [115.503607, 39.355054],\n  &quot;河北省-保定市-曲阳县&quot;: [114.751455, 38.628384],\n  &quot;河北省-保定市-蠡县&quot;: [115.590445, 38.494201],\n  &quot;河北省-保定市-顺平县&quot;: [115.141597, 38.843261],\n  &quot;河北省-保定市-博野县&quot;: [115.470467, 38.463408],\n  &quot;河北省-保定市-雄县&quot;: [116.114601, 39.00018],\n  &quot;河北省-保定市-涿州市&quot;: [115.98162, 39.491066],\n  &quot;河北省-保定市-安国市&quot;: [115.333408, 38.424828],\n  &quot;河北省-保定市-高碑店市&quot;: [115.880569, 39.332335],\n  &quot;河北省-张家口市&quot;: [114.892572, 40.773237],\n  &quot;河北省-张家口市-桥东区&quot;: [114.900606, 40.794268],\n  &quot;河北省-张家口市-桥西区&quot;: [114.876516, 40.825606],\n  &quot;河北省-张家口市-宣化区&quot;: [115.105444, 40.614592],\n  &quot;河北省-张家口市-下花园区&quot;: [115.293517, 40.508145],\n  &quot;河北省-张家口市-万全区&quot;: [114.747426, 40.77315],\n  &quot;河北省-张家口市-崇礼区&quot;: [115.289549, 40.980478],\n  &quot;河北省-张家口市-张北县&quot;: [114.726375, 41.164944],\n  &quot;河北省-张家口市-康保县&quot;: [114.606356, 41.858637],\n  &quot;河北省-张家口市-沽源县&quot;: [115.695407, 41.676016],\n  &quot;河北省-张家口市-尚义县&quot;: [113.975524, 41.081888],\n  &quot;河北省-张家口市-蔚县&quot;: [114.595401, 39.847089],\n  &quot;河北省-张家口市-阳原县&quot;: [114.157524, 40.109588],\n  &quot;河北省-张家口市-怀安县&quot;: [114.392469, 40.680369],\n  &quot;河北省-张家口市-怀来县&quot;: [115.524553, 40.42029],\n  &quot;河北省-张家口市-涿鹿县&quot;: [115.211383, 40.385834],\n  &quot;河北省-张家口市-赤城县&quot;: [115.838506, 40.918761],\n  &quot;河北省-承德市&quot;: [117.969398, 40.957856],\n  &quot;河北省-承德市-双桥区&quot;: [117.949428, 40.980824],\n  &quot;河北省-承德市-双滦区&quot;: [117.806578, 40.964729],\n  &quot;河北省-承德市-鹰手营子矿区&quot;: [117.665609, 40.552043],\n  &quot;河北省-承德市-承德县&quot;: [118.180456, 40.774367],\n  &quot;河北省-承德市-兴隆县&quot;: [117.507427, 40.423454],\n  &quot;河北省-承德市-平泉县&quot;: [118.707427, 41.023756],\n  &quot;河北省-承德市-滦平县&quot;: [117.339498, 40.947561],\n  &quot;河北省-承德市-隆化县&quot;: [117.745451, 41.319899],\n  &quot;河北省-承德市-丰宁满族自治县&quot;: [116.652393, 41.215336],\n  &quot;河北省-承德市-宽城满族自治县&quot;: [118.491594, 40.617152],\n  &quot;河北省-承德市-围场满族蒙古族自治县&quot;: [117.766564, 41.944324],\n  &quot;河北省-沧州市&quot;: [116.845581, 38.310215],\n  &quot;河北省-沧州市-新华区&quot;: [116.872433, 38.320367],\n  &quot;河北省-沧州市-运河区&quot;: [116.838612, 38.316523],\n  &quot;河北省-沧州市-沧县&quot;: [116.884398, 38.299453],\n  &quot;河北省-沧州市-青县&quot;: [116.810575, 38.588465],\n  &quot;河北省-沧州市-东光县&quot;: [116.54341, 37.894514],\n  &quot;河北省-沧州市-海兴县&quot;: [117.504418, 38.149402],\n  &quot;河北省-沧州市-盐山县&quot;: [117.237414, 38.064318],\n  &quot;河北省-沧州市-肃宁县&quot;: [115.836518, 38.428906],\n  &quot;河北省-沧州市-南皮县&quot;: [116.715601, 38.045188],\n  &quot;河北省-沧州市-吴桥县&quot;: [116.397392, 37.633909],\n  &quot;河北省-沧州市-献县&quot;: [116.12956, 38.195981],\n  &quot;河北省-沧州市-孟村回族自治县&quot;: [117.110436, 38.059839],\n  &quot;河北省-沧州市-泊头市&quot;: [116.584628, 38.089257],\n  &quot;河北省-沧州市-任丘市&quot;: [116.105605, 38.717349],\n  &quot;河北省-沧州市-黄骅市&quot;: [117.336481, 38.377494],\n  &quot;河北省-沧州市-河间市&quot;: [116.105628, 38.451357],\n  &quot;河北省-廊坊市&quot;: [116.690582, 39.543367],\n  &quot;河北省-廊坊市-安次区&quot;: [116.709633, 39.52616],\n  &quot;河北省-廊坊市-广阳区&quot;: [116.717614, 39.528611],\n  &quot;河北省-廊坊市-固安县&quot;: [116.30542, 39.444485],\n  &quot;河北省-廊坊市-永清县&quot;: [116.505429, 39.327853],\n  &quot;河北省-廊坊市-香河县&quot;: [117.012402, 39.767939],\n  &quot;河北省-廊坊市-大城县&quot;: [116.660409, 38.710859],\n  &quot;河北省-廊坊市-文安县&quot;: [116.464609, 38.87895],\n  &quot;河北省-廊坊市-大厂回族自治县&quot;: [116.996409, 39.892208],\n  &quot;河北省-廊坊市-霸州市&quot;: [116.398397, 39.130921],\n  &quot;河北省-廊坊市-三河市&quot;: [117.084588, 39.9881],\n  &quot;河北省-衡水市&quot;: [115.675406, 37.745191],\n  &quot;河北省-衡水市-桃城区&quot;: [115.681395, 37.741637],\n  &quot;河北省-衡水市-冀州区&quot;: [115.58543, 37.557086],\n  &quot;河北省-衡水市-枣强县&quot;: [115.730563, 37.519364],\n  &quot;河北省-衡水市-武邑县&quot;: [115.894514, 37.807764],\n  &quot;河北省-衡水市-武强县&quot;: [115.989614, 38.046857],\n  &quot;河北省-衡水市-饶阳县&quot;: [115.732572, 38.241038],\n  &quot;河北省-衡水市-安平县&quot;: [115.525549, 38.240507],\n  &quot;河北省-衡水市-故城县&quot;: [115.972602, 37.353348],\n  &quot;河北省-衡水市-景县&quot;: [116.277411, 37.698815],\n  &quot;河北省-衡水市-阜城县&quot;: [116.182422, 37.868732],\n  &quot;河北省-衡水市-深州市&quot;: [115.566369, 38.006941],\n  &quot;河北省-定州市&quot;: [114.996496, 38.522199],\n  &quot;河北省-辛集市&quot;: [115.224451, 37.949309],\n  &quot;山西省&quot;: [112.569376, 37.879829],\n  &quot;山西省-太原市&quot;: [112.556391, 37.876989],\n  &quot;山西省-太原市-小店区&quot;: [112.572396, 37.742323],\n  &quot;山西省-太原市-迎泽区&quot;: [112.569385, 37.869532],\n  &quot;山西省-太原市-杏花岭区&quot;: [112.576383, 37.900186],\n  &quot;山西省-太原市-尖草坪区&quot;: [112.493605, 37.945943],\n  &quot;山西省-太原市-万柏林区&quot;: [112.522577, 37.864974],\n  &quot;山西省-太原市-晋源区&quot;: [112.484564, 37.721169],\n  &quot;山西省-太原市-清徐县&quot;: [112.364558, 37.613067],\n  &quot;山西省-太原市-阳曲县&quot;: [112.679409, 38.064621],\n  &quot;山西省-太原市-娄烦县&quot;: [111.803591, 38.073195],\n  &quot;山西省-太原市-古交市&quot;: [112.182453, 37.913],\n  &quot;山西省-大同市&quot;: [113.306436, 40.082469],\n  &quot;山西省-大同市-城区&quot;: [113.304425, 40.081998],\n  &quot;山西省-大同市-矿区&quot;: [113.162402, 39.996839],\n  &quot;山西省-大同市-南郊区&quot;: [113.162402, 39.996839],\n  &quot;山西省-大同市-新荣区&quot;: [113.146444, 40.261971],\n  &quot;山西省-大同市-阳高县&quot;: [113.755414, 40.367392],\n  &quot;山西省-大同市-天镇县&quot;: [114.097478, 40.426412],\n  &quot;山西省-大同市-广灵县&quot;: [114.288586, 39.766004],\n  &quot;山西省-大同市-灵丘县&quot;: [114.241368, 39.448825],\n  &quot;山西省-大同市-浑源县&quot;: [113.7056, 39.698953],\n  &quot;山西省-大同市-左云县&quot;: [112.709463, 40.019623],\n  &quot;山西省-大同市-大同县&quot;: [113.618471, 40.04623],\n  &quot;山西省-阳泉市&quot;: [113.587617, 37.862361],\n  &quot;山西省-阳泉市-城区&quot;: [113.606568, 37.853433],\n  &quot;山西省-阳泉市-矿区&quot;: [113.561521, 37.874409],\n  &quot;山西省-阳泉市-郊区&quot;: [113.600603, 37.950353],\n  &quot;山西省-阳泉市-平定县&quot;: [113.664421, 37.792796],\n  &quot;山西省-阳泉市-盂县&quot;: [113.41842, 38.09198],\n  &quot;山西省-长治市&quot;: [113.122559, 36.201268],\n  &quot;山西省-长治市-城区&quot;: [113.129521, 36.209472],\n  &quot;山西省-长治市-郊区&quot;: [113.105622, 36.261066],\n  &quot;山西省-长治市-长治县&quot;: [113.057416, 36.059286],\n  &quot;山西省-长治市-襄垣县&quot;: [113.057413, 36.541686],\n  &quot;山西省-长治市-屯留县&quot;: [112.898475, 36.321631],\n  &quot;山西省-长治市-平顺县&quot;: [113.442517, 36.205989],\n  &quot;山西省-长治市-黎城县&quot;: [113.393432, 36.50867],\n  &quot;山西省-长治市-壶关县&quot;: [113.21358, 36.121335],\n  &quot;山西省-长治市-长子县&quot;: [112.884566, 36.128002],\n  &quot;山西省-长治市-武乡县&quot;: [112.870606, 36.843168],\n  &quot;山西省-长治市-沁县&quot;: [112.705458, 36.76219],\n  &quot;山西省-长治市-沁源县&quot;: [112.344452, 36.506103],\n  &quot;山西省-长治市-潞城市&quot;: [113.235578, 36.339691],\n  &quot;山西省-晋城市&quot;: [112.858578, 35.496285],\n  &quot;山西省-晋城市-城区&quot;: [112.855303, 35.520559],\n  &quot;山西省-晋城市-沁水县&quot;: [112.193426, 35.696364],\n  &quot;山西省-晋城市-阳城县&quot;: [112.421454, 35.492181],\n  &quot;山西省-晋城市-陵川县&quot;: [113.287407, 35.781744],\n  &quot;山西省-晋城市-泽州县&quot;: [112.794401, 35.59977],\n  &quot;山西省-晋城市-高平市&quot;: [112.930412, 35.804337],\n  &quot;山西省-朔州市&quot;: [112.439371, 39.337108],\n  &quot;山西省-朔州市-朔城区&quot;: [112.438376, 39.325303],\n  &quot;山西省-朔州市-平鲁区&quot;: [112.295525, 39.517389],\n  &quot;山西省-朔州市-山阴县&quot;: [112.822432, 39.53403],\n  &quot;山西省-朔州市-应县&quot;: [113.197494, 39.560078],\n  &quot;山西省-朔州市-右玉县&quot;: [112.4735, 39.99486],\n  &quot;山西省-朔州市-怀仁县&quot;: [113.106608, 39.833757],\n  &quot;山西省-晋中市&quot;: [112.759595, 37.692839],\n  &quot;山西省-晋中市-榆次区&quot;: [112.714504, 37.70394],\n  &quot;山西省-晋中市-榆社县&quot;: [112.981599, 37.07637],\n  &quot;山西省-晋中市-左权县&quot;: [113.385452, 37.088555],\n  &quot;山西省-晋中市-和顺县&quot;: [113.576606, 37.334808],\n  &quot;山西省-晋中市-昔阳县&quot;: [113.713613, 37.617884],\n  &quot;山西省-晋中市-寿阳县&quot;: [113.18341, 37.901308],\n  &quot;山西省-晋中市-太谷县&quot;: [112.557384, 37.427396],\n  &quot;山西省-晋中市-祁县&quot;: [112.342442, 37.364131],\n  &quot;山西省-晋中市-平遥县&quot;: [112.182456, 37.195601],\n  &quot;山西省-晋中市-灵石县&quot;: [111.785618, 36.853368],\n  &quot;山西省-晋中市-介休市&quot;: [111.923563, 37.032686],\n  &quot;山西省-运城市&quot;: [111.013389, 35.032707],\n  &quot;山西省-运城市-盐湖区&quot;: [111.004377, 35.021425],\n  &quot;山西省-运城市-临猗县&quot;: [110.780407, 35.149542],\n  &quot;山西省-运城市-万荣县&quot;: [110.844576, 35.421109],\n  &quot;山西省-运城市-闻喜县&quot;: [111.23141, 35.362931],\n  &quot;山西省-运城市-稷山县&quot;: [110.989415, 35.610403],\n  &quot;山西省-运城市-新绛县&quot;: [111.231406, 35.62263],\n  &quot;山西省-运城市-绛县&quot;: [111.575487, 35.497276],\n  &quot;山西省-运城市-垣曲县&quot;: [111.676607, 35.303015],\n  &quot;山西省-运城市-夏县&quot;: [111.226431, 35.147462],\n  &quot;山西省-运城市-平陆县&quot;: [111.22348, 34.842925],\n  &quot;山西省-运城市-芮城县&quot;: [110.700612, 34.699388],\n  &quot;山西省-运城市-永济市&quot;: [110.454578, 34.87283],\n  &quot;山西省-运城市-河津市&quot;: [110.718572, 35.601927],\n  &quot;山西省-忻州市&quot;: [112.740624, 38.422383],\n  &quot;山西省-忻州市-忻府区&quot;: [112.752614, 38.40988],\n  &quot;山西省-忻州市-定襄县&quot;: [112.963529, 38.479974],\n  &quot;山西省-忻州市-五台县&quot;: [113.261451, 38.734182],\n  &quot;山西省-忻州市-代县&quot;: [112.966552, 39.072728],\n  &quot;山西省-忻州市-繁峙县&quot;: [113.271408, 39.195237],\n  &quot;山西省-忻州市-宁武县&quot;: [112.326398, 39.024342],\n  &quot;山西省-忻州市-静乐县&quot;: [111.945432, 38.365147],\n  &quot;山西省-忻州市-神池县&quot;: [112.217383, 39.096876],\n  &quot;山西省-忻州市-五寨县&quot;: [111.85341, 38.91702],\n  &quot;山西省-忻州市-岢岚县&quot;: [111.579478, 38.710151],\n  &quot;山西省-忻州市-河曲县&quot;: [111.144449, 39.390702],\n  &quot;山西省-忻州市-保德县&quot;: [111.092542, 39.028337],\n  &quot;山西省-忻州市-偏关县&quot;: [111.514474, 39.44223],\n  &quot;山西省-忻州市-原平市&quot;: [112.717487, 38.736476],\n  &quot;山西省-临汾市&quot;: [111.52553, 36.093742],\n  &quot;山西省-临汾市-尧都区&quot;: [111.58643, 36.084562],\n  &quot;山西省-临汾市-曲沃县&quot;: [111.482396, 35.647327],\n  &quot;山西省-临汾市-翼城县&quot;: [111.725376, 35.744429],\n  &quot;山西省-临汾市-襄汾县&quot;: [111.44854, 35.882063],\n  &quot;山西省-临汾市-洪洞县&quot;: [111.681589, 36.259467],\n  &quot;山西省-临汾市-古县&quot;: [111.926573, 36.272338],\n  &quot;山西省-临汾市-安泽县&quot;: [112.256613, 36.153514],\n  &quot;山西省-临汾市-浮山县&quot;: [111.855385, 35.974393],\n  &quot;山西省-临汾市-吉县&quot;: [110.688546, 36.103999],\n  &quot;山西省-临汾市-乡宁县&quot;: [110.853498, 35.976442],\n  &quot;山西省-临汾市-大宁县&quot;: [110.759384, 36.471306],\n  &quot;山西省-临汾市-隰县&quot;: [110.947591, 36.699061],\n  &quot;山西省-临汾市-永和县&quot;: [110.638416, 36.765909],\n  &quot;山西省-临汾市-蒲县&quot;: [111.102474, 36.418005],\n  &quot;山西省-临汾市-汾西县&quot;: [111.569546, 36.658782],\n  &quot;山西省-临汾市-侯马市&quot;: [111.378397, 35.625365],\n  &quot;山西省-临汾市-霍州市&quot;: [111.761509, 36.574607],\n  &quot;山西省-吕梁市&quot;: [111.15045, 37.524498],\n  &quot;山西省-吕梁市-离石区&quot;: [111.157491, 37.523577],\n  &quot;山西省-吕梁市-文水县&quot;: [112.035599, 37.4443],\n  &quot;山西省-吕梁市-交城县&quot;: [112.162568, 37.557772],\n  &quot;山西省-吕梁市-兴县&quot;: [111.134392, 38.468804],\n  &quot;山西省-吕梁市-临县&quot;: [110.998415, 37.957211],\n  &quot;山西省-吕梁市-柳林县&quot;: [110.89539, 37.435493],\n  &quot;山西省-吕梁市-石楼县&quot;: [110.841596, 37.004471],\n  &quot;山西省-吕梁市-岚县&quot;: [111.678592, 38.285029],\n  &quot;山西省-吕梁市-方山县&quot;: [111.25037, 37.90102],\n  &quot;山西省-吕梁市-中阳县&quot;: [111.18563, 37.362873],\n  &quot;山西省-吕梁市-交口县&quot;: [111.187628, 36.987873],\n  &quot;山西省-吕梁市-孝义市&quot;: [111.785606, 37.151063],\n  &quot;山西省-吕梁市-汾阳市&quot;: [111.794597, 37.271292],\n  &quot;内蒙古自治区&quot;: [111.772606, 40.823156],\n  &quot;内蒙古自治区-呼和浩特市&quot;: [111.755509, 40.848423],\n  &quot;内蒙古自治区-呼和浩特市-新城区&quot;: [111.67162, 40.863877],\n  &quot;内蒙古自治区-呼和浩特市-回民区&quot;: [111.63047, 40.814506],\n  &quot;内蒙古自治区-呼和浩特市-玉泉区&quot;: [111.681575, 40.758059],\n  &quot;内蒙古自治区-呼和浩特市-赛罕区&quot;: [111.708421, 40.798394],\n  &quot;内蒙古自治区-呼和浩特市-土默特左旗&quot;: [111.169587, 40.735294],\n  &quot;内蒙古自治区-呼和浩特市-托克托县&quot;: [111.200575, 40.283147],\n  &quot;内蒙古自治区-呼和浩特市-和林格尔县&quot;: [111.82843, 40.384798],\n  &quot;内蒙古自治区-呼和浩特市-清水河县&quot;: [111.653576, 39.926334],\n  &quot;内蒙古自治区-呼和浩特市-武川县&quot;: [111.457497, 41.102419],\n  &quot;内蒙古自治区-包头市&quot;: [109.846544, 40.662929],\n  &quot;内蒙古自治区-包头市-东河区&quot;: [110.050395, 40.582228],\n  &quot;内蒙古自治区-包头市-昆都仑区&quot;: [109.845538, 40.647644],\n  &quot;内蒙古自治区-包头市-青山区&quot;: [109.907416, 40.649473],\n  &quot;内蒙古自治区-包头市-石拐区&quot;: [110.278381, 40.678299],\n  &quot;内蒙古自治区-包头市-白云鄂博矿区&quot;: [109.979626, 41.774995],\n  &quot;内蒙古自治区-包头市-九原区&quot;: [109.969588, 40.613397],\n  &quot;内蒙古自治区-包头市-土默特右旗&quot;: [110.530389, 40.575127],\n  &quot;内蒙古自治区-包头市-固阳县&quot;: [110.066433, 41.040163],\n  &quot;内蒙古自治区-包头市-达尔罕茂明安联合旗&quot;: [110.439521, 41.704549],\n  &quot;内蒙古自治区-乌海市&quot;: [106.800391, 39.662006],\n  &quot;内蒙古自治区-乌海市-海勃湾区&quot;: [106.829439, 39.696908],\n  &quot;内蒙古自治区-乌海市-海南区&quot;: [106.898471, 39.446828],\n  &quot;内蒙古自治区-乌海市-乌达区&quot;: [106.732606, 39.511469],\n  &quot;内蒙古自治区-赤峰市&quot;: [118.89552, 42.261686],\n  &quot;内蒙古自治区-赤峰市-红山区&quot;: [118.963564, 42.270478],\n  &quot;内蒙古自治区-赤峰市-元宝山区&quot;: [119.295405, 42.045125],\n  &quot;内蒙古自治区-赤峰市-松山区&quot;: [118.939414, 42.292482],\n  &quot;内蒙古自治区-赤峰市-阿鲁科尔沁旗&quot;: [120.072614, 43.877953],\n  &quot;内蒙古自治区-赤峰市-巴林左旗&quot;: [119.386443, 43.976383],\n  &quot;内蒙古自治区-赤峰市-巴林右旗&quot;: [118.670394, 43.540132],\n  &quot;内蒙古自治区-赤峰市-林西县&quot;: [118.062461, 43.62421],\n  &quot;内蒙古自治区-赤峰市-克什克腾旗&quot;: [117.55162, 43.270758],\n  &quot;内蒙古自治区-赤峰市-翁牛特旗&quot;: [119.012509, 42.942019],\n  &quot;内蒙古自治区-赤峰市-喀喇沁旗&quot;: [118.710474, 41.932214],\n  &quot;内蒙古自治区-赤峰市-宁城县&quot;: [119.350609, 41.600245],\n  &quot;内蒙古自治区-赤峰市-敖汉旗&quot;: [119.927578, 42.296507],\n  &quot;内蒙古自治区-通辽市&quot;: [122.250522, 43.65798],\n  &quot;内蒙古自治区-通辽市-科尔沁区&quot;: [122.262457, 43.628712],\n  &quot;内蒙古自治区-通辽市-科尔沁左翼中旗&quot;: [123.318589, 44.132294],\n  &quot;内蒙古自治区-通辽市-科尔沁左翼后旗&quot;: [122.363563, 42.939562],\n  &quot;内蒙古自治区-通辽市-开鲁县&quot;: [121.325386, 43.606369],\n  &quot;内蒙古自治区-通辽市-库伦旗&quot;: [121.817406, 42.741211],\n  &quot;内蒙古自治区-通辽市-奈曼旗&quot;: [120.664646, 42.871846],\n  &quot;内蒙古自治区-通辽市-扎鲁特旗&quot;: [120.918626, 44.562213],\n  &quot;内蒙古自治区-通辽市-霍林郭勒市&quot;: [119.670466, 45.537513],\n  &quot;内蒙古自治区-鄂尔多斯市&quot;: [109.787443, 39.614482],\n  &quot;内蒙古自治区-鄂尔多斯市-东胜区&quot;: [109.96956, 39.827987],\n  &quot;内蒙古自治区-鄂尔多斯市-康巴什区&quot;: [109.869627, 39.616378],\n  &quot;内蒙古自治区-鄂尔多斯市-达拉特旗&quot;: [110.040366, 40.418907],\n  &quot;内蒙古自治区-鄂尔多斯市-准格尔旗&quot;: [111.246398, 39.87054],\n  &quot;内蒙古自治区-鄂尔多斯市-鄂托克前旗&quot;: [107.484585, 38.188217],\n  &quot;内蒙古自治区-鄂尔多斯市-鄂托克旗&quot;: [107.982445, 39.095293],\n  &quot;内蒙古自治区-鄂尔多斯市-杭锦旗&quot;: [108.742413, 39.838816],\n  &quot;内蒙古自治区-鄂尔多斯市-乌审旗&quot;: [108.824435, 38.610027],\n  &quot;内蒙古自治区-鄂尔多斯市-伊金霍洛旗&quot;: [109.75459, 39.570093],\n  &quot;内蒙古自治区-呼伦贝尔市&quot;: [119.77237, 49.218446],\n  &quot;内蒙古自治区-呼伦贝尔市-海拉尔区&quot;: [119.742465, 49.218216],\n  &quot;内蒙古自治区-呼伦贝尔市-扎赉诺尔区&quot;: [117.385436, 49.604099],\n  &quot;内蒙古自治区-呼伦贝尔市-阿荣旗&quot;: [123.46544, 48.131971],\n  &quot;内蒙古自治区-呼伦贝尔市-莫力达瓦达斡尔族自治旗&quot;: [124.525576, 48.482896],\n  &quot;内蒙古自治区-呼伦贝尔市-鄂伦春自治旗&quot;: [123.732345, 50.597948],\n  &quot;内蒙古自治区-呼伦贝尔市-鄂温克族自治旗&quot;: [119.761351, 49.153045],\n  &quot;内蒙古自治区-呼伦贝尔市-陈巴尔虎旗&quot;: [119.430462, 49.334914],\n  &quot;内蒙古自治区-呼伦贝尔市-新巴尔虎左旗&quot;: [118.276608, 48.223787],\n  &quot;内蒙古自治区-呼伦贝尔市-新巴尔虎右旗&quot;: [116.830632, 48.677054],\n  &quot;内蒙古自治区-呼伦贝尔市-满洲里市&quot;: [117.385436, 49.604099],\n  &quot;内蒙古自治区-呼伦贝尔市-牙克石市&quot;: [120.718347, 49.292024],\n  &quot;内蒙古自治区-呼伦贝尔市-扎兰屯市&quot;: [122.744454, 48.019956],\n  &quot;内蒙古自治区-呼伦贝尔市-额尔古纳市&quot;: [120.186634, 50.248132],\n  &quot;内蒙古自治区-呼伦贝尔市-根河市&quot;: [121.527585, 50.78614],\n  &quot;内蒙古自治区-巴彦淖尔市&quot;: [107.394398, 40.749359],\n  &quot;内蒙古自治区-巴彦淖尔市-临河区&quot;: [107.369534, 40.756681],\n  &quot;内蒙古自治区-巴彦淖尔市-五原县&quot;: [108.273491, 41.094455],\n  &quot;内蒙古自治区-巴彦淖尔市-磴口县&quot;: [107.014522, 40.33647],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特前旗&quot;: [108.658615, 40.742104],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特中旗&quot;: [108.519512, 41.593346],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特后旗&quot;: [107.081546, 41.089422],\n  &quot;内蒙古自治区-巴彦淖尔市-杭锦后旗&quot;: [107.157372, 40.892179],\n  &quot;内蒙古自治区-乌兰察布市&quot;: [113.139468, 41.000748],\n  &quot;内蒙古自治区-乌兰察布市-集宁区&quot;: [113.120587, 41.041146],\n  &quot;内蒙古自治区-乌兰察布市-卓资县&quot;: [112.58441, 40.900292],\n  &quot;内蒙古自治区-乌兰察布市-化德县&quot;: [114.016409, 41.909603],\n  &quot;内蒙古自治区-乌兰察布市-商都县&quot;: [113.584639, 41.567567],\n  &quot;内蒙古自治区-乌兰察布市-兴和县&quot;: [113.840579, 40.879342],\n  &quot;内蒙古自治区-乌兰察布市-凉城县&quot;: [112.5106, 40.537163],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼前旗&quot;: [113.221605, 40.791267],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼中旗&quot;: [112.64258, 41.283273],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼后旗&quot;: [113.198531, 41.441771],\n  &quot;内蒙古自治区-乌兰察布市-四子王旗&quot;: [111.712419, 41.539353],\n  &quot;内蒙古自治区-乌兰察布市-丰镇市&quot;: [113.116601, 40.441805],\n  &quot;内蒙古自治区-兴安盟&quot;: [122.044365, 46.088464],\n  &quot;内蒙古自治区-兴安盟-乌兰浩特市&quot;: [122.099622, 46.078654],\n  &quot;内蒙古自治区-兴安盟-阿尔山市&quot;: [119.950653, 47.183054],\n  &quot;内蒙古自治区-兴安盟-科尔沁右翼前旗&quot;: [121.964553, 46.082649],\n  &quot;内蒙古自治区-兴安盟-科尔沁右翼中旗&quot;: [121.483548, 45.066471],\n  &quot;内蒙古自治区-兴安盟-扎赉特旗&quot;: [122.906444, 46.72919],\n  &quot;内蒙古自治区-兴安盟-突泉县&quot;: [121.600545, 45.38783],\n  &quot;内蒙古自治区-锡林郭勒盟&quot;: [116.054391, 43.939423],\n  &quot;内蒙古自治区-锡林郭勒盟-二连浩特市&quot;: [111.958363, 43.6488],\n  &quot;内蒙古自治区-锡林郭勒盟-锡林浩特市&quot;: [116.093614, 43.938334],\n  &quot;内蒙古自治区-锡林郭勒盟-阿巴嘎旗&quot;: [114.957367, 44.028102],\n  &quot;内蒙古自治区-锡林郭勒盟-苏尼特左旗&quot;: [113.67348, 43.865554],\n  &quot;内蒙古自治区-锡林郭勒盟-苏尼特右旗&quot;: [112.648569, 42.747369],\n  &quot;内蒙古自治区-锡林郭勒盟-东乌珠穆沁旗&quot;: [116.978504, 45.515743],\n  &quot;内蒙古自治区-锡林郭勒盟-西乌珠穆沁旗&quot;: [117.616377, 44.593803],\n  &quot;内蒙古自治区-锡林郭勒盟-太仆寺旗&quot;: [115.290535, 41.882292],\n  &quot;内蒙古自治区-锡林郭勒盟-镶黄旗&quot;: [113.854505, 42.237661],\n  &quot;内蒙古自治区-锡林郭勒盟-正镶白旗&quot;: [115.036622, 42.292605],\n  &quot;内蒙古自治区-锡林郭勒盟-正蓝旗&quot;: [115.998604, 42.247119],\n  &quot;内蒙古自治区-锡林郭勒盟-多伦县&quot;: [116.492509, 42.208921],\n  &quot;内蒙古自治区-阿拉善盟&quot;: [105.735377, 38.858276],\n  &quot;内蒙古自治区-阿拉善盟-阿拉善左旗&quot;: [105.672599, 38.839094],\n  &quot;内蒙古自治区-阿拉善盟-阿拉善右旗&quot;: [101.673464, 39.222241],\n  &quot;内蒙古自治区-阿拉善盟-额济纳旗&quot;: [101.062403, 41.960298],\n  &quot;辽宁省&quot;: [123.435598, 41.841465],\n  &quot;辽宁省-沈阳市&quot;: [123.466452, 41.68879],\n  &quot;辽宁省-沈阳市-和平区&quot;: [123.426644, 41.795236],\n  &quot;辽宁省-沈阳市-沈河区&quot;: [123.465461, 41.802274],\n  &quot;辽宁省-沈阳市-大东区&quot;: [123.476405, 41.811425],\n  &quot;辽宁省-沈阳市-皇姑区&quot;: [123.431621, 41.826042],\n  &quot;辽宁省-沈阳市-铁西区&quot;: [123.383436, 41.809038],\n  &quot;辽宁省-沈阳市-苏家屯区&quot;: [123.350435, 41.671254],\n  &quot;辽宁省-沈阳市-浑南区&quot;: [123.567539, 41.849226],\n  &quot;辽宁省-沈阳市-沈北新区&quot;: [123.533605, 42.058914],\n  &quot;辽宁省-沈阳市-于洪区&quot;: [123.314633, 41.799668],\n  &quot;辽宁省-沈阳市-辽中区&quot;: [122.772378, 41.523149],\n  &quot;辽宁省-沈阳市-康平县&quot;: [123.337511, 42.749925],\n  &quot;辽宁省-沈阳市-法库县&quot;: [123.414621, 42.509607],\n  &quot;辽宁省-沈阳市-新民市&quot;: [122.875395, 42.007109],\n  &quot;辽宁省-大连市&quot;: [121.621631, 38.918954],\n  &quot;辽宁省-大连市-中山区&quot;: [121.651547, 38.924511],\n  &quot;辽宁省-大连市-西岗区&quot;: [121.618625, 38.920473],\n  &quot;辽宁省-大连市-沙河口区&quot;: [121.594507, 38.913544],\n  &quot;辽宁省-大连市-甘井子区&quot;: [121.531519, 38.958002],\n  &quot;辽宁省-大连市-旅顺口区&quot;: [121.268597, 38.856832],\n  &quot;辽宁省-大连市-金州区&quot;: [121.789436, 39.056433],\n  &quot;辽宁省-大连市-普兰店区&quot;: [121.94646, 39.398089],\n  &quot;辽宁省-大连市-长海县&quot;: [122.594627, 39.27827],\n  &quot;辽宁省-大连市-瓦房店市&quot;: [121.985638, 39.632741],\n  &quot;辽宁省-大连市-庄河市&quot;: [122.974495, 39.686956],\n  &quot;辽宁省-鞍山市&quot;: [123.001373, 41.115054],\n  &quot;辽宁省-鞍山市-铁东区&quot;: [122.9974, 41.096332],\n  &quot;辽宁省-鞍山市-铁西区&quot;: [122.97549, 41.125475],\n  &quot;辽宁省-鞍山市-立山区&quot;: [123.035484, 41.156116],\n  &quot;辽宁省-鞍山市-千山区&quot;: [122.967574, 41.080939],\n  &quot;辽宁省-鞍山市-台安县&quot;: [122.44255, 41.41859],\n  &quot;辽宁省-鞍山市-岫岩满族自治县&quot;: [123.287547, 40.295892],\n  &quot;辽宁省-鞍山市-海城市&quot;: [122.691569, 40.887634],\n  &quot;辽宁省-抚顺市&quot;: [123.964375, 41.88597],\n  &quot;辽宁省-抚顺市-新抚区&quot;: [123.919582, 41.867806],\n  &quot;辽宁省-抚顺市-东洲区&quot;: [124.04555, 41.859191],\n  &quot;辽宁省-抚顺市-望花区&quot;: [123.790604, 41.85903],\n  &quot;辽宁省-抚顺市-顺城区&quot;: [123.951414, 41.889164],\n  &quot;辽宁省-抚顺市-抚顺县&quot;: [123.92159, 41.887037],\n  &quot;辽宁省-抚顺市-新宾满族自治县&quot;: [125.046356, 41.739969],\n  &quot;辽宁省-抚顺市-清原满族自治县&quot;: [124.93036, 42.106761],\n  &quot;辽宁省-本溪市&quot;: [123.692507, 41.492916],\n  &quot;辽宁省-本溪市-平山区&quot;: [123.774614, 41.301604],\n  &quot;辽宁省-本溪市-溪湖区&quot;: [123.774611, 41.334803],\n  &quot;辽宁省-本溪市-明山区&quot;: [123.823474, 41.314939],\n  &quot;辽宁省-本溪市-南芬区&quot;: [123.751467, 41.107096],\n  &quot;辽宁省-本溪市-本溪满族自治县&quot;: [124.127585, 41.307903],\n  &quot;辽宁省-本溪市-桓仁满族自治县&quot;: [125.367544, 41.272925],\n  &quot;辽宁省-丹东市&quot;: [124.361547, 40.006409],\n  &quot;辽宁省-丹东市-元宝区&quot;: [124.402584, 40.142251],\n  &quot;辽宁省-丹东市-振兴区&quot;: [124.366579, 40.110719],\n  &quot;辽宁省-丹东市-振安区&quot;: [124.434387, 40.164697],\n  &quot;辽宁省-丹东市-宽甸满族自治县&quot;: [124.790427, 40.737553],\n  &quot;辽宁省-丹东市-东港市&quot;: [124.15961, 39.867716],\n  &quot;辽宁省-丹东市-凤城市&quot;: [124.072422, 40.45918],\n  &quot;辽宁省-锦州市&quot;: [121.132596, 41.100931],\n  &quot;辽宁省-锦州市-古塔区&quot;: [121.134585, 41.122901],\n  &quot;辽宁省-锦州市-凌河区&quot;: [121.15759, 41.120691],\n  &quot;辽宁省-锦州市-太和区&quot;: [121.110453, 41.115109],\n  &quot;辽宁省-锦州市-黑山县&quot;: [122.130557, 41.671593],\n  &quot;辽宁省-锦州市-义县&quot;: [121.245569, 41.538939],\n  &quot;辽宁省-锦州市-凌海市&quot;: [121.362539, 41.166488],\n  &quot;辽宁省-锦州市-北镇市&quot;: [121.783447, 41.594428],\n  &quot;辽宁省-营口市&quot;: [122.241575, 40.673137],\n  &quot;辽宁省-营口市-站前区&quot;: [122.265437, 40.678764],\n  &quot;辽宁省-营口市-西市区&quot;: [122.213582, 40.672111],\n  &quot;辽宁省-营口市-鲅鱼圈区&quot;: [122.127573, 40.23234],\n  &quot;辽宁省-营口市-老边区&quot;: [122.386439, 40.686384],\n  &quot;辽宁省-营口市-盖州市&quot;: [122.355591, 40.406167],\n  &quot;辽宁省-营口市-大石桥市&quot;: [122.51538, 40.650802],\n  &quot;辽宁省-阜新市&quot;: [121.676408, 42.028022],\n  &quot;辽宁省-阜新市-海州区&quot;: [121.669436, 42.023735],\n  &quot;辽宁省-阜新市-新邱区&quot;: [121.799363, 42.093935],\n  &quot;辽宁省-阜新市-太平区&quot;: [121.685384, 42.016968],\n  &quot;辽宁省-阜新市-清河门区&quot;: [121.422479, 41.789319],\n  &quot;辽宁省-阜新市-细河区&quot;: [121.686392, 42.031871],\n  &quot;辽宁省-阜新市-阜新蒙古族自治县&quot;: [121.763574, 42.071368],\n  &quot;辽宁省-阜新市-彰武县&quot;: [122.545449, 42.392707],\n  &quot;辽宁省-辽阳市&quot;: [123.243366, 41.274161],\n  &quot;辽宁省-辽阳市-白塔区&quot;: [123.180608, 41.275845],\n  &quot;辽宁省-辽阳市-文圣区&quot;: [123.191605, 41.268438],\n  &quot;辽宁省-辽阳市-宏伟区&quot;: [123.20358, 41.223368],\n  &quot;辽宁省-辽阳市-弓长岭区&quot;: [123.426615, 41.157327],\n  &quot;辽宁省-辽阳市-太子河区&quot;: [123.188604, 41.259226],\n  &quot;辽宁省-辽阳市-辽阳县&quot;: [123.112421, 41.211679],\n  &quot;辽宁省-辽阳市-灯塔市&quot;: [123.345462, 41.432474],\n  &quot;辽宁省-盘锦市&quot;: [122.07749, 41.125875],\n  &quot;辽宁省-盘锦市-双台子区&quot;: [122.046393, 41.206072],\n  &quot;辽宁省-盘锦市-兴隆台区&quot;: [122.076499, 41.164499],\n  &quot;辽宁省-盘锦市-大洼区&quot;: [122.088555, 41.008179],\n  &quot;辽宁省-盘锦市-盘山县&quot;: [122.00356, 41.248264],\n  &quot;辽宁省-铁岭市&quot;: [123.732365, 42.229948],\n  &quot;辽宁省-铁岭市-银州区&quot;: [123.848386, 42.292574],\n  &quot;辽宁省-铁岭市-清河区&quot;: [124.165563, 42.552495],\n  &quot;辽宁省-铁岭市-铁岭县&quot;: [123.735372, 42.229226],\n  &quot;辽宁省-铁岭市-西丰县&quot;: [124.733615, 42.744014],\n  &quot;辽宁省-铁岭市-昌图县&quot;: [124.117501, 42.792178],\n  &quot;辽宁省-铁岭市-调兵山市&quot;: [123.573509, 42.473738],\n  &quot;辽宁省-铁岭市-开原市&quot;: [124.044569, 42.552079],\n  &quot;辽宁省-朝阳市&quot;: [120.457499, 41.579821],\n  &quot;辽宁省-朝阳市-双塔区&quot;: [120.460487, 41.571779],\n  &quot;辽宁省-朝阳市-龙城区&quot;: [120.443567, 41.598469],\n  &quot;辽宁省-朝阳市-朝阳县&quot;: [120.259391, 41.241076],\n  &quot;辽宁省-朝阳市-建平县&quot;: [119.64938, 41.409456],\n  &quot;辽宁省-朝阳市-喀喇沁左翼蒙古族自治县&quot;: [119.747414, 41.133689],\n  &quot;辽宁省-朝阳市-北票市&quot;: [120.777628, 41.806483],\n  &quot;辽宁省-朝阳市-凌源市&quot;: [119.407358, 41.251651],\n  &quot;辽宁省-葫芦岛市&quot;: [120.843398, 40.717364],\n  &quot;辽宁省-葫芦岛市-连山区&quot;: [120.876482, 40.780894],\n  &quot;辽宁省-葫芦岛市-龙港区&quot;: [120.900621, 40.741057],\n  &quot;辽宁省-葫芦岛市-南票区&quot;: [120.756493, 41.113098],\n  &quot;辽宁省-葫芦岛市-绥中县&quot;: [120.350425, 40.331843],\n  &quot;辽宁省-葫芦岛市-建昌县&quot;: [119.843595, 40.83038],\n  &quot;辽宁省-葫芦岛市-兴城市&quot;: [120.764558, 40.616556],\n  &quot;吉林省&quot;: [125.33258, 43.901714],\n  &quot;吉林省-长春市&quot;: [125.330602, 43.821954],\n  &quot;吉林省-长春市-南关区&quot;: [125.35661, 43.869873],\n  &quot;吉林省-长春市-宽城区&quot;: [125.334625, 43.949502],\n  &quot;吉林省-长春市-朝阳区&quot;: [125.295401, 43.840641],\n  &quot;吉林省-长春市-二道区&quot;: [125.380468, 43.871277],\n  &quot;吉林省-长春市-绿园区&quot;: [125.262443, 43.88681],\n  &quot;吉林省-长春市-双阳区&quot;: [125.671448, 43.531091],\n  &quot;吉林省-长春市-九台区&quot;: [125.845564, 44.157792],\n  &quot;吉林省-长春市-农安县&quot;: [125.191484, 44.438904],\n  &quot;吉林省-长春市-榆树市&quot;: [126.539609, 44.84544],\n  &quot;吉林省-长春市-德惠市&quot;: [125.734515, 44.527161],\n  &quot;吉林省-吉林市&quot;: [126.555635, 43.843568],\n  &quot;吉林省-吉林市-昌邑区&quot;: [126.581449, 43.887992],\n  &quot;吉林省-吉林市-龙潭区&quot;: [126.568545, 43.916343],\n  &quot;吉林省-吉林市-船营区&quot;: [126.54765, 43.839927],\n  &quot;吉林省-吉林市-丰满区&quot;: [126.56857, 43.827152],\n  &quot;吉林省-吉林市-永吉县&quot;: [126.504416, 43.678721],\n  &quot;吉林省-吉林市-蛟河市&quot;: [127.35148, 43.730004],\n  &quot;吉林省-吉林市-桦甸市&quot;: [126.752484, 42.977983],\n  &quot;吉林省-吉林市-舒兰市&quot;: [126.971377, 44.41227],\n  &quot;吉林省-吉林市-磐石市&quot;: [126.066616, 42.951817],\n  &quot;吉林省-四平市&quot;: [124.356482, 43.171994],\n  &quot;吉林省-四平市-铁西区&quot;: [124.352467, 43.152575],\n  &quot;吉林省-四平市-铁东区&quot;: [124.416483, 43.167994],\n  &quot;吉林省-四平市-梨树县&quot;: [124.342401, 43.313346],\n  &quot;吉林省-四平市-伊通满族自治县&quot;: [125.311485, 43.351104],\n  &quot;吉林省-四平市-公主岭市&quot;: [124.829449, 43.510833],\n  &quot;吉林省-四平市-双辽市&quot;: [123.509438, 43.524527],\n  &quot;吉林省-辽源市&quot;: [125.150425, 42.894055],\n  &quot;吉林省-辽源市-龙山区&quot;: [125.143452, 42.907634],\n  &quot;吉林省-辽源市-西安区&quot;: [125.155373, 42.933308],\n  &quot;吉林省-辽源市-东丰县&quot;: [125.537378, 42.683311],\n  &quot;吉林省-辽源市-东辽县&quot;: [124.997589, 42.931879],\n  &quot;吉林省-通化市&quot;: [125.946606, 41.733816],\n  &quot;吉林省-通化市-东昌区&quot;: [125.933595, 41.708405],\n  &quot;吉林省-通化市-二道江区&quot;: [126.049592, 41.779966],\n  &quot;吉林省-通化市-通化县&quot;: [125.765392, 41.685682],\n  &quot;吉林省-通化市-辉南县&quot;: [126.053581, 42.6907],\n  &quot;吉林省-通化市-柳河县&quot;: [125.751424, 42.290871],\n  &quot;吉林省-通化市-梅河口市&quot;: [125.717608, 42.544884],\n  &quot;吉林省-通化市-集安市&quot;: [126.199577, 41.1313],\n  &quot;吉林省-白山市&quot;: [126.42963, 41.939627],\n  &quot;吉林省-白山市-浑江区&quot;: [126.42362, 41.950424],\n  &quot;吉林省-白山市-江源区&quot;: [126.597391, 42.062939],\n  &quot;吉林省-白山市-抚松县&quot;: [127.455371, 42.227335],\n  &quot;吉林省-白山市-靖宇县&quot;: [126.819499, 42.394766],\n  &quot;吉林省-白山市-长白朝鲜族自治县&quot;: [128.207584, 41.425896],\n  &quot;吉林省-白山市-临江市&quot;: [126.924582, 41.817679],\n  &quot;吉林省-松原市&quot;: [124.831482, 45.147404],\n  &quot;吉林省-松原市-宁江区&quot;: [124.823423, 45.178039],\n  &quot;吉林省-松原市-前郭尔罗斯蒙古族自治县&quot;: [124.830456, 45.123416],\n  &quot;吉林省-松原市-长岭县&quot;: [123.974374, 44.281638],\n  &quot;吉林省-松原市-乾安县&quot;: [124.047564, 45.008434],\n  &quot;吉林省-松原市-扶余市&quot;: [126.056606, 44.994168],\n  &quot;吉林省-白城市&quot;: [122.845591, 45.625504],\n  &quot;吉林省-白城市-洮北区&quot;: [122.85751, 45.627525],\n  &quot;吉林省-白城市-镇赉县&quot;: [123.206576, 45.853117],\n  &quot;吉林省-白城市-通榆县&quot;: [123.094521, 44.818964],\n  &quot;吉林省-白城市-洮南市&quot;: [122.794468, 45.341132],\n  &quot;吉林省-白城市-大安市&quot;: [124.298504, 45.513045],\n  &quot;吉林省-延边朝鲜族自治州&quot;: [129.477376, 42.915743],\n  &quot;吉林省-延边朝鲜族自治州-延吉市&quot;: [129.52052, 42.912717],\n  &quot;吉林省-延边朝鲜族自治州-图们市&quot;: [129.850382, 42.974283],\n  &quot;吉林省-延边朝鲜族自治州-敦化市&quot;: [128.238612, 43.378291],\n  &quot;吉林省-延边朝鲜族自治州-珲春市&quot;: [130.372613, 42.868515],\n  &quot;吉林省-延边朝鲜族自治州-龙井市&quot;: [129.432635, 42.771535],\n  &quot;吉林省-延边朝鲜族自治州-和龙市&quot;: [129.017387, 42.552323],\n  &quot;吉林省-延边朝鲜族自治州-汪清县&quot;: [129.777609, 43.318451],\n  &quot;吉林省-延边朝鲜族自治州-安图县&quot;: [128.905448, 43.117917],\n  &quot;黑龙江省&quot;: [126.669653, 45.74793],\n  &quot;黑龙江省-哈尔滨市&quot;: [126.541615, 45.808826],\n  &quot;黑龙江省-哈尔滨市-道里区&quot;: [126.623432, 45.761844],\n  &quot;黑龙江省-哈尔滨市-南岗区&quot;: [126.675638, 45.765866],\n  &quot;黑龙江省-哈尔滨市-道外区&quot;: [126.655604, 45.797776],\n  &quot;黑龙江省-哈尔滨市-平房区&quot;: [126.643547, 45.603862],\n  &quot;黑龙江省-哈尔滨市-松北区&quot;: [126.516483, 45.808593],\n  &quot;黑龙江省-哈尔滨市-香坊区&quot;: [126.669624, 45.71362],\n  &quot;黑龙江省-哈尔滨市-呼兰区&quot;: [126.594399, 45.89521],\n  &quot;黑龙江省-哈尔滨市-阿城区&quot;: [126.964356, 45.554275],\n  &quot;黑龙江省-哈尔滨市-双城区&quot;: [126.319623, 45.388112],\n  &quot;黑龙江省-哈尔滨市-依兰县&quot;: [129.57452, 46.33126],\n  &quot;黑龙江省-哈尔滨市-方正县&quot;: [128.835634, 45.857758],\n  &quot;黑龙江省-哈尔滨市-宾县&quot;: [127.473497, 45.752465],\n  &quot;黑龙江省-哈尔滨市-巴彦县&quot;: [127.410548, 46.091283],\n  &quot;黑龙江省-哈尔滨市-木兰县&quot;: [128.050356, 45.956871],\n  &quot;黑龙江省-哈尔滨市-通河县&quot;: [128.752416, 45.996393],\n  &quot;黑龙江省-哈尔滨市-延寿县&quot;: [128.338606, 45.457641],\n  &quot;黑龙江省-哈尔滨市-尚志市&quot;: [128.015488, 45.215474],\n  &quot;黑龙江省-哈尔滨市-五常市&quot;: [127.173529, 44.937843],\n  &quot;黑龙江省-齐齐哈尔市&quot;: [123.924571, 47.359977],\n  &quot;黑龙江省-齐齐哈尔市-龙沙区&quot;: [123.964376, 47.323577],\n  &quot;黑龙江省-齐齐哈尔市-建华区&quot;: [123.96135, 47.360555],\n  &quot;黑龙江省-齐齐哈尔市-铁锋区&quot;: [123.984416, 47.347019],\n  &quot;黑龙江省-齐齐哈尔市-昂昂溪区&quot;: [123.829406, 47.161332],\n  &quot;黑龙江省-齐齐哈尔市-富拉尔基区&quot;: [123.63651, 47.215504],\n  &quot;黑龙江省-齐齐哈尔市-碾子山区&quot;: [122.894367, 47.523236],\n  &quot;黑龙江省-齐齐哈尔市-梅里斯达斡尔族区&quot;: [123.759541, 47.31555],\n  &quot;黑龙江省-齐齐哈尔市-龙江县&quot;: [123.211539, 47.343606],\n  &quot;黑龙江省-齐齐哈尔市-依安县&quot;: [125.312482, 47.899484],\n  &quot;黑龙江省-齐齐哈尔市-泰来县&quot;: [123.423626, 46.397829],\n  &quot;黑龙江省-齐齐哈尔市-甘南县&quot;: [123.512486, 47.926884],\n  &quot;黑龙江省-齐齐哈尔市-富裕县&quot;: [124.480542, 47.780228],\n  &quot;黑龙江省-齐齐哈尔市-克山县&quot;: [125.881378, 48.043172],\n  &quot;黑龙江省-齐齐哈尔市-克东县&quot;: [126.255387, 48.048244],\n  &quot;黑龙江省-齐齐哈尔市-拜泉县&quot;: [126.105421, 47.601867],\n  &quot;黑龙江省-齐齐哈尔市-讷河市&quot;: [124.890549, 48.490087],\n  &quot;黑龙江省-鸡西市&quot;: [130.975619, 45.300872],\n  &quot;黑龙江省-鸡西市-鸡冠区&quot;: [130.987632, 45.309806],\n  &quot;黑龙江省-鸡西市-恒山区&quot;: [130.911385, 45.216972],\n  &quot;黑龙江省-鸡西市-滴道区&quot;: [130.85058, 45.354434],\n  &quot;黑龙江省-鸡西市-梨树区&quot;: [130.703396, 45.098242],\n  &quot;黑龙江省-鸡西市-城子河区&quot;: [131.018469, 45.344435],\n  &quot;黑龙江省-鸡西市-麻山区&quot;: [130.484536, 45.217935],\n  &quot;黑龙江省-鸡西市-鸡东县&quot;: [131.130558, 45.266185],\n  &quot;黑龙江省-鸡西市-虎林市&quot;: [132.943466, 45.768947],\n  &quot;黑龙江省-鸡西市-密山市&quot;: [131.853531, 45.535641],\n  &quot;黑龙江省-鹤岗市&quot;: [130.304433, 47.356056],\n  &quot;黑龙江省-鹤岗市-向阳区&quot;: [130.300468, 47.348581],\n  &quot;黑龙江省-鹤岗市-工农区&quot;: [130.281617, 47.32443],\n  &quot;黑龙江省-鹤岗市-南山区&quot;: [130.29354, 47.321246],\n  &quot;黑龙江省-鹤岗市-兴安区&quot;: [130.245546, 47.258716],\n  &quot;黑龙江省-鹤岗市-东山区&quot;: [130.323361, 47.344987],\n  &quot;黑龙江省-鹤岗市-兴山区&quot;: [130.317364, 47.396045],\n  &quot;黑龙江省-鹤岗市-萝北县&quot;: [130.835495, 47.583422],\n  &quot;黑龙江省-鹤岗市-绥滨县&quot;: [131.859487, 47.295265],\n  &quot;黑龙江省-双鸭山市&quot;: [131.165342, 46.653186],\n  &quot;黑龙江省-双鸭山市-尖山区&quot;: [131.165342, 46.652586],\n  &quot;黑龙江省-双鸭山市-岭东区&quot;: [131.164377, 46.464596],\n  &quot;黑龙江省-双鸭山市-四方台区&quot;: [131.345657, 46.602012],\n  &quot;黑龙江省-双鸭山市-宝山区&quot;: [131.407375, 46.583598],\n  &quot;黑龙江省-双鸭山市-集贤县&quot;: [131.147434, 46.734518],\n  &quot;黑龙江省-双鸭山市-友谊县&quot;: [131.814595, 46.772973],\n  &quot;黑龙江省-双鸭山市-宝清县&quot;: [132.203594, 46.332652],\n  &quot;黑龙江省-双鸭山市-饶河县&quot;: [134.020469, 46.804183],\n  &quot;黑龙江省-大庆市&quot;: [125.108658, 46.593633],\n  &quot;黑龙江省-大庆市-萨尔图区&quot;: [125.13351, 46.638936],\n  &quot;黑龙江省-大庆市-龙凤区&quot;: [125.140473, 46.567678],\n  &quot;黑龙江省-大庆市-让胡路区&quot;: [124.877599, 46.658078],\n  &quot;黑龙江省-大庆市-红岗区&quot;: [124.897477, 46.404313],\n  &quot;黑龙江省-大庆市-大同区&quot;: [124.819377, 46.045584],\n  &quot;黑龙江省-大庆市-肇州县&quot;: [125.275368, 45.705108],\n  &quot;黑龙江省-大庆市-肇源县&quot;: [125.084573, 45.524153],\n  &quot;黑龙江省-大庆市-林甸县&quot;: [124.86965, 47.177234],\n  &quot;黑龙江省-大庆市-杜尔伯特蒙古族自治县&quot;: [124.449359, 46.868768],\n  &quot;黑龙江省-伊春市&quot;: [128.847546, 47.733318],\n  &quot;黑龙江省-伊春市-伊春区&quot;: [128.913459, 47.733954],\n  &quot;黑龙江省-伊春市-南岔区&quot;: [129.289572, 47.14375],\n  &quot;黑龙江省-伊春市-友好区&quot;: [128.842579, 47.846436],\n  &quot;黑龙江省-伊春市-西林区&quot;: [129.319594, 47.486393],\n  &quot;黑龙江省-伊春市-翠峦区&quot;: [128.676482, 47.732894],\n  &quot;黑龙江省-伊春市-新青区&quot;: [129.540647, 48.296135],\n  &quot;黑龙江省-伊春市-美溪区&quot;: [129.135368, 47.641344],\n  &quot;黑龙江省-伊春市-金山屯区&quot;: [129.435639, 47.418759],\n  &quot;黑龙江省-伊春市-五营区&quot;: [129.25135, 48.114271],\n  &quot;黑龙江省-伊春市-乌马河区&quot;: [128.805546, 47.733619],\n  &quot;黑龙江省-伊春市-汤旺河区&quot;: [129.577474, 48.460614],\n  &quot;黑龙江省-伊春市-带岭区&quot;: [129.027425, 47.034572],\n  &quot;黑龙江省-伊春市-乌伊岭区&quot;: [129.444577, 48.596169],\n  &quot;黑龙江省-伊春市-红星区&quot;: [129.397507, 48.24548],\n  &quot;黑龙江省-伊春市-上甘岭区&quot;: [129.030437, 47.980914],\n  &quot;黑龙江省-伊春市-嘉荫县&quot;: [130.410555, 48.894983],\n  &quot;黑龙江省-伊春市-铁力市&quot;: [128.038365, 46.992949],\n  &quot;黑龙江省-佳木斯市&quot;: [130.327359, 46.80569],\n  &quot;黑龙江省-佳木斯市-向阳区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-前进区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-东风区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-郊区&quot;: [130.333378, 46.816168],\n  &quot;黑龙江省-佳木斯市-桦南县&quot;: [130.560385, 46.245077],\n  &quot;黑龙江省-佳木斯市-桦川县&quot;: [130.725549, 47.028817],\n  &quot;黑龙江省-佳木斯市-汤原县&quot;: [129.911645, 46.735327],\n  &quot;黑龙江省-佳木斯市-同江市&quot;: [132.517509, 47.647981],\n  &quot;黑龙江省-佳木斯市-富锦市&quot;: [132.044539, 47.255933],\n  &quot;黑龙江省-佳木斯市-抚远市&quot;: [134.31449, 48.370945],\n  &quot;黑龙江省-七台河市&quot;: [131.011545, 45.7763],\n  &quot;黑龙江省-七台河市-新兴区&quot;: [130.938371, 45.82231],\n  &quot;黑龙江省-七台河市-桃山区&quot;: [131.026444, 45.7718],\n  &quot;黑龙江省-七台河市-茄子河区&quot;: [131.074481, 45.791238],\n  &quot;黑龙江省-七台河市-勃利县&quot;: [130.598533, 45.760964],\n  &quot;黑龙江省-牡丹江市&quot;: [129.63954, 44.556246],\n  &quot;黑龙江省-牡丹江市-东安区&quot;: [129.633478, 44.58746],\n  &quot;黑龙江省-牡丹江市-阳明区&quot;: [129.642527, 44.601775],\n  &quot;黑龙江省-牡丹江市-爱民区&quot;: [129.598364, 44.60235],\n  &quot;黑龙江省-牡丹江市-西安区&quot;: [129.622413, 44.583861],\n  &quot;黑龙江省-牡丹江市-林口县&quot;: [130.287579, 45.284129],\n  &quot;黑龙江省-牡丹江市-绥芬河市&quot;: [131.157392, 44.418154],\n  &quot;黑龙江省-牡丹江市-海林市&quot;: [129.387427, 44.599872],\n  &quot;黑龙江省-牡丹江市-宁安市&quot;: [129.489368, 44.346984],\n  &quot;黑龙江省-牡丹江市-穆棱市&quot;: [130.530559, 44.924785],\n  &quot;黑龙江省-牡丹江市-东宁市&quot;: [131.131544, 44.096101],\n  &quot;黑龙江省-黑河市&quot;: [127.53549, 50.251272],\n  &quot;黑龙江省-黑河市-爱辉区&quot;: [127.506632, 50.25771],\n  &quot;黑龙江省-黑河市-嫩江县&quot;: [125.227635, 49.19132],\n  &quot;黑龙江省-黑河市-逊克县&quot;: [128.485585, 49.569491],\n  &quot;黑龙江省-黑河市-孙吴县&quot;: [127.342388, 49.431451],\n  &quot;黑龙江省-黑河市-北安市&quot;: [126.49738, 48.24742],\n  &quot;黑龙江省-黑河市-五大连池市&quot;: [126.211555, 48.52261],\n  &quot;黑龙江省-绥化市&quot;: [126.975357, 46.660032],\n  &quot;黑龙江省-绥化市-北林区&quot;: [126.991449, 46.643493],\n  &quot;黑龙江省-绥化市-望奎县&quot;: [126.492385, 46.839168],\n  &quot;黑龙江省-绥化市-兰西县&quot;: [126.29462, 46.258095],\n  &quot;黑龙江省-绥化市-青冈县&quot;: [126.100489, 46.710685],\n  &quot;黑龙江省-绥化市-庆安县&quot;: [127.514612, 46.885744],\n  &quot;黑龙江省-绥化市-明水县&quot;: [125.912483, 47.179483],\n  &quot;黑龙江省-绥化市-绥棱县&quot;: [127.120515, 47.242516],\n  &quot;黑龙江省-绥化市-安达市&quot;: [125.348622, 46.425719],\n  &quot;黑龙江省-绥化市-肇东市&quot;: [125.968537, 46.056938],\n  &quot;黑龙江省-绥化市-海伦市&quot;: [126.936509, 47.456904],\n  &quot;黑龙江省-大兴安岭地区&quot;: [123.644559, 52.510947],\n  &quot;黑龙江省-大兴安岭地区-呼玛县&quot;: [126.65965, 51.730947],\n  &quot;黑龙江省-大兴安岭地区-塔河县&quot;: [124.716513, 52.340305],\n  &quot;黑龙江省-大兴安岭地区-漠河县&quot;: [122.545421, 52.978304],\n  &quot;上海市&quot;: [121.480539, 31.235929],\n  &quot;上海市-市辖区&quot;: [121.480539, 31.235929],\n  &quot;上海市-市辖区-黄浦区&quot;: [121.491586, 31.237247],\n  &quot;上海市-市辖区-徐汇区&quot;: [121.443396, 31.194557],\n  &quot;上海市-市辖区-长宁区&quot;: [121.430454, 31.226848],\n  &quot;上海市-市辖区-静安区&quot;: [121.453432, 31.233845],\n  &quot;上海市-市辖区-普陀区&quot;: [121.403569, 31.254973],\n  &quot;上海市-市辖区-虹口区&quot;: [121.511586, 31.269747],\n  &quot;上海市-市辖区-杨浦区&quot;: [121.53252, 31.265524],\n  &quot;上海市-市辖区-闵行区&quot;: [121.388612, 31.118843],\n  &quot;上海市-市辖区-宝山区&quot;: [121.496563, 31.410279],\n  &quot;上海市-市辖区-嘉定区&quot;: [121.272595, 31.380155],\n  &quot;上海市-市辖区-浦东新区&quot;: [121.550455, 31.227348],\n  &quot;上海市-市辖区-金山区&quot;: [121.34848, 30.747852],\n  &quot;上海市-市辖区-松江区&quot;: [121.23448, 31.037135],\n  &quot;上海市-市辖区-青浦区&quot;: [121.130553, 31.155454],\n  &quot;上海市-市辖区-奉贤区&quot;: [121.480504, 30.92372],\n  &quot;上海市-市辖区-崇明区&quot;: [121.403557, 31.62857],\n  &quot;江苏省&quot;: [118.769552, 32.066777],\n  &quot;江苏省-南京市&quot;: [118.802422, 32.064653],\n  &quot;江苏省-南京市-玄武区&quot;: [118.804413, 32.054757],\n  &quot;江苏省-南京市-秦淮区&quot;: [118.800407, 32.045139],\n  &quot;江苏省-南京市-建邺区&quot;: [118.738569, 32.00937],\n  &quot;江苏省-南京市-鼓楼区&quot;: [118.776519, 32.072405],\n  &quot;江苏省-南京市-浦口区&quot;: [118.634604, 32.064679],\n  &quot;江苏省-南京市-栖霞区&quot;: [118.915423, 32.1026],\n  &quot;江苏省-南京市-雨花台区&quot;: [118.785445, 31.997859],\n  &quot;江苏省-南京市-江宁区&quot;: [118.846567, 31.958527],\n  &quot;江苏省-南京市-六合区&quot;: [118.827471, 32.328666],\n  &quot;江苏省-南京市-溧水区&quot;: [119.034404, 31.657284],\n  &quot;江苏省-南京市-高淳区&quot;: [118.898498, 31.333639],\n  &quot;江苏省-无锡市&quot;: [120.318583, 31.49881],\n  &quot;江苏省-无锡市-锡山区&quot;: [120.363426, 31.594762],\n  &quot;江苏省-无锡市-惠山区&quot;: [120.304596, 31.686741],\n  &quot;江苏省-无锡市-滨湖区&quot;: [120.291548, 31.53464],\n  &quot;江苏省-无锡市-梁溪区&quot;: [120.3096, 31.571645],\n  &quot;江苏省-无锡市-新吴区&quot;: [120.370396, 31.55485],\n  &quot;江苏省-无锡市-江阴市&quot;: [120.370396, 31.55485],\n  &quot;江苏省-无锡市-宜兴市&quot;: [119.831606, 31.342957],\n  &quot;江苏省-徐州市&quot;: [117.290575, 34.212667],\n  &quot;江苏省-徐州市-鼓楼区&quot;: [117.192579, 34.29376],\n  &quot;江苏省-徐州市-云龙区&quot;: [117.258424, 34.259087],\n  &quot;江苏省-徐州市-贾汪区&quot;: [117.46943, 34.44162],\n  &quot;江苏省-徐州市-泉山区&quot;: [117.20059, 34.249943],\n  &quot;江苏省-徐州市-铜山区&quot;: [117.17557, 34.1861],\n  &quot;江苏省-徐州市-丰县&quot;: [116.602582, 34.69977],\n  &quot;江苏省-徐州市-沛县&quot;: [116.942586, 34.765152],\n  &quot;江苏省-徐州市-睢宁县&quot;: [117.947433, 33.918789],\n  &quot;江苏省-徐州市-新沂市&quot;: [118.361537, 34.375611],\n  &quot;江苏省-徐州市-邳州市&quot;: [117.963411, 34.339753],\n  &quot;江苏省-常州市&quot;: [119.981485, 31.815796],\n  &quot;江苏省-常州市-天宁区&quot;: [119.980463, 31.78557],\n  &quot;江苏省-常州市-钟楼区&quot;: [119.908463, 31.807647],\n  &quot;江苏省-常州市-新北区&quot;: [119.977514, 31.836324],\n  &quot;江苏省-常州市-武进区&quot;: [119.948612, 31.706447],\n  &quot;江苏省-常州市-金坛区&quot;: [119.604571, 31.728893],\n  &quot;江苏省-常州市-溧阳市&quot;: [119.491506, 31.422102],\n  &quot;江苏省-苏州市&quot;: [120.592412, 31.303564],\n  &quot;江苏省-苏州市-虎丘区&quot;: [120.578472, 31.301933],\n  &quot;江苏省-苏州市-吴中区&quot;: [120.638508, 31.268261],\n  &quot;江苏省-苏州市-相城区&quot;: [120.648566, 31.37469],\n  &quot;江苏省-苏州市-姑苏区&quot;: [120.623455, 31.341831],\n  &quot;江苏省-苏州市-吴江区&quot;: [120.651567, 31.144644],\n  &quot;江苏省-苏州市-常熟市&quot;: [120.759496, 31.659538],\n  &quot;江苏省-苏州市-张家港市&quot;: [120.561554, 31.881141],\n  &quot;江苏省-苏州市-昆山市&quot;: [120.987452, 31.390863],\n  &quot;江苏省-苏州市-太仓市&quot;: [121.135595, 31.464599],\n  &quot;江苏省-南通市&quot;: [120.901592, 31.986549],\n  &quot;江苏省-南通市-崇川区&quot;: [120.86342, 32.015923],\n  &quot;江苏省-南通市-港闸区&quot;: [120.824452, 32.037345],\n  &quot;江苏省-南通市-通州区&quot;: [121.081425, 32.070356],\n  &quot;江苏省-南通市-海安县&quot;: [120.474433, 32.539196],\n  &quot;江苏省-南通市-如东县&quot;: [121.192438, 32.335873],\n  &quot;江苏省-南通市-启东市&quot;: [121.663474, 31.814233],\n  &quot;江苏省-南通市-如皋市&quot;: [120.579466, 32.377851],\n  &quot;江苏省-南通市-海门市&quot;: [121.188436, 31.873612],\n  &quot;江苏省-连云港市&quot;: [119.228621, 34.60225],\n  &quot;江苏省-连云港市-连云区&quot;: [119.346588, 34.765337],\n  &quot;江苏省-连云港市-海州区&quot;: [119.169408, 34.577456],\n  &quot;江苏省-连云港市-赣榆区&quot;: [119.179435, 34.847682],\n  &quot;江苏省-连云港市-东海县&quot;: [118.759565, 34.547919],\n  &quot;江苏省-连云港市-灌云县&quot;: [119.246534, 34.288616],\n  &quot;江苏省-连云港市-灌南县&quot;: [119.322538, 34.092591],\n  &quot;江苏省-淮安市&quot;: [119.021484, 33.616295],\n  &quot;江苏省-淮安市-淮安区&quot;: [119.147463, 33.509],\n  &quot;江苏省-淮安市-淮阴区&quot;: [119.041422, 33.63815],\n  &quot;江苏省-淮安市-清江浦区&quot;: [119.032414, 33.558562],\n  &quot;江苏省-淮安市-洪泽区&quot;: [118.879584, 33.299625],\n  &quot;江苏省-淮安市-涟水县&quot;: [119.266448, 33.787079],\n  &quot;江苏省-淮安市-盱眙县&quot;: [118.551441, 33.018255],\n  &quot;江苏省-淮安市-金湖县&quot;: [119.026469, 33.031284],\n  &quot;江苏省-盐城市&quot;: [120.167544, 33.355101],\n  &quot;江苏省-盐城市-亭湖区&quot;: [120.204578, 33.395893],\n  &quot;江苏省-盐城市-盐都区&quot;: [120.160503, 33.34402],\n  &quot;江苏省-盐城市-大丰区&quot;: [120.507439, 33.20476],\n  &quot;江苏省-盐城市-响水县&quot;: [119.584601, 34.204743],\n  &quot;江苏省-盐城市-滨海县&quot;: [119.827621, 33.995647],\n  &quot;江苏省-盐城市-阜宁县&quot;: [119.809581, 33.765079],\n  &quot;江苏省-盐城市-射阳县&quot;: [120.264446, 33.781014],\n  &quot;江苏省-盐城市-建湖县&quot;: [119.805531, 33.469833],\n  &quot;江苏省-盐城市-东台市&quot;: [120.326537, 32.872716],\n  &quot;江苏省-扬州市&quot;: [119.419419, 32.400677],\n  &quot;江苏省-扬州市-广陵区&quot;: [119.438505, 32.400661],\n  &quot;江苏省-扬州市-邗江区&quot;: [119.404385, 32.382751],\n  &quot;江苏省-扬州市-江都区&quot;: [119.576603, 32.440295],\n  &quot;江苏省-扬州市-宝应县&quot;: [119.365556, 33.247205],\n  &quot;江苏省-扬州市-仪征市&quot;: [119.191467, 32.27809],\n  &quot;江苏省-扬州市-高邮市&quot;: [119.465616, 32.787147],\n  &quot;江苏省-镇江市&quot;: [119.430489, 32.194716],\n  &quot;江苏省-镇江市-京口区&quot;: [119.475604, 32.203785],\n  &quot;江苏省-镇江市-润州区&quot;: [119.41844, 32.201495],\n  &quot;江苏省-镇江市-丹徒区&quot;: [119.440501, 32.13792],\n  &quot;江苏省-镇江市-丹阳市&quot;: [119.612501, 32.01592],\n  &quot;江苏省-镇江市-扬中市&quot;: [119.80352, 32.242967],\n  &quot;江苏省-镇江市-句容市&quot;: [119.175433, 31.950923],\n  &quot;江苏省-泰州市&quot;: [119.929566, 32.460675],\n  &quot;江苏省-泰州市-海陵区&quot;: [119.925525, 32.496732],\n  &quot;江苏省-泰州市-高港区&quot;: [119.888421, 32.324862],\n  &quot;江苏省-泰州市-姜堰区&quot;: [120.133398, 32.515234],\n  &quot;江苏省-泰州市-兴化市&quot;: [119.857514, 32.917824],\n  &quot;江苏省-泰州市-靖江市&quot;: [120.283532, 31.98817],\n  &quot;江苏省-泰州市-泰兴市&quot;: [120.058599, 32.177474],\n  &quot;江苏省-宿迁市&quot;: [118.281574, 33.96775],\n  &quot;江苏省-宿迁市-宿城区&quot;: [118.249567, 33.968678],\n  &quot;江苏省-宿迁市-宿豫区&quot;: [118.336401, 33.954804],\n  &quot;江苏省-宿迁市-沭阳县&quot;: [118.810419, 34.117454],\n  &quot;江苏省-宿迁市-泗阳县&quot;: [118.709466, 33.728328],\n  &quot;江苏省-宿迁市-泗洪县&quot;: [118.222416, 33.465733],\n  &quot;浙江省&quot;: [120.159533, 30.271548],\n  &quot;浙江省-杭州市&quot;: [120.215512, 30.253083],\n  &quot;浙江省-杭州市-上城区&quot;: [120.175579, 30.248398],\n  &quot;浙江省-杭州市-下城区&quot;: [120.187607, 30.286744],\n  &quot;浙江省-杭州市-江干区&quot;: [120.211539, 30.263311],\n  &quot;浙江省-杭州市-拱墅区&quot;: [120.148447, 30.324643],\n  &quot;浙江省-杭州市-西湖区&quot;: [120.136438, 30.265916],\n  &quot;浙江省-杭州市-滨江区&quot;: [120.218471, 30.214333],\n  &quot;浙江省-杭州市-萧山区&quot;: [120.218471, 30.214333],\n  &quot;浙江省-杭州市-余杭区&quot;: [120.306592, 30.424739],\n  &quot;浙江省-杭州市-富阳区&quot;: [119.966556, 30.054723],\n  &quot;浙江省-杭州市-桐庐县&quot;: [119.697599, 29.798585],\n  &quot;浙江省-杭州市-淳安县&quot;: [119.048392, 29.61495],\n  &quot;浙江省-杭州市-建德市&quot;: [119.287398, 29.481154],\n  &quot;浙江省-杭州市-临安市&quot;: [119.731517, 30.239806],\n  &quot;浙江省-宁波市&quot;: [121.628572, 29.866033],\n  &quot;浙江省-宁波市-海曙区&quot;: [121.557403, 29.865721],\n  &quot;浙江省-宁波市-江东区&quot;: [121.576533, 29.8733],\n  &quot;浙江省-宁波市-江北区&quot;: [121.560421, 29.892948],\n  &quot;浙江省-宁波市-北仑区&quot;: [121.850576, 29.904659],\n  &quot;浙江省-宁波市-镇海区&quot;: [121.722519, 29.954885],\n  &quot;浙江省-宁波市-鄞州区&quot;: [121.555427, 29.824206],\n  &quot;浙江省-宁波市-象山县&quot;: [121.875564, 29.482271],\n  &quot;浙江省-宁波市-宁海县&quot;: [121.436432, 29.294317],\n  &quot;浙江省-宁波市-余姚市&quot;: [121.160585, 30.042735],\n  &quot;浙江省-宁波市-慈溪市&quot;: [121.272596, 30.175257],\n  &quot;浙江省-宁波市-奉化市&quot;: [121.413528, 29.661146],\n  &quot;浙江省-温州市&quot;: [120.706477, 28.001085],\n  &quot;浙江省-温州市-鹿城区&quot;: [120.661586, 28.020352],\n  &quot;浙江省-温州市-龙湾区&quot;: [120.819468, 27.938652],\n  &quot;浙江省-温州市-瓯海区&quot;: [120.621447, 27.972857],\n  &quot;浙江省-温州市-洞头区&quot;: [121.163549, 27.84187],\n  &quot;浙江省-温州市-永嘉县&quot;: [120.688524, 28.15645],\n  &quot;浙江省-温州市-平阳县&quot;: [120.572515, 27.667724],\n  &quot;浙江省-温州市-苍南县&quot;: [120.433595, 27.523067],\n  &quot;浙江省-温州市-文成县&quot;: [120.097488, 27.793217],\n  &quot;浙江省-温州市-泰顺县&quot;: [119.723537, 27.562171],\n  &quot;浙江省-温州市-瑞安市&quot;: [120.661582, 27.783951],\n  &quot;浙江省-温州市-乐清市&quot;: [120.992502, 28.11818],\n  &quot;浙江省-嘉兴市&quot;: [120.763552, 30.750975],\n  &quot;浙江省-嘉兴市-南湖区&quot;: [120.78961, 30.751547],\n  &quot;浙江省-嘉兴市-秀洲区&quot;: [120.715437, 30.770207],\n  &quot;浙江省-嘉兴市-嘉善县&quot;: [120.932511, 30.837122],\n  &quot;浙江省-嘉兴市-海盐县&quot;: [120.952445, 30.531873],\n  &quot;浙江省-嘉兴市-海宁市&quot;: [120.686565, 30.517924],\n  &quot;浙江省-嘉兴市-平湖市&quot;: [121.022575, 30.682241],\n  &quot;浙江省-嘉兴市-桐乡市&quot;: [120.571543, 30.636311],\n  &quot;浙江省-湖州市&quot;: [120.094517, 30.898964],\n  &quot;浙江省-湖州市-吴兴区&quot;: [120.191605, 30.862955],\n  &quot;浙江省-湖州市-南浔区&quot;: [120.424601, 30.855243],\n  &quot;浙江省-湖州市-德清县&quot;: [119.983465, 30.548628],\n  &quot;浙江省-湖州市-长兴县&quot;: [119.917498, 31.032579],\n  &quot;浙江省-湖州市-安吉县&quot;: [119.686563, 30.644425],\n  &quot;浙江省-绍兴市&quot;: [120.585478, 30.036369],\n  &quot;浙江省-绍兴市-越城区&quot;: [120.588437, 29.99531],\n  &quot;浙江省-绍兴市-柯桥区&quot;: [120.451511, 30.079004],\n  &quot;浙江省-绍兴市-上虞区&quot;: [120.87451, 30.038243],\n  &quot;浙江省-绍兴市-新昌县&quot;: [120.91057, 29.505541],\n  &quot;浙江省-绍兴市-诸暨市&quot;: [120.253408, 29.714935],\n  &quot;浙江省-绍兴市-嵊州市&quot;: [120.837437, 29.567327],\n  &quot;浙江省-金华市&quot;: [119.653436, 29.084639],\n  &quot;浙江省-金华市-婺城区&quot;: [119.578593, 29.091775],\n  &quot;浙江省-金华市-金东区&quot;: [119.699582, 29.104765],\n  &quot;浙江省-金华市-武义县&quot;: [119.822566, 28.898244],\n  &quot;浙江省-金华市-浦江县&quot;: [119.898436, 29.458693],\n  &quot;浙江省-金华市-磐安县&quot;: [120.456513, 29.060103],\n  &quot;浙江省-金华市-兰溪市&quot;: [119.466599, 29.214044],\n  &quot;浙江省-金华市-义乌市&quot;: [120.081581, 29.31115],\n  &quot;浙江省-金华市-东阳市&quot;: [120.248422, 29.295861],\n  &quot;浙江省-金华市-永康市&quot;: [120.054551, 28.894204],\n  &quot;浙江省-衢州市&quot;: [118.866597, 28.975546],\n  &quot;浙江省-衢州市-柯城区&quot;: [118.877584, 28.974204],\n  &quot;浙江省-衢州市-衢江区&quot;: [118.965539, 28.986238],\n  &quot;浙江省-衢州市-常山县&quot;: [118.517557, 28.906998],\n  &quot;浙江省-衢州市-开化县&quot;: [118.421459, 29.143188],\n  &quot;浙江省-衢州市-龙游县&quot;: [119.178418, 29.034487],\n  &quot;浙江省-衢州市-江山市&quot;: [118.633583, 28.742868],\n  &quot;浙江省-舟山市&quot;: [122.213556, 29.990912],\n  &quot;浙江省-舟山市-定海区&quot;: [122.113601, 30.025462],\n  &quot;浙江省-舟山市-普陀区&quot;: [122.331544, 29.976836],\n  &quot;浙江省-舟山市-岱山县&quot;: [122.232605, 30.269656],\n  &quot;浙江省-舟山市-嵊泗县&quot;: [122.457588, 30.731274],\n  &quot;浙江省-台州市&quot;: [121.427435, 28.662194],\n  &quot;浙江省-台州市-椒江区&quot;: [121.449408, 28.679258],\n  &quot;浙江省-台州市-黄岩区&quot;: [121.268566, 28.655334],\n  &quot;浙江省-台州市-路桥区&quot;: [121.371578, 28.586947],\n  &quot;浙江省-台州市-玉环县&quot;: [121.238513, 28.141863],\n  &quot;浙江省-台州市-三门县&quot;: [121.402554, 29.110355],\n  &quot;浙江省-台州市-天台县&quot;: [121.013553, 29.149514],\n  &quot;浙江省-台州市-仙居县&quot;: [120.735435, 28.853226],\n  &quot;浙江省-台州市-温岭市&quot;: [121.392589, 28.377655],\n  &quot;浙江省-台州市-临海市&quot;: [121.151585, 28.864049],\n  &quot;浙江省-丽水市&quot;: [119.929573, 28.473278],\n  &quot;浙江省-丽水市-莲都区&quot;: [119.919519, 28.451745],\n  &quot;浙江省-丽水市-青田县&quot;: [120.296573, 28.145488],\n  &quot;浙江省-丽水市-缙云县&quot;: [120.097478, 28.665215],\n  &quot;浙江省-丽水市-遂昌县&quot;: [119.282435, 28.598455],\n  &quot;浙江省-丽水市-松阳县&quot;: [119.488544, 28.455056],\n  &quot;浙江省-丽水市-云和县&quot;: [119.579597, 28.12147],\n  &quot;浙江省-丽水市-庆元县&quot;: [119.069487, 27.625432],\n  &quot;浙江省-丽水市-景宁畲族自治县&quot;: [119.64243, 27.979554],\n  &quot;浙江省-丽水市-龙泉市&quot;: [119.148445, 28.080509],\n  &quot;安徽省&quot;: [117.33054, 31.734294],\n  &quot;安徽省-合肥市&quot;: [117.233443, 31.826578],\n  &quot;安徽省-合肥市-瑶海区&quot;: [117.315587, 31.863787],\n  &quot;安徽省-合肥市-庐阳区&quot;: [117.271459, 31.884887],\n  &quot;安徽省-合肥市-蜀山区&quot;: [117.266461, 31.857378],\n  &quot;安徽省-合肥市-包河区&quot;: [117.316576, 31.799293],\n  &quot;安徽省-合肥市-长丰县&quot;: [117.17356, 32.483723],\n  &quot;安徽省-合肥市-肥东县&quot;: [117.475401, 31.89389],\n  &quot;安徽省-合肥市-肥西县&quot;: [117.164558, 31.712962],\n  &quot;安徽省-合肥市-庐江县&quot;: [117.293577, 31.261328],\n  &quot;安徽省-合肥市-巢湖市&quot;: [117.895576, 31.629002],\n  &quot;安徽省-芜湖市&quot;: [118.439431, 31.358537],\n  &quot;安徽省-芜湖市-镜湖区&quot;: [118.392606, 31.345867],\n  &quot;安徽省-芜湖市-弋江区&quot;: [118.37958, 31.317566],\n  &quot;安徽省-芜湖市-鸠江区&quot;: [118.397588, 31.375805],\n  &quot;安徽省-芜湖市-三山区&quot;: [118.274602, 31.22528],\n  &quot;安徽省-芜湖市-芜湖县&quot;: [118.582443, 31.141239],\n  &quot;安徽省-芜湖市-繁昌县&quot;: [118.205424, 31.107959],\n  &quot;安徽省-芜湖市-南陵县&quot;: [118.340418, 30.92026],\n  &quot;安徽省-芜湖市-无为县&quot;: [118.071407, 31.340204],\n  &quot;安徽省-蚌埠市&quot;: [117.395513, 32.921524],\n  &quot;安徽省-蚌埠市-龙子湖区&quot;: [117.399513, 32.948644],\n  &quot;安徽省-蚌埠市-蚌山区&quot;: [117.379441, 32.923379],\n  &quot;安徽省-蚌埠市-禹会区&quot;: [117.348452, 32.93531],\n  &quot;安徽省-蚌埠市-淮上区&quot;: [117.366383, 32.970547],\n  &quot;安徽省-蚌埠市-怀远县&quot;: [117.211506, 32.976004],\n  &quot;安徽省-蚌埠市-五河县&quot;: [117.887561, 33.132709],\n  &quot;安徽省-蚌埠市-固镇县&quot;: [117.323548, 33.323274],\n  &quot;安徽省-淮南市&quot;: [117.006389, 32.631847],\n  &quot;安徽省-淮南市-大通区&quot;: [117.059583, 32.63727],\n  &quot;安徽省-淮南市-田家庵区&quot;: [117.023445, 32.653323],\n  &quot;安徽省-淮南市-谢家集区&quot;: [116.865439, 32.606255],\n  &quot;安徽省-淮南市-八公山区&quot;: [116.840564, 32.637137],\n  &quot;安徽省-淮南市-潘集区&quot;: [116.841581, 32.777955],\n  &quot;安徽省-淮南市-凤台县&quot;: [116.717573, 32.715104],\n  &quot;安徽省-淮南市-寿县&quot;: [116.805563, 32.561546],\n  &quot;安徽省-马鞍山市&quot;: [118.51358, 31.676266],\n  &quot;安徽省-马鞍山市-花山区&quot;: [118.499606, 31.725473],\n  &quot;安徽省-马鞍山市-雨山区&quot;: [118.505597, 31.687745],\n  &quot;安徽省-马鞍山市-博望区&quot;: [118.504605, 31.576649],\n  &quot;安徽省-马鞍山市-当涂县&quot;: [118.504605, 31.576649],\n  &quot;安徽省-马鞍山市-含山县&quot;: [118.129204, 31.740485],\n  &quot;安徽省-马鞍山市-和县&quot;: [118.359513, 31.748244],\n  &quot;安徽省-淮北市&quot;: [116.804537, 33.961656],\n  &quot;安徽省-淮北市-杜集区&quot;: [116.834612, 33.997285],\n  &quot;安徽省-淮北市-相山区&quot;: [116.800521, 33.965827],\n  &quot;安徽省-淮北市-烈山区&quot;: [116.819599, 33.901574],\n  &quot;安徽省-淮北市-濉溪县&quot;: [116.772389, 33.921629],\n  &quot;安徽省-铜陵市&quot;: [117.818477, 30.951233],\n  &quot;安徽省-铜陵市-铜官区&quot;: [117.821457, 30.940386],\n  &quot;安徽省-铜陵市-义安区&quot;: [117.798568, 30.958512],\n  &quot;安徽省-铜陵市-郊区&quot;: [117.80755, 30.897741],\n  &quot;安徽省-铜陵市-枞阳县&quot;: [117.226437, 30.705671],\n  &quot;安徽省-安庆市&quot;: [117.063604, 30.530957],\n  &quot;安徽省-安庆市-迎江区&quot;: [117.097514, 30.517523],\n  &quot;安徽省-安庆市-大观区&quot;: [117.040538, 30.518232],\n  &quot;安徽省-安庆市-宜秀区&quot;: [116.993441, 30.619676],\n  &quot;安徽省-安庆市-怀宁县&quot;: [116.836593, 30.7394],\n  &quot;安徽省-安庆市-潜山县&quot;: [116.587611, 30.636756],\n  &quot;安徽省-安庆市-太湖县&quot;: [116.315476, 30.460113],\n  &quot;安徽省-安庆市-宿松县&quot;: [116.135524, 30.159787],\n  &quot;安徽省-安庆市-望江县&quot;: [116.70059, 30.129968],\n  &quot;安徽省-安庆市-岳西县&quot;: [116.366555, 30.855228],\n  &quot;安徽省-安庆市-桐城市&quot;: [116.980466, 31.041969],\n  &quot;安徽省-黄山市&quot;: [118.345437, 29.72189],\n  &quot;安徽省-黄山市-屯溪区&quot;: [118.321418, 29.702144],\n  &quot;安徽省-黄山市-黄山区&quot;: [118.14761, 30.278651],\n  &quot;安徽省-黄山市-徽州区&quot;: [118.343436, 29.834221],\n  &quot;安徽省-黄山市-歙县&quot;: [118.42146, 29.866288],\n  &quot;安徽省-黄山市-休宁县&quot;: [118.20543, 29.795459],\n  &quot;安徽省-黄山市-黟县&quot;: [117.944477, 29.931047],\n  &quot;安徽省-黄山市-祁门县&quot;: [117.723393, 29.860344],\n  &quot;安徽省-滁州市&quot;: [118.339406, 32.261271],\n  &quot;安徽省-滁州市-琅琊区&quot;: [118.312441, 32.300867],\n  &quot;安徽省-滁州市-南谯区&quot;: [118.423482, 32.206132],\n  &quot;安徽省-滁州市-来安县&quot;: [118.442412, 32.45845],\n  &quot;安徽省-滁州市-全椒县&quot;: [118.280584, 32.09194],\n  &quot;安徽省-滁州市-定远县&quot;: [117.704471, 32.537047],\n  &quot;安徽省-滁州市-凤阳县&quot;: [117.538585, 32.880977],\n  &quot;安徽省-滁州市-天长市&quot;: [118.950489, 32.794116],\n  &quot;安徽省-滁州市-明光市&quot;: [117.99551, 32.783023],\n  &quot;安徽省-阜阳市&quot;: [115.820436, 32.896061],\n  &quot;安徽省-阜阳市-颍州区&quot;: [115.813411, 32.889625],\n  &quot;安徽省-阜阳市-颍东区&quot;: [115.863617, 32.917362],\n  &quot;安徽省-阜阳市-颍泉区&quot;: [115.815426, 32.931314],\n  &quot;安徽省-阜阳市-临泉县&quot;: [115.267616, 33.04596],\n  &quot;安徽省-阜阳市-太和县&quot;: [115.628615, 33.16596],\n  &quot;安徽省-阜阳市-阜南县&quot;: [115.602546, 32.664097],\n  &quot;安徽省-阜阳市-颍上县&quot;: [116.263477, 32.659028],\n  &quot;安徽省-阜阳市-界首市&quot;: [115.38061, 33.262775],\n  &quot;安徽省-宿州市&quot;: [116.970544, 33.652095],\n  &quot;安徽省-宿州市-埇桥区&quot;: [116.98348, 33.646131],\n  &quot;安徽省-宿州市-砀山县&quot;: [116.372524, 34.448428],\n  &quot;安徽省-宿州市-萧县&quot;: [116.953585, 34.194269],\n  &quot;安徽省-宿州市-灵璧县&quot;: [117.564557, 33.547892],\n  &quot;安徽省-宿州市-泗县&quot;: [117.91659, 33.488695],\n  &quot;安徽省-六安市&quot;: [116.52641, 31.741451],\n  &quot;安徽省-六安市-金安区&quot;: [116.545438, 31.756288],\n  &quot;安徽省-六安市-裕安区&quot;: [116.48655, 31.743626],\n  &quot;安徽省-六安市-叶集区&quot;: [115.947476, 31.835263],\n  &quot;安徽省-六安市-霍邱县&quot;: [115.947476, 31.835263],\n  &quot;安徽省-六安市-舒城县&quot;: [116.955602, 31.467692],\n  &quot;安徽省-六安市-金寨县&quot;: [115.940441, 31.733462],\n  &quot;安徽省-六安市-霍山县&quot;: [116.339576, 31.398571],\n  &quot;安徽省-亳州市&quot;: [115.784463, 33.850643],\n  &quot;安徽省-亳州市-谯城区&quot;: [115.785472, 33.882663],\n  &quot;安徽省-亳州市-涡阳县&quot;: [116.221609, 33.498567],\n  &quot;安徽省-亳州市-蒙城县&quot;: [116.571589, 33.271658],\n  &quot;安徽省-亳州市-利辛县&quot;: [116.191494, 33.155596],\n  &quot;安徽省-池州市&quot;: [117.498421, 30.670884],\n  &quot;安徽省-池州市-贵池区&quot;: [117.57449, 30.693858],\n  &quot;安徽省-池州市-东至县&quot;: [117.034481, 30.116535],\n  &quot;安徽省-池州市-石台县&quot;: [117.492394, 30.21653],\n  &quot;安徽省-池州市-青阳县&quot;: [117.853431, 30.645634],\n  &quot;安徽省-宣城市&quot;: [118.765534, 30.946602],\n  &quot;安徽省-宣城市-宣州区&quot;: [118.762549, 30.952158],\n  &quot;安徽省-宣城市-郎溪县&quot;: [119.186466, 31.132682],\n  &quot;安徽省-宣城市-广德县&quot;: [119.427476, 30.883667],\n  &quot;安徽省-宣城市-泾县&quot;: [118.426435, 30.694672],\n  &quot;安徽省-宣城市-绩溪县&quot;: [118.585444, 30.073292],\n  &quot;安徽省-宣城市-旌德县&quot;: [118.546467, 30.292481],\n  &quot;安徽省-宣城市-宁国市&quot;: [118.98961, 30.639352],\n  &quot;福建省&quot;: [119.302447, 26.106339],\n  &quot;福建省-福州市&quot;: [119.30347, 26.080429],\n  &quot;福建省-福州市-鼓楼区&quot;: [119.310492, 26.088114],\n  &quot;福建省-福州市-台江区&quot;: [119.320528, 26.058528],\n  &quot;福建省-福州市-仓山区&quot;: [119.280432, 26.052842],\n  &quot;福建省-福州市-马尾区&quot;: [119.445519, 26.004534],\n  &quot;福建省-福州市-晋安区&quot;: [119.334579, 26.087214],\n  &quot;福建省-福州市-闽侯县&quot;: [119.138482, 26.156035],\n  &quot;福建省-福州市-连江县&quot;: [119.546479, 26.203583],\n  &quot;福建省-福州市-罗源县&quot;: [119.55648, 26.495496],\n  &quot;福建省-福州市-闽清县&quot;: [118.869577, 26.226848],\n  &quot;福建省-福州市-永泰县&quot;: [118.938431, 25.872787],\n  &quot;福建省-福州市-平潭县&quot;: [119.796501, 25.5047],\n  &quot;福建省-福州市-福清市&quot;: [119.390465, 25.726343],\n  &quot;福建省-福州市-长乐市&quot;: [119.529438, 25.969257],\n  &quot;福建省-厦门市&quot;: [118.096435, 24.485407],\n  &quot;福建省-厦门市-思明区&quot;: [118.088408, 24.451948],\n  &quot;福建省-厦门市-海沧区&quot;: [118.039562, 24.490326],\n  &quot;福建省-厦门市-湖里区&quot;: [118.153588, 24.517573],\n  &quot;福建省-厦门市-集美区&quot;: [118.103435, 24.582019],\n  &quot;福建省-厦门市-同安区&quot;: [118.158563, 24.729114],\n  &quot;福建省-厦门市-翔安区&quot;: [118.254576, 24.624216],\n  &quot;福建省-莆田市&quot;: [119.014521, 25.459865],\n  &quot;福建省-莆田市-城厢区&quot;: [119.001536, 25.424344],\n  &quot;福建省-莆田市-涵江区&quot;: [119.122567, 25.464464],\n  &quot;福建省-莆田市-荔城区&quot;: [119.019482, 25.439754],\n  &quot;福建省-莆田市-秀屿区&quot;: [119.111571, 25.323654],\n  &quot;福建省-莆田市-仙游县&quot;: [118.698454, 25.368291],\n  &quot;福建省-三明市&quot;: [117.645521, 26.269737],\n  &quot;福建省-三明市-梅列区&quot;: [117.65255, 26.277336],\n  &quot;福建省-三明市-三元区&quot;: [117.614415, 26.240219],\n  &quot;福建省-三明市-明溪县&quot;: [117.208518, 26.361854],\n  &quot;福建省-三明市-清流县&quot;: [116.823593, 26.183357],\n  &quot;福建省-三明市-宁化县&quot;: [116.660426, 26.267956],\n  &quot;福建省-三明市-大田县&quot;: [117.85344, 25.698933],\n  &quot;福建省-三明市-尤溪县&quot;: [118.19744, 26.176218],\n  &quot;福建省-三明市-沙县&quot;: [117.798561, 26.402813],\n  &quot;福建省-三明市-将乐县&quot;: [117.477409, 26.73521],\n  &quot;福建省-三明市-泰宁县&quot;: [117.182596, 26.90566],\n  &quot;福建省-三明市-建宁县&quot;: [116.852506, 26.836825],\n  &quot;福建省-三明市-永安市&quot;: [117.371443, 25.948144],\n  &quot;福建省-泉州市&quot;: [118.682446, 24.879952],\n  &quot;福建省-泉州市-鲤城区&quot;: [118.593481, 24.913354],\n  &quot;福建省-泉州市-丰泽区&quot;: [118.61958, 24.89497],\n  &quot;福建省-泉州市-洛江区&quot;: [118.677416, 24.946214],\n  &quot;福建省-泉州市-泉港区&quot;: [118.922433, 25.13965],\n  &quot;福建省-泉州市-惠安县&quot;: [118.803416, 25.03695],\n  &quot;福建省-泉州市-安溪县&quot;: [118.192425, 25.06176],\n  &quot;福建省-泉州市-永春县&quot;: [118.300486, 25.327974],\n  &quot;福建省-泉州市-德化县&quot;: [118.24755, 25.497309],\n  &quot;福建省-泉州市-金门县&quot;: [118.330415, 24.440445],\n  &quot;福建省-泉州市-石狮市&quot;: [118.654519, 24.737665],\n  &quot;福建省-泉州市-晋江市&quot;: [118.558431, 24.787825],\n  &quot;福建省-泉州市-南安市&quot;: [118.392572, 24.966362],\n  &quot;福建省-漳州市&quot;: [117.653576, 24.51893],\n  &quot;福建省-漳州市-芗城区&quot;: [117.66059, 24.516268],\n  &quot;福建省-漳州市-龙文区&quot;: [117.716455, 24.50951],\n  &quot;福建省-漳州市-云霄县&quot;: [117.346448, 23.964073],\n  &quot;福建省-漳州市-漳浦县&quot;: [117.620443, 24.123462],\n  &quot;福建省-漳州市-诏安县&quot;: [117.182559, 23.717054],\n  &quot;福建省-漳州市-长泰县&quot;: [117.765553, 24.631244],\n  &quot;福建省-漳州市-东山县&quot;: [117.43656, 23.706895],\n  &quot;福建省-漳州市-南靖县&quot;: [117.363446, 24.520852],\n  &quot;福建省-漳州市-平和县&quot;: [117.322552, 24.368365],\n  &quot;福建省-漳州市-华安县&quot;: [117.540586, 25.010068],\n  &quot;福建省-漳州市-龙海市&quot;: [117.824451, 24.45294],\n  &quot;福建省-南平市&quot;: [118.0595, 27.292158],\n  &quot;福建省-南平市-延平区&quot;: [118.188451, 26.643808],\n  &quot;福建省-南平市-建阳区&quot;: [118.127525, 27.337502],\n  &quot;福建省-南平市-顺昌县&quot;: [117.816519, 26.799104],\n  &quot;福建省-南平市-浦城县&quot;: [118.547439, 27.92339],\n  &quot;福建省-南平市-光泽县&quot;: [117.340482, 27.547273],\n  &quot;福建省-南平市-松溪县&quot;: [118.791454, 27.532555],\n  &quot;福建省-南平市-政和县&quot;: [118.863587, 27.371749],\n  &quot;福建省-南平市-邵武市&quot;: [117.49942, 27.34647],\n  &quot;福建省-南平市-武夷山市&quot;: [118.041577, 27.762554],\n  &quot;福建省-南平市-建瓯市&quot;: [118.311461, 27.028955],\n  &quot;福建省-龙岩市&quot;: [117.023448, 25.08122],\n  &quot;福建省-龙岩市-新罗区&quot;: [117.043543, 25.104078],\n  &quot;福建省-龙岩市-永定区&quot;: [116.892447, 24.869137],\n  &quot;福建省-龙岩市-长汀县&quot;: [116.363568, 25.839185],\n  &quot;福建省-龙岩市-上杭县&quot;: [116.426443, 25.05557],\n  &quot;福建省-龙岩市-武平县&quot;: [116.107589, 25.100855],\n  &quot;福建省-龙岩市-连城县&quot;: [116.760446, 25.716337],\n  &quot;福建省-龙岩市-漳平市&quot;: [117.426556, 25.295743],\n  &quot;福建省-宁德市&quot;: [119.554511, 26.672242],\n  &quot;福建省-宁德市-蕉城区&quot;: [119.533442, 26.666739],\n  &quot;福建省-宁德市-霞浦县&quot;: [120.011427, 26.891349],\n  &quot;福建省-宁德市-古田县&quot;: [118.752578, 26.583262],\n  &quot;福建省-宁德市-屏南县&quot;: [118.992596, 26.914265],\n  &quot;福建省-宁德市-寿宁县&quot;: [119.511425, 27.46665],\n  &quot;福建省-宁德市-周宁县&quot;: [119.345567, 27.110239],\n  &quot;福建省-宁德市-柘荣县&quot;: [119.907457, 27.239962],\n  &quot;福建省-宁德市-福安市&quot;: [119.654406, 27.094324],\n  &quot;福建省-宁德市-福鼎市&quot;: [120.223452, 27.330525],\n  &quot;江西省&quot;: [115.915423, 28.681691],\n  &quot;江西省-南昌市&quot;: [115.864589, 28.689455],\n  &quot;江西省-南昌市-东湖区&quot;: [115.905466, 28.691259],\n  &quot;江西省-南昌市-西湖区&quot;: [115.883536, 28.661977],\n  &quot;江西省-南昌市-青云谱区&quot;: [115.931416, 28.627236],\n  &quot;江西省-南昌市-湾里区&quot;: [115.737596, 28.720195],\n  &quot;江西省-南昌市-青山湖区&quot;: [115.968552, 28.687596],\n  &quot;江西省-南昌市-新建区&quot;: [115.821451, 28.698749],\n  &quot;江西省-南昌市-南昌县&quot;: [115.95046, 28.551604],\n  &quot;江西省-南昌市-安义县&quot;: [115.555441, 28.850794],\n  &quot;江西省-南昌市-进贤县&quot;: [116.248538, 28.382759],\n  &quot;江西省-景德镇市&quot;: [117.184576, 29.274248],\n  &quot;江西省-景德镇市-昌江区&quot;: [117.190579, 29.278854],\n  &quot;江西省-景德镇市-珠山区&quot;: [117.209548, 29.305778],\n  &quot;江西省-景德镇市-浮梁县&quot;: [117.221466, 29.357788],\n  &quot;江西省-景德镇市-乐平市&quot;: [117.158511, 28.984364],\n  &quot;江西省-萍乡市&quot;: [113.861496, 27.628393],\n  &quot;江西省-萍乡市-安源区&quot;: [113.87744, 27.621308],\n  &quot;江西省-萍乡市-湘东区&quot;: [113.7405, 27.645875],\n  &quot;江西省-萍乡市-莲花县&quot;: [113.968541, 27.133463],\n  &quot;江西省-萍乡市-上栗县&quot;: [113.801538, 27.886416],\n  &quot;江西省-萍乡市-芦溪县&quot;: [114.036519, 27.636605],\n  &quot;江西省-九江市&quot;: [116.007535, 29.711341],\n  &quot;江西省-九江市-濂溪区&quot;: [115.995599, 29.677495],\n  &quot;江西省-九江市-浔阳区&quot;: [115.996558, 29.733094],\n  &quot;江西省-九江市-九江县&quot;: [115.917402, 29.614805],\n  &quot;江西省-九江市-武宁县&quot;: [115.107442, 29.262352],\n  &quot;江西省-九江市-修水县&quot;: [114.553568, 29.031176],\n  &quot;江西省-九江市-永修县&quot;: [115.815407, 29.028006],\n  &quot;江西省-九江市-德安县&quot;: [115.762578, 29.319172],\n  &quot;江西省-九江市-都昌县&quot;: [116.210552, 29.278965],\n  &quot;江西省-九江市-湖口县&quot;: [116.258471, 29.737132],\n  &quot;江西省-九江市-彭泽县&quot;: [116.55551, 29.902122],\n  &quot;江西省-九江市-瑞昌市&quot;: [115.68743, 29.681951],\n  &quot;江西省-九江市-共青城市&quot;: [115.762578, 29.319172],\n  &quot;江西省-九江市-庐山市&quot;: [116.051426, 29.454539],\n  &quot;江西省-新余市&quot;: [114.923535, 27.823579],\n  &quot;江西省-新余市-渝水区&quot;: [114.951424, 27.80684],\n  &quot;江西省-新余市-分宜县&quot;: [114.698472, 27.820731],\n  &quot;江西省-鹰潭市&quot;: [117.075575, 28.265787],\n  &quot;江西省-鹰潭市-月湖区&quot;: [117.043548, 28.245078],\n  &quot;江西省-鹰潭市-余江县&quot;: [116.824594, 28.215354],\n  &quot;江西省-鹰潭市-贵溪市&quot;: [117.251399, 28.298735],\n  &quot;江西省-赣州市&quot;: [114.940503, 25.835176],\n  &quot;江西省-赣州市-章贡区&quot;: [114.927551, 25.823747],\n  &quot;江西省-赣州市-南康区&quot;: [114.771538, 25.667053],\n  &quot;江西省-赣州市-赣县&quot;: [115.01857, 25.866385],\n  &quot;江西省-赣州市-信丰县&quot;: [114.929521, 25.391975],\n  &quot;江西省-赣州市-大余县&quot;: [114.368407, 25.407637],\n  &quot;江西省-赣州市-上犹县&quot;: [114.558549, 25.790519],\n  &quot;江西省-赣州市-崇义县&quot;: [114.314572, 25.687687],\n  &quot;江西省-赣州市-安远县&quot;: [115.400559, 25.142743],\n  &quot;江西省-赣州市-龙南县&quot;: [114.796554, 24.916599],\n  &quot;江西省-赣州市-定南县&quot;: [115.034564, 24.789784],\n  &quot;江西省-赣州市-全南县&quot;: [114.536582, 24.748206],\n  &quot;江西省-赣州市-宁都县&quot;: [116.015494, 26.47598],\n  &quot;江西省-赣州市-于都县&quot;: [115.421499, 25.957894],\n  &quot;江西省-赣州市-兴国县&quot;: [115.369552, 26.343883],\n  &quot;江西省-赣州市-会昌县&quot;: [115.79246, 25.606662],\n  &quot;江西省-赣州市-寻乌县&quot;: [115.653515, 24.969447],\n  &quot;江西省-赣州市-石城县&quot;: [116.352594, 26.318972],\n  &quot;江西省-赣州市-瑞金市&quot;: [116.033421, 25.891666],\n  &quot;江西省-吉安市&quot;: [115.000511, 27.119727],\n  &quot;江西省-吉安市-吉州区&quot;: [115.001539, 27.149315],\n  &quot;江西省-吉安市-青原区&quot;: [115.021561, 27.087663],\n  &quot;江西省-吉安市-吉安县&quot;: [114.914591, 27.044989],\n  &quot;江西省-吉安市-吉水县&quot;: [115.14257, 27.23526],\n  &quot;江西省-吉安市-峡江县&quot;: [115.322403, 27.588235],\n  &quot;江西省-吉安市-新干县&quot;: [115.393595, 27.746081],\n  &quot;江西省-吉安市-永丰县&quot;: [115.447402, 27.324342],\n  &quot;江西省-吉安市-泰和县&quot;: [114.915591, 26.795697],\n  &quot;江西省-吉安市-遂川县&quot;: [114.527562, 26.319517],\n  &quot;江西省-吉安市-万安县&quot;: [114.792577, 26.464073],\n  &quot;江西省-吉安市-安福县&quot;: [114.626478, 27.399076],\n  &quot;江西省-吉安市-永新县&quot;: [114.249415, 26.951537],\n  &quot;江西省-吉安市-井冈山市&quot;: [114.295556, 26.75371],\n  &quot;江西省-宜春市&quot;: [114.423564, 27.820856],\n  &quot;江西省-宜春市-袁州区&quot;: [114.434561, 27.802583],\n  &quot;江西省-宜春市-奉新县&quot;: [115.406551, 28.694029],\n  &quot;江西省-宜春市-万载县&quot;: [114.452537, 28.112133],\n  &quot;江西省-宜春市-上高县&quot;: [114.931541, 28.238815],\n  &quot;江西省-宜春市-宜丰县&quot;: [114.700858, 28.400373],\n  &quot;江西省-宜春市-靖安县&quot;: [115.369553, 28.867082],\n  &quot;江西省-宜春市-铜鼓县&quot;: [114.377411, 28.527083],\n  &quot;江西省-宜春市-丰城市&quot;: [115.777478, 28.166614],\n  &quot;江西省-宜春市-樟树市&quot;: [115.552419, 28.062153],\n  &quot;江西省-宜春市-高安市&quot;: [115.382565, 28.422857],\n  &quot;江西省-抚州市&quot;: [116.364539, 27.954892],\n  &quot;江西省-抚州市-临川区&quot;: [116.31849, 27.940459],\n  &quot;江西省-抚州市-南城县&quot;: [116.643399, 27.576241],\n  &quot;江西省-抚州市-黎川县&quot;: [116.914507, 27.28834],\n  &quot;江西省-抚州市-南丰县&quot;: [116.531404, 27.224734],\n  &quot;江西省-抚州市-崇仁县&quot;: [116.083549, 27.75908],\n  &quot;江西省-抚州市-乐安县&quot;: [115.837496, 27.43408],\n  &quot;江西省-抚州市-宜黄县&quot;: [116.242542, 27.560563],\n  &quot;江西省-抚州市-金溪县&quot;: [116.760404, 27.925329],\n  &quot;江西省-抚州市-资溪县&quot;: [117.06657, 27.711846],\n  &quot;江西省-抚州市-东乡县&quot;: [116.609542, 28.253977],\n  &quot;江西省-抚州市-广昌县&quot;: [116.342561, 26.848454],\n  &quot;江西省-上饶市&quot;: [117.94946, 28.460626],\n  &quot;江西省-上饶市-信州区&quot;: [117.973412, 28.437628],\n  &quot;江西省-上饶市-广丰区&quot;: [118.19742, 28.442615],\n  &quot;江西省-上饶市-上饶县&quot;: [117.915584, 28.454187],\n  &quot;江西省-上饶市-玉山县&quot;: [118.251563, 28.68775],\n  &quot;江西省-上饶市-铅山县&quot;: [117.716422, 28.321505],\n  &quot;江西省-上饶市-横峰县&quot;: [117.602397, 28.41344],\n  &quot;江西省-上饶市-弋阳县&quot;: [117.455506, 28.384082],\n  &quot;江西省-上饶市-余干县&quot;: [116.701601, 28.707866],\n  &quot;江西省-上饶市-鄱阳县&quot;: [116.710566, 29.011453],\n  &quot;江西省-上饶市-万年县&quot;: [117.064599, 28.700054],\n  &quot;江西省-上饶市-婺源县&quot;: [117.868445, 29.254039],\n  &quot;江西省-上饶市-德兴市&quot;: [117.58548, 28.952565],\n  &quot;山东省&quot;: [117.027442, 36.674857],\n  &quot;山东省-济南市&quot;: [117.126399, 36.656554],\n  &quot;山东省-济南市-历下区&quot;: [117.082567, 36.672163],\n  &quot;山东省-济南市-市中区&quot;: [117.004399, 36.657552],\n  &quot;山东省-济南市-槐荫区&quot;: [116.907458, 36.657562],\n  &quot;山东省-济南市-天桥区&quot;: [116.993399, 36.684068],\n  &quot;山东省-济南市-历城区&quot;: [117.07159, 36.685656],\n  &quot;山东省-济南市-长清区&quot;: [116.758387, 36.560216],\n  &quot;山东省-济南市-平阴县&quot;: [116.462617, 36.294861],\n  &quot;山东省-济南市-济阳县&quot;: [117.180621, 36.983971],\n  &quot;山东省-济南市-商河县&quot;: [117.16353, 37.314971],\n  &quot;山东省-济南市-章丘市&quot;: [117.532565, 36.685533],\n  &quot;山东省-青岛市&quot;: [120.389455, 36.072227],\n  &quot;山东省-青岛市-市南区&quot;: [120.418585, 36.081466],\n  &quot;山东省-青岛市-市北区&quot;: [120.381404, 36.09345],\n  &quot;山东省-青岛市-黄岛区&quot;: [120.204547, 35.966383],\n  &quot;山东省-青岛市-崂山区&quot;: [120.475397, 36.113499],\n  &quot;山东省-青岛市-李沧区&quot;: [120.439603, 36.151025],\n  &quot;山东省-青岛市-城阳区&quot;: [120.402527, 36.312886],\n  &quot;山东省-青岛市-胶州市&quot;: [120.039535, 36.270349],\n  &quot;山东省-青岛市-即墨市&quot;: [120.453536, 36.394749],\n  &quot;山东省-青岛市-平度市&quot;: [119.994414, 36.782692],\n  &quot;山东省-青岛市-莱西市&quot;: [120.524556, 36.893956],\n  &quot;山东省-淄博市&quot;: [118.061453, 36.819086],\n  &quot;山东省-淄博市-淄川区&quot;: [117.973412, 36.649835],\n  &quot;山东省-淄博市-张店区&quot;: [118.024591, 36.811942],\n  &quot;山东省-淄博市-博山区&quot;: [117.868469, 36.500848],\n  &quot;山东省-淄博市-临淄区&quot;: [118.315395, 36.832294],\n  &quot;山东省-淄博市-周村区&quot;: [117.876482, 36.808994],\n  &quot;山东省-淄博市-桓台县&quot;: [118.104434, 36.965608],\n  &quot;山东省-淄博市-高青县&quot;: [117.833394, 37.177269],\n  &quot;山东省-淄博市-沂源县&quot;: [118.177489, 36.190917],\n  &quot;山东省-枣庄市&quot;: [117.330542, 34.815994],\n  &quot;山东省-枣庄市-市中区&quot;: [117.562566, 34.869963],\n  &quot;山东省-枣庄市-薛城区&quot;: [117.269458, 34.801125],\n  &quot;山东省-枣庄市-峄城区&quot;: [117.596391, 34.7786],\n  &quot;山东省-枣庄市-台儿庄区&quot;: [117.740425, 34.568763],\n  &quot;山东省-枣庄市-山亭区&quot;: [117.467443, 35.105692],\n  &quot;山东省-枣庄市-滕州市&quot;: [117.172565, 35.120035],\n  &quot;山东省-东营市&quot;: [118.681385, 37.439642],\n  &quot;山东省-东营市-东营区&quot;: [118.588463, 37.454847],\n  &quot;山东省-东营市-河口区&quot;: [118.532505, 37.89112],\n  &quot;山东省-东营市-垦利区&quot;: [118.581432, 37.578555],\n  &quot;山东省-东营市-利津县&quot;: [118.261618, 37.49586],\n  &quot;山东省-东营市-广饶县&quot;: [118.413499, 37.059638],\n  &quot;山东省-烟台市&quot;: [121.454415, 37.470038],\n  &quot;山东省-烟台市-芝罘区&quot;: [121.40654, 37.546313],\n  &quot;山东省-烟台市-福山区&quot;: [121.274605, 37.503668],\n  &quot;山东省-烟台市-牟平区&quot;: [121.606549, 37.392915],\n  &quot;山东省-烟台市-莱山区&quot;: [121.451381, 37.517649],\n  &quot;山东省-烟台市-长岛县&quot;: [120.74343, 37.927628],\n  &quot;山东省-烟台市-龙口市&quot;: [120.485369, 37.652555],\n  &quot;山东省-烟台市-莱阳市&quot;: [120.718414, 36.984636],\n  &quot;山东省-烟台市-莱州市&quot;: [119.948593, 37.182637],\n  &quot;山东省-烟台市-蓬莱市&quot;: [120.765562, 37.816439],\n  &quot;山东省-烟台市-招远市&quot;: [120.440602, 37.361137],\n  &quot;山东省-烟台市-栖霞市&quot;: [120.856417, 37.341418],\n  &quot;山东省-烟台市-海阳市&quot;: [121.180458, 36.69327],\n  &quot;山东省-潍坊市&quot;: [119.168378, 36.712652],\n  &quot;山东省-潍坊市-潍城区&quot;: [119.031429, 36.732854],\n  &quot;山东省-潍坊市-寒亭区&quot;: [119.226615, 36.780744],\n  &quot;山东省-潍坊市-坊子区&quot;: [119.172401, 36.660742],\n  &quot;山东省-潍坊市-奎文区&quot;: [119.139471, 36.712752],\n  &quot;山东省-潍坊市-临朐县&quot;: [118.54945, 36.51913],\n  &quot;山东省-潍坊市-昌乐县&quot;: [118.836488, 36.712996],\n  &quot;山东省-潍坊市-青州市&quot;: [118.486537, 36.690417],\n  &quot;山东省-潍坊市-诸城市&quot;: [119.416402, 36.002009],\n  &quot;山东省-潍坊市-寿光市&quot;: [118.797415, 36.861922],\n  &quot;山东省-潍坊市-安丘市&quot;: [119.225608, 36.483842],\n  &quot;山东省-潍坊市-高密市&quot;: [119.762411, 36.388957],\n  &quot;山东省-潍坊市-昌邑市&quot;: [119.404406, 36.865161],\n  &quot;山东省-济宁市&quot;: [116.593612, 35.420177],\n  &quot;山东省-济宁市-任城区&quot;: [116.55447, 35.493731],\n  &quot;山东省-济宁市-兖州区&quot;: [116.805536, 35.599737],\n  &quot;山东省-济宁市-微山县&quot;: [117.135414, 34.813315],\n  &quot;山东省-济宁市-鱼台县&quot;: [116.657393, 35.017888],\n  &quot;山东省-济宁市-金乡县&quot;: [116.31853, 35.072569],\n  &quot;山东省-济宁市-嘉祥县&quot;: [116.348613, 35.413255],\n  &quot;山东省-济宁市-汶上县&quot;: [116.505441, 35.717055],\n  &quot;山东省-济宁市-泗水县&quot;: [117.257429, 35.6706],\n  &quot;山东省-济宁市-梁山县&quot;: [116.10262, 35.808064],\n  &quot;山东省-济宁市-曲阜市&quot;: [116.993416, 35.587372],\n  &quot;山东省-济宁市-邹城市&quot;: [117.014404, 35.407521],\n  &quot;山东省-泰安市&quot;: [117.094495, 36.205858],\n  &quot;山东省-泰安市-泰山区&quot;: [117.141411, 36.199445],\n  &quot;山东省-泰安市-岱岳区&quot;: [117.048556, 36.193291],\n  &quot;山东省-泰安市-宁阳县&quot;: [116.812579, 35.764539],\n  &quot;山东省-泰安市-东平县&quot;: [116.477594, 35.941908],\n  &quot;山东省-泰安市-新泰市&quot;: [117.774606, 35.91462],\n  &quot;山东省-泰安市-肥城市&quot;: [116.775401, 36.188811],\n  &quot;山东省-威海市&quot;: [122.127541, 37.516431],\n  &quot;山东省-威海市-环翠区&quot;: [122.129538, 37.507968],\n  &quot;山东省-威海市-文登区&quot;: [122.064428, 37.200113],\n  &quot;山东省-威海市-荣成市&quot;: [122.492505, 37.171318],\n  &quot;山东省-威海市-乳山市&quot;: [121.546429, 36.925177],\n  &quot;山东省-日照市&quot;: [119.533415, 35.422839],\n  &quot;山东省-日照市-东港区&quot;: [119.468624, 35.431049],\n  &quot;山东省-日照市-岚山区&quot;: [119.32553, 35.127432],\n  &quot;山东省-日照市-五莲县&quot;: [119.21558, 35.755697],\n  &quot;山东省-日照市-莒县&quot;: [118.843538, 35.585872],\n  &quot;山东省-莱芜市&quot;: [117.68355, 36.219472],\n  &quot;山东省-莱芜市-莱城区&quot;: [117.666591, 36.208841],\n  &quot;山东省-莱芜市-钢城区&quot;: [117.817496, 36.064719],\n  &quot;山东省-临沂市&quot;: [118.363533, 35.110671],\n  &quot;山东省-临沂市-兰山区&quot;: [118.3545, 35.05734],\n  &quot;山东省-临沂市-罗庄区&quot;: [118.291513, 35.002504],\n  &quot;山东省-临沂市-河东区&quot;: [118.409547, 35.095676],\n  &quot;山东省-临沂市-沂南县&quot;: [118.471492, 35.556098],\n  &quot;山东省-临沂市-郯城县&quot;: [118.373587, 34.619226],\n  &quot;山东省-临沂市-沂水县&quot;: [118.634617, 35.796181],\n  &quot;山东省-临沂市-兰陵县&quot;: [118.077409, 34.863616],\n  &quot;山东省-临沂市-费县&quot;: [117.984425, 35.272304],\n  &quot;山东省-临沂市-平邑县&quot;: [117.646541, 35.51202],\n  &quot;山东省-临沂市-莒南县&quot;: [118.841541, 35.180812],\n  &quot;山东省-临沂市-蒙阴县&quot;: [117.951415, 35.716347],\n  &quot;山东省-临沂市-临沭县&quot;: [118.657495, 34.926019],\n  &quot;山东省-德州市&quot;: [116.365557, 37.441308],\n  &quot;山东省-德州市-德城区&quot;: [116.305449, 37.456993],\n  &quot;山东省-德州市-陵城区&quot;: [116.77141, 37.476844],\n  &quot;山东省-德州市-宁津县&quot;: [116.806538, 37.658019],\n  &quot;山东省-德州市-庆云县&quot;: [117.391452, 37.781585],\n  &quot;山东省-德州市-临邑县&quot;: [116.873404, 37.196169],\n  &quot;山东省-德州市-齐河县&quot;: [116.769387, 36.789945],\n  &quot;山东省-德州市-平原县&quot;: [116.440505, 37.171221],\n  &quot;山东省-德州市-夏津县&quot;: [116.008534, 36.954155],\n  &quot;山东省-德州市-武城县&quot;: [116.075506, 37.219222],\n  &quot;山东省-德州市-乐陵市&quot;: [117.238406, 37.735925],\n  &quot;山东省-德州市-禹城市&quot;: [116.644371, 36.940242],\n  &quot;山东省-聊城市&quot;: [115.991588, 36.462758],\n  &quot;山东省-聊城市-东昌府区&quot;: [115.994587, 36.440378],\n  &quot;山东省-聊城市-阳谷县&quot;: [115.798396, 36.120816],\n  &quot;山东省-聊城市-莘县&quot;: [115.677397, 36.239907],\n  &quot;山东省-聊城市-茌平县&quot;: [116.261455, 36.586785],\n  &quot;山东省-聊城市-东阿县&quot;: [116.254493, 36.340958],\n  &quot;山东省-聊城市-冠县&quot;: [115.449396, 36.490243],\n  &quot;山东省-聊城市-高唐县&quot;: [116.235604, 36.851591],\n  &quot;山东省-聊城市-临清市&quot;: [115.71147, 36.844289],\n  &quot;山东省-滨州市&quot;: [117.977404, 37.388196],\n  &quot;山东省-滨州市-滨城区&quot;: [118.026604, 37.436843],\n  &quot;山东省-滨州市-沾化区&quot;: [118.105454, 37.705298],\n  &quot;山东省-滨州市-惠民县&quot;: [117.51651, 37.495803],\n  &quot;山东省-滨州市-阳信县&quot;: [117.584437, 37.647338],\n  &quot;山东省-滨州市-无棣县&quot;: [117.632457, 37.777567],\n  &quot;山东省-滨州市-博兴县&quot;: [118.117493, 37.160477],\n  &quot;山东省-滨州市-邹平县&quot;: [117.749478, 36.870032],\n  &quot;山东省-菏泽市&quot;: [115.487545, 35.239407],\n  &quot;山东省-菏泽市-牡丹区&quot;: [115.423443, 35.257018],\n  &quot;山东省-菏泽市-定陶区&quot;: [115.579437, 35.077275],\n  &quot;山东省-菏泽市-曹县&quot;: [115.548457, 34.831809],\n  &quot;山东省-菏泽市-单县&quot;: [116.111584, 34.784658],\n  &quot;山东省-菏泽市-成武县&quot;: [115.896519, 34.958606],\n  &quot;山东省-菏泽市-巨野县&quot;: [116.210258, 35.402062],\n  &quot;山东省-菏泽市-郓城县&quot;: [115.950451, 35.605902],\n  &quot;山东省-菏泽市-鄄城县&quot;: [115.516607, 35.569204],\n  &quot;山东省-菏泽市-东明县&quot;: [115.096417, 35.295702],\n  &quot;河南省&quot;: [113.759384, 34.771713],\n  &quot;河南省-郑州市&quot;: [113.631419, 34.753439],\n  &quot;河南省-郑州市-中原区&quot;: [113.619476, 34.754451],\n  &quot;河南省-郑州市-二七区&quot;: [113.64641, 34.731045],\n  &quot;河南省-郑州市-管城回族区&quot;: [113.683525, 34.759674],\n  &quot;河南省-郑州市-金水区&quot;: [113.666448, 34.80607],\n  &quot;河南省-郑州市-上街区&quot;: [113.315497, 34.808819],\n  &quot;河南省-郑州市-惠济区&quot;: [113.623455, 34.87352],\n  &quot;河南省-郑州市-中牟县&quot;: [113.982485, 34.725011],\n  &quot;河南省-郑州市-巩义市&quot;: [113.028431, 34.754097],\n  &quot;河南省-郑州市-荥阳市&quot;: [113.389423, 34.793811],\n  &quot;河南省-郑州市-新密市&quot;: [113.397391, 34.545898],\n  &quot;河南省-郑州市-新郑市&quot;: [113.746434, 34.401766],\n  &quot;河南省-郑州市-登封市&quot;: [113.056423, 34.459697],\n  &quot;河南省-开封市&quot;: [114.314593, 34.802886],\n  &quot;河南省-开封市-龙亭区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-顺河回族区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-鼓楼区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-禹王台区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-金明区&quot;: [114.229635, 34.798756],\n  &quot;河南省-开封市-祥符区&quot;: [114.452186, 34.726004],\n  &quot;河南省-开封市-杞县&quot;: [114.789592, 34.554857],\n  &quot;河南省-开封市-通许县&quot;: [114.473436, 34.486772],\n  &quot;河南省-开封市-尉氏县&quot;: [114.199561, 34.417228],\n  &quot;河南省-开封市-兰考县&quot;: [114.827461, 34.828493],\n  &quot;河南省-洛阳市&quot;: [112.459421, 34.624263],\n  &quot;河南省-洛阳市-老城区&quot;: [112.476504, 34.689601],\n  &quot;河南省-洛阳市-西工区&quot;: [112.4344, 34.666768],\n  &quot;河南省-洛阳市-瀍河回族区&quot;: [112.506604, 34.685462],\n  &quot;河南省-洛阳市-涧西区&quot;: [112.402552, 34.663469],\n  &quot;河南省-洛阳市-吉利区&quot;: [112.595478, 34.907013],\n  &quot;河南省-洛阳市-洛龙区&quot;: [112.470469, 34.624705],\n  &quot;河南省-洛阳市-孟津县&quot;: [112.451418, 34.831732],\n  &quot;河南省-洛阳市-新安县&quot;: [112.14061, 34.734383],\n  &quot;河南省-洛阳市-栾川县&quot;: [111.622427, 33.791822],\n  &quot;河南省-洛阳市-嵩县&quot;: [112.092408, 34.140722],\n  &quot;河南省-洛阳市-汝阳县&quot;: [112.479503, 34.159843],\n  &quot;河南省-洛阳市-宜阳县&quot;: [112.179465, 34.541047],\n  &quot;河南省-洛阳市-洛宁县&quot;: [111.659587, 34.394985],\n  &quot;河南省-洛阳市-伊川县&quot;: [112.432407, 34.427646],\n  &quot;河南省-洛阳市-偃师市&quot;: [112.796421, 34.733797],\n  &quot;河南省-平顶山市&quot;: [113.199529, 33.772051],\n  &quot;河南省-平顶山市-新华区&quot;: [113.30044, 33.743657],\n  &quot;河南省-平顶山市-卫东区&quot;: [113.341611, 33.740376],\n  &quot;河南省-平顶山市-石龙区&quot;: [112.905455, 33.904754],\n  &quot;河南省-平顶山市-湛河区&quot;: [113.250515, 33.68579],\n  &quot;河南省-平顶山市-宝丰县&quot;: [113.061447, 33.874746],\n  &quot;河南省-平顶山市-叶县&quot;: [113.363582, 33.632492],\n  &quot;河南省-平顶山市-鲁山县&quot;: [112.914434, 33.744879],\n  &quot;河南省-平顶山市-郏县&quot;: [113.219606, 33.977486],\n  &quot;河南省-平顶山市-舞钢市&quot;: [113.53141, 33.299431],\n  &quot;河南省-平顶山市-汝州市&quot;: [112.85055, 34.172768],\n  &quot;河南省-安阳市&quot;: [114.3995, 36.105941],\n  &quot;河南省-安阳市-文峰区&quot;: [114.363374, 36.096833],\n  &quot;河南省-安阳市-北关区&quot;: [114.362382, 36.113132],\n  &quot;河南省-安阳市-殷都区&quot;: [114.309598, 36.115758],\n  &quot;河南省-安阳市-龙安区&quot;: [114.307593, 36.082753],\n  &quot;河南省-安阳市-安阳县&quot;: [114.238382, 36.218907],\n  &quot;河南省-安阳市-汤阴县&quot;: [114.363409, 35.927644],\n  &quot;河南省-安阳市-滑县&quot;: [114.525553, 35.581045],\n  &quot;河南省-安阳市-内黄县&quot;: [114.907589, 35.97695],\n  &quot;河南省-安阳市-林州市&quot;: [113.82559, 36.088853],\n  &quot;河南省-鹤壁市&quot;: [114.303594, 35.752357],\n  &quot;河南省-鹤壁市-鹤山区&quot;: [114.169555, 35.96028],\n  &quot;河南省-鹤壁市-山城区&quot;: [114.190621, 35.90337],\n  &quot;河南省-鹤壁市-淇滨区&quot;: [114.305591, 35.746953],\n  &quot;河南省-鹤壁市-浚县&quot;: [114.557608, 35.681917],\n  &quot;河南省-鹤壁市-淇县&quot;: [114.21549, 35.627277],\n  &quot;河南省-新乡市&quot;: [113.9336, 35.30964],\n  &quot;河南省-新乡市-红旗区&quot;: [113.881416, 35.310136],\n  &quot;河南省-新乡市-卫滨区&quot;: [113.872439, 35.308459],\n  &quot;河南省-新乡市-凤泉区&quot;: [113.912459, 35.375665],\n  &quot;河南省-新乡市-牧野区&quot;: [113.915513, 35.321023],\n  &quot;河南省-新乡市-新乡县&quot;: [113.811594, 35.196564],\n  &quot;河南省-新乡市-获嘉县&quot;: [113.663417, 35.265809],\n  &quot;河南省-新乡市-原阳县&quot;: [113.946624, 35.071164],\n  &quot;河南省-新乡市-延津县&quot;: [114.211512, 35.147807],\n  &quot;河南省-新乡市-封丘县&quot;: [114.425606, 35.046858],\n  &quot;河南省-新乡市-长垣县&quot;: [114.67561, 35.207198],\n  &quot;河南省-新乡市-卫辉市&quot;: [114.071601, 35.404069],\n  &quot;河南省-新乡市-辉县市&quot;: [113.811573, 35.467958],\n  &quot;河南省-焦作市&quot;: [113.248548, 35.220963],\n  &quot;河南省-焦作市-解放区&quot;: [113.237572, 35.24631],\n  &quot;河南省-焦作市-中站区&quot;: [113.189448, 35.242617],\n  &quot;河南省-焦作市-马村区&quot;: [113.328544, 35.261894],\n  &quot;河南省-焦作市-山阳区&quot;: [113.260484, 35.220272],\n  &quot;河南省-焦作市-修武县&quot;: [113.454582, 35.229323],\n  &quot;河南省-焦作市-博爱县&quot;: [113.070478, 35.177308],\n  &quot;河南省-焦作市-武陟县&quot;: [113.408396, 35.105838],\n  &quot;河南省-焦作市-温县&quot;: [113.086569, 34.946135],\n  &quot;河南省-焦作市-沁阳市&quot;: [112.957517, 35.093786],\n  &quot;河南省-焦作市-孟州市&quot;: [112.797395, 34.913598],\n  &quot;河南省-濮阳市&quot;: [115.035597, 35.767593],\n  &quot;河南省-濮阳市-华龙区&quot;: [115.080413, 35.783633],\n  &quot;河南省-濮阳市-清丰县&quot;: [115.110472, 35.891308],\n  &quot;河南省-濮阳市-南乐县&quot;: [115.211386, 36.076031],\n  &quot;河南省-濮阳市-范县&quot;: [115.510586, 35.857655],\n  &quot;河南省-濮阳市-台前县&quot;: [115.878568, 35.975013],\n  &quot;河南省-濮阳市-濮阳县&quot;: [115.035584, 35.717889],\n  &quot;河南省-许昌市&quot;: [113.858476, 34.041432],\n  &quot;河南省-许昌市-魏都区&quot;: [113.829596, 34.030861],\n  &quot;河南省-许昌市-许昌县&quot;: [113.829615, 34.129967],\n  &quot;河南省-许昌市-鄢陵县&quot;: [114.18562, 34.107963],\n  &quot;河南省-许昌市-襄城县&quot;: [113.513431, 33.856968],\n  &quot;河南省-许昌市-禹州市&quot;: [113.495505, 34.146082],\n  &quot;河南省-许昌市-长葛市&quot;: [113.774421, 34.223016],\n  &quot;河南省-漯河市&quot;: [114.023421, 33.587711],\n  &quot;河南省-漯河市-源汇区&quot;: [113.990414, 33.578423],\n  &quot;河南省-漯河市-郾城区&quot;: [114.013394, 33.593416],\n  &quot;河南省-漯河市-召陵区&quot;: [114.100467, 33.592468],\n  &quot;河南省-漯河市-舞阳县&quot;: [113.61549, 33.443578],\n  &quot;河南省-漯河市-临颍县&quot;: [113.937578, 33.832692],\n  &quot;河南省-三门峡市&quot;: [111.206533, 34.778327],\n  &quot;河南省-三门峡市-湖滨区&quot;: [111.195574, 34.775997],\n  &quot;河南省-三门峡市-陕州区&quot;: [111.109451, 34.726915],\n  &quot;河南省-三门峡市-渑池县&quot;: [111.768542, 34.773197],\n  &quot;河南省-三门峡市-卢氏县&quot;: [111.054564, 34.059925],\n  &quot;河南省-三门峡市-义马市&quot;: [111.880515, 34.753028],\n  &quot;河南省-三门峡市-灵宝市&quot;: [110.900408, 34.523143],\n  &quot;河南省-南阳市&quot;: [112.534501, 32.996562],\n  &quot;河南省-南阳市-宛城区&quot;: [112.546454, 33.00987],\n  &quot;河南省-南阳市-卧龙区&quot;: [112.541462, 32.992484],\n  &quot;河南省-南阳市-南召县&quot;: [112.435425, 33.496186],\n  &quot;河南省-南阳市-方城县&quot;: [113.018503, 33.260539],\n  &quot;河南省-南阳市-西峡县&quot;: [111.480398, 33.313316],\n  &quot;河南省-南阳市-镇平县&quot;: [112.241544, 33.039719],\n  &quot;河南省-南阳市-内乡县&quot;: [111.855425, 33.051203],\n  &quot;河南省-南阳市-淅川县&quot;: [111.497432, 33.144185],\n  &quot;河南省-南阳市-社旗县&quot;: [112.954493, 33.062237],\n  &quot;河南省-南阳市-唐河县&quot;: [112.813424, 32.687721],\n  &quot;河南省-南阳市-新野县&quot;: [112.36655, 32.526632],\n  &quot;河南省-南阳市-桐柏县&quot;: [113.434473, 32.385131],\n  &quot;河南省-南阳市-邓州市&quot;: [112.09342, 32.693917],\n  &quot;河南省-商丘市&quot;: [115.662449, 34.420202],\n  &quot;河南省-商丘市-梁园区&quot;: [115.620602, 34.449471],\n  &quot;河南省-商丘市-睢阳区&quot;: [115.659476, 34.394152],\n  &quot;河南省-商丘市-民权县&quot;: [115.154576, 34.652479],\n  &quot;河南省-商丘市-睢县&quot;: [115.078411, 34.451617],\n  &quot;河南省-商丘市-宁陵县&quot;: [115.320418, 34.466634],\n  &quot;河南省-商丘市-柘城县&quot;: [115.312435, 34.09736],\n  &quot;河南省-商丘市-虞城县&quot;: [115.834473, 34.405332],\n  &quot;河南省-商丘市-夏邑县&quot;: [116.137512, 34.243523],\n  &quot;河南省-商丘市-永城市&quot;: [116.455566, 33.934801],\n  &quot;河南省-信阳市&quot;: [114.097483, 32.153015],\n  &quot;河南省-信阳市-浉河区&quot;: [114.065581, 32.122554],\n  &quot;河南省-信阳市-平桥区&quot;: [114.132407, 32.107325],\n  &quot;河南省-信阳市-罗山县&quot;: [114.51953, 32.20915],\n  &quot;河南省-信阳市-光山县&quot;: [114.925533, 32.015907],\n  &quot;河南省-信阳市-新县&quot;: [114.885525, 31.649738],\n  &quot;河南省-信阳市-商城县&quot;: [115.413513, 31.804345],\n  &quot;河南省-信阳市-固始县&quot;: [115.660488, 32.174174],\n  &quot;河南省-信阳市-潢川县&quot;: [115.058471, 32.137531],\n  &quot;河南省-信阳市-淮滨县&quot;: [115.426439, 32.47947],\n  &quot;河南省-信阳市-息县&quot;: [114.747453, 32.348956],\n  &quot;河南省-周口市&quot;: [114.703483, 33.631829],\n  &quot;河南省-周口市-川汇区&quot;: [114.657602, 33.652997],\n  &quot;河南省-周口市-扶沟县&quot;: [114.40151, 34.065906],\n  &quot;河南省-周口市-西华县&quot;: [114.535597, 33.773215],\n  &quot;河南省-周口市-商水县&quot;: [114.618416, 33.548877],\n  &quot;河南省-周口市-沈丘县&quot;: [115.105455, 33.415691],\n  &quot;河南省-周口市-郸城县&quot;: [115.183478, 33.650828],\n  &quot;河南省-周口市-淮阳县&quot;: [114.892586, 33.737347],\n  &quot;河南省-周口市-太康县&quot;: [114.844384, 34.070038],\n  &quot;河南省-周口市-鹿邑县&quot;: [115.490585, 33.867173],\n  &quot;河南省-周口市-项城市&quot;: [114.881514, 33.473007],\n  &quot;河南省-驻马店市&quot;: [114.028471, 33.017842],\n  &quot;河南省-驻马店市-驿城区&quot;: [114.000387, 32.97952],\n  &quot;河南省-驻马店市-西平县&quot;: [114.027474, 33.393861],\n  &quot;河南省-驻马店市-上蔡县&quot;: [114.270487, 33.268511],\n  &quot;河南省-驻马店市-平舆县&quot;: [114.625429, 32.967982],\n  &quot;河南省-驻马店市-正阳县&quot;: [114.399497, 32.611641],\n  &quot;河南省-驻马店市-确山县&quot;: [114.032495, 32.808176],\n  &quot;河南省-驻马店市-泌阳县&quot;: [113.333558, 32.729731],\n  &quot;河南省-驻马店市-汝南县&quot;: [114.369409, 33.013141],\n  &quot;河南省-驻马店市-遂平县&quot;: [114.019441, 33.151971],\n  &quot;河南省-驻马店市-新蔡县&quot;: [114.992469, 32.755269],\n  &quot;河南省-济源市&quot;: [112.608581, 35.072907],\n  &quot;湖北省&quot;: [114.348441, 30.5516],\n  &quot;湖北省-武汉市&quot;: [114.311582, 30.598467],\n  &quot;湖北省-武汉市-江岸区&quot;: [114.316579, 30.605403],\n  &quot;湖北省-武汉市-江汉区&quot;: [114.277506, 30.607282],\n  &quot;湖北省-武汉市-硚口区&quot;: [114.22146, 30.587584],\n  &quot;湖北省-武汉市-汉阳区&quot;: [114.225446, 30.560052],\n  &quot;湖北省-武汉市-武昌区&quot;: [114.322549, 30.559567],\n  &quot;湖北省-武汉市-青山区&quot;: [114.391493, 30.646593],\n  &quot;湖北省-武汉市-洪山区&quot;: [114.350456, 30.506334],\n  &quot;湖北省-武汉市-东西湖区&quot;: [114.143459, 30.62592],\n  &quot;湖北省-武汉市-汉南区&quot;: [114.091515, 30.314809],\n  &quot;湖北省-武汉市-蔡甸区&quot;: [114.03548, 30.588114],\n  &quot;湖北省-武汉市-江夏区&quot;: [114.328551, 30.381564],\n  &quot;湖北省-武汉市-黄陂区&quot;: [114.382454, 30.887534],\n  &quot;湖北省-武汉市-新洲区&quot;: [114.807543, 30.847244],\n  &quot;湖北省-黄石市&quot;: [115.045533, 30.205208],\n  &quot;湖北省-黄石市-黄石港区&quot;: [115.072417, 30.229053],\n  &quot;湖北省-黄石市-西塞山区&quot;: [115.116481, 30.210695],\n  &quot;湖北省-黄石市-下陆区&quot;: [114.967416, 30.180046],\n  &quot;湖北省-黄石市-铁山区&quot;: [114.907571, 30.212251],\n  &quot;湖北省-黄石市-阳新县&quot;: [115.221427, 29.836542],\n  &quot;湖北省-黄石市-大冶市&quot;: [114.986436, 30.101668],\n  &quot;湖北省-十堰市&quot;: [110.80453, 32.635062],\n  &quot;湖北省-十堰市-茅箭区&quot;: [110.81958, 32.597287],\n  &quot;湖北省-十堰市-张湾区&quot;: [110.775424, 32.6584],\n  &quot;湖北省-十堰市-郧阳区&quot;: [110.818577, 32.840592],\n  &quot;湖北省-十堰市-郧西县&quot;: [110.432473, 32.999167],\n  &quot;湖北省-十堰市-竹山县&quot;: [110.235582, 32.230304],\n  &quot;湖北省-十堰市-竹溪县&quot;: [109.721542, 32.32412],\n  &quot;湖北省-十堰市-房县&quot;: [110.747462, 32.061685],\n  &quot;湖北省-十堰市-丹江口市&quot;: [111.519532, 32.546253],\n  &quot;湖北省-宜昌市&quot;: [111.292549, 30.697446],\n  &quot;湖北省-宜昌市-西陵区&quot;: [111.29256, 30.716749],\n  &quot;湖北省-宜昌市-伍家岗区&quot;: [111.367422, 30.650737],\n  &quot;湖北省-宜昌市-点军区&quot;: [111.274471, 30.69933],\n  &quot;湖北省-宜昌市-猇亭区&quot;: [111.441574, 30.536466],\n  &quot;湖北省-宜昌市-夷陵区&quot;: [111.33253, 30.774833],\n  &quot;湖北省-宜昌市-远安县&quot;: [111.64653, 31.066628],\n  &quot;湖北省-宜昌市-兴山县&quot;: [110.753446, 31.354464],\n  &quot;湖北省-宜昌市-秭归县&quot;: [110.984449, 30.831932],\n  &quot;湖北省-宜昌市-长阳土家族自治县&quot;: [111.213507, 30.478646],\n  &quot;湖北省-宜昌市-五峰土家族自治县&quot;: [111.052581, 30.171156],\n  &quot;湖北省-宜昌市-宜都市&quot;: [111.456516, 30.384404],\n  &quot;湖北省-宜昌市-当阳市&quot;: [111.794569, 30.826989],\n  &quot;湖北省-宜昌市-枝江市&quot;: [111.76654, 30.431731],\n  &quot;湖北省-襄阳市&quot;: [112.128537, 32.014797],\n  &quot;湖北省-襄阳市-襄城区&quot;: [112.140572, 32.016175],\n  &quot;湖北省-襄阳市-樊城区&quot;: [112.142599, 32.050572],\n  &quot;湖北省-襄阳市-襄州区&quot;: [112.218434, 32.093376],\n  &quot;湖北省-襄阳市-南漳县&quot;: [111.845386, 31.78113],\n  &quot;湖北省-襄阳市-谷城县&quot;: [111.659576, 32.268983],\n  &quot;湖北省-襄阳市-保康县&quot;: [111.267441, 31.883847],\n  &quot;湖北省-襄阳市-老河口市&quot;: [111.681556, 32.39246],\n  &quot;湖北省-襄阳市-枣阳市&quot;: [112.778471, 32.13473],\n  &quot;湖北省-襄阳市-宜城市&quot;: [112.264611, 31.72547],\n  &quot;湖北省-鄂州市&quot;: [114.901607, 30.396572],\n  &quot;湖北省-鄂州市-梁子湖区&quot;: [114.691507, 30.105907],\n  &quot;湖北省-鄂州市-华容区&quot;: [114.736426, 30.5406],\n  &quot;湖北省-鄂州市-鄂城区&quot;: [114.8986, 30.406389],\n  &quot;湖北省-荆门市&quot;: [112.206393, 31.041733],\n  &quot;湖北省-荆门市-东宝区&quot;: [112.208388, 31.058429],\n  &quot;湖北省-荆门市-掇刀区&quot;: [112.214428, 30.979911],\n  &quot;湖北省-荆门市-京山县&quot;: [113.126548, 31.024331],\n  &quot;湖北省-荆门市-沙洋县&quot;: [112.595485, 30.715315],\n  &quot;湖北省-荆门市-钟祥市&quot;: [112.594471, 31.17403],\n  &quot;湖北省-孝感市&quot;: [113.92251, 30.930689],\n  &quot;湖北省-孝感市-孝南区&quot;: [113.91749, 30.922978],\n  &quot;湖北省-孝感市-孝昌县&quot;: [114.004409, 31.26454],\n  &quot;湖北省-孝感市-大悟县&quot;: [114.133413, 31.56722],\n  &quot;湖北省-孝感市-云梦县&quot;: [113.759412, 31.027218],\n  &quot;湖北省-孝感市-应城市&quot;: [113.579567, 30.933977],\n  &quot;湖北省-孝感市-安陆市&quot;: [113.695583, 31.261415],\n  &quot;湖北省-孝感市-汉川市&quot;: [113.845549, 30.666914],\n  &quot;湖北省-荆州市&quot;: [112.245523, 30.340842],\n  &quot;湖北省-荆州市-沙市区&quot;: [112.261577, 30.316572],\n  &quot;湖北省-荆州市-荆州区&quot;: [112.196414, 30.358989],\n  &quot;湖北省-荆州市-公安县&quot;: [112.236502, 30.064401],\n  &quot;湖北省-荆州市-监利县&quot;: [112.91142, 29.845735],\n  &quot;湖北省-荆州市-江陵县&quot;: [112.431452, 30.048043],\n  &quot;湖北省-荆州市-石首市&quot;: [112.43142, 29.727034],\n  &quot;湖北省-荆州市-洪湖市&quot;: [113.482553, 29.83277],\n  &quot;湖北省-荆州市-松滋市&quot;: [111.77358, 30.175342],\n  &quot;湖北省-黄冈市&quot;: [114.87849, 30.459359],\n  &quot;湖北省-黄冈市-黄州区&quot;: [114.886532, 30.440224],\n  &quot;湖北省-黄冈市-团风县&quot;: [114.878524, 30.649368],\n  &quot;湖北省-黄冈市-红安县&quot;: [114.624426, 31.294297],\n  &quot;湖北省-黄冈市-罗田县&quot;: [115.405547, 30.78891],\n  &quot;湖北省-黄冈市-英山县&quot;: [115.687422, 30.74135],\n  &quot;湖北省-黄冈市-浠水县&quot;: [115.271569, 30.457461],\n  &quot;湖北省-黄冈市-蕲春县&quot;: [115.442399, 30.232535],\n  &quot;湖北省-黄冈市-黄梅县&quot;: [115.950462, 30.076605],\n  &quot;湖北省-黄冈市-麻城市&quot;: [115.016562, 31.176996],\n  &quot;湖北省-黄冈市-武穴市&quot;: [115.567392, 29.850441],\n  &quot;湖北省-咸宁市&quot;: [114.328519, 29.847056],\n  &quot;湖北省-咸宁市-咸安区&quot;: [114.30457, 29.858154],\n  &quot;湖北省-咸宁市-嘉鱼县&quot;: [113.94557, 29.976354],\n  &quot;湖北省-咸宁市-通城县&quot;: [113.823568, 29.250858],\n  &quot;湖北省-咸宁市-崇阳县&quot;: [114.046563, 29.561334],\n  &quot;湖北省-咸宁市-通山县&quot;: [114.489393, 29.612634],\n  &quot;湖北省-咸宁市-赤壁市&quot;: [113.906437, 29.730666],\n  &quot;湖北省-随州市&quot;: [113.38945, 31.696517],\n  &quot;湖北省-随州市-曾都区&quot;: [113.377513, 31.722123],\n  &quot;湖北省-随州市-随县&quot;: [113.377513, 31.722123],\n  &quot;湖北省-随州市-广水市&quot;: [113.832593, 31.622476],\n  &quot;湖北省-恩施土家族苗族自治州&quot;: [109.494593, 30.27794],\n  &quot;湖北省-恩施土家族苗族自治州-恩施市&quot;: [109.48655, 30.301037],\n  &quot;湖北省-恩施土家族苗族自治州-利川市&quot;: [108.942481, 30.297203],\n  &quot;湖北省-恩施土家族苗族自治州-建始县&quot;: [109.728556, 30.607907],\n  &quot;湖北省-恩施土家族苗族自治州-巴东县&quot;: [110.347575, 31.048064],\n  &quot;湖北省-恩施土家族苗族自治州-宣恩县&quot;: [109.497568, 29.992604],\n  &quot;湖北省-恩施土家族苗族自治州-咸丰县&quot;: [109.146608, 29.671078],\n  &quot;湖北省-恩施土家族苗族自治州-来凤县&quot;: [109.413495, 29.499444],\n  &quot;湖北省-恩施土家族苗族自治州-鹤峰县&quot;: [110.040424, 29.896116],\n  &quot;湖北省-仙桃市&quot;: [113.461591, 30.368272],\n  &quot;湖北省-潜江市&quot;: [112.905474, 30.408358],\n  &quot;湖北省-天门市&quot;: [113.172409, 30.669622],\n  &quot;湖北省-神农架林区&quot;: [110.682525, 31.750496],\n  &quot;湖南省&quot;: [112.989603, 28.11827],\n  &quot;湖南省-长沙市&quot;: [112.945473, 28.234889],\n  &quot;湖南省-长沙市-芙蓉区&quot;: [113.039408, 28.191913],\n  &quot;湖南省-长沙市-天心区&quot;: [112.996592, 28.118211],\n  &quot;湖南省-长沙市-岳麓区&quot;: [112.937448, 28.241489],\n  &quot;湖南省-长沙市-开福区&quot;: [112.992585, 28.261379],\n  &quot;湖南省-长沙市-雨花区&quot;: [113.042422, 28.142233],\n  &quot;湖南省-长沙市-望城区&quot;: [112.824466, 28.367403],\n  &quot;湖南省-长沙市-长沙县&quot;: [113.087559, 28.251818],\n  &quot;湖南省-长沙市-宁乡县&quot;: [112.558407, 28.284105],\n  &quot;湖南省-长沙市-浏阳市&quot;: [113.649398, 28.169832],\n  &quot;湖南省-株洲市&quot;: [113.140471, 27.833568],\n  &quot;湖南省-株洲市-荷塘区&quot;: [113.180452, 27.862156],\n  &quot;湖南省-株洲市-芦淞区&quot;: [113.158419, 27.791509],\n  &quot;湖南省-株洲市-石峰区&quot;: [113.124568, 27.880705],\n  &quot;湖南省-株洲市-天元区&quot;: [113.089541, 27.833084],\n  &quot;湖南省-株洲市-株洲县&quot;: [113.150427, 27.704323],\n  &quot;湖南省-株洲市-攸县&quot;: [113.351578, 27.005772],\n  &quot;湖南省-株洲市-茶陵县&quot;: [113.545472, 26.783589],\n  &quot;湖南省-株洲市-炎陵县&quot;: [113.779419, 26.496061],\n  &quot;湖南省-株洲市-醴陵市&quot;: [113.503483, 27.652325],\n  &quot;湖南省-湘潭市&quot;: [112.950464, 27.835702],\n  &quot;湖南省-湘潭市-雨湖区&quot;: [112.91345, 27.862467],\n  &quot;湖南省-湘潭市-岳塘区&quot;: [112.975589, 27.877721],\n  &quot;湖南省-湘潭市-湘潭县&quot;: [112.957505, 27.784983],\n  &quot;湖南省-湘潭市-湘乡市&quot;: [112.541492, 27.740191],\n  &quot;湖南省-湘潭市-韶山市&quot;: [112.533499, 27.921044],\n  &quot;湖南省-衡阳市&quot;: [112.578447, 26.899576],\n  &quot;湖南省-衡阳市-珠晖区&quot;: [112.626594, 26.900265],\n  &quot;湖南省-衡阳市-雁峰区&quot;: [112.623588, 26.894368],\n  &quot;湖南省-衡阳市-石鼓区&quot;: [112.60453, 26.948962],\n  &quot;湖南省-衡阳市-蒸湘区&quot;: [112.573444, 26.91772],\n  &quot;湖南省-衡阳市-南岳区&quot;: [112.745574, 27.23836],\n  &quot;湖南省-衡阳市-衡阳县&quot;: [112.377553, 26.975295],\n  &quot;湖南省-衡阳市-衡南县&quot;: [112.684403, 26.744532],\n  &quot;湖南省-衡阳市-衡山县&quot;: [112.875563, 27.235996],\n  &quot;湖南省-衡阳市-衡东县&quot;: [112.959495, 27.087043],\n  &quot;湖南省-衡阳市-祁东县&quot;: [112.096447, 26.805995],\n  &quot;湖南省-衡阳市-耒阳市&quot;: [112.866597, 26.428066],\n  &quot;湖南省-衡阳市-常宁市&quot;: [112.405561, 26.42672],\n  &quot;湖南省-邵阳市&quot;: [111.474433, 27.24527],\n  &quot;湖南省-邵阳市-双清区&quot;: [111.503442, 27.239109],\n  &quot;湖南省-邵阳市-大祥区&quot;: [111.445528, 27.227014],\n  &quot;湖南省-邵阳市-北塔区&quot;: [111.458497, 27.251536],\n  &quot;湖南省-邵阳市-邵东县&quot;: [111.750491, 27.264507],\n  &quot;湖南省-邵阳市-新邵县&quot;: [111.464449, 27.327132],\n  &quot;湖南省-邵阳市-邵阳县&quot;: [111.280508, 26.996528],\n  &quot;湖南省-邵阳市-隆回县&quot;: [111.039507, 27.119946],\n  &quot;湖南省-邵阳市-洞口县&quot;: [110.582579, 27.065975],\n  &quot;湖南省-邵阳市-绥宁县&quot;: [110.16242, 26.588423],\n  &quot;湖南省-邵阳市-新宁县&quot;: [110.863491, 26.439724],\n  &quot;湖南省-邵阳市-城步苗族自治县&quot;: [110.328537, 26.396203],\n  &quot;湖南省-邵阳市-武冈市&quot;: [110.638408, 26.732899],\n  &quot;湖南省-岳阳市&quot;: [113.135489, 29.363178],\n  &quot;湖南省-岳阳市-岳阳楼区&quot;: [113.136481, 29.377995],\n  &quot;湖南省-岳阳市-云溪区&quot;: [113.278407, 29.479907],\n  &quot;湖南省-岳阳市-君山区&quot;: [113.012517, 29.467129],\n  &quot;湖南省-岳阳市-岳阳县&quot;: [113.122544, 29.150269],\n  &quot;湖南省-岳阳市-华容县&quot;: [112.547462, 29.536286],\n  &quot;湖南省-岳阳市-湘阴县&quot;: [112.889522, 28.676676],\n  &quot;湖南省-岳阳市-平江县&quot;: [113.587604, 28.707564],\n  &quot;湖南省-岳阳市-汨罗市&quot;: [113.073493, 28.812455],\n  &quot;湖南省-岳阳市-临湘市&quot;: [113.456562, 29.482801],\n  &quot;湖南省-常德市&quot;: [111.705452, 29.03775],\n  &quot;湖南省-常德市-武陵区&quot;: [111.689545, 29.060783],\n  &quot;湖南省-常德市-鼎城区&quot;: [111.687522, 29.024443],\n  &quot;湖南省-常德市-安乡县&quot;: [112.177506, 29.41732],\n  &quot;湖南省-常德市-汉寿县&quot;: [111.976412, 28.912288],\n  &quot;湖南省-常德市-澧县&quot;: [111.765534, 29.638946],\n  &quot;湖南省-常德市-临澧县&quot;: [111.653585, 29.446544],\n  &quot;湖南省-常德市-桃源县&quot;: [111.495407, 28.908694],\n  &quot;湖南省-常德市-石门县&quot;: [111.386451, 29.590366],\n  &quot;湖南省-常德市-津市市&quot;: [111.884517, 29.611259],\n  &quot;湖南省-张家界市&quot;: [110.485533, 29.122816],\n  &quot;湖南省-张家界市-永定区&quot;: [110.544432, 29.126191],\n  &quot;湖南省-张家界市-武陵源区&quot;: [110.557499, 29.351681],\n  &quot;湖南省-张家界市-慈利县&quot;: [111.145471, 29.435987],\n  &quot;湖南省-张家界市-桑植县&quot;: [110.170413, 29.405923],\n  &quot;湖南省-益阳市&quot;: [112.361516, 28.559711],\n  &quot;湖南省-益阳市-资阳区&quot;: [112.330435, 28.597235],\n  &quot;湖南省-益阳市-赫山区&quot;: [112.380598, 28.584984],\n  &quot;湖南省-益阳市-南县&quot;: [112.402542, 29.36707],\n  &quot;湖南省-益阳市-桃江县&quot;: [112.162541, 28.523871],\n  &quot;湖南省-益阳市-安化县&quot;: [111.219493, 28.380054],\n  &quot;湖南省-益阳市-沅江市&quot;: [112.360532, 28.850234],\n  &quot;湖南省-郴州市&quot;: [113.02146, 25.776683],\n  &quot;湖南省-郴州市-北湖区&quot;: [113.017482, 25.790815],\n  &quot;湖南省-郴州市-苏仙区&quot;: [113.048423, 25.806737],\n  &quot;湖南省-郴州市-桂阳县&quot;: [112.74056, 25.759775],\n  &quot;湖南省-郴州市-宜章县&quot;: [112.955479, 25.405714],\n  &quot;湖南省-郴州市-永兴县&quot;: [113.122533, 26.132968],\n  &quot;湖南省-郴州市-嘉禾县&quot;: [112.375584, 25.593422],\n  &quot;湖南省-郴州市-临武县&quot;: [112.570411, 25.282527],\n  &quot;湖南省-郴州市-汝城县&quot;: [113.691545, 25.556057],\n  &quot;湖南省-郴州市-桂东县&quot;: [113.951594, 26.083174],\n  &quot;湖南省-郴州市-安仁县&quot;: [113.275424, 26.715683],\n  &quot;湖南省-郴州市-资兴市&quot;: [113.242556, 25.981874],\n  &quot;湖南省-永州市&quot;: [111.619455, 26.425864],\n  &quot;湖南省-永州市-零陵区&quot;: [111.637502, 26.227682],\n  &quot;湖南省-永州市-冷水滩区&quot;: [111.598426, 26.467706],\n  &quot;湖南省-永州市-祁阳县&quot;: [111.84742, 26.586435],\n  &quot;湖南省-永州市-东安县&quot;: [111.323542, 26.398288],\n  &quot;湖南省-永州市-双牌县&quot;: [111.667594, 25.967169],\n  &quot;湖南省-永州市-道县&quot;: [111.607404, 25.53253],\n  &quot;湖南省-永州市-江永县&quot;: [111.350437, 25.279721],\n  &quot;湖南省-永州市-宁远县&quot;: [111.952453, 25.577052],\n  &quot;湖南省-永州市-蓝山县&quot;: [112.203435, 25.375935],\n  &quot;湖南省-永州市-新田县&quot;: [112.210409, 25.909826],\n  &quot;湖南省-永州市-江华瑶族自治县&quot;: [111.585452, 25.191349],\n  &quot;湖南省-怀化市&quot;: [110.008514, 27.575161],\n  &quot;湖南省-怀化市-鹤城区&quot;: [110.0464, 27.585226],\n  &quot;湖南省-怀化市-中方县&quot;: [109.951462, 27.446081],\n  &quot;湖南省-怀化市-沅陵县&quot;: [110.400431, 28.459018],\n  &quot;湖南省-怀化市-辰溪县&quot;: [110.190487, 28.012605],\n  &quot;湖南省-怀化市-溆浦县&quot;: [110.601551, 27.913963],\n  &quot;湖南省-怀化市-会同县&quot;: [109.741586, 26.893384],\n  &quot;湖南省-怀化市-麻阳苗族自治县&quot;: [109.809436, 27.87193],\n  &quot;湖南省-怀化市-新晃侗族自治县&quot;: [109.181472, 27.358783],\n  &quot;湖南省-怀化市-芷江侗族自治县&quot;: [109.691402, 27.449513],\n  &quot;湖南省-怀化市-靖州苗族侗族自治县&quot;: [109.702452, 26.581321],\n  &quot;湖南省-怀化市-通道侗族自治县&quot;: [109.790445, 26.16422],\n  &quot;湖南省-怀化市-洪江市&quot;: [109.84351, 27.215077],\n  &quot;湖南省-娄底市&quot;: [112.001503, 27.703209],\n  &quot;湖南省-娄底市-娄星区&quot;: [112.008558, 27.735605],\n  &quot;湖南省-娄底市-双峰县&quot;: [112.18146, 27.462983],\n  &quot;湖南省-娄底市-新化县&quot;: [111.334515, 27.732667],\n  &quot;湖南省-娄底市-冷水江市&quot;: [111.44154, 27.692059],\n  &quot;湖南省-娄底市-涟源市&quot;: [111.670562, 27.698168],\n  &quot;湖南省-湘西土家族苗族自治州&quot;: [109.745577, 28.317369],\n  &quot;湖南省-湘西土家族苗族自治州-吉首市&quot;: [109.704449, 28.267493],\n  &quot;湖南省-湘西土家族苗族自治州-泸溪县&quot;: [110.226599, 28.221873],\n  &quot;湖南省-湘西土家族苗族自治州-凤凰县&quot;: [109.605527, 27.953848],\n  &quot;湖南省-湘西土家族苗族自治州-花垣县&quot;: [109.488562, 28.57791],\n  &quot;湖南省-湘西土家族苗族自治州-保靖县&quot;: [109.666474, 28.705969],\n  &quot;湖南省-湘西土家族苗族自治州-古丈县&quot;: [109.957507, 28.623084],\n  &quot;湖南省-湘西土家族苗族自治州-永顺县&quot;: [109.863586, 28.985774],\n  &quot;湖南省-湘西土家族苗族自治州-龙山县&quot;: [109.450416, 29.464122],\n  &quot;广东省&quot;: [113.272429, 23.137949],\n  &quot;广东省-广州市&quot;: [113.271431, 23.135336],\n  &quot;广东省-广州市-荔湾区&quot;: [113.250502, 23.131791],\n  &quot;广东省-广州市-越秀区&quot;: [113.273426, 23.13526],\n  &quot;广东省-广州市-海珠区&quot;: [113.32354, 23.088981],\n  &quot;广东省-广州市-天河区&quot;: [113.368509, 23.130358],\n  &quot;广东省-广州市-白云区&quot;: [113.279433, 23.164317],\n  &quot;广东省-广州市-黄埔区&quot;: [113.466563, 23.112058],\n  &quot;广东省-广州市-番禺区&quot;: [113.39047, 22.943831],\n  &quot;广东省-广州市-花都区&quot;: [113.226576, 23.411162],\n  &quot;广东省-广州市-南沙区&quot;: [113.531436, 22.807929],\n  &quot;广东省-广州市-从化区&quot;: [113.593585, 23.553986],\n  &quot;广东省-广州市-增城区&quot;: [113.817546, 23.266592],\n  &quot;广东省-韶关市&quot;: [113.603527, 24.815881],\n  &quot;广东省-韶关市-武江区&quot;: [113.594556, 24.798486],\n  &quot;广东省-韶关市-浈江区&quot;: [113.617477, 24.810414],\n  &quot;广东省-韶关市-曲江区&quot;: [113.611501, 24.688408],\n  &quot;广东省-韶关市-始兴县&quot;: [114.068567, 24.958558],\n  &quot;广东省-韶关市-仁化县&quot;: [113.755443, 25.092288],\n  &quot;广东省-韶关市-翁源县&quot;: [114.136427, 24.356594],\n  &quot;广东省-韶关市-乳源瑶族自治县&quot;: [113.282431, 24.782333],\n  &quot;广东省-韶关市-新丰县&quot;: [114.213512, 24.065547],\n  &quot;广东省-韶关市-乐昌市&quot;: [113.354579, 25.135592],\n  &quot;广东省-韶关市-南雄市&quot;: [114.318579, 25.123527],\n  &quot;广东省-深圳市&quot;: [114.064552, 22.548457],\n  &quot;广东省-深圳市-罗湖区&quot;: [114.137432, 22.554485],\n  &quot;广东省-深圳市-福田区&quot;: [114.061547, 22.528466],\n  &quot;广东省-深圳市-南山区&quot;: [113.936539, 22.5385],\n  &quot;广东省-深圳市-宝安区&quot;: [113.890427, 22.560033],\n  &quot;广东省-深圳市-龙岗区&quot;: [114.254455, 22.726017],\n  &quot;广东省-深圳市-盐田区&quot;: [114.24343, 22.563438],\n  &quot;广东省-珠海市&quot;: [113.582555, 22.276565],\n  &quot;广东省-珠海市-香洲区&quot;: [113.550472, 22.273004],\n  &quot;广东省-珠海市-斗门区&quot;: [113.303467, 22.215516],\n  &quot;广东省-珠海市-金湾区&quot;: [113.369517, 22.152577],\n  &quot;广东省-汕头市&quot;: [116.688529, 23.359092],\n  &quot;广东省-汕头市-龙湖区&quot;: [116.723525, 23.377776],\n  &quot;广东省-汕头市-金平区&quot;: [116.70955, 23.37175],\n  &quot;广东省-汕头市-濠江区&quot;: [116.733517, 23.291546],\n  &quot;广东省-汕头市-潮阳区&quot;: [116.608515, 23.270855],\n  &quot;广东省-汕头市-潮南区&quot;: [116.439491, 23.256341],\n  &quot;广东省-汕头市-澄海区&quot;: [116.762425, 23.472341],\n  &quot;广东省-汕头市-南澳县&quot;: [117.030496, 23.427812],\n  &quot;广东省-佛山市&quot;: [113.128512, 23.027759],\n  &quot;广东省-佛山市-禅城区&quot;: [113.129505, 23.015374],\n  &quot;广东省-佛山市-南海区&quot;: [113.149446, 23.035011],\n  &quot;广东省-佛山市-顺德区&quot;: [113.300453, 22.810453],\n  &quot;广东省-佛山市-三水区&quot;: [112.903471, 23.16192],\n  &quot;广东省-佛山市-高明区&quot;: [112.899472, 22.90635],\n  &quot;广东省-江门市&quot;: [113.088556, 22.584604],\n  &quot;广东省-江门市-蓬江区&quot;: [113.084546, 22.601066],\n  &quot;广东省-江门市-江海区&quot;: [113.117557, 22.566115],\n  &quot;广东省-江门市-新会区&quot;: [113.038455, 22.465113],\n  &quot;广东省-江门市-台山市&quot;: [112.800445, 22.257923],\n  &quot;广东省-江门市-开平市&quot;: [112.704464, 22.382499],\n  &quot;广东省-江门市-鹤山市&quot;: [112.970527, 22.771169],\n  &quot;广东省-江门市-恩平市&quot;: [112.311438, 22.189035],\n  &quot;广东省-湛江市&quot;: [110.365554, 21.276723],\n  &quot;广东省-湛江市-赤坎区&quot;: [110.372533, 21.272135],\n  &quot;广东省-湛江市-霞山区&quot;: [110.404425, 21.198227],\n  &quot;广东省-湛江市-坡头区&quot;: [110.462567, 21.250377],\n  &quot;广东省-湛江市-麻章区&quot;: [110.340579, 21.269189],\n  &quot;广东省-湛江市-遂溪县&quot;: [110.256515, 21.383103],\n  &quot;广东省-湛江市-徐闻县&quot;: [110.182473, 20.331724],\n  &quot;广东省-湛江市-廉江市&quot;: [110.292448, 21.615816],\n  &quot;广东省-湛江市-雷州市&quot;: [110.102581, 20.919881],\n  &quot;广东省-湛江市-吴川市&quot;: [110.78645, 21.447263],\n  &quot;广东省-茂名市&quot;: [110.931543, 21.669064],\n  &quot;广东省-茂名市-茂南区&quot;: [110.925546, 21.647152],\n  &quot;广东省-茂名市-电白区&quot;: [111.020471, 21.520351],\n  &quot;广东省-茂名市-高州市&quot;: [110.859474, 21.924049],\n  &quot;广东省-茂名市-化州市&quot;: [110.646431, 21.670231],\n  &quot;广东省-茂名市-信宜市&quot;: [110.953582, 22.360093],\n  &quot;广东省-肇庆市&quot;: [112.471489, 23.052889],\n  &quot;广东省-肇庆市-端州区&quot;: [112.49156, 23.057564],\n  &quot;广东省-肇庆市-鼎湖区&quot;: [112.574434, 23.164308],\n  &quot;广东省-肇庆市-高要区&quot;: [112.464446, 23.031896],\n  &quot;广东省-肇庆市-广宁县&quot;: [112.447424, 23.641036],\n  &quot;广东省-肇庆市-怀集县&quot;: [112.191469, 23.917842],\n  &quot;广东省-肇庆市-封开县&quot;: [111.518526, 23.429769],\n  &quot;广东省-肇庆市-德庆县&quot;: [111.791554, 23.151373],\n  &quot;广东省-肇庆市-四会市&quot;: [112.740579, 23.332381],\n  &quot;广东省-惠州市&quot;: [114.423558, 23.116359],\n  &quot;广东省-惠州市-惠城区&quot;: [114.38949, 23.089726],\n  &quot;广东省-惠州市-惠阳区&quot;: [114.463464, 22.794721],\n  &quot;广东省-惠州市-博罗县&quot;: [114.296573, 23.178806],\n  &quot;广东省-惠州市-惠东县&quot;: [114.726426, 22.991443],\n  &quot;广东省-惠州市-龙门县&quot;: [114.26143, 23.733838],\n  &quot;广东省-梅州市&quot;: [116.129537, 24.294178],\n  &quot;广东省-梅州市-梅江区&quot;: [116.123536, 24.315879],\n  &quot;广东省-梅州市-梅县区&quot;: [116.088562, 24.270999],\n  &quot;广东省-梅州市-大埔县&quot;: [116.701559, 24.353459],\n  &quot;广东省-梅州市-丰顺县&quot;: [116.188454, 23.745738],\n  &quot;广东省-梅州市-五华县&quot;: [115.782485, 23.938409],\n  &quot;广东省-梅州市-平远县&quot;: [115.897477, 24.572414],\n  &quot;广东省-梅州市-蕉岭县&quot;: [116.177439, 24.664993],\n  &quot;广东省-梅州市-兴宁市&quot;: [115.737579, 24.142294],\n  &quot;广东省-汕尾市&quot;: [115.381553, 22.791263],\n  &quot;广东省-汕尾市-城区&quot;: [115.371531, 22.784552],\n  &quot;广东省-汕尾市-海丰县&quot;: [115.329445, 22.972744],\n  &quot;广东省-汕尾市-陆河县&quot;: [115.666483, 23.307677],\n  &quot;广东省-汕尾市-陆丰市&quot;: [115.65849, 22.923636],\n  &quot;广东省-河源市&quot;: [114.707446, 23.749684],\n  &quot;广东省-河源市-源城区&quot;: [114.708439, 23.740298],\n  &quot;广东省-河源市-紫金县&quot;: [115.190448, 23.64143],\n  &quot;广东省-河源市-龙川县&quot;: [115.266555, 24.105851],\n  &quot;广东省-河源市-连平县&quot;: [114.495444, 24.375808],\n  &quot;广东省-河源市-和平县&quot;: [114.945449, 24.448253],\n  &quot;广东省-河源市-东源县&quot;: [114.753508, 23.794258],\n  &quot;广东省-阳江市&quot;: [111.988489, 21.86434],\n  &quot;广东省-阳江市-江城区&quot;: [111.961455, 21.868128],\n  &quot;广东省-阳江市-阳东区&quot;: [112.018579, 21.873997],\n  &quot;广东省-阳江市-阳西县&quot;: [111.624481, 21.758701],\n  &quot;广东省-阳江市-阳春市&quot;: [111.797536, 22.176015],\n  &quot;广东省-清远市&quot;: [113.062468, 23.68823],\n  &quot;广东省-清远市-清城区&quot;: [113.069477, 23.704022],\n  &quot;广东省-清远市-清新区&quot;: [112.991558, 23.75427],\n  &quot;广东省-清远市-佛冈县&quot;: [113.538441, 23.885475],\n  &quot;广东省-清远市-阳山县&quot;: [112.64752, 24.470944],\n  &quot;广东省-清远市-连山壮族瑶族自治县&quot;: [112.100426, 24.576846],\n  &quot;广东省-清远市-连南瑶族自治县&quot;: [112.293517, 24.731549],\n  &quot;广东省-清远市-英德市&quot;: [113.421443, 24.191939],\n  &quot;广东省-清远市-连州市&quot;: [112.383573, 24.786467],\n  &quot;广东省-东莞市&quot;: [113.75842, 23.027308],\n  &quot;广东省-中山市&quot;: [113.399422, 22.522315],\n  &quot;广东省-潮州市&quot;: [116.62947, 23.662623],\n  &quot;广东省-潮州市-湘桥区&quot;: [116.634462, 23.680687],\n  &quot;广东省-潮州市-潮安区&quot;: [116.684526, 23.468357],\n  &quot;广东省-潮州市-饶平县&quot;: [117.010449, 23.670347],\n  &quot;广东省-揭阳市&quot;: [116.378512, 23.55574],\n  &quot;广东省-揭阳市-榕城区&quot;: [116.373516, 23.530746],\n  &quot;广东省-揭阳市-揭东区&quot;: [116.418456, 23.572485],\n  &quot;广东省-揭阳市-揭西县&quot;: [115.848561, 23.4373],\n  &quot;广东省-揭阳市-惠来县&quot;: [116.301444, 23.039645],\n  &quot;广东省-揭阳市-普宁市&quot;: [116.172449, 23.303635],\n  &quot;广东省-云浮市&quot;: [112.051513, 22.920912],\n  &quot;广东省-云浮市-云城区&quot;: [112.050529, 22.933898],\n  &quot;广东省-云浮市-云安区&quot;: [112.009563, 23.076893],\n  &quot;广东省-云浮市-新兴县&quot;: [112.231497, 22.70189],\n  &quot;广东省-云浮市-郁南县&quot;: [111.541554, 23.240174],\n  &quot;广东省-云浮市-罗定市&quot;: [111.57648, 22.774296],\n  &quot;广西壮族自治区&quot;: [108.334521, 22.821269],\n  &quot;广西壮族自治区-南宁市&quot;: [108.373451, 22.822607],\n  &quot;广西壮族自治区-南宁市-兴宁区&quot;: [108.375445, 22.860291],\n  &quot;广西壮族自治区-南宁市-青秀区&quot;: [108.501439, 22.792227],\n  &quot;广西壮族自治区-南宁市-江南区&quot;: [108.279494, 22.787046],\n  &quot;广西壮族自治区-南宁市-西乡塘区&quot;: [108.319572, 22.839652],\n  &quot;广西壮族自治区-南宁市-良庆区&quot;: [108.327516, 22.762849],\n  &quot;广西壮族自治区-南宁市-邕宁区&quot;: [108.49342, 22.7646],\n  &quot;广西壮族自治区-南宁市-武鸣区&quot;: [108.281517, 23.164516],\n  &quot;广西壮族自治区-南宁市-隆安县&quot;: [107.702574, 23.171585],\n  &quot;广西壮族自治区-南宁市-马山县&quot;: [108.183562, 23.713878],\n  &quot;广西壮族自治区-南宁市-上林县&quot;: [108.611451, 23.438519],\n  &quot;广西壮族自治区-南宁市-宾阳县&quot;: [108.816502, 23.223701],\n  &quot;广西壮族自治区-南宁市-横县&quot;: [109.267568, 22.685573],\n  &quot;广西壮族自治区-柳州市&quot;: [109.434422, 24.331961],\n  &quot;广西壮族自治区-柳州市-城中区&quot;: [109.417482, 24.321314],\n  &quot;广西壮族自治区-柳州市-鱼峰区&quot;: [109.449416, 24.318522],\n  &quot;广西壮族自治区-柳州市-柳南区&quot;: [109.391552, 24.341579],\n  &quot;广西壮族自治区-柳州市-柳北区&quot;: [109.408532, 24.367867],\n  &quot;广西壮族自治区-柳州市-柳江区&quot;: [109.332444, 24.260815],\n  &quot;广西壮族自治区-柳州市-柳城县&quot;: [109.251562, 24.65637],\n  &quot;广西壮族自治区-柳州市-鹿寨县&quot;: [109.757554, 24.478622],\n  &quot;广西壮族自治区-柳州市-融安县&quot;: [109.404563, 25.230511],\n  &quot;广西壮族自治区-柳州市-融水苗族自治县&quot;: [109.262561, 25.072077],\n  &quot;广西壮族自治区-柳州市-三江侗族自治县&quot;: [109.614547, 25.78883],\n  &quot;广西壮族自治区-桂林市&quot;: [110.203545, 25.242886],\n  &quot;广西壮族自治区-桂林市-秀峰区&quot;: [110.270437, 25.279618],\n  &quot;广西壮族自治区-桂林市-叠彩区&quot;: [110.308463, 25.320233],\n  &quot;广西壮族自治区-桂林市-象山区&quot;: [110.287423, 25.26793],\n  &quot;广西壮族自治区-桂林市-七星区&quot;: [110.324538, 25.258567],\n  &quot;广西壮族自治区-桂林市-雁山区&quot;: [110.315479, 25.066214],\n  &quot;广西壮族自治区-桂林市-临桂区&quot;: [110.218587, 25.244302],\n  &quot;广西壮族自治区-桂林市-阳朔县&quot;: [110.503475, 24.784519],\n  &quot;广西壮族自治区-桂林市-灵川县&quot;: [110.332537, 25.41555],\n  &quot;广西壮族自治区-桂林市-全州县&quot;: [111.079569, 25.934343],\n  &quot;广西壮族自治区-桂林市-兴安县&quot;: [110.678516, 25.617567],\n  &quot;广西壮族自治区-桂林市-永福县&quot;: [109.989591, 24.985578],\n  &quot;广西壮族自治区-桂林市-灌阳县&quot;: [111.167552, 25.495121],\n  &quot;广西壮族自治区-桂林市-龙胜各族自治县&quot;: [110.017494, 25.804117],\n  &quot;广西壮族自治区-桂林市-资源县&quot;: [110.658439, 26.048569],\n  &quot;广西壮族自治区-桂林市-平乐县&quot;: [110.649446, 24.639632],\n  &quot;广西壮族自治区-桂林市-荔浦县&quot;: [110.401437, 24.494122],\n  &quot;广西壮族自治区-桂林市-恭城瑶族自治县&quot;: [110.83456, 24.837194],\n  &quot;广西壮族自治区-梧州市&quot;: [111.285517, 23.482745],\n  &quot;广西壮族自治区-梧州市-万秀区&quot;: [111.32752, 23.478846],\n  &quot;广西壮族自治区-梧州市-长洲区&quot;: [111.281499, 23.49151],\n  &quot;广西壮族自治区-梧州市-龙圩区&quot;: [111.285517, 23.482745],\n  &quot;广西壮族自治区-梧州市-苍梧县&quot;: [111.555547, 23.845998],\n  &quot;广西壮族自治区-梧州市-藤县&quot;: [110.921499, 23.38101],\n  &quot;广西壮族自治区-梧州市-蒙山县&quot;: [110.531417, 24.200017],\n  &quot;广西壮族自治区-梧州市-岑溪市&quot;: [111.001432, 22.924621],\n  &quot;广西壮族自治区-北海市&quot;: [109.126533, 21.486836],\n  &quot;广西壮族自治区-北海市-海城区&quot;: [109.124521, 21.481066],\n  &quot;广西壮族自治区-北海市-银海区&quot;: [109.146545, 21.454769],\n  &quot;广西壮族自治区-北海市-铁山港区&quot;: [109.428473, 21.535295],\n  &quot;广西壮族自治区-北海市-合浦县&quot;: [109.213439, 21.667006],\n  &quot;广西壮族自治区-防城港市&quot;: [108.360419, 21.693005],\n  &quot;广西壮族自治区-防城港市-港口区&quot;: [108.386483, 21.649566],\n  &quot;广西壮族自治区-防城港市-防城区&quot;: [108.360448, 21.775411],\n  &quot;广西壮族自治区-防城港市-上思县&quot;: [107.990443, 22.159914],\n  &quot;广西壮族自治区-防城港市-东兴市&quot;: [107.977489, 21.553615],\n  &quot;广西壮族自治区-钦州市&quot;: [108.66058, 21.986594],\n  &quot;广西壮族自治区-钦州市-钦南区&quot;: [108.664549, 21.945972],\n  &quot;广西壮族自治区-钦州市-钦北区&quot;: [108.638513, 22.020367],\n  &quot;广西壮族自治区-钦州市-灵山县&quot;: [109.297478, 22.422413],\n  &quot;广西壮族自治区-钦州市-浦北县&quot;: [109.563423, 22.277822],\n  &quot;广西壮族自治区-贵港市&quot;: [109.60552, 23.117448],\n  &quot;广西壮族自治区-贵港市-港北区&quot;: [109.578433, 23.117564],\n  &quot;广西壮族自治区-贵港市-港南区&quot;: [109.606553, 23.08124],\n  &quot;广西壮族自治区-贵港市-覃塘区&quot;: [109.459427, 23.133251],\n  &quot;广西壮族自治区-贵港市-平南县&quot;: [110.398452, 23.545506],\n  &quot;广西壮族自治区-贵港市-桂平市&quot;: [110.085526, 23.400049],\n  &quot;广西壮族自治区-玉林市&quot;: [110.188453, 22.659831],\n  &quot;广西壮族自治区-玉林市-玉州区&quot;: [110.157431, 22.634493],\n  &quot;广西壮族自治区-玉林市-福绵区&quot;: [110.157431, 22.634493],\n  &quot;广西壮族自治区-玉林市-容县&quot;: [110.56453, 22.863666],\n  &quot;广西壮族自治区-玉林市-陆川县&quot;: [110.270456, 22.327222],\n  &quot;广西壮族自治区-玉林市-博白县&quot;: [109.982553, 22.278675],\n  &quot;广西壮族自治区-玉林市-兴业县&quot;: [109.881552, 22.742268],\n  &quot;广西壮族自治区-玉林市-北流市&quot;: [110.36057, 22.713958],\n  &quot;广西壮族自治区-百色市&quot;: [106.624589, 23.908186],\n  &quot;广西壮族自治区-百色市-右江区&quot;: [106.625589, 23.907085],\n  &quot;广西壮族自治区-百色市-田阳县&quot;: [106.921413, 23.742006],\n  &quot;广西壮族自治区-百色市-田东县&quot;: [107.132499, 23.60313],\n  &quot;广西壮族自治区-百色市-平果县&quot;: [107.596571, 23.334923],\n  &quot;广西壮族自治区-百色市-德保县&quot;: [106.621583, 23.328994],\n  &quot;广西壮族自治区-百色市-那坡县&quot;: [105.839423, 23.393794],\n  &quot;广西壮族自治区-百色市-凌云县&quot;: [106.568416, 24.354015],\n  &quot;广西壮族自治区-百色市-乐业县&quot;: [106.56343, 24.783216],\n  &quot;广西壮族自治区-百色市-田林县&quot;: [106.234498, 24.300535],\n  &quot;广西壮族自治区-百色市-西林县&quot;: [105.100494, 24.495668],\n  &quot;广西壮族自治区-百色市-隆林各族自治县&quot;: [105.350459, 24.776814],\n  &quot;广西壮族自治区-百色市-靖西市&quot;: [106.424453, 23.140126],\n  &quot;广西壮族自治区-贺州市&quot;: [111.573526, 24.409451],\n  &quot;广西壮族自治区-贺州市-八步区&quot;: [111.558567, 24.417531],\n  &quot;广西壮族自治区-贺州市-平桂区&quot;: [111.478414, 24.462001],\n  &quot;广西壮族自治区-贺州市-昭平县&quot;: [110.817575, 24.175106],\n  &quot;广西壮族自治区-贺州市-钟山县&quot;: [111.309586, 24.531673],\n  &quot;广西壮族自治区-贺州市-富川瑶族自治县&quot;: [111.284511, 24.82016],\n  &quot;广西壮族自治区-河池市&quot;: [108.0915, 24.698912],\n  &quot;广西壮族自治区-河池市-金城江区&quot;: [108.043507, 24.695679],\n  &quot;广西壮族自治区-河池市-南丹县&quot;: [107.54748, 24.98185],\n  &quot;广西壮族自治区-河池市-天峨县&quot;: [107.178456, 25.005664],\n  &quot;广西壮族自治区-河池市-凤山县&quot;: [107.04842, 24.553218],\n  &quot;广西壮族自治区-河池市-东兰县&quot;: [107.380504, 24.516871],\n  &quot;广西壮族自治区-河池市-罗城仫佬族自治县&quot;: [108.911574, 24.783085],\n  &quot;广西壮族自治区-河池市-环江毛南族自治县&quot;: [108.264443, 24.832088],\n  &quot;广西壮族自治区-河池市-巴马瑶族自治县&quot;: [107.266481, 24.147265],\n  &quot;广西壮族自治区-河池市-都安瑶族自治县&quot;: [108.111458, 23.937331],\n  &quot;广西壮族自治区-河池市-大化瑶族自治县&quot;: [108.004411, 23.742818],\n  &quot;广西壮族自治区-河池市-宜州市&quot;: [108.643532, 24.491084],\n  &quot;广西壮族自治区-来宾市&quot;: [109.227458, 23.756547],\n  &quot;广西壮族自治区-来宾市-兴宾区&quot;: [109.241499, 23.733211],\n  &quot;广西壮族自治区-来宾市-忻城县&quot;: [108.672562, 24.071889],\n  &quot;广西壮族自治区-来宾市-象州县&quot;: [109.711462, 23.979681],\n  &quot;广西壮族自治区-来宾市-武宣县&quot;: [109.669442, 23.600404],\n  &quot;广西壮族自治区-来宾市-金秀瑶族自治县&quot;: [110.195506, 24.136319],\n  &quot;广西壮族自治区-来宾市-合山市&quot;: [108.892566, 23.81226],\n  &quot;广西壮族自治区-崇左市&quot;: [107.37152, 22.383117],\n  &quot;广西壮族自治区-崇左市-江州区&quot;: [107.359533, 22.411246],\n  &quot;广西壮族自治区-崇左市-扶绥县&quot;: [107.910465, 22.641097],\n  &quot;广西壮族自治区-崇左市-宁明县&quot;: [107.083524, 22.145885],\n  &quot;广西壮族自治区-崇左市-龙州县&quot;: [106.860582, 22.348299],\n  &quot;广西壮族自治区-崇左市-大新县&quot;: [107.207557, 22.836229],\n  &quot;广西壮族自治区-崇左市-天等县&quot;: [107.149473, 23.087506],\n  &quot;广西壮族自治区-崇左市-凭祥市&quot;: [106.773524, 22.100153],\n  &quot;海南省&quot;: [110.355537, 20.025802],\n  &quot;海南省-海口市&quot;: [110.325525, 20.044049],\n  &quot;海南省-海口市-秀英区&quot;: [110.300436, 20.013642],\n  &quot;海南省-海口市-龙华区&quot;: [110.335541, 20.036321],\n  &quot;海南省-海口市-琼山区&quot;: [110.360526, 20.009151],\n  &quot;海南省-海口市-美兰区&quot;: [110.373498, 20.034646],\n  &quot;海南省-三亚市&quot;: [109.518557, 18.258736],\n  &quot;海南省-三亚市-海棠区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-吉阳区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-天涯区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-崖州区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三沙市&quot;: [111.673087, 16.497085],\n  &quot;海南省-儋州市&quot;: [109.587456, 19.527146],\n  &quot;海南省-五指山市&quot;: [109.52354, 18.780994],\n  &quot;海南省-琼海市&quot;: [110.480545, 19.264254],\n  &quot;海南省-文昌市&quot;: [110.804509, 19.549062],\n  &quot;海南省-万宁市&quot;: [110.399434, 18.800107],\n  &quot;海南省-东方市&quot;: [108.658567, 19.101105],\n  &quot;海南省-定安县&quot;: [110.365533, 19.68712],\n  &quot;海南省-屯昌县&quot;: [110.108577, 19.357375],\n  &quot;海南省-澄迈县&quot;: [110.013511, 19.744349],\n  &quot;海南省-临高县&quot;: [109.697443, 19.919475],\n  &quot;海南省-白沙黎族自治县&quot;: [109.457471, 19.231379],\n  &quot;海南省-昌江黎族自治县&quot;: [109.062464, 19.303998],\n  &quot;海南省-乐东黎族自治县&quot;: [109.180508, 18.755871],\n  &quot;海南省-陵水黎族自治县&quot;: [110.044464, 18.512332],\n  &quot;海南省-保亭黎族苗族自治县&quot;: [109.703482, 18.64691],\n  &quot;海南省-琼中黎族苗族自治县&quot;: [109.844511, 19.039164],\n  &quot;重庆市&quot;: [106.558434, 29.568996],\n  &quot;重庆市-市辖区&quot;: [106.558434, 29.568996],\n  &quot;重庆市-市辖区-万州区&quot;: [108.415558, 30.813622],\n  &quot;重庆市-市辖区-涪陵区&quot;: [107.39642, 29.709278],\n  &quot;重庆市-市辖区-渝中区&quot;: [106.57544, 29.55909],\n  &quot;重庆市-市辖区-大渡口区&quot;: [106.488534, 29.490107],\n  &quot;重庆市-市辖区-江北区&quot;: [106.580415, 29.612832],\n  &quot;重庆市-市辖区-沙坪坝区&quot;: [106.464465, 29.547193],\n  &quot;重庆市-市辖区-九龙坡区&quot;: [106.517559, 29.507928],\n  &quot;重庆市-市辖区-南岸区&quot;: [106.66843, 29.502683],\n  &quot;重庆市-市辖区-北碚区&quot;: [106.403569, 29.811603],\n  &quot;重庆市-市辖区-綦江区&quot;: [106.657484, 29.034114],\n  &quot;重庆市-市辖区-大足区&quot;: [105.728405, 29.713114],\n  &quot;重庆市-市辖区-渝北区&quot;: [106.637559, 29.723927],\n  &quot;重庆市-市辖区-巴南区&quot;: [106.547454, 29.408475],\n  &quot;重庆市-市辖区-黔江区&quot;: [108.777591, 29.538813],\n  &quot;重庆市-市辖区-长寿区&quot;: [107.087531, 29.86352],\n  &quot;重庆市-市辖区-江津区&quot;: [106.265598, 29.295884],\n  &quot;重庆市-市辖区-合川区&quot;: [106.282541, 29.978181],\n  &quot;重庆市-市辖区-永川区&quot;: [105.933499, 29.362046],\n  &quot;重庆市-市辖区-南川区&quot;: [107.105585, 29.163479],\n  &quot;重庆市-市辖区-璧山区&quot;: [106.233475, 29.598347],\n  &quot;重庆市-市辖区-铜梁区&quot;: [106.063449, 29.850509],\n  &quot;重庆市-市辖区-潼南区&quot;: [105.847399, 30.197314],\n  &quot;重庆市-市辖区-荣昌区&quot;: [105.60142, 29.411307],\n  &quot;重庆市-市辖区-开州区&quot;: [108.399498, 31.166644],\n  &quot;重庆市-县&quot;: [108.120414, 30.006109],\n  &quot;重庆市-县-梁平县&quot;: [107.7761, 30.660545],\n  &quot;重庆市-县-城口县&quot;: [108.671612, 31.953391],\n  &quot;重庆市-县-丰都县&quot;: [107.737481, 29.869413],\n  &quot;重庆市-县-垫江县&quot;: [107.339566, 30.333294],\n  &quot;重庆市-县-武隆县&quot;: [107.774902, 29.335005],\n  &quot;重庆市-县-忠县&quot;: [107.478814, 30.278161],\n  &quot;重庆市-县-云阳县&quot;: [108.703448, 30.936611],\n  &quot;重庆市-县-奉节县&quot;: [109.470473, 31.024602],\n  &quot;重庆市-县-巫山县&quot;: [109.885546, 31.080519],\n  &quot;重庆市-县-巫溪县&quot;: [109.576403, 31.40488],\n  &quot;重庆市-县-石柱土家族自治县&quot;: [109.576403, 31.40488],\n  &quot;重庆市-县-秀山土家族苗族自治县&quot;: [109.013574, 28.453448],\n  &quot;重庆市-县-酉阳土家族苗族自治县&quot;: [108.774586, 28.84704],\n  &quot;重庆市-县-彭水苗族土家族自治县&quot;: [108.172578, 29.299462],\n  &quot;四川省&quot;: [104.073467, 30.577543],\n  &quot;四川省-成都市&quot;: [104.081534, 30.655822],\n  &quot;四川省-成都市-锦江区&quot;: [104.089562, 30.661904],\n  &quot;四川省-成都市-青羊区&quot;: [104.067445, 30.680038],\n  &quot;四川省-成都市-金牛区&quot;: [104.057404, 30.697356],\n  &quot;四川省-成都市-武侯区&quot;: [104.049424, 30.648713],\n  &quot;四川省-成都市-成华区&quot;: [104.108592, 30.665589],\n  &quot;四川省-成都市-龙泉驿区&quot;: [104.281397, 30.562698],\n  &quot;四川省-成都市-青白江区&quot;: [104.257512, 30.884421],\n  &quot;四川省-成都市-新都区&quot;: [104.165393, 30.829407],\n  &quot;四川省-成都市-温江区&quot;: [103.863573, 30.688487],\n  &quot;四川省-成都市-双流区&quot;: [103.930392, 30.580399],\n  &quot;四川省-成都市-金堂县&quot;: [104.418443, 30.868358],\n  &quot;四川省-成都市-郫县&quot;: [103.905446, 30.799538],\n  &quot;四川省-成都市-大邑县&quot;: [103.52753, 30.593155],\n  &quot;四川省-成都市-蒲江县&quot;: [103.512571, 30.2025],\n  &quot;四川省-成都市-新津县&quot;: [103.817433, 30.416364],\n  &quot;四川省-成都市-都江堰市&quot;: [103.653534, 30.994257],\n  &quot;四川省-成都市-彭州市&quot;: [103.965561, 30.995564],\n  &quot;四川省-成都市-邛崃市&quot;: [103.470481, 30.416399],\n  &quot;四川省-成都市-崇州市&quot;: [103.679433, 30.636596],\n  &quot;四川省-成都市-简阳市&quot;: [104.569516, 30.3766],\n  &quot;四川省-自贡市&quot;: [104.784449, 29.345585],\n  &quot;四川省-自贡市-自流井区&quot;: [104.783447, 29.343499],\n  &quot;四川省-自贡市-贡井区&quot;: [104.721557, 29.351476],\n  &quot;四川省-自贡市-大安区&quot;: [104.780416, 29.369929],\n  &quot;四川省-自贡市-沿滩区&quot;: [104.880409, 29.278797],\n  &quot;四川省-自贡市-荣县&quot;: [104.423458, 29.451801],\n  &quot;四川省-自贡市-富顺县&quot;: [104.981494, 29.186886],\n  &quot;四川省-攀枝花市&quot;: [101.725541, 26.588033],\n  &quot;四川省-攀枝花市-东区&quot;: [101.710597, 26.552106],\n  &quot;四川省-攀枝花市-西区&quot;: [101.637413, 26.603868],\n  &quot;四川省-攀枝花市-仁和区&quot;: [101.74445, 26.504019],\n  &quot;四川省-攀枝花市-米易县&quot;: [102.11644, 26.896968],\n  &quot;四川省-攀枝花市-盐边县&quot;: [101.860499, 26.688767],\n  &quot;四川省-泸州市&quot;: [105.448524, 28.877668],\n  &quot;四川省-泸州市-江阳区&quot;: [105.441545, 28.884672],\n  &quot;四川省-泸州市-纳溪区&quot;: [105.377409, 28.77936],\n  &quot;四川省-泸州市-龙马潭区&quot;: [105.444544, 28.919012],\n  &quot;四川省-泸州市-泸县&quot;: [105.388456, 29.157626],\n  &quot;四川省-泸州市-合江县&quot;: [105.838432, 28.817793],\n  &quot;四川省-泸州市-叙永县&quot;: [105.451508, 28.161714],\n  &quot;四川省-泸州市-古蔺县&quot;: [105.819471, 28.044745],\n  &quot;四川省-德阳市&quot;: [104.404419, 31.133115],\n  &quot;四川省-德阳市-旌阳区&quot;: [104.423439, 31.148596],\n  &quot;四川省-德阳市-中江县&quot;: [104.68553, 31.038954],\n  &quot;四川省-德阳市-罗江县&quot;: [104.517414, 31.324179],\n  &quot;四川省-德阳市-广汉市&quot;: [104.288422, 30.982415],\n  &quot;四川省-德阳市-什邡市&quot;: [104.174427, 31.132889],\n  &quot;四川省-德阳市-绵竹市&quot;: [104.227609, 31.343592],\n  &quot;四川省-绵阳市&quot;: [104.685562, 31.473663],\n  &quot;四川省-绵阳市-涪城区&quot;: [104.76342, 31.461314],\n  &quot;四川省-绵阳市-游仙区&quot;: [104.772429, 31.479904],\n  &quot;四川省-绵阳市-安州区&quot;: [104.573555, 31.540751],\n  &quot;四川省-绵阳市-三台县&quot;: [105.10149, 31.101586],\n  &quot;四川省-绵阳市-盐亭县&quot;: [105.395503, 31.214319],\n  &quot;四川省-绵阳市-梓潼县&quot;: [105.177567, 31.648313],\n  &quot;四川省-绵阳市-北川羌族自治县&quot;: [104.361586, 31.963084],\n  &quot;四川省-绵阳市-平武县&quot;: [104.535422, 32.414682],\n  &quot;四川省-绵阳市-江油市&quot;: [104.752412, 31.784128],\n  &quot;四川省-广元市&quot;: [105.850423, 32.441616],\n  &quot;四川省-广元市-利州区&quot;: [105.852426, 32.440208],\n  &quot;四川省-广元市-昭化区&quot;: [105.969419, 32.329618],\n  &quot;四川省-广元市-朝天区&quot;: [105.896589, 32.649726],\n  &quot;四川省-广元市-旺苍县&quot;: [106.296491, 32.235097],\n  &quot;四川省-广元市-青川县&quot;: [105.245407, 32.581617],\n  &quot;四川省-广元市-剑阁县&quot;: [105.531576, 32.293479],\n  &quot;四川省-广元市-苍溪县&quot;: [105.941483, 31.738684],\n  &quot;四川省-遂宁市&quot;: [105.599422, 30.539098],\n  &quot;四川省-遂宁市-船山区&quot;: [105.574523, 30.531471],\n  &quot;四川省-遂宁市-安居区&quot;: [105.462467, 30.361496],\n  &quot;四川省-遂宁市-蓬溪县&quot;: [105.713446, 30.763751],\n  &quot;四川省-遂宁市-射洪县&quot;: [105.39451, 30.877139],\n  &quot;四川省-遂宁市-大英县&quot;: [105.243404, 30.60081],\n  &quot;四川省-内江市&quot;: [105.064588, 29.585887],\n  &quot;四川省-内江市-市中区&quot;: [105.074574, 29.59271],\n  &quot;四川省-内江市-东兴区&quot;: [105.082547, 29.598486],\n  &quot;四川省-内江市-威远县&quot;: [104.674498, 29.533635],\n  &quot;四川省-内江市-资中县&quot;: [104.858495, 29.770234],\n  &quot;四川省-内江市-隆昌县&quot;: [105.294572, 29.345245],\n  &quot;四川省-乐山市&quot;: [103.772538, 29.557941],\n  &quot;四川省-乐山市-市中区&quot;: [103.767559, 29.561364],\n  &quot;四川省-乐山市-沙湾区&quot;: [103.556436, 29.419272],\n  &quot;四川省-乐山市-五通桥区&quot;: [103.824455, 29.413185],\n  &quot;四川省-乐山市-金口河区&quot;: [103.085394, 29.250804],\n  &quot;四川省-乐山市-犍为县&quot;: [103.955507, 29.214219],\n  &quot;四川省-乐山市-井研县&quot;: [104.076511, 29.657303],\n  &quot;四川省-乐山市-夹江县&quot;: [103.57841, 29.743846],\n  &quot;四川省-乐山市-沐川县&quot;: [103.908467, 28.962888],\n  &quot;四川省-乐山市-峨边彝族自治县&quot;: [103.268577, 29.236089],\n  &quot;四川省-乐山市-马边彝族自治县&quot;: [103.552454, 28.841736],\n  &quot;四川省-乐山市-峨眉山市&quot;: [103.491546, 29.606976],\n  &quot;四川省-南充市&quot;: [106.117503, 30.843783],\n  &quot;四川省-南充市-顺庆区&quot;: [106.098411, 30.802753],\n  &quot;四川省-南充市-高坪区&quot;: [106.12554, 30.787255],\n  &quot;四川省-南充市-嘉陵区&quot;: [106.078433, 30.764896],\n  &quot;四川省-南充市-南部县&quot;: [106.043578, 31.353705],\n  &quot;四川省-南充市-营山县&quot;: [106.572408, 31.083003],\n  &quot;四川省-南充市-蓬安县&quot;: [106.418482, 31.034631],\n  &quot;四川省-南充市-仪陇县&quot;: [106.30943, 31.277597],\n  &quot;四川省-南充市-西充县&quot;: [105.907611, 31.000688],\n  &quot;四川省-南充市-阆中市&quot;: [106.011565, 31.564075],\n  &quot;四川省-眉山市&quot;: [103.856563, 30.082526],\n  &quot;四川省-眉山市-东坡区&quot;: [103.838525, 30.048272],\n  &quot;四川省-眉山市-彭山区&quot;: [103.879558, 30.198854],\n  &quot;四川省-眉山市-仁寿县&quot;: [104.140477, 30.001664],\n  &quot;四川省-眉山市-洪雅县&quot;: [103.379602, 29.910616],\n  &quot;四川省-眉山市-丹棱县&quot;: [103.519583, 30.020363],\n  &quot;四川省-眉山市-青神县&quot;: [103.853559, 29.837055],\n  &quot;四川省-宜宾市&quot;: [104.649404, 28.758007],\n  &quot;四川省-宜宾市-翠屏区&quot;: [104.626438, 28.772052],\n  &quot;四川省-宜宾市-南溪区&quot;: [104.976513, 28.851504],\n  &quot;四川省-宜宾市-宜宾县&quot;: [104.539443, 28.696246],\n  &quot;四川省-宜宾市-江安县&quot;: [105.073595, 28.72961],\n  &quot;四川省-宜宾市-长宁县&quot;: [104.927564, 28.588133],\n  &quot;四川省-宜宾市-高县&quot;: [104.524411, 28.442511],\n  &quot;四川省-宜宾市-珙县&quot;: [104.715575, 28.44432],\n  &quot;四川省-宜宾市-筠连县&quot;: [104.517406, 28.170174],\n  &quot;四川省-宜宾市-兴文县&quot;: [105.242402, 28.309905],\n  &quot;四川省-宜宾市-屏山县&quot;: [104.05945, 28.707647],\n  &quot;四川省-广安市&quot;: [106.639553, 30.461746],\n  &quot;四川省-广安市-广安区&quot;: [106.648531, 30.479768],\n  &quot;四川省-广安市-前锋区&quot;: [106.639553, 30.461746],\n  &quot;四川省-广安市-岳池县&quot;: [106.446411, 30.54412],\n  &quot;四川省-广安市-武胜县&quot;: [106.302462, 30.355496],\n  &quot;四川省-广安市-邻水县&quot;: [106.936403, 30.341073],\n  &quot;四川省-广安市-华蓥市&quot;: [106.789462, 30.396307],\n  &quot;四川省-达州市&quot;: [107.474594, 31.214308],\n  &quot;四川省-达州市-通川区&quot;: [107.511447, 31.220932],\n  &quot;四川省-达州市-达川区&quot;: [107.518411, 31.202393],\n  &quot;四川省-达州市-宣汉县&quot;: [107.733534, 31.359755],\n  &quot;四川省-达州市-开江县&quot;: [107.875425, 31.089372],\n  &quot;四川省-达州市-大竹县&quot;: [107.21158, 30.742077],\n  &quot;四川省-达州市-渠县&quot;: [106.979583, 30.842299],\n  &quot;四川省-达州市-万源市&quot;: [108.041541, 32.087421],\n  &quot;四川省-雅安市&quot;: [103.049543, 30.016793],\n  &quot;四川省-雅安市-雨城区&quot;: [103.039575, 30.011062],\n  &quot;四川省-雅安市-名山区&quot;: [103.115486, 30.075914],\n  &quot;四川省-雅安市-荥经县&quot;: [102.853436, 29.799194],\n  &quot;四川省-雅安市-汉源县&quot;: [102.658576, 29.350217],\n  &quot;四川省-雅安市-石棉县&quot;: [102.366405, 29.234305],\n  &quot;四川省-雅安市-天全县&quot;: [102.76453, 30.072473],\n  &quot;四川省-雅安市-芦山县&quot;: [102.934528, 30.149873],\n  &quot;四川省-雅安市-宝兴县&quot;: [102.821484, 30.374082],\n  &quot;四川省-巴中市&quot;: [106.751585, 31.872889],\n  &quot;四川省-巴中市-巴州区&quot;: [106.775513, 31.857686],\n  &quot;四川省-巴中市-恩阳区&quot;: [106.775513, 31.857686],\n  &quot;四川省-巴中市-通江县&quot;: [107.251517, 31.917714],\n  &quot;四川省-巴中市-南江县&quot;: [106.834483, 32.352532],\n  &quot;四川省-巴中市-平昌县&quot;: [107.110593, 31.566186],\n  &quot;四川省-资阳市&quot;: [104.634435, 30.134957],\n  &quot;四川省-资阳市-雁江区&quot;: [104.658424, 30.123753],\n  &quot;四川省-资阳市-安岳县&quot;: [105.342454, 30.103393],\n  &quot;四川省-资阳市-乐至县&quot;: [105.027477, 30.282348],\n  &quot;四川省-阿坝藏族羌族自治州&quot;: [102.231415, 31.905512],\n  &quot;四川省-阿坝藏族羌族自治州-马尔康市&quot;: [102.213502, 31.911748],\n  &quot;四川省-阿坝藏族羌族自治州-汶川县&quot;: [103.596518, 31.483005],\n  &quot;四川省-阿坝藏族羌族自治州-理县&quot;: [103.173511, 31.44255],\n  &quot;四川省-阿坝藏族羌族自治州-茂县&quot;: [103.85959, 31.686809],\n  &quot;四川省-阿坝藏族羌族自治州-松潘县&quot;: [103.61058, 32.661797],\n  &quot;四川省-阿坝藏族羌族自治州-九寨沟县&quot;: [104.249547, 33.257592],\n  &quot;四川省-阿坝藏族羌族自治州-金川县&quot;: [102.07061, 31.482006],\n  &quot;四川省-阿坝藏族羌族自治州-小金县&quot;: [102.369426, 31.002209],\n  &quot;四川省-阿坝藏族羌族自治州-黑水县&quot;: [102.996517, 32.067805],\n  &quot;四川省-阿坝藏族羌族自治州-壤塘县&quot;: [100.985583, 32.271093],\n  &quot;四川省-阿坝藏族羌族自治州-阿坝县&quot;: [101.71361, 32.908221],\n  &quot;四川省-阿坝藏族羌族自治州-若尔盖县&quot;: [102.974391, 33.584377],\n  &quot;四川省-阿坝藏族羌族自治州-红原县&quot;: [102.550615, 32.796605],\n  &quot;四川省-甘孜藏族自治州&quot;: [101.968547, 30.055279],\n  &quot;四川省-甘孜藏族自治州-康定市&quot;: [101.963555, 30.004407],\n  &quot;四川省-甘孜藏族自治州-泸定县&quot;: [102.241432, 29.920402],\n  &quot;四川省-甘孜藏族自治州-丹巴县&quot;: [101.896437, 30.88477],\n  &quot;四川省-甘孜藏族自治州-九龙县&quot;: [101.896437, 30.88477],\n  &quot;四川省-甘孜藏族自治州-雅江县&quot;: [101.0205, 30.037569],\n  &quot;四川省-甘孜藏族自治州-道孚县&quot;: [101.13154, 30.985326],\n  &quot;四川省-甘孜藏族自治州-炉霍县&quot;: [100.682397, 31.397992],\n  &quot;四川省-甘孜藏族自治州-甘孜县&quot;: [99.99921, 31.628957],\n  &quot;四川省-甘孜藏族自治州-新龙县&quot;: [100.318398, 30.94547],\n  &quot;四川省-甘孜藏族自治州-德格县&quot;: [98.587402, 31.812106],\n  &quot;四川省-甘孜藏族自治州-白玉县&quot;: [98.8311, 31.215314],\n  &quot;四川省-甘孜藏族自治州-石渠县&quot;: [98.109481, 32.984003],\n  &quot;四川省-甘孜藏族自治州-色达县&quot;: [100.339414, 32.27433],\n  &quot;四川省-甘孜藏族自治州-理塘县&quot;: [100.275575, 30.000031],\n  &quot;四川省-甘孜藏族自治州-巴塘县&quot;: [99.116727, 30.011662],\n  &quot;四川省-甘孜藏族自治州-乡城县&quot;: [99.80506, 28.936733],\n  &quot;四川省-甘孜藏族自治州-稻城县&quot;: [100.304462, 29.043122],\n  &quot;四川省-甘孜藏族自治州-得荣县&quot;: [99.292984, 28.71878],\n  &quot;四川省-凉山彝族自治州&quot;: [102.273503, 27.887752],\n  &quot;四川省-凉山彝族自治州-西昌市&quot;: [102.271484, 27.900581],\n  &quot;四川省-凉山彝族自治州-木里藏族自治县&quot;: [101.286397, 27.934599],\n  &quot;四川省-凉山彝族自治州-盐源县&quot;: [101.515429, 27.428155],\n  &quot;四川省-凉山彝族自治州-德昌县&quot;: [102.182596, 27.408504],\n  &quot;四川省-凉山彝族自治州-会理县&quot;: [102.251436, 26.6612],\n  &quot;四川省-凉山彝族自治州-会东县&quot;: [102.584462, 26.640824],\n  &quot;四川省-凉山彝族自治州-宁南县&quot;: [102.762526, 27.064605],\n  &quot;四川省-凉山彝族自治州-普格县&quot;: [102.546597, 27.381996],\n  &quot;四川省-凉山彝族自治州-布拖县&quot;: [102.818478, 27.712129],\n  &quot;四川省-凉山彝族自治州-金阳县&quot;: [103.254549, 27.702145],\n  &quot;四川省-凉山彝族自治州-昭觉县&quot;: [102.849423, 28.020506],\n  &quot;四川省-凉山彝族自治州-喜德县&quot;: [102.419567, 28.31271],\n  &quot;四川省-凉山彝族自治州-冕宁县&quot;: [102.183575, 28.555294],\n  &quot;四川省-凉山彝族自治州-越西县&quot;: [102.514474, 28.645828],\n  &quot;四川省-凉山彝族自治州-甘洛县&quot;: [102.778597, 28.964823],\n  &quot;四川省-凉山彝族自治州-美姑县&quot;: [103.138586, 28.33402],\n  &quot;四川省-凉山彝族自治州-雷波县&quot;: [103.578429, 28.268951],\n  &quot;贵州省&quot;: [106.714476, 26.60403],\n  &quot;贵州省-贵阳市&quot;: [106.714476, 26.60403],\n  &quot;贵州省-贵阳市-南明区&quot;: [106.720528, 26.574336],\n  &quot;贵州省-贵阳市-云岩区&quot;: [106.730535, 26.610381],\n  &quot;贵州省-贵阳市-花溪区&quot;: [106.676441, 26.415879],\n  &quot;贵州省-贵阳市-乌当区&quot;: [106.757558, 26.636529],\n  &quot;贵州省-贵阳市-白云区&quot;: [106.629597, 26.683588],\n  &quot;贵州省-贵阳市-观山湖区&quot;: [106.757558, 26.636529],\n  &quot;贵州省-贵阳市-开阳县&quot;: [106.97156, 27.063674],\n  &quot;贵州省-贵阳市-息烽县&quot;: [106.747562, 27.096475],\n  &quot;贵州省-贵阳市-修文县&quot;: [106.598492, 26.844862],\n  &quot;贵州省-贵阳市-清镇市&quot;: [106.477523, 26.561988],\n  &quot;贵州省-六盘水市&quot;: [104.837555, 26.598833],\n  &quot;贵州省-六盘水市-钟山区&quot;: [104.85053, 26.580704],\n  &quot;贵州省-六盘水市-六枝特区&quot;: [105.483429, 26.219214],\n  &quot;贵州省-六盘水市-水城县&quot;: [104.964566, 26.55372],\n  &quot;贵州省-六盘水市-盘县&quot;: [104.478582, 25.715651],\n  &quot;贵州省-遵义市&quot;: [106.933428, 27.731701],\n  &quot;贵州省-遵义市-红花岗区&quot;: [106.900497, 27.65087],\n  &quot;贵州省-遵义市-汇川区&quot;: [106.940458, 27.756343],\n  &quot;贵州省-遵义市-播州区&quot;: [106.836504, 27.542501],\n  &quot;贵州省-遵义市-桐梓县&quot;: [106.832489, 28.139468],\n  &quot;贵州省-遵义市-绥阳县&quot;: [107.197492, 27.95308],\n  &quot;贵州省-遵义市-正安县&quot;: [107.460575, 28.559092],\n  &quot;贵州省-遵义市-道真仡佬族苗族自治县&quot;: [107.619484, 28.86865],\n  &quot;贵州省-遵义市-务川仡佬族苗族自治县&quot;: [107.905456, 28.569077],\n  &quot;贵州省-遵义市-凤冈县&quot;: [107.723548, 27.960695],\n  &quot;贵州省-遵义市-湄潭县&quot;: [107.472599, 27.754498],\n  &quot;贵州省-遵义市-余庆县&quot;: [107.91146, 27.221379],\n  &quot;贵州省-遵义市-习水县&quot;: [106.203428, 28.339118],\n  &quot;贵州省-遵义市-赤水市&quot;: [105.703489, 28.596119],\n  &quot;贵州省-遵义市-仁怀市&quot;: [106.407527, 27.797752],\n  &quot;贵州省-安顺市&quot;: [105.954417, 26.259252],\n  &quot;贵州省-安顺市-西秀区&quot;: [105.972406, 26.251498],\n  &quot;贵州省-安顺市-平坝区&quot;: [106.263584, 26.411186],\n  &quot;贵州省-安顺市-普定县&quot;: [105.748486, 26.308233],\n  &quot;贵州省-安顺市-镇宁布依族苗族自治县&quot;: [105.776583, 26.063829],\n  &quot;贵州省-安顺市-关岭布依族苗族自治县&quot;: [105.625476, 25.949877],\n  &quot;贵州省-安顺市-紫云苗族布依族自治县&quot;: [106.090414, 25.757409],\n  &quot;贵州省-毕节市&quot;: [105.311581, 27.304095],\n  &quot;贵州省-毕节市-七星关区&quot;: [105.311581, 27.304095],\n  &quot;贵州省-毕节市-大方县&quot;: [105.611399, 27.165261],\n  &quot;贵州省-毕节市-黔西县&quot;: [106.038574, 27.014345],\n  &quot;贵州省-毕节市-金沙县&quot;: [106.226442, 27.465355],\n  &quot;贵州省-毕节市-织金县&quot;: [105.77759, 26.669222],\n  &quot;贵州省-毕节市-纳雍县&quot;: [105.389487, 26.783717],\n  &quot;贵州省-毕节市-威宁彝族回族苗族自治县&quot;: [104.282508, 26.875711],\n  &quot;贵州省-毕节市-赫章县&quot;: [104.733516, 27.129052],\n  &quot;贵州省-铜仁市&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-碧江区&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-万山区&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-江口县&quot;: [108.857371, 27.699558],\n  &quot;贵州省-铜仁市-玉屏侗族自治县&quot;: [109.024903, 27.455339],\n  &quot;贵州省-铜仁市-石阡县&quot;: [108.230464, 27.519722],\n  &quot;贵州省-铜仁市-思南县&quot;: [109.195295, 27.743042],\n  &quot;贵州省-铜仁市-印江土家族苗族自治县&quot;: [108.415088, 27.999307],\n  &quot;贵州省-铜仁市-德江县&quot;: [108.126401, 28.270733],\n  &quot;贵州省-铜仁市-沿河土家族自治县&quot;: [108.50793, 28.570124],\n  &quot;贵州省-铜仁市-松桃苗族自治县&quot;: [109.134326, 27.875214],\n  &quot;贵州省-黔西南布依族苗族自治州&quot;: [104.912492, 25.093967],\n  &quot;贵州省-黔西南布依族苗族自治州-兴义市&quot;: [104.902461, 25.098113],\n  &quot;贵州省-黔西南布依族苗族自治州-兴仁县&quot;: [105.192568, 25.440899],\n  &quot;贵州省-黔西南布依族苗族自治州-普安县&quot;: [104.959546, 25.789952],\n  &quot;贵州省-黔西南布依族苗族自治州-晴隆县&quot;: [105.225484, 25.841048],\n  &quot;贵州省-黔西南布依族苗族自治州-贞丰县&quot;: [105.65656, 25.392124],\n  &quot;贵州省-黔西南布依族苗族自治州-望谟县&quot;: [106.106445, 25.184355],\n  &quot;贵州省-黔西南布依族苗族自治州-册亨县&quot;: [105.818511, 24.989637],\n  &quot;贵州省-黔西南布依族苗族自治州-安龙县&quot;: [105.449543, 25.10399],\n  &quot;贵州省-黔东南苗族侗族自治州&quot;: [107.989446, 26.589703],\n  &quot;贵州省-黔东南苗族侗族自治州-凯里市&quot;: [107.987469, 26.573079],\n  &quot;贵州省-黔东南苗族侗族自治州-黄平县&quot;: [107.923548, 26.911289],\n  &quot;贵州省-黔东南苗族侗族自治州-施秉县&quot;: [108.13044, 27.039822],\n  &quot;贵州省-黔东南苗族侗族自治州-三穗县&quot;: [108.681545, 26.958666],\n  &quot;贵州省-黔东南苗族侗族自治州-镇远县&quot;: [108.436581, 27.054821],\n  &quot;贵州省-黔东南苗族侗族自治州-岑巩县&quot;: [108.822481, 27.179902],\n  &quot;贵州省-黔东南苗族侗族自治州-天柱县&quot;: [109.214446, 26.915804],\n  &quot;贵州省-黔东南苗族侗族自治州-锦屏县&quot;: [109.207438, 26.682632],\n  &quot;贵州省-黔东南苗族侗族自治州-剑河县&quot;: [108.447517, 26.734048],\n  &quot;贵州省-黔东南苗族侗族自治州-台江县&quot;: [108.328552, 26.672373],\n  &quot;贵州省-黔东南苗族侗族自治州-黎平县&quot;: [109.143567, 26.236874],\n  &quot;贵州省-黔东南苗族侗族自治州-榕江县&quot;: [108.527554, 25.937725],\n  &quot;贵州省-黔东南苗族侗族自治州-从江县&quot;: [108.911561, 25.759881],\n  &quot;贵州省-黔东南苗族侗族自治州-雷山县&quot;: [108.084529, 26.384205],\n  &quot;贵州省-黔东南苗族侗族自治州-麻江县&quot;: [107.595551, 26.496808],\n  &quot;贵州省-黔东南苗族侗族自治州-丹寨县&quot;: [107.795513, 26.204421],\n  &quot;贵州省-黔南布依族苗族自治州&quot;: [107.528403, 26.260616],\n  &quot;贵州省-黔南布依族苗族自治州-都匀市&quot;: [107.525404, 26.266118],\n  &quot;贵州省-黔南布依族苗族自治州-福泉市&quot;: [107.526433, 26.692526],\n  &quot;贵州省-黔南布依族苗族自治州-荔波县&quot;: [107.893409, 25.417098],\n  &quot;贵州省-黔南布依族苗族自治州-贵定县&quot;: [107.240554, 26.59066],\n  &quot;贵州省-黔南布依族苗族自治州-瓮安县&quot;: [107.477552, 27.084126],\n  &quot;贵州省-黔南布依族苗族自治州-独山县&quot;: [107.551498, 25.828288],\n  &quot;贵州省-黔南布依族苗族自治州-平塘县&quot;: [107.329567, 25.828202],\n  &quot;贵州省-黔南布依族苗族自治州-罗甸县&quot;: [106.758548, 25.430838],\n  &quot;贵州省-黔南布依族苗族自治州-长顺县&quot;: [106.458421, 26.028455],\n  &quot;贵州省-黔南布依族苗族自治州-龙里县&quot;: [106.986586, 26.459081],\n  &quot;贵州省-黔南布依族苗族自治州-惠水县&quot;: [106.663453, 26.13821],\n  &quot;贵州省-黔南布依族苗族自治州-三都水族自治县&quot;: [107.876429, 25.989479],\n  &quot;云南省&quot;: [102.716416, 25.051562],\n  &quot;云南省-昆明市&quot;: [102.852448, 24.873998],\n  &quot;云南省-昆明市-五华区&quot;: [102.713423, 25.049835],\n  &quot;云南省-昆明市-盘龙区&quot;: [102.758526, 25.122372],\n  &quot;云南省-昆明市-官渡区&quot;: [102.750482, 25.021196],\n  &quot;云南省-昆明市-西山区&quot;: [102.671557, 25.043199],\n  &quot;云南省-昆明市-东川区&quot;: [103.194452, 26.089054],\n  &quot;云南省-昆明市-呈贡区&quot;: [102.827473, 24.891871],\n  &quot;云南省-昆明市-晋宁县&quot;: [102.602418, 24.676099],\n  &quot;云南省-昆明市-富民县&quot;: [102.504473, 25.228085],\n  &quot;云南省-昆明市-宜良县&quot;: [103.147558, 24.925287],\n  &quot;云南省-昆明市-石林彝族自治县&quot;: [103.296508, 24.777702],\n  &quot;云南省-昆明市-嵩明县&quot;: [103.043564, 25.344409],\n  &quot;云南省-昆明市-禄劝彝族苗族自治县&quot;: [102.477423, 25.557672],\n  &quot;云南省-昆明市-寻甸回族彝族自治县&quot;: [103.263574, 25.563894],\n  &quot;云南省-昆明市-安宁市&quot;: [102.484409, 24.925602],\n  &quot;云南省-曲靖市&quot;: [103.802435, 25.496407],\n  &quot;云南省-曲靖市-麒麟区&quot;: [103.81143, 25.502102],\n  &quot;云南省-曲靖市-沾益区&quot;: [103.828485, 25.606631],\n  &quot;云南省-曲靖市-马龙县&quot;: [103.585447, 25.433966],\n  &quot;云南省-曲靖市-陆良县&quot;: [103.673432, 25.035639],\n  &quot;云南省-曲靖市-师宗县&quot;: [103.991556, 24.827995],\n  &quot;云南省-曲靖市-罗平县&quot;: [104.31551, 24.89052],\n  &quot;云南省-曲靖市-富源县&quot;: [104.261474, 25.68028],\n  &quot;云南省-曲靖市-会泽县&quot;: [103.303487, 26.424215],\n  &quot;云南省-曲靖市-宣威市&quot;: [104.111576, 26.225598],\n  &quot;云南省-玉溪市&quot;: [102.55356, 24.357711],\n  &quot;云南省-玉溪市-红塔区&quot;: [102.551565, 24.359801],\n  &quot;云南省-玉溪市-江川区&quot;: [102.760527, 24.293439],\n  &quot;云南省-玉溪市-澄江县&quot;: [102.914555, 24.679415],\n  &quot;云南省-玉溪市-通海县&quot;: [102.732423, 24.117891],\n  &quot;云南省-玉溪市-华宁县&quot;: [102.935492, 24.198581],\n  &quot;云南省-玉溪市-易门县&quot;: [102.169535, 24.677404],\n  &quot;云南省-玉溪市-峨山彝族自治县&quot;: [102.412565, 24.174774],\n  &quot;云南省-玉溪市-新平彝族傣族自治县&quot;: [101.996428, 24.076263],\n  &quot;云南省-玉溪市-元江哈尼族彝族傣族自治县&quot;: [102.004415, 23.603001],\n  &quot;云南省-保山市&quot;: [99.177273, 25.139039],\n  &quot;云南省-保山市-隆阳区&quot;: [99.172071, 25.126888],\n  &quot;云南省-保山市-施甸县&quot;: [99.195469, 24.728835],\n  &quot;云南省-保山市-龙陵县&quot;: [98.69575, 24.592547],\n  &quot;云南省-保山市-昌宁县&quot;: [99.611617, 24.833985],\n  &quot;云南省-保山市-腾冲市&quot;: [98.497595, 25.026617],\n  &quot;云南省-昭通市&quot;: [103.723512, 27.344084],\n  &quot;云南省-昭通市-昭阳区&quot;: [103.71347, 27.326144],\n  &quot;云南省-昭通市-鲁甸县&quot;: [103.564412, 27.193107],\n  &quot;云南省-昭通市-巧家县&quot;: [102.936519, 26.914705],\n  &quot;云南省-昭通市-盐津县&quot;: [104.241579, 28.114384],\n  &quot;云南省-昭通市-大关县&quot;: [103.897515, 27.754021],\n  &quot;云南省-昭通市-永善县&quot;: [103.644569, 28.234722],\n  &quot;云南省-昭通市-绥江县&quot;: [103.964552, 28.604278],\n  &quot;云南省-昭通市-镇雄县&quot;: [104.880404, 27.447795],\n  &quot;云南省-昭通市-彝良县&quot;: [104.054443, 27.63169],\n  &quot;云南省-昭通市-威信县&quot;: [105.055577, 27.852537],\n  &quot;云南省-昭通市-水富县&quot;: [104.422433, 28.636107],\n  &quot;云南省-丽江市&quot;: [100.232465, 26.860657],\n  &quot;云南省-丽江市-古城区&quot;: [100.23248, 26.883162],\n  &quot;云南省-丽江市-玉龙纳西族自治县&quot;: [100.243527, 26.827392],\n  &quot;云南省-丽江市-永胜县&quot;: [100.757581, 26.68995],\n  &quot;云南省-丽江市-华坪县&quot;: [101.27243, 26.635223],\n  &quot;云南省-丽江市-宁蒗彝族自治县&quot;: [100.85859, 27.287728],\n  &quot;云南省-普洱市&quot;: [100.97257, 22.830979],\n  &quot;云南省-普洱市-思茅区&quot;: [100.983555, 22.792498],\n  &quot;云南省-普洱市-宁洱哈尼族彝族自治县&quot;: [101.052442, 23.05459],\n  &quot;云南省-普洱市-墨江哈尼族自治县&quot;: [101.698584, 23.437726],\n  &quot;云南省-普洱市-景东彝族自治县&quot;: [100.838489, 24.451864],\n  &quot;云南省-普洱市-景谷傣族彝族自治县&quot;: [100.838489, 24.451864],\n  &quot;云南省-普洱市-镇沅彝族哈尼族拉祜族自治县&quot;: [101.115569, 24.010331],\n  &quot;云南省-普洱市-江城哈尼族彝族自治县&quot;: [101.868479, 22.591684],\n  &quot;云南省-普洱市-孟连傣族拉祜族佤族自治县&quot;: [99.590963, 22.335308],\n  &quot;云南省-普洱市-澜沧拉祜族自治县&quot;: [99.938588, 22.561832],\n  &quot;云南省-普洱市-西盟佤族自治县&quot;: [99.596622, 22.650656],\n  &quot;云南省-临沧市&quot;: [100.09544, 23.890469],\n  &quot;云南省-临沧市-临翔区&quot;: [100.088443, 23.901402],\n  &quot;云南省-临沧市-凤庆县&quot;: [99.934989, 24.586472],\n  &quot;云南省-临沧市-云县&quot;: [100.129531, 24.442807],\n  &quot;云南省-临沧市-永德县&quot;: [99.265076, 24.024871],\n  &quot;云南省-临沧市-镇康县&quot;: [98.831871, 23.768315],\n  &quot;云南省-临沧市-双江拉祜族佤族布朗族傣族自治县&quot;: [99.834131, 23.479837],\n  &quot;云南省-临沧市-耿马傣族佤族自治县&quot;: [99.403942, 23.543491],\n  &quot;云南省-临沧市-沧源佤族自治县&quot;: [99.252722, 23.152879],\n  &quot;云南省-楚雄彝族自治州&quot;: [101.534412, 25.051774],\n  &quot;云南省-楚雄彝族自治州-楚雄市&quot;: [101.552472, 25.03886],\n  &quot;云南省-楚雄彝族自治州-双柏县&quot;: [101.552472, 25.03886],\n  &quot;云南省-楚雄彝族自治州-牟定县&quot;: [101.553481, 25.318846],\n  &quot;云南省-楚雄彝族自治州-南华县&quot;: [101.280421, 25.198587],\n  &quot;云南省-楚雄彝族自治州-姚安县&quot;: [101.248527, 25.509775],\n  &quot;云南省-楚雄彝族自治州-大姚县&quot;: [101.330567, 25.727601],\n  &quot;云南省-楚雄彝族自治州-永仁县&quot;: [101.672493, 26.055566],\n  &quot;云南省-楚雄彝族自治州-元谋县&quot;: [101.880445, 25.710895],\n  &quot;云南省-楚雄彝族自治州-武定县&quot;: [102.410532, 25.53609],\n  &quot;云南省-楚雄彝族自治州-禄丰县&quot;: [102.085531, 25.155831],\n  &quot;云南省-红河哈尼族彝族自治州&quot;: [103.381549, 23.369996],\n  &quot;云南省-红河哈尼族彝族自治州-个旧市&quot;: [103.166519, 23.364942],\n  &quot;云南省-红河哈尼族彝族自治州-开远市&quot;: [103.166519, 23.364942],\n  &quot;云南省-红河哈尼族彝族自治州-蒙自市&quot;: [103.371546, 23.40208],\n  &quot;云南省-红河哈尼族彝族自治州-弥勒市&quot;: [103.421489, 24.417982],\n  &quot;云南省-红河哈尼族彝族自治州-屏边苗族自治县&quot;: [103.693432, 22.98999],\n  &quot;云南省-红河哈尼族彝族自治州-建水县&quot;: [102.83344, 23.640939],\n  &quot;云南省-红河哈尼族彝族自治州-石屏县&quot;: [102.502447, 23.712004],\n  &quot;云南省-红河哈尼族彝族自治州-泸西县&quot;: [103.772523, 24.538037],\n  &quot;云南省-红河哈尼族彝族自治州-元阳县&quot;: [102.841433, 23.226198],\n  &quot;云南省-红河哈尼族彝族自治州-红河县&quot;: [102.427551, 23.374489],\n  &quot;云南省-红河哈尼族彝族自治州-金平苗族瑶族傣族自治县&quot;: [102.427551, 23.374489],\n  &quot;云南省-红河哈尼族彝族自治州-绿春县&quot;: [102.398494, 23.000165],\n  &quot;云南省-红河哈尼族彝族自治州-河口瑶族自治县&quot;: [103.945444, 22.535466],\n  &quot;云南省-文山壮族苗族自治州&quot;: [104.222569, 23.405994],\n  &quot;云南省-文山壮族苗族自治州-文山市&quot;: [104.238544, 23.391944],\n  &quot;云南省-文山壮族苗族自治州-砚山县&quot;: [104.343551, 23.611487],\n  &quot;云南省-文山壮族苗族自治州-西畴县&quot;: [104.678525, 23.443271],\n  &quot;云南省-文山壮族苗族自治州-麻栗坡县&quot;: [104.709549, 23.131586],\n  &quot;云南省-文山壮族苗族自治州-马关县&quot;: [104.400415, 23.018994],\n  &quot;云南省-文山壮族苗族自治州-丘北县&quot;: [104.173442, 24.056994],\n  &quot;云南省-文山壮族苗族自治州-广南县&quot;: [105.061582, 24.052199],\n  &quot;云南省-文山壮族苗族自治州-富宁县&quot;: [105.63749, 23.63138],\n  &quot;云南省-西双版纳傣族自治州&quot;: [100.803447, 22.013601],\n  &quot;云南省-西双版纳傣族自治州-景洪市&quot;: [100.806443, 22.017004],\n  &quot;云南省-西双版纳傣族自治州-勐海县&quot;: [100.459446, 21.963434],\n  &quot;云南省-西双版纳傣族自治州-勐腊县&quot;: [101.571528, 21.465281],\n  &quot;云南省-大理白族自治州&quot;: [100.274583, 25.612128],\n  &quot;云南省-大理白族自治州-大理市&quot;: [100.236519, 25.597605],\n  &quot;云南省-大理白族自治州-漾濞彝族自治县&quot;: [100.236519, 25.597605],\n  &quot;云南省-大理白族自治州-祥云县&quot;: [100.557447, 25.489873],\n  &quot;云南省-大理白族自治州-宾川县&quot;: [100.578457, 25.835249],\n  &quot;云南省-大理白族自治州-弥渡县&quot;: [100.497586, 25.349336],\n  &quot;云南省-大理白族自治州-南涧彝族自治县&quot;: [100.497586, 25.349336],\n  &quot;云南省-大理白族自治州-巍山彝族回族自治县&quot;: [100.31346, 25.233439],\n  &quot;云南省-大理白族自治州-永平县&quot;: [99.547495, 25.470206],\n  &quot;云南省-大理白族自治州-云龙县&quot;: [99.377416, 25.891945],\n  &quot;云南省-大理白族自治州-洱源县&quot;: [99.96921, 26.120093],\n  &quot;云南省-大理白族自治州-剑川县&quot;: [99.912091, 26.542517],\n  &quot;云南省-大理白族自治州-鹤庆县&quot;: [100.182492, 26.566197],\n  &quot;云南省-德宏傣族景颇族自治州&quot;: [98.591359, 24.438011],\n  &quot;云南省-德宏傣族景颇族自治州-瑞丽市&quot;: [97.862486, 24.022817],\n  &quot;云南省-德宏傣族景颇族自治州-芒市&quot;: [97.862486, 24.022817],\n  &quot;云南省-德宏傣族景颇族自治州-梁河县&quot;: [98.303134, 24.810784],\n  &quot;云南省-德宏傣族景颇族自治州-盈江县&quot;: [97.938427, 24.711534],\n  &quot;云南省-德宏傣族景颇族自治州-陇川县&quot;: [97.79853, 24.189468],\n  &quot;云南省-怒江傈僳族自治州&quot;: [98.863288, 25.823707],\n  &quot;云南省-怒江傈僳族自治州-泸水市&quot;: [98.864586, 25.829027],\n  &quot;云南省-怒江傈僳族自治州-福贡县&quot;: [98.875649, 26.908055],\n  &quot;云南省-怒江傈僳族自治州-贡山独龙族怒族自治县&quot;: [98.672399, 27.747068],\n  &quot;云南省-怒江傈僳族自治州-兰坪白族普米族自治县&quot;: [99.423285, 26.459208],\n  &quot;云南省-迪庆藏族自治州&quot;: [99.70953, 27.825185],\n  &quot;云南省-迪庆藏族自治州-香格里拉市&quot;: [99.707445, 27.83576],\n  &quot;云南省-迪庆藏族自治州-德钦县&quot;: [98.924453, 28.470086],\n  &quot;云南省-迪庆藏族自治州-维西傈僳族自治县&quot;: [99.293466, 27.18317],\n  &quot;西藏自治区&quot;: [91.124342, 29.652894],\n  &quot;西藏自治区-拉萨市&quot;: [91.120824, 29.65004],\n  &quot;西藏自治区-拉萨市-城关区&quot;: [91.1451, 29.658331],\n  &quot;西藏自治区-拉萨市-堆龙德庆区&quot;: [91.009963, 29.651626],\n  &quot;西藏自治区-拉萨市-林周县&quot;: [91.269501, 29.898733],\n  &quot;西藏自治区-拉萨市-当雄县&quot;: [91.107452, 30.479222],\n  &quot;西藏自治区-拉萨市-尼木县&quot;: [90.17118, 29.437519],\n  &quot;西藏自治区-拉萨市-曲水县&quot;: [90.749959, 29.358987],\n  &quot;西藏自治区-拉萨市-达孜县&quot;: [91.356318, 29.675409],\n  &quot;西藏自治区-拉萨市-墨竹工卡县&quot;: [91.737266, 29.839753],\n  &quot;西藏自治区-日喀则市&quot;: [88.902952, 29.255583],\n  &quot;西藏自治区-日喀则市-桑珠孜区&quot;: [88.902952, 29.255583],\n  &quot;西藏自治区-日喀则市-南木林县&quot;: [89.108283, 29.688959],\n  &quot;西藏自治区-日喀则市-江孜县&quot;: [89.614958, 28.916435],\n  &quot;西藏自治区-日喀则市-定日县&quot;: [88.859425, 29.004648],\n  &quot;西藏自治区-日喀则市-萨迦县&quot;: [88.02935, 28.907594],\n  &quot;西藏自治区-日喀则市-拉孜县&quot;: [88.893863, 29.273927],\n  &quot;西藏自治区-日喀则市-昂仁县&quot;: [88.88319, 29.271424],\n  &quot;西藏自治区-日喀则市-谢通门县&quot;: [88.267177, 29.436132],\n  &quot;西藏自治区-日喀则市-白朗县&quot;: [89.267941, 29.116209],\n  &quot;西藏自治区-日喀则市-仁布县&quot;: [89.848427, 29.236361],\n  &quot;西藏自治区-日喀则市-康马县&quot;: [89.688245, 28.561444],\n  &quot;西藏自治区-日喀则市-定结县&quot;: [87.772377, 28.369911],\n  &quot;西藏自治区-日喀则市-仲巴县&quot;: [84.038117, 29.775982],\n  &quot;西藏自治区-日喀则市-亚东县&quot;: [88.896978, 29.275644],\n  &quot;西藏自治区-日喀则市-吉隆县&quot;: [88.662548, 29.401862],\n  &quot;西藏自治区-日喀则市-聂拉木县&quot;: [88.889064, 29.275236],\n  &quot;西藏自治区-日喀则市-萨嘎县&quot;: [88.647947, 29.079969],\n  &quot;西藏自治区-日喀则市-岗巴县&quot;: [89.322529, 29.277094],\n  &quot;西藏自治区-昌都市&quot;: [97.186654, 31.144249],\n  &quot;西藏自治区-昌都市-卡若区&quot;: [97.186654, 31.144249],\n  &quot;西藏自治区-昌都市-江达县&quot;: [98.224424, 31.505147],\n  &quot;西藏自治区-昌都市-贡觉县&quot;: [98.277334, 30.865967],\n  &quot;西藏自治区-昌都市-类乌齐县&quot;: [96.608489, 31.22509],\n  &quot;西藏自治区-昌都市-丁青县&quot;: [97.177402, 31.149643],\n  &quot;西藏自治区-昌都市-察雅县&quot;: [97.575976, 30.660119],\n  &quot;西藏自治区-昌都市-八宿县&quot;: [96.931495, 30.061833],\n  &quot;西藏自治区-昌都市-左贡县&quot;: [97.847367, 29.676849],\n  &quot;西藏自治区-昌都市-芒康县&quot;: [96.848134, 30.738561],\n  &quot;西藏自治区-昌都市-洛隆县&quot;: [97.399916, 31.06774],\n  &quot;西藏自治区-昌都市-边坝县&quot;: [94.714371, 30.939625],\n  &quot;西藏自治区-林芝市&quot;: [94.368058, 29.654042],\n  &quot;西藏自治区-林芝市-巴宜区&quot;: [94.367544, 29.641645],\n  &quot;西藏自治区-林芝市-工布江达县&quot;: [93.25242, 29.891368],\n  &quot;西藏自治区-林芝市-米林县&quot;: [94.219939, 29.220917],\n  &quot;西藏自治区-林芝市-墨脱县&quot;: [95.339495, 29.330938],\n  &quot;西藏自治区-林芝市-波密县&quot;: [95.7739, 29.86506],\n  &quot;西藏自治区-林芝市-察隅县&quot;: [97.47327, 28.667444],\n  &quot;西藏自治区-林芝市-朗县&quot;: [93.081368, 29.051902],\n  &quot;西藏自治区-山南市&quot;: [91.778675, 29.243027],\n  &quot;西藏自治区-山南市-乃东区&quot;: [91.778682, 29.234229],\n  &quot;西藏自治区-山南市-扎囊县&quot;: [91.343627, 29.251164],\n  &quot;西藏自治区-山南市-贡嘎县&quot;: [91.343627, 29.251164],\n  &quot;西藏自治区-山南市-桑日县&quot;: [92.021252, 29.267104],\n  &quot;西藏自治区-山南市-琼结县&quot;: [91.690101, 29.030866],\n  &quot;西藏自治区-山南市-曲松县&quot;: [92.205435, 29.071107],\n  &quot;西藏自治区-山南市-措美县&quot;: [91.439918, 28.444258],\n  &quot;西藏自治区-山南市-洛扎县&quot;: [90.855029, 28.391993],\n  &quot;西藏自治区-山南市-加查县&quot;: [92.601582, 29.144787],\n  &quot;西藏自治区-山南市-隆子县&quot;: [92.469078, 28.414441],\n  &quot;西藏自治区-山南市-错那县&quot;: [91.968115, 27.998343],\n  &quot;西藏自治区-山南市-浪卡子县&quot;: [90.404647, 28.973992],\n  &quot;西藏自治区-那曲地区&quot;: [92.057338, 31.482438],\n  &quot;西藏自治区-那曲地区-那曲县&quot;: [92.059847, 31.476117],\n  &quot;西藏自治区-那曲地区-嘉黎县&quot;: [93.238732, 30.647062],\n  &quot;西藏自治区-那曲地区-比如县&quot;: [93.685966, 31.486357],\n  &quot;西藏自治区-那曲地区-聂荣县&quot;: [92.308654, 32.113707],\n  &quot;西藏自治区-那曲地区-安多县&quot;: [91.688891, 32.271268],\n  &quot;西藏自治区-那曲地区-申扎县&quot;: [88.716481, 30.936393],\n  &quot;西藏自治区-那曲地区-索县&quot;: [93.792173, 31.892424],\n  &quot;西藏自治区-那曲地区-班戈县&quot;: [90.016708, 31.398728],\n  &quot;西藏自治区-那曲地区-巴青县&quot;: [94.059882, 31.924549],\n  &quot;西藏自治区-那曲地区-尼玛县&quot;: [87.243292, 31.790953],\n  &quot;西藏自治区-那曲地区-双湖县&quot;: [87.243292, 31.790953],\n  &quot;西藏自治区-阿里地区&quot;: [80.112777, 32.506866],\n  &quot;西藏自治区-阿里地区-普兰县&quot;: [81.183095, 30.300163],\n  &quot;西藏自治区-阿里地区-札达县&quot;: [79.809323, 31.485343],\n  &quot;西藏自治区-阿里地区-噶尔县&quot;: [80.102877, 32.497157],\n  &quot;西藏自治区-阿里地区-日土县&quot;: [79.739109, 33.387186],\n  &quot;西藏自治区-阿里地区-革吉县&quot;: [81.151664, 32.393356],\n  &quot;西藏自治区-阿里地区-改则县&quot;: [84.069113, 32.308357],\n  &quot;西藏自治区-阿里地区-措勤县&quot;: [84.069113, 32.308357],\n  &quot;陕西省&quot;: [108.960393, 34.275808],\n  &quot;陕西省-西安市&quot;: [108.946466, 34.347269],\n  &quot;陕西省-西安市-新城区&quot;: [108.967391, 34.272724],\n  &quot;陕西省-西安市-碑林区&quot;: [108.940498, 34.236474],\n  &quot;陕西省-西安市-莲湖区&quot;: [108.950426, 34.271017],\n  &quot;陕西省-西安市-灞桥区&quot;: [109.071415, 34.279128],\n  &quot;陕西省-西安市-未央区&quot;: [108.953401, 34.299148],\n  &quot;陕西省-西安市-雁塔区&quot;: [108.95144, 34.220635],\n  &quot;陕西省-西安市-阎良区&quot;: [109.232463, 34.668363],\n  &quot;陕西省-西安市-临潼区&quot;: [109.220436, 34.372747],\n  &quot;陕西省-西安市-长安区&quot;: [108.91358, 34.16329],\n  &quot;陕西省-西安市-高陵区&quot;: [109.094387, 34.541093],\n  &quot;陕西省-西安市-蓝田县&quot;: [109.329388, 34.157621],\n  &quot;陕西省-西安市-周至县&quot;: [108.228422, 34.169385],\n  &quot;陕西省-西安市-户县&quot;: [108.61142, 34.115021],\n  &quot;陕西省-铜川市&quot;: [108.952404, 34.902637],\n  &quot;陕西省-铜川市-王益区&quot;: [109.081417, 35.075322],\n  &quot;陕西省-铜川市-印台区&quot;: [109.106434, 35.120859],\n  &quot;陕西省-铜川市-耀州区&quot;: [108.986438, 34.91596],\n  &quot;陕西省-铜川市-宜君县&quot;: [109.123537, 35.404582],\n  &quot;陕西省-宝鸡市&quot;: [107.244575, 34.368916],\n  &quot;陕西省-宝鸡市-渭滨区&quot;: [107.156419, 34.377481],\n  &quot;陕西省-宝鸡市-金台区&quot;: [107.153424, 34.382351],\n  &quot;陕西省-宝鸡市-陈仓区&quot;: [107.393438, 34.360756],\n  &quot;陕西省-宝鸡市-凤翔县&quot;: [107.407379, 34.527616],\n  &quot;陕西省-宝鸡市-岐山县&quot;: [107.627447, 34.449777],\n  &quot;陕西省-宝鸡市-扶风县&quot;: [107.906453, 34.381463],\n  &quot;陕西省-宝鸡市-眉县&quot;: [107.756398, 34.280376],\n  &quot;陕西省-宝鸡市-陇县&quot;: [106.870584, 34.89878],\n  &quot;陕西省-宝鸡市-千阳县&quot;: [107.139466, 34.648545],\n  &quot;陕西省-宝鸡市-麟游县&quot;: [107.799514, 34.683749],\n  &quot;陕西省-宝鸡市-凤县&quot;: [106.522558, 33.916583],\n  &quot;陕西省-宝鸡市-太白县&quot;: [107.325529, 34.064248],\n  &quot;陕西省-咸阳市&quot;: [108.715422, 34.335476],\n  &quot;陕西省-咸阳市-秦都区&quot;: [108.712432, 34.335145],\n  &quot;陕西省-咸阳市-杨陵区&quot;: [108.091515, 34.278013],\n  &quot;陕西省-咸阳市-渭城区&quot;: [108.743451, 34.36811],\n  &quot;陕西省-咸阳市-三原县&quot;: [108.947447, 34.623079],\n  &quot;陕西省-咸阳市-泾阳县&quot;: [108.849379, 34.533317],\n  &quot;陕西省-咸阳市-乾县&quot;: [108.245378, 34.534018],\n  &quot;陕西省-咸阳市-礼泉县&quot;: [108.431615, 34.487391],\n  &quot;陕西省-咸阳市-永寿县&quot;: [108.148469, 34.698036],\n  &quot;陕西省-咸阳市-彬县&quot;: [108.084566, 35.049611],\n  &quot;陕西省-咸阳市-长武县&quot;: [107.805561, 35.211657],\n  &quot;陕西省-咸阳市-旬邑县&quot;: [108.340467, 35.117964],\n  &quot;陕西省-咸阳市-淳化县&quot;: [108.587442, 34.804777],\n  &quot;陕西省-咸阳市-武功县&quot;: [108.206551, 34.266138],\n  &quot;陕西省-咸阳市-兴平市&quot;: [108.496394, 34.305477],\n  &quot;陕西省-渭南市&quot;: [109.51659, 34.505716],\n  &quot;陕西省-渭南市-临渭区&quot;: [109.498596, 34.504],\n  &quot;陕西省-渭南市-华州区&quot;: [109.778477, 34.518731],\n  &quot;陕西省-渭南市-潼关县&quot;: [110.252508, 34.550327],\n  &quot;陕西省-渭南市-大荔县&quot;: [109.948453, 34.801833],\n  &quot;陕西省-渭南市-合阳县&quot;: [110.155396, 35.243872],\n  &quot;陕西省-渭南市-澄城县&quot;: [109.938434, 35.196573],\n  &quot;陕西省-渭南市-蒲城县&quot;: [109.592497, 34.961274],\n  &quot;陕西省-渭南市-白水县&quot;: [109.597521, 35.183288],\n  &quot;陕西省-渭南市-富平县&quot;: [109.186437, 34.75726],\n  &quot;陕西省-渭南市-韩城市&quot;: [110.449553, 35.482087],\n  &quot;陕西省-渭南市-华阴市&quot;: [110.098601, 34.5718],\n  &quot;陕西省-延安市&quot;: [109.496582, 36.591111],\n  &quot;陕西省-延安市-宝塔区&quot;: [109.499594, 36.59689],\n  &quot;陕西省-延安市-安塞区&quot;: [109.335419, 36.870098],\n  &quot;陕西省-延安市-延长县&quot;: [110.018472, 36.585329],\n  &quot;陕西省-延安市-延川县&quot;: [110.20054, 36.884137],\n  &quot;陕西省-延安市-子长县&quot;: [109.68139, 37.148817],\n  &quot;陕西省-延安市-志丹县&quot;: [108.775577, 36.828021],\n  &quot;陕西省-延安市-吴起县&quot;: [108.18259, 36.932576],\n  &quot;陕西省-延安市-甘泉县&quot;: [109.357524, 36.282689],\n  &quot;陕西省-延安市-富县&quot;: [109.386597, 35.993368],\n  &quot;陕西省-延安市-洛川县&quot;: [109.438404, 35.7683],\n  &quot;陕西省-延安市-宜川县&quot;: [110.175413, 36.056397],\n  &quot;陕西省-延安市-黄龙县&quot;: [109.846549, 35.590234],\n  &quot;陕西省-延安市-黄陵县&quot;: [109.269606, 35.585076],\n  &quot;陕西省-汉中市&quot;: [107.02943, 33.0738],\n  &quot;陕西省-汉中市-汉台区&quot;: [107.038402, 33.074191],\n  &quot;陕西省-汉中市-南郑县&quot;: [106.942433, 33.005615],\n  &quot;陕西省-汉中市-城固县&quot;: [107.340613, 33.162399],\n  &quot;陕西省-汉中市-洋县&quot;: [107.552464, 33.228863],\n  &quot;陕西省-汉中市-西乡县&quot;: [107.773393, 32.989397],\n  &quot;陕西省-汉中市-勉县&quot;: [106.679426, 33.159805],\n  &quot;陕西省-汉中市-宁强县&quot;: [106.264589, 32.83538],\n  &quot;陕西省-汉中市-略阳县&quot;: [106.163544, 33.333194],\n  &quot;陕西省-汉中市-镇巴县&quot;: [107.901446, 32.542833],\n  &quot;陕西省-汉中市-留坝县&quot;: [106.927414, 33.623825],\n  &quot;陕西省-汉中市-佛坪县&quot;: [107.997424, 33.530693],\n  &quot;陕西省-榆林市&quot;: [109.741616, 38.290884],\n  &quot;陕西省-榆林市-榆阳区&quot;: [109.727559, 38.28242],\n  &quot;陕西省-榆林市-横山区&quot;: [109.300491, 37.968573],\n  &quot;陕西省-榆林市-神木县&quot;: [110.50543, 38.848544],\n  &quot;陕西省-榆林市-府谷县&quot;: [111.073628, 39.033796],\n  &quot;陕西省-榆林市-靖边县&quot;: [108.8006, 37.605063],\n  &quot;陕西省-榆林市-定边县&quot;: [107.60757, 37.60046],\n  &quot;陕西省-榆林市-绥德县&quot;: [110.269426, 37.508907],\n  &quot;陕西省-榆林市-米脂县&quot;: [110.190451, 37.761398],\n  &quot;陕西省-榆林市-佳县&quot;: [110.497477, 38.025612],\n  &quot;陕西省-榆林市-吴堡县&quot;: [110.746455, 37.45827],\n  &quot;陕西省-榆林市-清涧县&quot;: [110.127559, 37.094853],\n  &quot;陕西省-榆林市-子洲县&quot;: [110.042398, 37.617026],\n  &quot;陕西省-安康市&quot;: [109.035601, 32.690513],\n  &quot;陕西省-安康市-汉滨区&quot;: [109.033596, 32.701196],\n  &quot;陕西省-安康市-汉阴县&quot;: [108.515507, 32.899121],\n  &quot;陕西省-安康市-石泉县&quot;: [108.254427, 33.044602],\n  &quot;陕西省-安康市-宁陕县&quot;: [108.320564, 33.316555],\n  &quot;陕西省-安康市-紫阳县&quot;: [108.541594, 32.525786],\n  &quot;陕西省-安康市-岚皋县&quot;: [108.908615, 32.312881],\n  &quot;陕西省-安康市-平利县&quot;: [109.368547, 32.394804],\n  &quot;陕西省-安康市-镇坪县&quot;: [109.533497, 31.889643],\n  &quot;陕西省-安康市-旬阳县&quot;: [109.371557, 32.839864],\n  &quot;陕西省-安康市-白河县&quot;: [110.119587, 32.814846],\n  &quot;陕西省-商洛市&quot;: [109.924418, 33.878634],\n  &quot;陕西省-商洛市-商州区&quot;: [109.947472, 33.868855],\n  &quot;陕西省-商洛市-洛南县&quot;: [110.154427, 34.097071],\n  &quot;陕西省-商洛市-丹凤县&quot;: [110.33356, 33.701537],\n  &quot;陕西省-商洛市-商南县&quot;: [110.888408, 33.537533],\n  &quot;陕西省-商洛市-山阳县&quot;: [109.888549, 33.537968],\n  &quot;陕西省-商洛市-镇安县&quot;: [109.159575, 33.429045],\n  &quot;陕西省-商洛市-柞水县&quot;: [109.120502, 33.692026],\n  &quot;甘肃省&quot;: [103.832478, 36.065465],\n  &quot;甘肃省-兰州市&quot;: [103.840521, 36.067235],\n  &quot;甘肃省-兰州市-城关区&quot;: [103.831475, 36.063181],\n  &quot;甘肃省-兰州市-七里河区&quot;: [103.792414, 36.072129],\n  &quot;甘肃省-兰州市-西固区&quot;: [103.63458, 36.094109],\n  &quot;甘肃省-兰州市-安宁区&quot;: [103.725535, 36.109754],\n  &quot;甘肃省-兰州市-红古区&quot;: [102.865428, 36.351863],\n  &quot;甘肃省-兰州市-永登县&quot;: [103.266624, 36.742095],\n  &quot;甘肃省-兰州市-皋兰县&quot;: [103.953464, 36.338142],\n  &quot;甘肃省-兰州市-榆中县&quot;: [104.119566, 35.848851],\n  &quot;甘肃省-嘉峪关市&quot;: [98.296204, 39.77796],\n  &quot;甘肃省-金昌市&quot;: [102.194606, 38.52582],\n  &quot;甘肃省-金昌市-金川区&quot;: [102.200586, 38.525772],\n  &quot;甘肃省-金昌市-永昌县&quot;: [101.979464, 38.252941],\n  &quot;甘肃省-白银市&quot;: [104.144451, 36.550825],\n  &quot;甘肃省-白银市-白银区&quot;: [104.155413, 36.541464],\n  &quot;甘肃省-白银市-平川区&quot;: [104.831614, 36.733499],\n  &quot;甘肃省-白银市-靖远县&quot;: [104.682515, 36.577096],\n  &quot;甘肃省-白银市-会宁县&quot;: [105.059607, 35.698508],\n  &quot;甘肃省-白银市-景泰县&quot;: [104.069444, 37.187406],\n  &quot;甘肃省-天水市&quot;: [105.731417, 34.587412],\n  &quot;甘肃省-天水市-秦州区&quot;: [105.730415, 34.587316],\n  &quot;甘肃省-天水市-麦积区&quot;: [105.895597, 34.576337],\n  &quot;甘肃省-天水市-清水县&quot;: [106.143595, 34.753883],\n  &quot;甘肃省-天水市-秦安县&quot;: [105.681575, 34.864876],\n  &quot;甘肃省-天水市-甘谷县&quot;: [105.342475, 34.7383],\n  &quot;甘肃省-天水市-武山县&quot;: [104.897428, 34.727669],\n  &quot;甘肃省-天水市-张家川回族自治县&quot;: [106.21139, 34.994905],\n  &quot;甘肃省-武威市&quot;: [102.644554, 37.934378],\n  &quot;甘肃省-武威市-凉州区&quot;: [102.648575, 37.934122],\n  &quot;甘肃省-武威市-民勤县&quot;: [103.1004, 38.630625],\n  &quot;甘肃省-武威市-古浪县&quot;: [102.90363, 37.475802],\n  &quot;甘肃省-武威市-天祝藏族自治县&quot;: [103.148621, 36.977596],\n  &quot;甘肃省-张掖市&quot;: [100.456411, 38.932066],\n  &quot;甘肃省-张掖市-甘州区&quot;: [100.484558, 38.934781],\n  &quot;甘肃省-张掖市-肃南裕固族自治县&quot;: [99.621905, 38.8431],\n  &quot;甘肃省-张掖市-民乐县&quot;: [100.819429, 38.436842],\n  &quot;甘肃省-张掖市-临泽县&quot;: [100.170555, 39.158514],\n  &quot;甘肃省-张掖市-高台县&quot;: [99.82576, 39.383646],\n  &quot;甘肃省-张掖市-山丹县&quot;: [101.095616, 38.790453],\n  &quot;甘肃省-平凉市&quot;: [106.671442, 35.549232],\n  &quot;甘肃省-平凉市-崆峒区&quot;: [106.681415, 35.548815],\n  &quot;甘肃省-平凉市-泾川县&quot;: [107.374518, 35.338669],\n  &quot;甘肃省-平凉市-灵台县&quot;: [107.627461, 35.071582],\n  &quot;甘肃省-平凉市-崇信县&quot;: [107.041415, 35.308616],\n  &quot;甘肃省-平凉市-华亭县&quot;: [106.659486, 35.223551],\n  &quot;甘肃省-平凉市-庄浪县&quot;: [106.042586, 35.208192],\n  &quot;甘肃省-平凉市-静宁县&quot;: [105.738416, 35.528257],\n  &quot;甘肃省-酒泉市&quot;: [98.500685, 39.738469],\n  &quot;甘肃省-酒泉市-肃州区&quot;: [98.514322, 39.751246],\n  &quot;甘肃省-酒泉市-金塔县&quot;: [98.908368, 39.990029],\n  &quot;甘肃省-酒泉市-瓜州县&quot;: [95.788736, 40.526106],\n  &quot;甘肃省-酒泉市-肃北蒙古族自治县&quot;: [94.883692, 39.51833],\n  &quot;甘肃省-酒泉市-阿克塞哈萨克族自治县&quot;: [94.34676, 39.640045],\n  &quot;甘肃省-酒泉市-玉门市&quot;: [97.051712, 40.29762],\n  &quot;甘肃省-酒泉市-敦煌市&quot;: [94.668527, 40.147867],\n  &quot;甘肃省-庆阳市&quot;: [107.649386, 35.715216],\n  &quot;甘肃省-庆阳市-西峰区&quot;: [107.657391, 35.736864],\n  &quot;甘肃省-庆阳市-庆城县&quot;: [107.888406, 36.021726],\n  &quot;甘肃省-庆阳市-环县&quot;: [107.31447, 36.574427],\n  &quot;甘肃省-庆阳市-华池县&quot;: [107.99639, 36.467575],\n  &quot;甘肃省-庆阳市-合水县&quot;: [108.026447, 35.825262],\n  &quot;甘肃省-庆阳市-正宁县&quot;: [108.366375, 35.498219],\n  &quot;甘肃省-庆阳市-宁县&quot;: [107.934571, 35.507933],\n  &quot;甘肃省-庆阳市-镇原县&quot;: [107.207576, 35.683231],\n  &quot;甘肃省-定西市&quot;: [104.63242, 35.586833],\n  &quot;甘肃省-定西市-安定区&quot;: [104.6165, 35.5856],\n  &quot;甘肃省-定西市-通渭县&quot;: [105.248404, 35.217217],\n  &quot;甘肃省-定西市-陇西县&quot;: [104.641381, 35.010197],\n  &quot;甘肃省-定西市-渭源县&quot;: [104.221584, 35.142392],\n  &quot;甘肃省-定西市-临洮县&quot;: [103.865601, 35.400587],\n  &quot;甘肃省-定西市-漳县&quot;: [104.478595, 34.85425],\n  &quot;甘肃省-定西市-岷县&quot;: [104.043396, 34.444408],\n  &quot;甘肃省-陇南市&quot;: [104.928575, 33.40662],\n  &quot;甘肃省-陇南市-武都区&quot;: [104.932593, 33.398072],\n  &quot;甘肃省-陇南市-成县&quot;: [105.748478, 33.756635],\n  &quot;甘肃省-陇南市-文县&quot;: [104.689558, 32.949601],\n  &quot;甘肃省-陇南市-宕昌县&quot;: [104.399386, 34.053486],\n  &quot;甘肃省-陇南市-康县&quot;: [105.615392, 33.335376],\n  &quot;甘肃省-陇南市-西和县&quot;: [105.30761, 34.016787],\n  &quot;甘肃省-陇南市-礼县&quot;: [105.183591, 34.194685],\n  &quot;甘肃省-陇南市-徽县&quot;: [106.094418, 33.775194],\n  &quot;甘肃省-陇南市-两当县&quot;: [106.311419, 33.915123],\n  &quot;甘肃省-临夏回族自治州&quot;: [103.216391, 35.607562],\n  &quot;甘肃省-临夏回族自治州-临夏市&quot;: [103.249549, 35.609899],\n  &quot;甘肃省-临夏回族自治州-临夏县&quot;: [103.002514, 35.497398],\n  &quot;甘肃省-临夏回族自治州-康乐县&quot;: [103.715476, 35.37611],\n  &quot;甘肃省-临夏回族自治州-永靖县&quot;: [103.292507, 35.96333],\n  &quot;甘肃省-临夏回族自治州-广河县&quot;: [103.58241, 35.494101],\n  &quot;甘肃省-临夏回族自治州-和政县&quot;: [103.357524, 35.43059],\n  &quot;甘肃省-临夏回族自治州-东乡族自治县&quot;: [103.395613, 35.66933],\n  &quot;甘肃省-临夏回族自治州-积石山保安族东乡族撒拉族自治县&quot;: [\n    102.882518, 35.723499\n  ],\n  &quot;甘肃省-甘南藏族自治州&quot;: [102.917585, 34.98914],\n  &quot;甘肃省-甘南藏族自治州-合作市&quot;: [102.917572, 35.005935],\n  &quot;甘肃省-甘南藏族自治州-临潭县&quot;: [103.360533, 34.698639],\n  &quot;甘肃省-甘南藏族自治州-卓尼县&quot;: [103.513616, 34.594916],\n  &quot;甘肃省-甘南藏族自治州-舟曲县&quot;: [104.37749, 33.790815],\n  &quot;甘肃省-甘南藏族自治州-迭部县&quot;: [103.22844, 34.06202],\n  &quot;甘肃省-甘南藏族自治州-玛曲县&quot;: [102.0786, 34.003358],\n  &quot;甘肃省-甘南藏族自治州-碌曲县&quot;: [102.494424, 34.597087],\n  &quot;甘肃省-甘南藏族自治州-夏河县&quot;: [102.528577, 35.208324],\n  &quot;青海省&quot;: [101.786462, 36.627159],\n  &quot;青海省-西宁市&quot;: [101.78445, 36.623385],\n  &quot;青海省-西宁市-城东区&quot;: [101.809569, 36.605708],\n  &quot;青海省-西宁市-城中区&quot;: [101.790484, 36.6288],\n  &quot;青海省-西宁市-城西区&quot;: [101.772414, 36.634497],\n  &quot;青海省-西宁市-城北区&quot;: [101.772405, 36.656294],\n  &quot;青海省-西宁市-大通回族土族自治县&quot;: [101.692564, 36.932666],\n  &quot;青海省-西宁市-湟中县&quot;: [101.578617, 36.506628],\n  &quot;青海省-西宁市-湟源县&quot;: [101.262449, 36.688588],\n  &quot;青海省-海东市&quot;: [102.110444, 36.508511],\n  &quot;青海省-海东市-乐都区&quot;: [102.408566, 36.48782],\n  &quot;青海省-海东市-平安区&quot;: [102.114428, 36.506554],\n  &quot;青海省-海东市-民和回族土族自治县&quot;: [102.83639, 36.325561],\n  &quot;青海省-海东市-互助土族自治县&quot;: [101.964569, 36.850022],\n  &quot;青海省-海东市-化隆回族自治县&quot;: [102.270448, 36.100988],\n  &quot;青海省-海东市-循化撒拉族自治县&quot;: [102.495385, 35.856667],\n  &quot;青海省-海北藏族自治州&quot;: [100.907434, 36.960663],\n  &quot;青海省-海北藏族自治州-门源回族自治县&quot;: [101.628438, 37.382181],\n  &quot;青海省-海北藏族自治州-祁连县&quot;: [100.259622, 38.182925],\n  &quot;青海省-海北藏族自治州-海晏县&quot;: [101.000586, 36.902376],\n  &quot;青海省-海北藏族自治州-刚察县&quot;: [100.153606, 37.32732],\n  &quot;青海省-黄南藏族自治州&quot;: [102.022428, 35.525805],\n  &quot;青海省-黄南藏族自治州-同仁县&quot;: [102.025438, 35.521865],\n  &quot;青海省-黄南藏族自治州-尖扎县&quot;: [102.037507, 35.944284],\n  &quot;青海省-黄南藏族自治州-泽库县&quot;: [101.473595, 35.042014],\n  &quot;青海省-黄南藏族自治州-河南蒙古族自治县&quot;: [101.622473, 34.740396],\n  &quot;青海省-海南藏族自治州&quot;: [100.626621, 36.292102],\n  &quot;青海省-海南藏族自治州-共和县&quot;: [100.626623, 36.288703],\n  &quot;青海省-海南藏族自治州-同德县&quot;: [100.585424, 35.259858],\n  &quot;青海省-海南藏族自治州-贵德县&quot;: [101.439533, 36.046158],\n  &quot;青海省-海南藏族自治州-兴海县&quot;: [99.99438, 35.59463],\n  &quot;青海省-海南藏族自治州-贵南县&quot;: [100.753593, 35.592415],\n  &quot;青海省-果洛藏族自治州&quot;: [100.251592, 34.477194],\n  &quot;青海省-果洛藏族自治州-玛沁县&quot;: [100.245564, 34.483569],\n  &quot;青海省-果洛藏族自治州-班玛县&quot;: [100.743605, 32.938504],\n  &quot;青海省-果洛藏族自治州-甘德县&quot;: [99.907511, 33.975004],\n  &quot;青海省-果洛藏族自治州-达日县&quot;: [99.65801, 33.754937],\n  &quot;青海省-果洛藏族自治州-久治县&quot;: [101.488532, 33.434773],\n  &quot;青海省-果洛藏族自治州-玛多县&quot;: [98.215884, 34.920749],\n  &quot;青海省-玉树藏族自治州&quot;: [97.013181, 33.01098],\n  &quot;青海省-玉树藏族自治州-玉树市&quot;: [97.015376, 32.999556],\n  &quot;青海省-玉树藏族自治州-杂多县&quot;: [95.306965, 32.899241],\n  &quot;青海省-玉树藏族自治州-称多县&quot;: [97.115, 33.374226],\n  &quot;青海省-玉树藏族自治州-治多县&quot;: [95.619794, 33.857953],\n  &quot;青海省-玉树藏族自治州-囊谦县&quot;: [96.486918, 32.209194],\n  &quot;青海省-玉树藏族自治州-曲麻莱县&quot;: [95.80375, 34.132299],\n  &quot;青海省-海西蒙古族藏族自治州&quot;: [97.376299, 37.38275],\n  &quot;青海省-海西蒙古族藏族自治州-格尔木市&quot;: [94.93331, 36.412371],\n  &quot;青海省-海西蒙古族藏族自治州-德令哈市&quot;: [97.36747, 37.375346],\n  &quot;青海省-海西蒙古族藏族自治州-乌兰县&quot;: [98.486736, 36.935748],\n  &quot;青海省-海西蒙古族藏族自治州-都兰县&quot;: [98.102705, 36.307611],\n  &quot;青海省-海西蒙古族藏族自治州-天峻县&quot;: [99.029243, 37.306903],\n  &quot;宁夏回族自治区&quot;: [106.265605, 38.476878],\n  &quot;宁夏回族自治区-银川市&quot;: [106.238494, 38.49246],\n  &quot;宁夏回族自治区-银川市-兴庆区&quot;: [106.295494, 38.479579],\n  &quot;宁夏回族自治区-银川市-西夏区&quot;: [106.156581, 38.496817],\n  &quot;宁夏回族自治区-银川市-金凤区&quot;: [106.249561, 38.478695],\n  &quot;宁夏回族自治区-银川市-永宁县&quot;: [106.259605, 38.283001],\n  &quot;宁夏回族自治区-银川市-贺兰县&quot;: [106.356518, 38.560407],\n  &quot;宁夏回族自治区-银川市-灵武市&quot;: [106.34644, 38.108659],\n  &quot;宁夏回族自治区-石嘴山市&quot;: [106.3906, 38.989683],\n  &quot;宁夏回族自治区-石嘴山市-大武口区&quot;: [106.37461, 39.024848],\n  &quot;宁夏回族自治区-石嘴山市-惠农区&quot;: [106.78843, 39.245388],\n  &quot;宁夏回族自治区-石嘴山市-平罗县&quot;: [106.536518, 38.919607],\n  &quot;宁夏回族自治区-吴忠市&quot;: [106.205371, 38.003713],\n  &quot;宁夏回族自治区-吴忠市-利通区&quot;: [106.219407, 37.990746],\n  &quot;宁夏回族自治区-吴忠市-红寺堡区&quot;: [106.068421, 37.431882],\n  &quot;宁夏回族自治区-吴忠市-盐池县&quot;: [107.41338, 37.789296],\n  &quot;宁夏回族自治区-吴忠市-同心县&quot;: [105.920599, 36.98627],\n  &quot;宁夏回族自治区-吴忠市-青铜峡市&quot;: [106.08537, 38.027412],\n  &quot;宁夏回族自治区-固原市&quot;: [106.248577, 36.021617],\n  &quot;宁夏回族自治区-固原市-原州区&quot;: [106.294515, 36.009368],\n  &quot;宁夏回族自治区-固原市-西吉县&quot;: [105.735386, 35.970076],\n  &quot;宁夏回族自治区-固原市-隆德县&quot;: [106.118498, 35.631762],\n  &quot;宁夏回族自治区-固原市-泾源县&quot;: [106.337393, 35.504362],\n  &quot;宁夏回族自治区-固原市-彭阳县&quot;: [106.644544, 35.855405],\n  &quot;宁夏回族自治区-中卫市&quot;: [105.203571, 37.505701],\n  &quot;宁夏回族自治区-中卫市-沙坡头区&quot;: [105.203571, 37.505701],\n  &quot;宁夏回族自治区-中卫市-中宁县&quot;: [105.691537, 37.497421],\n  &quot;宁夏回族自治区-中卫市-海原县&quot;: [105.650555, 36.570781],\n  &quot;新疆维吾尔自治区&quot;: [87.633473, 43.799238],\n  &quot;新疆维吾尔自治区-乌鲁木齐市&quot;: [87.62444, 43.830763],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-天山区&quot;: [87.638408, 43.800271],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-沙依巴克区&quot;: [87.60467, 43.807262],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-新市区&quot;: [87.575908, 43.861394],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-水磨沟区&quot;: [87.575908, 43.861394],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-头屯河区&quot;: [87.434507, 43.882653],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-达坂城区&quot;: [88.317398, 43.369943],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-米东区&quot;: [87.662134, 43.979247],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-乌鲁木齐县&quot;: [87.416029, 43.477086],\n  &quot;新疆维吾尔自治区-克拉玛依市&quot;: [84.895901, 45.585675],\n  &quot;新疆维吾尔自治区-克拉玛依市-独山子区&quot;: [84.893613, 44.334407],\n  &quot;新疆维吾尔自治区-克拉玛依市-克拉玛依区&quot;: [84.866222, 45.596624],\n  &quot;新疆维吾尔自治区-克拉玛依市-白碱滩区&quot;: [85.13951, 45.693952],\n  &quot;新疆维吾尔自治区-克拉玛依市-乌尔禾区&quot;: [85.700305, 46.095295],\n  &quot;新疆维吾尔自治区-吐鲁番市&quot;: [89.192459, 42.948549],\n  &quot;新疆维吾尔自治区-吐鲁番市-高昌区&quot;: [89.192459, 42.948549],\n  &quot;新疆维吾尔自治区-吐鲁番市-鄯善县&quot;: [90.220094, 42.874759],\n  &quot;新疆维吾尔自治区-吐鲁番市-托克逊县&quot;: [88.660164, 42.798546],\n  &quot;新疆维吾尔自治区-哈密市&quot;: [93.521308, 42.832856],\n  &quot;新疆维吾尔自治区-哈密市-伊州区&quot;: [93.519883, 42.825878],\n  &quot;新疆维吾尔自治区-哈密市-巴里坤哈萨克自治县&quot;: [93.022931, 43.605689],\n  &quot;新疆维吾尔自治区-哈密市-伊吾县&quot;: [94.703826, 43.260677],\n  &quot;新疆维吾尔自治区-昌吉回族自治州&quot;: [87.315002, 44.016854],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-昌吉市&quot;: [87.273865, 44.020127],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-阜康市&quot;: [87.273865, 44.020127],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-呼图壁县&quot;: [86.905144, 44.197655],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-玛纳斯县&quot;: [86.220643, 44.310063],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-奇台县&quot;: [89.601081, 44.026898],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-吉木萨尔县&quot;: [89.187123, 44.005718],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-木垒哈萨克自治县&quot;: [90.292515, 43.840308],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州&quot;: [82.072915, 44.912196],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-博乐市&quot;: [82.057972, 44.86001],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-阿拉山口市&quot;: [82.057972, 44.86001],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-精河县&quot;: [82.900655, 44.606646],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-温泉县&quot;: [81.031146, 44.974857],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州&quot;: [86.151714, 41.770287],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-库尔勒市&quot;: [86.181494, 41.732373],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-轮台县&quot;: [86.181494, 41.732373],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-尉犁县&quot;: [86.266037, 41.350123],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-若羌县&quot;: [88.175324, 39.028991],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-且末县&quot;: [85.53599, 38.151388],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-焉耆回族自治县&quot;: [86.581222, 42.064851],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-和静县&quot;: [86.390398, 42.329365],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-和硕县&quot;: [86.883689, 42.288065],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-博湖县&quot;: [86.638469, 41.98643],\n  &quot;新疆维吾尔自治区-阿克苏地区&quot;: [80.266943, 41.17503],\n  &quot;新疆维吾尔自治区-阿克苏地区-阿克苏市&quot;: [80.269927, 41.17386],\n  &quot;新疆维吾尔自治区-阿克苏地区-温宿县&quot;: [80.245564, 41.282567],\n  &quot;新疆维吾尔自治区-阿克苏地区-库车县&quot;: [82.968459, 41.723448],\n  &quot;新疆维吾尔自治区-阿克苏地区-沙雅县&quot;: [82.788824, 41.227749],\n  &quot;新疆维吾尔自治区-阿克苏地区-新和县&quot;: [82.615823, 41.554],\n  &quot;新疆维吾尔自治区-阿克苏地区-拜城县&quot;: [81.858516, 41.800707],\n  &quot;新疆维吾尔自治区-阿克苏地区-乌什县&quot;: [79.230869, 41.220871],\n  &quot;新疆维吾尔自治区-阿克苏地区-阿瓦提县&quot;: [80.381849, 40.649359],\n  &quot;新疆维吾尔自治区-阿克苏地区-柯坪县&quot;: [79.053214, 40.514055],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州&quot;: [76.174309, 39.720471],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿图什市&quot;: [76.174906, 39.722079],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿克陶县&quot;: [75.953725, 39.153889],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿合奇县&quot;: [75.953725, 39.153889],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-乌恰县&quot;: [75.265334, 39.725124],\n  &quot;新疆维吾尔自治区-喀什地区&quot;: [75.996391, 39.476097],\n  &quot;新疆维吾尔自治区-喀什地区-喀什市&quot;: [76.000313, 39.47365],\n  &quot;新疆维吾尔自治区-喀什地区-疏附县&quot;: [75.869169, 39.381292],\n  &quot;新疆维吾尔自治区-喀什地区-疏勒县&quot;: [76.056614, 39.406709],\n  &quot;新疆维吾尔自治区-喀什地区-英吉沙县&quot;: [76.182075, 38.935671],\n  &quot;新疆维吾尔自治区-喀什地区-泽普县&quot;: [77.266559, 38.190725],\n  &quot;新疆维吾尔自治区-喀什地区-莎车县&quot;: [77.252437, 38.420157],\n  &quot;新疆维吾尔自治区-喀什地区-叶城县&quot;: [77.420098, 37.889167],\n  &quot;新疆维吾尔自治区-喀什地区-麦盖提县&quot;: [77.658824, 38.911194],\n  &quot;新疆维吾尔自治区-喀什地区-岳普湖县&quot;: [76.784148, 39.239387],\n  &quot;新疆维吾尔自治区-喀什地区-伽师县&quot;: [76.730386, 39.493852],\n  &quot;新疆维吾尔自治区-喀什地区-巴楚县&quot;: [78.555701, 39.790788],\n  &quot;新疆维吾尔自治区-喀什地区-塔什库尔干塔吉克自治县&quot;: [75.230805, 37.779046],\n  &quot;新疆维吾尔自治区-和田地区&quot;: [79.928507, 37.120446],\n  &quot;新疆维吾尔自治区-和田地区-和田市&quot;: [79.920212, 37.118336],\n  &quot;新疆维吾尔自治区-和田地区-和田县&quot;: [79.866216, 37.090362],\n  &quot;新疆维吾尔自治区-和田地区-墨玉县&quot;: [79.735479, 37.282993],\n  &quot;新疆维吾尔自治区-和田地区-皮山县&quot;: [78.289871, 37.627249],\n  &quot;新疆维吾尔自治区-和田地区-洛浦县&quot;: [80.195388, 37.079611],\n  &quot;新疆维吾尔自治区-和田地区-策勒县&quot;: [80.813201, 37.004122],\n  &quot;新疆维吾尔自治区-和田地区-于田县&quot;: [81.683783, 36.862954],\n  &quot;新疆维吾尔自治区-和田地区-民丰县&quot;: [82.702713, 37.070257],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州&quot;: [81.330538, 43.922723],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-伊宁市&quot;: [81.284242, 43.915299],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-奎屯市&quot;: [84.909449, 44.432057],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-霍尔果斯市&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-伊宁县&quot;: [81.533906, 43.982909],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-察布查尔锡伯自治县&quot;: [81.157925, 43.84669],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-霍城县&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-巩留县&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-新源县&quot;: [83.267022, 43.435927],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-昭苏县&quot;: [81.137378, 43.163497],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-特克斯县&quot;: [81.842587, 43.224248],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-尼勒克县&quot;: [82.518007, 43.804595],\n  &quot;新疆维吾尔自治区-塔城地区&quot;: [82.987236, 46.750948],\n  &quot;新疆维吾尔自治区-塔城地区-塔城市&quot;: [82.985532, 46.754347],\n  &quot;新疆维吾尔自治区-塔城地区-乌苏市&quot;: [84.720088, 44.424048],\n  &quot;新疆维吾尔自治区-塔城地区-额敏县&quot;: [83.633374, 46.531885],\n  &quot;新疆维吾尔自治区-塔城地区-沙湾县&quot;: [85.626145, 44.331949],\n  &quot;新疆维吾尔自治区-塔城地区-托里县&quot;: [83.612909, 45.942743],\n  &quot;新疆维吾尔自治区-塔城地区-裕民县&quot;: [82.989439, 46.207454],\n  &quot;新疆维吾尔自治区-塔城地区-和布克赛尔蒙古自治县&quot;: [85.735009, 46.798685],\n  &quot;新疆维吾尔自治区-阿勒泰地区&quot;: [88.147926, 47.850728],\n  &quot;新疆维吾尔自治区-阿勒泰地区-阿勒泰市&quot;: [88.139227, 47.832753],\n  &quot;新疆维吾尔自治区-阿勒泰地区-布尔津县&quot;: [86.88136, 47.707952],\n  &quot;新疆维吾尔自治区-阿勒泰地区-富蕴县&quot;: [89.531953, 46.999951],\n  &quot;新疆维吾尔自治区-阿勒泰地区-福海县&quot;: [87.493157, 47.118141],\n  &quot;新疆维吾尔自治区-阿勒泰地区-哈巴河县&quot;: [86.424818, 48.066149],\n  &quot;新疆维吾尔自治区-阿勒泰地区-青河县&quot;: [90.389444, 46.680194],\n  &quot;新疆维吾尔自治区-阿勒泰地区-吉木乃县&quot;: [85.880818, 47.449018],\n  &quot;新疆维吾尔自治区-石河子市&quot;: [86.086886, 44.311976],\n  &quot;新疆维吾尔自治区-阿拉尔市&quot;: [81.287354, 40.553264],\n  &quot;新疆维吾尔自治区-图木舒克市&quot;: [79.075616, 39.871209],\n  &quot;新疆维吾尔自治区-五家渠市&quot;: [87.549937, 44.172445],\n  &quot;新疆维吾尔自治区-铁门关市&quot;: [86.181494, 41.732373],\n  &quot;香港特别行政区&quot;: [114.173825, 22.337784],\n  &quot;香港特别行政区-中西區&quot;: [114.159491, 22.291343],\n  &quot;香港特别行政区-灣仔區&quot;: [114.18355, 22.283159],\n  &quot;香港特别行政区-東區&quot;: [114.235426, 22.287684],\n  &quot;香港特别行政区-南區&quot;: [114.165543, 22.251947],\n  &quot;香港特别行政区-油尖旺區&quot;: [114.178545, 22.306584],\n  &quot;香港特别行政区-深水埗區&quot;: [114.181574, 22.345029],\n  &quot;香港特别行政区-九龍城區&quot;: [114.198554, 22.325723],\n  &quot;香港特别行政区-黃大仙區&quot;: [114.205553, 22.344517],\n  &quot;香港特别行政区-觀塘區&quot;: [114.237431, 22.316804],\n  &quot;香港特别行政区-荃灣區&quot;: [114.126441, 22.378244],\n  &quot;香港特别行政区-屯門區&quot;: [113.987456, 22.393585],\n  &quot;香港特别行政区-元朗區&quot;: [114.03851, 22.448565],\n  &quot;香港特别行政区-北區&quot;: [114.149484, 22.498024],\n  &quot;香港特别行政区-大埔區&quot;: [114.175565, 22.453814],\n  &quot;香港特别行政区-西貢區&quot;: [114.283525, 22.385077],\n  &quot;香港特别行政区-沙田區&quot;: [114.198551, 22.388522],\n  &quot;香港特别行政区-葵青區&quot;: [114.143475, 22.366619],\n  &quot;香港特别行政区-離島區&quot;: [113.951547, 22.286066],\n  &quot;澳门特别行政区&quot;: [113.560161, 22.214787],\n  &quot;澳门特别行政区-花地瑪堂區&quot;: [113.55751, 22.212784],\n  &quot;澳门特别行政区-花王堂區&quot;: [113.550294, 22.202058],\n  &quot;澳门特别行政区-望德堂區&quot;: [113.561514, 22.202511],\n  &quot;澳门特别行政区-大堂區&quot;: [113.561167, 22.192801],\n  &quot;澳门特别行政区-風順堂區&quot;: [113.545451, 22.192783],\n  &quot;澳门特别行政区-嘉模堂區&quot;: [113.565515, 22.163142],\n  &quot;澳门特别行政区-路氹填海區&quot;: [113.570544, 22.146272],\n  &quot;台湾省&quot;: [86.181494, 41.732373],\n  &quot;台湾省-台北市 &quot;: [121.539414, 25.073653],\n  &quot;台湾省-高雄市&quot;: [120.315994, 22.679904],\n  &quot;曾母暗沙&quot;: [111.79862, 4.008237]\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>================</p>","more":"<p>原文地址：<a href=\"https://www.cnblogs.com/henuyuxiang/p/12981201.html\">https://www.cnblogs.com/henuyuxiang/p/12981201.html</a></p>\n<pre><code class=\"json\">&#123;\n  &quot;全国&quot;: [116.413384, 39.910925],\n  &quot;北京市&quot;: [116.413384, 39.910925],\n  &quot;北京市-市辖区&quot;: [116.413384, 39.910925],\n  &quot;北京市-市辖区-东城区&quot;: [116.422401, 39.934827],\n  &quot;北京市-市辖区-西城区&quot;: [116.372514, 39.918124],\n  &quot;北京市-市辖区-朝阳区&quot;: [116.449559, 39.926375],\n  &quot;北京市-市辖区-丰台区&quot;: [116.292402, 39.864937],\n  &quot;北京市-市辖区-石景山区&quot;: [116.229613, 39.911354],\n  &quot;北京市-市辖区-海淀区&quot;: [116.305434, 39.96549],\n  &quot;北京市-市辖区-门头沟区&quot;: [116.107604, 39.946147],\n  &quot;北京市-市辖区-房山区&quot;: [116.149444, 39.754326],\n  &quot;北京市-市辖区-通州区&quot;: [116.663415, 39.916017],\n  &quot;北京市-市辖区-顺义区&quot;: [116.661424, 40.136351],\n  &quot;北京市-市辖区-昌平区&quot;: [116.237618, 40.226413],\n  &quot;北京市-市辖区-大兴区&quot;: [116.348625, 39.732555],\n  &quot;北京市-市辖区-怀柔区&quot;: [116.638386, 40.322618],\n  &quot;北京市-市辖区-平谷区&quot;: [117.127379, 40.146951],\n  &quot;北京市-市辖区-密云区&quot;: [116.849547, 40.382176],\n  &quot;北京市-市辖区-延庆区&quot;: [115.981632, 40.462169],\n  &quot;天津市&quot;: [117.209523, 39.093668],\n  &quot;天津市-市辖区&quot;: [117.209523, 39.093668],\n  &quot;天津市-市辖区-和平区&quot;: [117.221467, 39.12339],\n  &quot;天津市-市辖区-河东区&quot;: [117.258413, 39.134487],\n  &quot;天津市-市辖区-河西区&quot;: [117.229416, 39.115718],\n  &quot;天津市-市辖区-南开区&quot;: [117.156515, 39.144105],\n  &quot;天津市-市辖区-河北区&quot;: [117.203593, 39.153485],\n  &quot;天津市-市辖区-红桥区&quot;: [117.157518, 39.173286],\n  &quot;天津市-市辖区-东丽区&quot;: [117.320569, 39.092332],\n  &quot;天津市-市辖区-西青区&quot;: [117.01441, 39.148727],\n  &quot;天津市-市辖区-津南区&quot;: [117.363387, 38.944148],\n  &quot;天津市-市辖区-北辰区&quot;: [117.141403, 39.230344],\n  &quot;天津市-市辖区-武清区&quot;: [117.050597, 39.389871],\n  &quot;天津市-市辖区-宝坻区&quot;: [117.316601, 39.723194],\n  &quot;天津市-市辖区-滨海新区&quot;: [117.717399, 39.009416],\n  &quot;天津市-市辖区-宁河区&quot;: [117.832393, 39.336956],\n  &quot;天津市-市辖区-静海区&quot;: [116.980469, 38.953371],\n  &quot;天津市-市辖区-蓟州区&quot;: [117.414579, 40.051509],\n  &quot;河北省&quot;: [114.536596, 38.043202],\n  &quot;河北省-石家庄市&quot;: [114.521532, 38.048312],\n  &quot;河北省-石家庄市-长安区&quot;: [114.545612, 38.043256],\n  &quot;河北省-石家庄市-桥西区&quot;: [114.46742, 38.010381],\n  &quot;河北省-石家庄市-新华区&quot;: [114.469438, 38.05712],\n  &quot;河北省-石家庄市-井陉矿区&quot;: [114.068632, 38.070566],\n  &quot;河北省-石家庄市-裕华区&quot;: [114.537583, 38.012088],\n  &quot;河北省-石家庄市-藁城区&quot;: [114.853378, 38.027817],\n  &quot;河北省-石家庄市-鹿泉区&quot;: [114.320598, 38.091749],\n  &quot;河北省-石家庄市-栾城区&quot;: [114.654576, 37.905816],\n  &quot;河北省-石家庄市-井陉县&quot;: [114.151463, 38.038386],\n  &quot;河北省-石家庄市-正定县&quot;: [114.577481, 38.151714],\n  &quot;河北省-石家庄市-行唐县&quot;: [114.559607, 38.444239],\n  &quot;河北省-石家庄市-灵寿县&quot;: [114.389478, 38.314629],\n  &quot;河北省-石家庄市-高邑县&quot;: [114.618413, 37.62188],\n  &quot;河北省-石家庄市-深泽县&quot;: [115.207404, 38.190451],\n  &quot;河北省-石家庄市-赞皇县&quot;: [114.392464, 37.671667],\n  &quot;河北省-石家庄市-无极县&quot;: [114.982439, 38.185436],\n  &quot;河北省-石家庄市-平山县&quot;: [113.985435, 38.271951],\n  &quot;河北省-石家庄市-元氏县&quot;: [114.532566, 37.772339],\n  &quot;河北省-石家庄市-赵县&quot;: [114.782597, 37.761859],\n  &quot;河北省-石家庄市-晋州市&quot;: [115.050529, 38.039491],\n  &quot;河北省-石家庄市-新乐市&quot;: [114.690532, 38.349293],\n  &quot;河北省-唐山市&quot;: [118.186459, 39.636584],\n  &quot;河北省-唐山市-路南区&quot;: [118.160607, 39.631043],\n  &quot;河北省-唐山市-路北区&quot;: [118.206399, 39.630661],\n  &quot;河北省-唐山市-古冶区&quot;: [118.453401, 39.739736],\n  &quot;河北省-唐山市-开平区&quot;: [118.268608, 39.677144],\n  &quot;河北省-唐山市-丰南区&quot;: [118.090366, 39.58154],\n  &quot;河北省-唐山市-丰润区&quot;: [118.168541, 39.838353],\n  &quot;河北省-唐山市-曹妃甸区&quot;: [118.46646, 39.279284],\n  &quot;河北省-唐山市-滦县&quot;: [118.71048, 39.747116],\n  &quot;河北省-唐山市-滦南县&quot;: [118.680405, 39.510045],\n  &quot;河北省-唐山市-乐亭县&quot;: [118.919384, 39.431931],\n  &quot;河北省-唐山市-迁西县&quot;: [118.320384, 40.147837],\n  &quot;河北省-唐山市-玉田县&quot;: [117.745434, 39.906592],\n  &quot;河北省-唐山市-遵化市&quot;: [117.972375, 40.195533],\n  &quot;河北省-唐山市-迁安市&quot;: [118.706457, 40.004184],\n  &quot;河北省-秦皇岛市&quot;: [119.608531, 39.941748],\n  &quot;河北省-秦皇岛市-海港区&quot;: [119.617475, 39.940413],\n  &quot;河北省-秦皇岛市-山海关区&quot;: [119.782435, 39.984446],\n  &quot;河北省-秦皇岛市-北戴河区&quot;: [119.491526, 39.841006],\n  &quot;河北省-秦皇岛市-抚宁区&quot;: [119.251549, 39.881414],\n  &quot;河北省-秦皇岛市-青龙满族自治县&quot;: [118.956481, 40.412794],\n  &quot;河北省-秦皇岛市-昌黎县&quot;: [119.169375, 39.719051],\n  &quot;河北省-秦皇岛市-卢龙县&quot;: [118.899489, 39.897958],\n  &quot;河北省-邯郸市&quot;: [114.545628, 36.631263],\n  &quot;河北省-邯郸市-邯山区&quot;: [114.496389, 36.586692],\n  &quot;河北省-邯郸市-丛台区&quot;: [114.499433, 36.642673],\n  &quot;河北省-邯郸市-复兴区&quot;: [114.479412, 36.623325],\n  &quot;河北省-邯郸市-峰峰矿区&quot;: [114.219483, 36.425654],\n  &quot;河北省-邯郸市-邯郸县&quot;: [114.537309, 36.599675],\n  &quot;河北省-邯郸市-临漳县&quot;: [114.626427, 36.340766],\n  &quot;河北省-邯郸市-成安县&quot;: [114.676577, 36.449796],\n  &quot;河北省-邯郸市-大名县&quot;: [115.154613, 36.291288],\n  &quot;河北省-邯郸市-涉县&quot;: [113.697584, 36.590692],\n  &quot;河北省-邯郸市-磁县&quot;: [114.380432, 36.380359],\n  &quot;河北省-邯郸市-肥乡县&quot;: [114.806547, 36.553825],\n  &quot;河北省-邯郸市-永年县&quot;: [114.550625, 36.747569],\n  &quot;河北省-邯郸市-邱县&quot;: [115.193395, 36.817362],\n  &quot;河北省-邯郸市-鸡泽县&quot;: [114.896586, 36.916398],\n  &quot;河北省-邯郸市-广平县&quot;: [114.954415, 36.48978],\n  &quot;河北省-邯郸市-馆陶县&quot;: [115.288537, 36.553957],\n  &quot;河北省-邯郸市-魏县&quot;: [114.94545, 36.366156],\n  &quot;河北省-邯郸市-曲周县&quot;: [114.963404, 36.771545],\n  &quot;河北省-邯郸市-武安市&quot;: [114.210516, 36.702488],\n  &quot;河北省-邢台市&quot;: [114.511462, 37.076686],\n  &quot;河北省-邢台市-桥东区&quot;: [114.513471, 37.07375],\n  &quot;河北省-邢台市-桥西区&quot;: [114.474393, 37.066172],\n  &quot;河北省-邢台市-邢台县&quot;: [114.143411, 37.177109],\n  &quot;河北省-邢台市-临城县&quot;: [114.505443, 37.450789],\n  &quot;河北省-邢台市-内丘县&quot;: [114.518493, 37.292858],\n  &quot;河北省-邢台市-柏乡县&quot;: [114.699497, 37.488759],\n  &quot;河北省-邢台市-隆尧县&quot;: [114.776616, 37.355908],\n  &quot;河北省-邢台市-任县&quot;: [114.678606, 37.126727],\n  &quot;河北省-邢台市-南和县&quot;: [114.690548, 37.010998],\n  &quot;河北省-邢台市-宁晋县&quot;: [114.925562, 37.625612],\n  &quot;河北省-邢台市-巨鹿县&quot;: [115.043587, 37.227088],\n  &quot;河北省-邢台市-新河县&quot;: [115.248547, 37.534591],\n  &quot;河北省-邢台市-广宗县&quot;: [115.149605, 37.080457],\n  &quot;河北省-邢台市-平乡县&quot;: [115.036582, 37.069096],\n  &quot;河北省-邢台市-威县&quot;: [115.273618, 36.981582],\n  &quot;河北省-邢台市-清河县&quot;: [115.674394, 37.046375],\n  &quot;河北省-邢台市-临西县&quot;: [115.507629, 36.87676],\n  &quot;河北省-邢台市-南宫市&quot;: [115.414529, 37.364069],\n  &quot;河北省-邢台市-沙河市&quot;: [114.509474, 36.861127],\n  &quot;河北省-保定市&quot;: [115.471464, 38.879988],\n  &quot;河北省-保定市-竞秀区&quot;: [115.465434, 38.883788],\n  &quot;河北省-保定市-莲池区&quot;: [115.535488, 38.860676],\n  &quot;河北省-保定市-满城区&quot;: [115.328375, 38.955441],\n  &quot;河北省-保定市-清苑区&quot;: [115.496606, 38.771002],\n  &quot;河北省-保定市-徐水区&quot;: [115.66248, 39.024713],\n  &quot;河北省-保定市-涞水县&quot;: [115.720543, 39.400334],\n  &quot;河北省-保定市-阜平县&quot;: [114.201563, 38.855351],\n  &quot;河北省-保定市-定兴县&quot;: [115.81441, 39.269424],\n  &quot;河北省-保定市-唐县&quot;: [114.989447, 38.75402],\n  &quot;河北省-保定市-高阳县&quot;: [115.785447, 38.706258],\n  &quot;河北省-保定市-容城县&quot;: [115.868631, 39.048559],\n  &quot;河北省-保定市-涞源县&quot;: [114.700476, 39.366272],\n  &quot;河北省-保定市-望都县&quot;: [115.161588, 38.700158],\n  &quot;河北省-保定市-安新县&quot;: [115.942426, 38.941734],\n  &quot;河北省-保定市-易县&quot;: [115.503607, 39.355054],\n  &quot;河北省-保定市-曲阳县&quot;: [114.751455, 38.628384],\n  &quot;河北省-保定市-蠡县&quot;: [115.590445, 38.494201],\n  &quot;河北省-保定市-顺平县&quot;: [115.141597, 38.843261],\n  &quot;河北省-保定市-博野县&quot;: [115.470467, 38.463408],\n  &quot;河北省-保定市-雄县&quot;: [116.114601, 39.00018],\n  &quot;河北省-保定市-涿州市&quot;: [115.98162, 39.491066],\n  &quot;河北省-保定市-安国市&quot;: [115.333408, 38.424828],\n  &quot;河北省-保定市-高碑店市&quot;: [115.880569, 39.332335],\n  &quot;河北省-张家口市&quot;: [114.892572, 40.773237],\n  &quot;河北省-张家口市-桥东区&quot;: [114.900606, 40.794268],\n  &quot;河北省-张家口市-桥西区&quot;: [114.876516, 40.825606],\n  &quot;河北省-张家口市-宣化区&quot;: [115.105444, 40.614592],\n  &quot;河北省-张家口市-下花园区&quot;: [115.293517, 40.508145],\n  &quot;河北省-张家口市-万全区&quot;: [114.747426, 40.77315],\n  &quot;河北省-张家口市-崇礼区&quot;: [115.289549, 40.980478],\n  &quot;河北省-张家口市-张北县&quot;: [114.726375, 41.164944],\n  &quot;河北省-张家口市-康保县&quot;: [114.606356, 41.858637],\n  &quot;河北省-张家口市-沽源县&quot;: [115.695407, 41.676016],\n  &quot;河北省-张家口市-尚义县&quot;: [113.975524, 41.081888],\n  &quot;河北省-张家口市-蔚县&quot;: [114.595401, 39.847089],\n  &quot;河北省-张家口市-阳原县&quot;: [114.157524, 40.109588],\n  &quot;河北省-张家口市-怀安县&quot;: [114.392469, 40.680369],\n  &quot;河北省-张家口市-怀来县&quot;: [115.524553, 40.42029],\n  &quot;河北省-张家口市-涿鹿县&quot;: [115.211383, 40.385834],\n  &quot;河北省-张家口市-赤城县&quot;: [115.838506, 40.918761],\n  &quot;河北省-承德市&quot;: [117.969398, 40.957856],\n  &quot;河北省-承德市-双桥区&quot;: [117.949428, 40.980824],\n  &quot;河北省-承德市-双滦区&quot;: [117.806578, 40.964729],\n  &quot;河北省-承德市-鹰手营子矿区&quot;: [117.665609, 40.552043],\n  &quot;河北省-承德市-承德县&quot;: [118.180456, 40.774367],\n  &quot;河北省-承德市-兴隆县&quot;: [117.507427, 40.423454],\n  &quot;河北省-承德市-平泉县&quot;: [118.707427, 41.023756],\n  &quot;河北省-承德市-滦平县&quot;: [117.339498, 40.947561],\n  &quot;河北省-承德市-隆化县&quot;: [117.745451, 41.319899],\n  &quot;河北省-承德市-丰宁满族自治县&quot;: [116.652393, 41.215336],\n  &quot;河北省-承德市-宽城满族自治县&quot;: [118.491594, 40.617152],\n  &quot;河北省-承德市-围场满族蒙古族自治县&quot;: [117.766564, 41.944324],\n  &quot;河北省-沧州市&quot;: [116.845581, 38.310215],\n  &quot;河北省-沧州市-新华区&quot;: [116.872433, 38.320367],\n  &quot;河北省-沧州市-运河区&quot;: [116.838612, 38.316523],\n  &quot;河北省-沧州市-沧县&quot;: [116.884398, 38.299453],\n  &quot;河北省-沧州市-青县&quot;: [116.810575, 38.588465],\n  &quot;河北省-沧州市-东光县&quot;: [116.54341, 37.894514],\n  &quot;河北省-沧州市-海兴县&quot;: [117.504418, 38.149402],\n  &quot;河北省-沧州市-盐山县&quot;: [117.237414, 38.064318],\n  &quot;河北省-沧州市-肃宁县&quot;: [115.836518, 38.428906],\n  &quot;河北省-沧州市-南皮县&quot;: [116.715601, 38.045188],\n  &quot;河北省-沧州市-吴桥县&quot;: [116.397392, 37.633909],\n  &quot;河北省-沧州市-献县&quot;: [116.12956, 38.195981],\n  &quot;河北省-沧州市-孟村回族自治县&quot;: [117.110436, 38.059839],\n  &quot;河北省-沧州市-泊头市&quot;: [116.584628, 38.089257],\n  &quot;河北省-沧州市-任丘市&quot;: [116.105605, 38.717349],\n  &quot;河北省-沧州市-黄骅市&quot;: [117.336481, 38.377494],\n  &quot;河北省-沧州市-河间市&quot;: [116.105628, 38.451357],\n  &quot;河北省-廊坊市&quot;: [116.690582, 39.543367],\n  &quot;河北省-廊坊市-安次区&quot;: [116.709633, 39.52616],\n  &quot;河北省-廊坊市-广阳区&quot;: [116.717614, 39.528611],\n  &quot;河北省-廊坊市-固安县&quot;: [116.30542, 39.444485],\n  &quot;河北省-廊坊市-永清县&quot;: [116.505429, 39.327853],\n  &quot;河北省-廊坊市-香河县&quot;: [117.012402, 39.767939],\n  &quot;河北省-廊坊市-大城县&quot;: [116.660409, 38.710859],\n  &quot;河北省-廊坊市-文安县&quot;: [116.464609, 38.87895],\n  &quot;河北省-廊坊市-大厂回族自治县&quot;: [116.996409, 39.892208],\n  &quot;河北省-廊坊市-霸州市&quot;: [116.398397, 39.130921],\n  &quot;河北省-廊坊市-三河市&quot;: [117.084588, 39.9881],\n  &quot;河北省-衡水市&quot;: [115.675406, 37.745191],\n  &quot;河北省-衡水市-桃城区&quot;: [115.681395, 37.741637],\n  &quot;河北省-衡水市-冀州区&quot;: [115.58543, 37.557086],\n  &quot;河北省-衡水市-枣强县&quot;: [115.730563, 37.519364],\n  &quot;河北省-衡水市-武邑县&quot;: [115.894514, 37.807764],\n  &quot;河北省-衡水市-武强县&quot;: [115.989614, 38.046857],\n  &quot;河北省-衡水市-饶阳县&quot;: [115.732572, 38.241038],\n  &quot;河北省-衡水市-安平县&quot;: [115.525549, 38.240507],\n  &quot;河北省-衡水市-故城县&quot;: [115.972602, 37.353348],\n  &quot;河北省-衡水市-景县&quot;: [116.277411, 37.698815],\n  &quot;河北省-衡水市-阜城县&quot;: [116.182422, 37.868732],\n  &quot;河北省-衡水市-深州市&quot;: [115.566369, 38.006941],\n  &quot;河北省-定州市&quot;: [114.996496, 38.522199],\n  &quot;河北省-辛集市&quot;: [115.224451, 37.949309],\n  &quot;山西省&quot;: [112.569376, 37.879829],\n  &quot;山西省-太原市&quot;: [112.556391, 37.876989],\n  &quot;山西省-太原市-小店区&quot;: [112.572396, 37.742323],\n  &quot;山西省-太原市-迎泽区&quot;: [112.569385, 37.869532],\n  &quot;山西省-太原市-杏花岭区&quot;: [112.576383, 37.900186],\n  &quot;山西省-太原市-尖草坪区&quot;: [112.493605, 37.945943],\n  &quot;山西省-太原市-万柏林区&quot;: [112.522577, 37.864974],\n  &quot;山西省-太原市-晋源区&quot;: [112.484564, 37.721169],\n  &quot;山西省-太原市-清徐县&quot;: [112.364558, 37.613067],\n  &quot;山西省-太原市-阳曲县&quot;: [112.679409, 38.064621],\n  &quot;山西省-太原市-娄烦县&quot;: [111.803591, 38.073195],\n  &quot;山西省-太原市-古交市&quot;: [112.182453, 37.913],\n  &quot;山西省-大同市&quot;: [113.306436, 40.082469],\n  &quot;山西省-大同市-城区&quot;: [113.304425, 40.081998],\n  &quot;山西省-大同市-矿区&quot;: [113.162402, 39.996839],\n  &quot;山西省-大同市-南郊区&quot;: [113.162402, 39.996839],\n  &quot;山西省-大同市-新荣区&quot;: [113.146444, 40.261971],\n  &quot;山西省-大同市-阳高县&quot;: [113.755414, 40.367392],\n  &quot;山西省-大同市-天镇县&quot;: [114.097478, 40.426412],\n  &quot;山西省-大同市-广灵县&quot;: [114.288586, 39.766004],\n  &quot;山西省-大同市-灵丘县&quot;: [114.241368, 39.448825],\n  &quot;山西省-大同市-浑源县&quot;: [113.7056, 39.698953],\n  &quot;山西省-大同市-左云县&quot;: [112.709463, 40.019623],\n  &quot;山西省-大同市-大同县&quot;: [113.618471, 40.04623],\n  &quot;山西省-阳泉市&quot;: [113.587617, 37.862361],\n  &quot;山西省-阳泉市-城区&quot;: [113.606568, 37.853433],\n  &quot;山西省-阳泉市-矿区&quot;: [113.561521, 37.874409],\n  &quot;山西省-阳泉市-郊区&quot;: [113.600603, 37.950353],\n  &quot;山西省-阳泉市-平定县&quot;: [113.664421, 37.792796],\n  &quot;山西省-阳泉市-盂县&quot;: [113.41842, 38.09198],\n  &quot;山西省-长治市&quot;: [113.122559, 36.201268],\n  &quot;山西省-长治市-城区&quot;: [113.129521, 36.209472],\n  &quot;山西省-长治市-郊区&quot;: [113.105622, 36.261066],\n  &quot;山西省-长治市-长治县&quot;: [113.057416, 36.059286],\n  &quot;山西省-长治市-襄垣县&quot;: [113.057413, 36.541686],\n  &quot;山西省-长治市-屯留县&quot;: [112.898475, 36.321631],\n  &quot;山西省-长治市-平顺县&quot;: [113.442517, 36.205989],\n  &quot;山西省-长治市-黎城县&quot;: [113.393432, 36.50867],\n  &quot;山西省-长治市-壶关县&quot;: [113.21358, 36.121335],\n  &quot;山西省-长治市-长子县&quot;: [112.884566, 36.128002],\n  &quot;山西省-长治市-武乡县&quot;: [112.870606, 36.843168],\n  &quot;山西省-长治市-沁县&quot;: [112.705458, 36.76219],\n  &quot;山西省-长治市-沁源县&quot;: [112.344452, 36.506103],\n  &quot;山西省-长治市-潞城市&quot;: [113.235578, 36.339691],\n  &quot;山西省-晋城市&quot;: [112.858578, 35.496285],\n  &quot;山西省-晋城市-城区&quot;: [112.855303, 35.520559],\n  &quot;山西省-晋城市-沁水县&quot;: [112.193426, 35.696364],\n  &quot;山西省-晋城市-阳城县&quot;: [112.421454, 35.492181],\n  &quot;山西省-晋城市-陵川县&quot;: [113.287407, 35.781744],\n  &quot;山西省-晋城市-泽州县&quot;: [112.794401, 35.59977],\n  &quot;山西省-晋城市-高平市&quot;: [112.930412, 35.804337],\n  &quot;山西省-朔州市&quot;: [112.439371, 39.337108],\n  &quot;山西省-朔州市-朔城区&quot;: [112.438376, 39.325303],\n  &quot;山西省-朔州市-平鲁区&quot;: [112.295525, 39.517389],\n  &quot;山西省-朔州市-山阴县&quot;: [112.822432, 39.53403],\n  &quot;山西省-朔州市-应县&quot;: [113.197494, 39.560078],\n  &quot;山西省-朔州市-右玉县&quot;: [112.4735, 39.99486],\n  &quot;山西省-朔州市-怀仁县&quot;: [113.106608, 39.833757],\n  &quot;山西省-晋中市&quot;: [112.759595, 37.692839],\n  &quot;山西省-晋中市-榆次区&quot;: [112.714504, 37.70394],\n  &quot;山西省-晋中市-榆社县&quot;: [112.981599, 37.07637],\n  &quot;山西省-晋中市-左权县&quot;: [113.385452, 37.088555],\n  &quot;山西省-晋中市-和顺县&quot;: [113.576606, 37.334808],\n  &quot;山西省-晋中市-昔阳县&quot;: [113.713613, 37.617884],\n  &quot;山西省-晋中市-寿阳县&quot;: [113.18341, 37.901308],\n  &quot;山西省-晋中市-太谷县&quot;: [112.557384, 37.427396],\n  &quot;山西省-晋中市-祁县&quot;: [112.342442, 37.364131],\n  &quot;山西省-晋中市-平遥县&quot;: [112.182456, 37.195601],\n  &quot;山西省-晋中市-灵石县&quot;: [111.785618, 36.853368],\n  &quot;山西省-晋中市-介休市&quot;: [111.923563, 37.032686],\n  &quot;山西省-运城市&quot;: [111.013389, 35.032707],\n  &quot;山西省-运城市-盐湖区&quot;: [111.004377, 35.021425],\n  &quot;山西省-运城市-临猗县&quot;: [110.780407, 35.149542],\n  &quot;山西省-运城市-万荣县&quot;: [110.844576, 35.421109],\n  &quot;山西省-运城市-闻喜县&quot;: [111.23141, 35.362931],\n  &quot;山西省-运城市-稷山县&quot;: [110.989415, 35.610403],\n  &quot;山西省-运城市-新绛县&quot;: [111.231406, 35.62263],\n  &quot;山西省-运城市-绛县&quot;: [111.575487, 35.497276],\n  &quot;山西省-运城市-垣曲县&quot;: [111.676607, 35.303015],\n  &quot;山西省-运城市-夏县&quot;: [111.226431, 35.147462],\n  &quot;山西省-运城市-平陆县&quot;: [111.22348, 34.842925],\n  &quot;山西省-运城市-芮城县&quot;: [110.700612, 34.699388],\n  &quot;山西省-运城市-永济市&quot;: [110.454578, 34.87283],\n  &quot;山西省-运城市-河津市&quot;: [110.718572, 35.601927],\n  &quot;山西省-忻州市&quot;: [112.740624, 38.422383],\n  &quot;山西省-忻州市-忻府区&quot;: [112.752614, 38.40988],\n  &quot;山西省-忻州市-定襄县&quot;: [112.963529, 38.479974],\n  &quot;山西省-忻州市-五台县&quot;: [113.261451, 38.734182],\n  &quot;山西省-忻州市-代县&quot;: [112.966552, 39.072728],\n  &quot;山西省-忻州市-繁峙县&quot;: [113.271408, 39.195237],\n  &quot;山西省-忻州市-宁武县&quot;: [112.326398, 39.024342],\n  &quot;山西省-忻州市-静乐县&quot;: [111.945432, 38.365147],\n  &quot;山西省-忻州市-神池县&quot;: [112.217383, 39.096876],\n  &quot;山西省-忻州市-五寨县&quot;: [111.85341, 38.91702],\n  &quot;山西省-忻州市-岢岚县&quot;: [111.579478, 38.710151],\n  &quot;山西省-忻州市-河曲县&quot;: [111.144449, 39.390702],\n  &quot;山西省-忻州市-保德县&quot;: [111.092542, 39.028337],\n  &quot;山西省-忻州市-偏关县&quot;: [111.514474, 39.44223],\n  &quot;山西省-忻州市-原平市&quot;: [112.717487, 38.736476],\n  &quot;山西省-临汾市&quot;: [111.52553, 36.093742],\n  &quot;山西省-临汾市-尧都区&quot;: [111.58643, 36.084562],\n  &quot;山西省-临汾市-曲沃县&quot;: [111.482396, 35.647327],\n  &quot;山西省-临汾市-翼城县&quot;: [111.725376, 35.744429],\n  &quot;山西省-临汾市-襄汾县&quot;: [111.44854, 35.882063],\n  &quot;山西省-临汾市-洪洞县&quot;: [111.681589, 36.259467],\n  &quot;山西省-临汾市-古县&quot;: [111.926573, 36.272338],\n  &quot;山西省-临汾市-安泽县&quot;: [112.256613, 36.153514],\n  &quot;山西省-临汾市-浮山县&quot;: [111.855385, 35.974393],\n  &quot;山西省-临汾市-吉县&quot;: [110.688546, 36.103999],\n  &quot;山西省-临汾市-乡宁县&quot;: [110.853498, 35.976442],\n  &quot;山西省-临汾市-大宁县&quot;: [110.759384, 36.471306],\n  &quot;山西省-临汾市-隰县&quot;: [110.947591, 36.699061],\n  &quot;山西省-临汾市-永和县&quot;: [110.638416, 36.765909],\n  &quot;山西省-临汾市-蒲县&quot;: [111.102474, 36.418005],\n  &quot;山西省-临汾市-汾西县&quot;: [111.569546, 36.658782],\n  &quot;山西省-临汾市-侯马市&quot;: [111.378397, 35.625365],\n  &quot;山西省-临汾市-霍州市&quot;: [111.761509, 36.574607],\n  &quot;山西省-吕梁市&quot;: [111.15045, 37.524498],\n  &quot;山西省-吕梁市-离石区&quot;: [111.157491, 37.523577],\n  &quot;山西省-吕梁市-文水县&quot;: [112.035599, 37.4443],\n  &quot;山西省-吕梁市-交城县&quot;: [112.162568, 37.557772],\n  &quot;山西省-吕梁市-兴县&quot;: [111.134392, 38.468804],\n  &quot;山西省-吕梁市-临县&quot;: [110.998415, 37.957211],\n  &quot;山西省-吕梁市-柳林县&quot;: [110.89539, 37.435493],\n  &quot;山西省-吕梁市-石楼县&quot;: [110.841596, 37.004471],\n  &quot;山西省-吕梁市-岚县&quot;: [111.678592, 38.285029],\n  &quot;山西省-吕梁市-方山县&quot;: [111.25037, 37.90102],\n  &quot;山西省-吕梁市-中阳县&quot;: [111.18563, 37.362873],\n  &quot;山西省-吕梁市-交口县&quot;: [111.187628, 36.987873],\n  &quot;山西省-吕梁市-孝义市&quot;: [111.785606, 37.151063],\n  &quot;山西省-吕梁市-汾阳市&quot;: [111.794597, 37.271292],\n  &quot;内蒙古自治区&quot;: [111.772606, 40.823156],\n  &quot;内蒙古自治区-呼和浩特市&quot;: [111.755509, 40.848423],\n  &quot;内蒙古自治区-呼和浩特市-新城区&quot;: [111.67162, 40.863877],\n  &quot;内蒙古自治区-呼和浩特市-回民区&quot;: [111.63047, 40.814506],\n  &quot;内蒙古自治区-呼和浩特市-玉泉区&quot;: [111.681575, 40.758059],\n  &quot;内蒙古自治区-呼和浩特市-赛罕区&quot;: [111.708421, 40.798394],\n  &quot;内蒙古自治区-呼和浩特市-土默特左旗&quot;: [111.169587, 40.735294],\n  &quot;内蒙古自治区-呼和浩特市-托克托县&quot;: [111.200575, 40.283147],\n  &quot;内蒙古自治区-呼和浩特市-和林格尔县&quot;: [111.82843, 40.384798],\n  &quot;内蒙古自治区-呼和浩特市-清水河县&quot;: [111.653576, 39.926334],\n  &quot;内蒙古自治区-呼和浩特市-武川县&quot;: [111.457497, 41.102419],\n  &quot;内蒙古自治区-包头市&quot;: [109.846544, 40.662929],\n  &quot;内蒙古自治区-包头市-东河区&quot;: [110.050395, 40.582228],\n  &quot;内蒙古自治区-包头市-昆都仑区&quot;: [109.845538, 40.647644],\n  &quot;内蒙古自治区-包头市-青山区&quot;: [109.907416, 40.649473],\n  &quot;内蒙古自治区-包头市-石拐区&quot;: [110.278381, 40.678299],\n  &quot;内蒙古自治区-包头市-白云鄂博矿区&quot;: [109.979626, 41.774995],\n  &quot;内蒙古自治区-包头市-九原区&quot;: [109.969588, 40.613397],\n  &quot;内蒙古自治区-包头市-土默特右旗&quot;: [110.530389, 40.575127],\n  &quot;内蒙古自治区-包头市-固阳县&quot;: [110.066433, 41.040163],\n  &quot;内蒙古自治区-包头市-达尔罕茂明安联合旗&quot;: [110.439521, 41.704549],\n  &quot;内蒙古自治区-乌海市&quot;: [106.800391, 39.662006],\n  &quot;内蒙古自治区-乌海市-海勃湾区&quot;: [106.829439, 39.696908],\n  &quot;内蒙古自治区-乌海市-海南区&quot;: [106.898471, 39.446828],\n  &quot;内蒙古自治区-乌海市-乌达区&quot;: [106.732606, 39.511469],\n  &quot;内蒙古自治区-赤峰市&quot;: [118.89552, 42.261686],\n  &quot;内蒙古自治区-赤峰市-红山区&quot;: [118.963564, 42.270478],\n  &quot;内蒙古自治区-赤峰市-元宝山区&quot;: [119.295405, 42.045125],\n  &quot;内蒙古自治区-赤峰市-松山区&quot;: [118.939414, 42.292482],\n  &quot;内蒙古自治区-赤峰市-阿鲁科尔沁旗&quot;: [120.072614, 43.877953],\n  &quot;内蒙古自治区-赤峰市-巴林左旗&quot;: [119.386443, 43.976383],\n  &quot;内蒙古自治区-赤峰市-巴林右旗&quot;: [118.670394, 43.540132],\n  &quot;内蒙古自治区-赤峰市-林西县&quot;: [118.062461, 43.62421],\n  &quot;内蒙古自治区-赤峰市-克什克腾旗&quot;: [117.55162, 43.270758],\n  &quot;内蒙古自治区-赤峰市-翁牛特旗&quot;: [119.012509, 42.942019],\n  &quot;内蒙古自治区-赤峰市-喀喇沁旗&quot;: [118.710474, 41.932214],\n  &quot;内蒙古自治区-赤峰市-宁城县&quot;: [119.350609, 41.600245],\n  &quot;内蒙古自治区-赤峰市-敖汉旗&quot;: [119.927578, 42.296507],\n  &quot;内蒙古自治区-通辽市&quot;: [122.250522, 43.65798],\n  &quot;内蒙古自治区-通辽市-科尔沁区&quot;: [122.262457, 43.628712],\n  &quot;内蒙古自治区-通辽市-科尔沁左翼中旗&quot;: [123.318589, 44.132294],\n  &quot;内蒙古自治区-通辽市-科尔沁左翼后旗&quot;: [122.363563, 42.939562],\n  &quot;内蒙古自治区-通辽市-开鲁县&quot;: [121.325386, 43.606369],\n  &quot;内蒙古自治区-通辽市-库伦旗&quot;: [121.817406, 42.741211],\n  &quot;内蒙古自治区-通辽市-奈曼旗&quot;: [120.664646, 42.871846],\n  &quot;内蒙古自治区-通辽市-扎鲁特旗&quot;: [120.918626, 44.562213],\n  &quot;内蒙古自治区-通辽市-霍林郭勒市&quot;: [119.670466, 45.537513],\n  &quot;内蒙古自治区-鄂尔多斯市&quot;: [109.787443, 39.614482],\n  &quot;内蒙古自治区-鄂尔多斯市-东胜区&quot;: [109.96956, 39.827987],\n  &quot;内蒙古自治区-鄂尔多斯市-康巴什区&quot;: [109.869627, 39.616378],\n  &quot;内蒙古自治区-鄂尔多斯市-达拉特旗&quot;: [110.040366, 40.418907],\n  &quot;内蒙古自治区-鄂尔多斯市-准格尔旗&quot;: [111.246398, 39.87054],\n  &quot;内蒙古自治区-鄂尔多斯市-鄂托克前旗&quot;: [107.484585, 38.188217],\n  &quot;内蒙古自治区-鄂尔多斯市-鄂托克旗&quot;: [107.982445, 39.095293],\n  &quot;内蒙古自治区-鄂尔多斯市-杭锦旗&quot;: [108.742413, 39.838816],\n  &quot;内蒙古自治区-鄂尔多斯市-乌审旗&quot;: [108.824435, 38.610027],\n  &quot;内蒙古自治区-鄂尔多斯市-伊金霍洛旗&quot;: [109.75459, 39.570093],\n  &quot;内蒙古自治区-呼伦贝尔市&quot;: [119.77237, 49.218446],\n  &quot;内蒙古自治区-呼伦贝尔市-海拉尔区&quot;: [119.742465, 49.218216],\n  &quot;内蒙古自治区-呼伦贝尔市-扎赉诺尔区&quot;: [117.385436, 49.604099],\n  &quot;内蒙古自治区-呼伦贝尔市-阿荣旗&quot;: [123.46544, 48.131971],\n  &quot;内蒙古自治区-呼伦贝尔市-莫力达瓦达斡尔族自治旗&quot;: [124.525576, 48.482896],\n  &quot;内蒙古自治区-呼伦贝尔市-鄂伦春自治旗&quot;: [123.732345, 50.597948],\n  &quot;内蒙古自治区-呼伦贝尔市-鄂温克族自治旗&quot;: [119.761351, 49.153045],\n  &quot;内蒙古自治区-呼伦贝尔市-陈巴尔虎旗&quot;: [119.430462, 49.334914],\n  &quot;内蒙古自治区-呼伦贝尔市-新巴尔虎左旗&quot;: [118.276608, 48.223787],\n  &quot;内蒙古自治区-呼伦贝尔市-新巴尔虎右旗&quot;: [116.830632, 48.677054],\n  &quot;内蒙古自治区-呼伦贝尔市-满洲里市&quot;: [117.385436, 49.604099],\n  &quot;内蒙古自治区-呼伦贝尔市-牙克石市&quot;: [120.718347, 49.292024],\n  &quot;内蒙古自治区-呼伦贝尔市-扎兰屯市&quot;: [122.744454, 48.019956],\n  &quot;内蒙古自治区-呼伦贝尔市-额尔古纳市&quot;: [120.186634, 50.248132],\n  &quot;内蒙古自治区-呼伦贝尔市-根河市&quot;: [121.527585, 50.78614],\n  &quot;内蒙古自治区-巴彦淖尔市&quot;: [107.394398, 40.749359],\n  &quot;内蒙古自治区-巴彦淖尔市-临河区&quot;: [107.369534, 40.756681],\n  &quot;内蒙古自治区-巴彦淖尔市-五原县&quot;: [108.273491, 41.094455],\n  &quot;内蒙古自治区-巴彦淖尔市-磴口县&quot;: [107.014522, 40.33647],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特前旗&quot;: [108.658615, 40.742104],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特中旗&quot;: [108.519512, 41.593346],\n  &quot;内蒙古自治区-巴彦淖尔市-乌拉特后旗&quot;: [107.081546, 41.089422],\n  &quot;内蒙古自治区-巴彦淖尔市-杭锦后旗&quot;: [107.157372, 40.892179],\n  &quot;内蒙古自治区-乌兰察布市&quot;: [113.139468, 41.000748],\n  &quot;内蒙古自治区-乌兰察布市-集宁区&quot;: [113.120587, 41.041146],\n  &quot;内蒙古自治区-乌兰察布市-卓资县&quot;: [112.58441, 40.900292],\n  &quot;内蒙古自治区-乌兰察布市-化德县&quot;: [114.016409, 41.909603],\n  &quot;内蒙古自治区-乌兰察布市-商都县&quot;: [113.584639, 41.567567],\n  &quot;内蒙古自治区-乌兰察布市-兴和县&quot;: [113.840579, 40.879342],\n  &quot;内蒙古自治区-乌兰察布市-凉城县&quot;: [112.5106, 40.537163],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼前旗&quot;: [113.221605, 40.791267],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼中旗&quot;: [112.64258, 41.283273],\n  &quot;内蒙古自治区-乌兰察布市-察哈尔右翼后旗&quot;: [113.198531, 41.441771],\n  &quot;内蒙古自治区-乌兰察布市-四子王旗&quot;: [111.712419, 41.539353],\n  &quot;内蒙古自治区-乌兰察布市-丰镇市&quot;: [113.116601, 40.441805],\n  &quot;内蒙古自治区-兴安盟&quot;: [122.044365, 46.088464],\n  &quot;内蒙古自治区-兴安盟-乌兰浩特市&quot;: [122.099622, 46.078654],\n  &quot;内蒙古自治区-兴安盟-阿尔山市&quot;: [119.950653, 47.183054],\n  &quot;内蒙古自治区-兴安盟-科尔沁右翼前旗&quot;: [121.964553, 46.082649],\n  &quot;内蒙古自治区-兴安盟-科尔沁右翼中旗&quot;: [121.483548, 45.066471],\n  &quot;内蒙古自治区-兴安盟-扎赉特旗&quot;: [122.906444, 46.72919],\n  &quot;内蒙古自治区-兴安盟-突泉县&quot;: [121.600545, 45.38783],\n  &quot;内蒙古自治区-锡林郭勒盟&quot;: [116.054391, 43.939423],\n  &quot;内蒙古自治区-锡林郭勒盟-二连浩特市&quot;: [111.958363, 43.6488],\n  &quot;内蒙古自治区-锡林郭勒盟-锡林浩特市&quot;: [116.093614, 43.938334],\n  &quot;内蒙古自治区-锡林郭勒盟-阿巴嘎旗&quot;: [114.957367, 44.028102],\n  &quot;内蒙古自治区-锡林郭勒盟-苏尼特左旗&quot;: [113.67348, 43.865554],\n  &quot;内蒙古自治区-锡林郭勒盟-苏尼特右旗&quot;: [112.648569, 42.747369],\n  &quot;内蒙古自治区-锡林郭勒盟-东乌珠穆沁旗&quot;: [116.978504, 45.515743],\n  &quot;内蒙古自治区-锡林郭勒盟-西乌珠穆沁旗&quot;: [117.616377, 44.593803],\n  &quot;内蒙古自治区-锡林郭勒盟-太仆寺旗&quot;: [115.290535, 41.882292],\n  &quot;内蒙古自治区-锡林郭勒盟-镶黄旗&quot;: [113.854505, 42.237661],\n  &quot;内蒙古自治区-锡林郭勒盟-正镶白旗&quot;: [115.036622, 42.292605],\n  &quot;内蒙古自治区-锡林郭勒盟-正蓝旗&quot;: [115.998604, 42.247119],\n  &quot;内蒙古自治区-锡林郭勒盟-多伦县&quot;: [116.492509, 42.208921],\n  &quot;内蒙古自治区-阿拉善盟&quot;: [105.735377, 38.858276],\n  &quot;内蒙古自治区-阿拉善盟-阿拉善左旗&quot;: [105.672599, 38.839094],\n  &quot;内蒙古自治区-阿拉善盟-阿拉善右旗&quot;: [101.673464, 39.222241],\n  &quot;内蒙古自治区-阿拉善盟-额济纳旗&quot;: [101.062403, 41.960298],\n  &quot;辽宁省&quot;: [123.435598, 41.841465],\n  &quot;辽宁省-沈阳市&quot;: [123.466452, 41.68879],\n  &quot;辽宁省-沈阳市-和平区&quot;: [123.426644, 41.795236],\n  &quot;辽宁省-沈阳市-沈河区&quot;: [123.465461, 41.802274],\n  &quot;辽宁省-沈阳市-大东区&quot;: [123.476405, 41.811425],\n  &quot;辽宁省-沈阳市-皇姑区&quot;: [123.431621, 41.826042],\n  &quot;辽宁省-沈阳市-铁西区&quot;: [123.383436, 41.809038],\n  &quot;辽宁省-沈阳市-苏家屯区&quot;: [123.350435, 41.671254],\n  &quot;辽宁省-沈阳市-浑南区&quot;: [123.567539, 41.849226],\n  &quot;辽宁省-沈阳市-沈北新区&quot;: [123.533605, 42.058914],\n  &quot;辽宁省-沈阳市-于洪区&quot;: [123.314633, 41.799668],\n  &quot;辽宁省-沈阳市-辽中区&quot;: [122.772378, 41.523149],\n  &quot;辽宁省-沈阳市-康平县&quot;: [123.337511, 42.749925],\n  &quot;辽宁省-沈阳市-法库县&quot;: [123.414621, 42.509607],\n  &quot;辽宁省-沈阳市-新民市&quot;: [122.875395, 42.007109],\n  &quot;辽宁省-大连市&quot;: [121.621631, 38.918954],\n  &quot;辽宁省-大连市-中山区&quot;: [121.651547, 38.924511],\n  &quot;辽宁省-大连市-西岗区&quot;: [121.618625, 38.920473],\n  &quot;辽宁省-大连市-沙河口区&quot;: [121.594507, 38.913544],\n  &quot;辽宁省-大连市-甘井子区&quot;: [121.531519, 38.958002],\n  &quot;辽宁省-大连市-旅顺口区&quot;: [121.268597, 38.856832],\n  &quot;辽宁省-大连市-金州区&quot;: [121.789436, 39.056433],\n  &quot;辽宁省-大连市-普兰店区&quot;: [121.94646, 39.398089],\n  &quot;辽宁省-大连市-长海县&quot;: [122.594627, 39.27827],\n  &quot;辽宁省-大连市-瓦房店市&quot;: [121.985638, 39.632741],\n  &quot;辽宁省-大连市-庄河市&quot;: [122.974495, 39.686956],\n  &quot;辽宁省-鞍山市&quot;: [123.001373, 41.115054],\n  &quot;辽宁省-鞍山市-铁东区&quot;: [122.9974, 41.096332],\n  &quot;辽宁省-鞍山市-铁西区&quot;: [122.97549, 41.125475],\n  &quot;辽宁省-鞍山市-立山区&quot;: [123.035484, 41.156116],\n  &quot;辽宁省-鞍山市-千山区&quot;: [122.967574, 41.080939],\n  &quot;辽宁省-鞍山市-台安县&quot;: [122.44255, 41.41859],\n  &quot;辽宁省-鞍山市-岫岩满族自治县&quot;: [123.287547, 40.295892],\n  &quot;辽宁省-鞍山市-海城市&quot;: [122.691569, 40.887634],\n  &quot;辽宁省-抚顺市&quot;: [123.964375, 41.88597],\n  &quot;辽宁省-抚顺市-新抚区&quot;: [123.919582, 41.867806],\n  &quot;辽宁省-抚顺市-东洲区&quot;: [124.04555, 41.859191],\n  &quot;辽宁省-抚顺市-望花区&quot;: [123.790604, 41.85903],\n  &quot;辽宁省-抚顺市-顺城区&quot;: [123.951414, 41.889164],\n  &quot;辽宁省-抚顺市-抚顺县&quot;: [123.92159, 41.887037],\n  &quot;辽宁省-抚顺市-新宾满族自治县&quot;: [125.046356, 41.739969],\n  &quot;辽宁省-抚顺市-清原满族自治县&quot;: [124.93036, 42.106761],\n  &quot;辽宁省-本溪市&quot;: [123.692507, 41.492916],\n  &quot;辽宁省-本溪市-平山区&quot;: [123.774614, 41.301604],\n  &quot;辽宁省-本溪市-溪湖区&quot;: [123.774611, 41.334803],\n  &quot;辽宁省-本溪市-明山区&quot;: [123.823474, 41.314939],\n  &quot;辽宁省-本溪市-南芬区&quot;: [123.751467, 41.107096],\n  &quot;辽宁省-本溪市-本溪满族自治县&quot;: [124.127585, 41.307903],\n  &quot;辽宁省-本溪市-桓仁满族自治县&quot;: [125.367544, 41.272925],\n  &quot;辽宁省-丹东市&quot;: [124.361547, 40.006409],\n  &quot;辽宁省-丹东市-元宝区&quot;: [124.402584, 40.142251],\n  &quot;辽宁省-丹东市-振兴区&quot;: [124.366579, 40.110719],\n  &quot;辽宁省-丹东市-振安区&quot;: [124.434387, 40.164697],\n  &quot;辽宁省-丹东市-宽甸满族自治县&quot;: [124.790427, 40.737553],\n  &quot;辽宁省-丹东市-东港市&quot;: [124.15961, 39.867716],\n  &quot;辽宁省-丹东市-凤城市&quot;: [124.072422, 40.45918],\n  &quot;辽宁省-锦州市&quot;: [121.132596, 41.100931],\n  &quot;辽宁省-锦州市-古塔区&quot;: [121.134585, 41.122901],\n  &quot;辽宁省-锦州市-凌河区&quot;: [121.15759, 41.120691],\n  &quot;辽宁省-锦州市-太和区&quot;: [121.110453, 41.115109],\n  &quot;辽宁省-锦州市-黑山县&quot;: [122.130557, 41.671593],\n  &quot;辽宁省-锦州市-义县&quot;: [121.245569, 41.538939],\n  &quot;辽宁省-锦州市-凌海市&quot;: [121.362539, 41.166488],\n  &quot;辽宁省-锦州市-北镇市&quot;: [121.783447, 41.594428],\n  &quot;辽宁省-营口市&quot;: [122.241575, 40.673137],\n  &quot;辽宁省-营口市-站前区&quot;: [122.265437, 40.678764],\n  &quot;辽宁省-营口市-西市区&quot;: [122.213582, 40.672111],\n  &quot;辽宁省-营口市-鲅鱼圈区&quot;: [122.127573, 40.23234],\n  &quot;辽宁省-营口市-老边区&quot;: [122.386439, 40.686384],\n  &quot;辽宁省-营口市-盖州市&quot;: [122.355591, 40.406167],\n  &quot;辽宁省-营口市-大石桥市&quot;: [122.51538, 40.650802],\n  &quot;辽宁省-阜新市&quot;: [121.676408, 42.028022],\n  &quot;辽宁省-阜新市-海州区&quot;: [121.669436, 42.023735],\n  &quot;辽宁省-阜新市-新邱区&quot;: [121.799363, 42.093935],\n  &quot;辽宁省-阜新市-太平区&quot;: [121.685384, 42.016968],\n  &quot;辽宁省-阜新市-清河门区&quot;: [121.422479, 41.789319],\n  &quot;辽宁省-阜新市-细河区&quot;: [121.686392, 42.031871],\n  &quot;辽宁省-阜新市-阜新蒙古族自治县&quot;: [121.763574, 42.071368],\n  &quot;辽宁省-阜新市-彰武县&quot;: [122.545449, 42.392707],\n  &quot;辽宁省-辽阳市&quot;: [123.243366, 41.274161],\n  &quot;辽宁省-辽阳市-白塔区&quot;: [123.180608, 41.275845],\n  &quot;辽宁省-辽阳市-文圣区&quot;: [123.191605, 41.268438],\n  &quot;辽宁省-辽阳市-宏伟区&quot;: [123.20358, 41.223368],\n  &quot;辽宁省-辽阳市-弓长岭区&quot;: [123.426615, 41.157327],\n  &quot;辽宁省-辽阳市-太子河区&quot;: [123.188604, 41.259226],\n  &quot;辽宁省-辽阳市-辽阳县&quot;: [123.112421, 41.211679],\n  &quot;辽宁省-辽阳市-灯塔市&quot;: [123.345462, 41.432474],\n  &quot;辽宁省-盘锦市&quot;: [122.07749, 41.125875],\n  &quot;辽宁省-盘锦市-双台子区&quot;: [122.046393, 41.206072],\n  &quot;辽宁省-盘锦市-兴隆台区&quot;: [122.076499, 41.164499],\n  &quot;辽宁省-盘锦市-大洼区&quot;: [122.088555, 41.008179],\n  &quot;辽宁省-盘锦市-盘山县&quot;: [122.00356, 41.248264],\n  &quot;辽宁省-铁岭市&quot;: [123.732365, 42.229948],\n  &quot;辽宁省-铁岭市-银州区&quot;: [123.848386, 42.292574],\n  &quot;辽宁省-铁岭市-清河区&quot;: [124.165563, 42.552495],\n  &quot;辽宁省-铁岭市-铁岭县&quot;: [123.735372, 42.229226],\n  &quot;辽宁省-铁岭市-西丰县&quot;: [124.733615, 42.744014],\n  &quot;辽宁省-铁岭市-昌图县&quot;: [124.117501, 42.792178],\n  &quot;辽宁省-铁岭市-调兵山市&quot;: [123.573509, 42.473738],\n  &quot;辽宁省-铁岭市-开原市&quot;: [124.044569, 42.552079],\n  &quot;辽宁省-朝阳市&quot;: [120.457499, 41.579821],\n  &quot;辽宁省-朝阳市-双塔区&quot;: [120.460487, 41.571779],\n  &quot;辽宁省-朝阳市-龙城区&quot;: [120.443567, 41.598469],\n  &quot;辽宁省-朝阳市-朝阳县&quot;: [120.259391, 41.241076],\n  &quot;辽宁省-朝阳市-建平县&quot;: [119.64938, 41.409456],\n  &quot;辽宁省-朝阳市-喀喇沁左翼蒙古族自治县&quot;: [119.747414, 41.133689],\n  &quot;辽宁省-朝阳市-北票市&quot;: [120.777628, 41.806483],\n  &quot;辽宁省-朝阳市-凌源市&quot;: [119.407358, 41.251651],\n  &quot;辽宁省-葫芦岛市&quot;: [120.843398, 40.717364],\n  &quot;辽宁省-葫芦岛市-连山区&quot;: [120.876482, 40.780894],\n  &quot;辽宁省-葫芦岛市-龙港区&quot;: [120.900621, 40.741057],\n  &quot;辽宁省-葫芦岛市-南票区&quot;: [120.756493, 41.113098],\n  &quot;辽宁省-葫芦岛市-绥中县&quot;: [120.350425, 40.331843],\n  &quot;辽宁省-葫芦岛市-建昌县&quot;: [119.843595, 40.83038],\n  &quot;辽宁省-葫芦岛市-兴城市&quot;: [120.764558, 40.616556],\n  &quot;吉林省&quot;: [125.33258, 43.901714],\n  &quot;吉林省-长春市&quot;: [125.330602, 43.821954],\n  &quot;吉林省-长春市-南关区&quot;: [125.35661, 43.869873],\n  &quot;吉林省-长春市-宽城区&quot;: [125.334625, 43.949502],\n  &quot;吉林省-长春市-朝阳区&quot;: [125.295401, 43.840641],\n  &quot;吉林省-长春市-二道区&quot;: [125.380468, 43.871277],\n  &quot;吉林省-长春市-绿园区&quot;: [125.262443, 43.88681],\n  &quot;吉林省-长春市-双阳区&quot;: [125.671448, 43.531091],\n  &quot;吉林省-长春市-九台区&quot;: [125.845564, 44.157792],\n  &quot;吉林省-长春市-农安县&quot;: [125.191484, 44.438904],\n  &quot;吉林省-长春市-榆树市&quot;: [126.539609, 44.84544],\n  &quot;吉林省-长春市-德惠市&quot;: [125.734515, 44.527161],\n  &quot;吉林省-吉林市&quot;: [126.555635, 43.843568],\n  &quot;吉林省-吉林市-昌邑区&quot;: [126.581449, 43.887992],\n  &quot;吉林省-吉林市-龙潭区&quot;: [126.568545, 43.916343],\n  &quot;吉林省-吉林市-船营区&quot;: [126.54765, 43.839927],\n  &quot;吉林省-吉林市-丰满区&quot;: [126.56857, 43.827152],\n  &quot;吉林省-吉林市-永吉县&quot;: [126.504416, 43.678721],\n  &quot;吉林省-吉林市-蛟河市&quot;: [127.35148, 43.730004],\n  &quot;吉林省-吉林市-桦甸市&quot;: [126.752484, 42.977983],\n  &quot;吉林省-吉林市-舒兰市&quot;: [126.971377, 44.41227],\n  &quot;吉林省-吉林市-磐石市&quot;: [126.066616, 42.951817],\n  &quot;吉林省-四平市&quot;: [124.356482, 43.171994],\n  &quot;吉林省-四平市-铁西区&quot;: [124.352467, 43.152575],\n  &quot;吉林省-四平市-铁东区&quot;: [124.416483, 43.167994],\n  &quot;吉林省-四平市-梨树县&quot;: [124.342401, 43.313346],\n  &quot;吉林省-四平市-伊通满族自治县&quot;: [125.311485, 43.351104],\n  &quot;吉林省-四平市-公主岭市&quot;: [124.829449, 43.510833],\n  &quot;吉林省-四平市-双辽市&quot;: [123.509438, 43.524527],\n  &quot;吉林省-辽源市&quot;: [125.150425, 42.894055],\n  &quot;吉林省-辽源市-龙山区&quot;: [125.143452, 42.907634],\n  &quot;吉林省-辽源市-西安区&quot;: [125.155373, 42.933308],\n  &quot;吉林省-辽源市-东丰县&quot;: [125.537378, 42.683311],\n  &quot;吉林省-辽源市-东辽县&quot;: [124.997589, 42.931879],\n  &quot;吉林省-通化市&quot;: [125.946606, 41.733816],\n  &quot;吉林省-通化市-东昌区&quot;: [125.933595, 41.708405],\n  &quot;吉林省-通化市-二道江区&quot;: [126.049592, 41.779966],\n  &quot;吉林省-通化市-通化县&quot;: [125.765392, 41.685682],\n  &quot;吉林省-通化市-辉南县&quot;: [126.053581, 42.6907],\n  &quot;吉林省-通化市-柳河县&quot;: [125.751424, 42.290871],\n  &quot;吉林省-通化市-梅河口市&quot;: [125.717608, 42.544884],\n  &quot;吉林省-通化市-集安市&quot;: [126.199577, 41.1313],\n  &quot;吉林省-白山市&quot;: [126.42963, 41.939627],\n  &quot;吉林省-白山市-浑江区&quot;: [126.42362, 41.950424],\n  &quot;吉林省-白山市-江源区&quot;: [126.597391, 42.062939],\n  &quot;吉林省-白山市-抚松县&quot;: [127.455371, 42.227335],\n  &quot;吉林省-白山市-靖宇县&quot;: [126.819499, 42.394766],\n  &quot;吉林省-白山市-长白朝鲜族自治县&quot;: [128.207584, 41.425896],\n  &quot;吉林省-白山市-临江市&quot;: [126.924582, 41.817679],\n  &quot;吉林省-松原市&quot;: [124.831482, 45.147404],\n  &quot;吉林省-松原市-宁江区&quot;: [124.823423, 45.178039],\n  &quot;吉林省-松原市-前郭尔罗斯蒙古族自治县&quot;: [124.830456, 45.123416],\n  &quot;吉林省-松原市-长岭县&quot;: [123.974374, 44.281638],\n  &quot;吉林省-松原市-乾安县&quot;: [124.047564, 45.008434],\n  &quot;吉林省-松原市-扶余市&quot;: [126.056606, 44.994168],\n  &quot;吉林省-白城市&quot;: [122.845591, 45.625504],\n  &quot;吉林省-白城市-洮北区&quot;: [122.85751, 45.627525],\n  &quot;吉林省-白城市-镇赉县&quot;: [123.206576, 45.853117],\n  &quot;吉林省-白城市-通榆县&quot;: [123.094521, 44.818964],\n  &quot;吉林省-白城市-洮南市&quot;: [122.794468, 45.341132],\n  &quot;吉林省-白城市-大安市&quot;: [124.298504, 45.513045],\n  &quot;吉林省-延边朝鲜族自治州&quot;: [129.477376, 42.915743],\n  &quot;吉林省-延边朝鲜族自治州-延吉市&quot;: [129.52052, 42.912717],\n  &quot;吉林省-延边朝鲜族自治州-图们市&quot;: [129.850382, 42.974283],\n  &quot;吉林省-延边朝鲜族自治州-敦化市&quot;: [128.238612, 43.378291],\n  &quot;吉林省-延边朝鲜族自治州-珲春市&quot;: [130.372613, 42.868515],\n  &quot;吉林省-延边朝鲜族自治州-龙井市&quot;: [129.432635, 42.771535],\n  &quot;吉林省-延边朝鲜族自治州-和龙市&quot;: [129.017387, 42.552323],\n  &quot;吉林省-延边朝鲜族自治州-汪清县&quot;: [129.777609, 43.318451],\n  &quot;吉林省-延边朝鲜族自治州-安图县&quot;: [128.905448, 43.117917],\n  &quot;黑龙江省&quot;: [126.669653, 45.74793],\n  &quot;黑龙江省-哈尔滨市&quot;: [126.541615, 45.808826],\n  &quot;黑龙江省-哈尔滨市-道里区&quot;: [126.623432, 45.761844],\n  &quot;黑龙江省-哈尔滨市-南岗区&quot;: [126.675638, 45.765866],\n  &quot;黑龙江省-哈尔滨市-道外区&quot;: [126.655604, 45.797776],\n  &quot;黑龙江省-哈尔滨市-平房区&quot;: [126.643547, 45.603862],\n  &quot;黑龙江省-哈尔滨市-松北区&quot;: [126.516483, 45.808593],\n  &quot;黑龙江省-哈尔滨市-香坊区&quot;: [126.669624, 45.71362],\n  &quot;黑龙江省-哈尔滨市-呼兰区&quot;: [126.594399, 45.89521],\n  &quot;黑龙江省-哈尔滨市-阿城区&quot;: [126.964356, 45.554275],\n  &quot;黑龙江省-哈尔滨市-双城区&quot;: [126.319623, 45.388112],\n  &quot;黑龙江省-哈尔滨市-依兰县&quot;: [129.57452, 46.33126],\n  &quot;黑龙江省-哈尔滨市-方正县&quot;: [128.835634, 45.857758],\n  &quot;黑龙江省-哈尔滨市-宾县&quot;: [127.473497, 45.752465],\n  &quot;黑龙江省-哈尔滨市-巴彦县&quot;: [127.410548, 46.091283],\n  &quot;黑龙江省-哈尔滨市-木兰县&quot;: [128.050356, 45.956871],\n  &quot;黑龙江省-哈尔滨市-通河县&quot;: [128.752416, 45.996393],\n  &quot;黑龙江省-哈尔滨市-延寿县&quot;: [128.338606, 45.457641],\n  &quot;黑龙江省-哈尔滨市-尚志市&quot;: [128.015488, 45.215474],\n  &quot;黑龙江省-哈尔滨市-五常市&quot;: [127.173529, 44.937843],\n  &quot;黑龙江省-齐齐哈尔市&quot;: [123.924571, 47.359977],\n  &quot;黑龙江省-齐齐哈尔市-龙沙区&quot;: [123.964376, 47.323577],\n  &quot;黑龙江省-齐齐哈尔市-建华区&quot;: [123.96135, 47.360555],\n  &quot;黑龙江省-齐齐哈尔市-铁锋区&quot;: [123.984416, 47.347019],\n  &quot;黑龙江省-齐齐哈尔市-昂昂溪区&quot;: [123.829406, 47.161332],\n  &quot;黑龙江省-齐齐哈尔市-富拉尔基区&quot;: [123.63651, 47.215504],\n  &quot;黑龙江省-齐齐哈尔市-碾子山区&quot;: [122.894367, 47.523236],\n  &quot;黑龙江省-齐齐哈尔市-梅里斯达斡尔族区&quot;: [123.759541, 47.31555],\n  &quot;黑龙江省-齐齐哈尔市-龙江县&quot;: [123.211539, 47.343606],\n  &quot;黑龙江省-齐齐哈尔市-依安县&quot;: [125.312482, 47.899484],\n  &quot;黑龙江省-齐齐哈尔市-泰来县&quot;: [123.423626, 46.397829],\n  &quot;黑龙江省-齐齐哈尔市-甘南县&quot;: [123.512486, 47.926884],\n  &quot;黑龙江省-齐齐哈尔市-富裕县&quot;: [124.480542, 47.780228],\n  &quot;黑龙江省-齐齐哈尔市-克山县&quot;: [125.881378, 48.043172],\n  &quot;黑龙江省-齐齐哈尔市-克东县&quot;: [126.255387, 48.048244],\n  &quot;黑龙江省-齐齐哈尔市-拜泉县&quot;: [126.105421, 47.601867],\n  &quot;黑龙江省-齐齐哈尔市-讷河市&quot;: [124.890549, 48.490087],\n  &quot;黑龙江省-鸡西市&quot;: [130.975619, 45.300872],\n  &quot;黑龙江省-鸡西市-鸡冠区&quot;: [130.987632, 45.309806],\n  &quot;黑龙江省-鸡西市-恒山区&quot;: [130.911385, 45.216972],\n  &quot;黑龙江省-鸡西市-滴道区&quot;: [130.85058, 45.354434],\n  &quot;黑龙江省-鸡西市-梨树区&quot;: [130.703396, 45.098242],\n  &quot;黑龙江省-鸡西市-城子河区&quot;: [131.018469, 45.344435],\n  &quot;黑龙江省-鸡西市-麻山区&quot;: [130.484536, 45.217935],\n  &quot;黑龙江省-鸡西市-鸡东县&quot;: [131.130558, 45.266185],\n  &quot;黑龙江省-鸡西市-虎林市&quot;: [132.943466, 45.768947],\n  &quot;黑龙江省-鸡西市-密山市&quot;: [131.853531, 45.535641],\n  &quot;黑龙江省-鹤岗市&quot;: [130.304433, 47.356056],\n  &quot;黑龙江省-鹤岗市-向阳区&quot;: [130.300468, 47.348581],\n  &quot;黑龙江省-鹤岗市-工农区&quot;: [130.281617, 47.32443],\n  &quot;黑龙江省-鹤岗市-南山区&quot;: [130.29354, 47.321246],\n  &quot;黑龙江省-鹤岗市-兴安区&quot;: [130.245546, 47.258716],\n  &quot;黑龙江省-鹤岗市-东山区&quot;: [130.323361, 47.344987],\n  &quot;黑龙江省-鹤岗市-兴山区&quot;: [130.317364, 47.396045],\n  &quot;黑龙江省-鹤岗市-萝北县&quot;: [130.835495, 47.583422],\n  &quot;黑龙江省-鹤岗市-绥滨县&quot;: [131.859487, 47.295265],\n  &quot;黑龙江省-双鸭山市&quot;: [131.165342, 46.653186],\n  &quot;黑龙江省-双鸭山市-尖山区&quot;: [131.165342, 46.652586],\n  &quot;黑龙江省-双鸭山市-岭东区&quot;: [131.164377, 46.464596],\n  &quot;黑龙江省-双鸭山市-四方台区&quot;: [131.345657, 46.602012],\n  &quot;黑龙江省-双鸭山市-宝山区&quot;: [131.407375, 46.583598],\n  &quot;黑龙江省-双鸭山市-集贤县&quot;: [131.147434, 46.734518],\n  &quot;黑龙江省-双鸭山市-友谊县&quot;: [131.814595, 46.772973],\n  &quot;黑龙江省-双鸭山市-宝清县&quot;: [132.203594, 46.332652],\n  &quot;黑龙江省-双鸭山市-饶河县&quot;: [134.020469, 46.804183],\n  &quot;黑龙江省-大庆市&quot;: [125.108658, 46.593633],\n  &quot;黑龙江省-大庆市-萨尔图区&quot;: [125.13351, 46.638936],\n  &quot;黑龙江省-大庆市-龙凤区&quot;: [125.140473, 46.567678],\n  &quot;黑龙江省-大庆市-让胡路区&quot;: [124.877599, 46.658078],\n  &quot;黑龙江省-大庆市-红岗区&quot;: [124.897477, 46.404313],\n  &quot;黑龙江省-大庆市-大同区&quot;: [124.819377, 46.045584],\n  &quot;黑龙江省-大庆市-肇州县&quot;: [125.275368, 45.705108],\n  &quot;黑龙江省-大庆市-肇源县&quot;: [125.084573, 45.524153],\n  &quot;黑龙江省-大庆市-林甸县&quot;: [124.86965, 47.177234],\n  &quot;黑龙江省-大庆市-杜尔伯特蒙古族自治县&quot;: [124.449359, 46.868768],\n  &quot;黑龙江省-伊春市&quot;: [128.847546, 47.733318],\n  &quot;黑龙江省-伊春市-伊春区&quot;: [128.913459, 47.733954],\n  &quot;黑龙江省-伊春市-南岔区&quot;: [129.289572, 47.14375],\n  &quot;黑龙江省-伊春市-友好区&quot;: [128.842579, 47.846436],\n  &quot;黑龙江省-伊春市-西林区&quot;: [129.319594, 47.486393],\n  &quot;黑龙江省-伊春市-翠峦区&quot;: [128.676482, 47.732894],\n  &quot;黑龙江省-伊春市-新青区&quot;: [129.540647, 48.296135],\n  &quot;黑龙江省-伊春市-美溪区&quot;: [129.135368, 47.641344],\n  &quot;黑龙江省-伊春市-金山屯区&quot;: [129.435639, 47.418759],\n  &quot;黑龙江省-伊春市-五营区&quot;: [129.25135, 48.114271],\n  &quot;黑龙江省-伊春市-乌马河区&quot;: [128.805546, 47.733619],\n  &quot;黑龙江省-伊春市-汤旺河区&quot;: [129.577474, 48.460614],\n  &quot;黑龙江省-伊春市-带岭区&quot;: [129.027425, 47.034572],\n  &quot;黑龙江省-伊春市-乌伊岭区&quot;: [129.444577, 48.596169],\n  &quot;黑龙江省-伊春市-红星区&quot;: [129.397507, 48.24548],\n  &quot;黑龙江省-伊春市-上甘岭区&quot;: [129.030437, 47.980914],\n  &quot;黑龙江省-伊春市-嘉荫县&quot;: [130.410555, 48.894983],\n  &quot;黑龙江省-伊春市-铁力市&quot;: [128.038365, 46.992949],\n  &quot;黑龙江省-佳木斯市&quot;: [130.327359, 46.80569],\n  &quot;黑龙江省-佳木斯市-向阳区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-前进区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-东风区&quot;: [130.372612, 46.813512],\n  &quot;黑龙江省-佳木斯市-郊区&quot;: [130.333378, 46.816168],\n  &quot;黑龙江省-佳木斯市-桦南县&quot;: [130.560385, 46.245077],\n  &quot;黑龙江省-佳木斯市-桦川县&quot;: [130.725549, 47.028817],\n  &quot;黑龙江省-佳木斯市-汤原县&quot;: [129.911645, 46.735327],\n  &quot;黑龙江省-佳木斯市-同江市&quot;: [132.517509, 47.647981],\n  &quot;黑龙江省-佳木斯市-富锦市&quot;: [132.044539, 47.255933],\n  &quot;黑龙江省-佳木斯市-抚远市&quot;: [134.31449, 48.370945],\n  &quot;黑龙江省-七台河市&quot;: [131.011545, 45.7763],\n  &quot;黑龙江省-七台河市-新兴区&quot;: [130.938371, 45.82231],\n  &quot;黑龙江省-七台河市-桃山区&quot;: [131.026444, 45.7718],\n  &quot;黑龙江省-七台河市-茄子河区&quot;: [131.074481, 45.791238],\n  &quot;黑龙江省-七台河市-勃利县&quot;: [130.598533, 45.760964],\n  &quot;黑龙江省-牡丹江市&quot;: [129.63954, 44.556246],\n  &quot;黑龙江省-牡丹江市-东安区&quot;: [129.633478, 44.58746],\n  &quot;黑龙江省-牡丹江市-阳明区&quot;: [129.642527, 44.601775],\n  &quot;黑龙江省-牡丹江市-爱民区&quot;: [129.598364, 44.60235],\n  &quot;黑龙江省-牡丹江市-西安区&quot;: [129.622413, 44.583861],\n  &quot;黑龙江省-牡丹江市-林口县&quot;: [130.287579, 45.284129],\n  &quot;黑龙江省-牡丹江市-绥芬河市&quot;: [131.157392, 44.418154],\n  &quot;黑龙江省-牡丹江市-海林市&quot;: [129.387427, 44.599872],\n  &quot;黑龙江省-牡丹江市-宁安市&quot;: [129.489368, 44.346984],\n  &quot;黑龙江省-牡丹江市-穆棱市&quot;: [130.530559, 44.924785],\n  &quot;黑龙江省-牡丹江市-东宁市&quot;: [131.131544, 44.096101],\n  &quot;黑龙江省-黑河市&quot;: [127.53549, 50.251272],\n  &quot;黑龙江省-黑河市-爱辉区&quot;: [127.506632, 50.25771],\n  &quot;黑龙江省-黑河市-嫩江县&quot;: [125.227635, 49.19132],\n  &quot;黑龙江省-黑河市-逊克县&quot;: [128.485585, 49.569491],\n  &quot;黑龙江省-黑河市-孙吴县&quot;: [127.342388, 49.431451],\n  &quot;黑龙江省-黑河市-北安市&quot;: [126.49738, 48.24742],\n  &quot;黑龙江省-黑河市-五大连池市&quot;: [126.211555, 48.52261],\n  &quot;黑龙江省-绥化市&quot;: [126.975357, 46.660032],\n  &quot;黑龙江省-绥化市-北林区&quot;: [126.991449, 46.643493],\n  &quot;黑龙江省-绥化市-望奎县&quot;: [126.492385, 46.839168],\n  &quot;黑龙江省-绥化市-兰西县&quot;: [126.29462, 46.258095],\n  &quot;黑龙江省-绥化市-青冈县&quot;: [126.100489, 46.710685],\n  &quot;黑龙江省-绥化市-庆安县&quot;: [127.514612, 46.885744],\n  &quot;黑龙江省-绥化市-明水县&quot;: [125.912483, 47.179483],\n  &quot;黑龙江省-绥化市-绥棱县&quot;: [127.120515, 47.242516],\n  &quot;黑龙江省-绥化市-安达市&quot;: [125.348622, 46.425719],\n  &quot;黑龙江省-绥化市-肇东市&quot;: [125.968537, 46.056938],\n  &quot;黑龙江省-绥化市-海伦市&quot;: [126.936509, 47.456904],\n  &quot;黑龙江省-大兴安岭地区&quot;: [123.644559, 52.510947],\n  &quot;黑龙江省-大兴安岭地区-呼玛县&quot;: [126.65965, 51.730947],\n  &quot;黑龙江省-大兴安岭地区-塔河县&quot;: [124.716513, 52.340305],\n  &quot;黑龙江省-大兴安岭地区-漠河县&quot;: [122.545421, 52.978304],\n  &quot;上海市&quot;: [121.480539, 31.235929],\n  &quot;上海市-市辖区&quot;: [121.480539, 31.235929],\n  &quot;上海市-市辖区-黄浦区&quot;: [121.491586, 31.237247],\n  &quot;上海市-市辖区-徐汇区&quot;: [121.443396, 31.194557],\n  &quot;上海市-市辖区-长宁区&quot;: [121.430454, 31.226848],\n  &quot;上海市-市辖区-静安区&quot;: [121.453432, 31.233845],\n  &quot;上海市-市辖区-普陀区&quot;: [121.403569, 31.254973],\n  &quot;上海市-市辖区-虹口区&quot;: [121.511586, 31.269747],\n  &quot;上海市-市辖区-杨浦区&quot;: [121.53252, 31.265524],\n  &quot;上海市-市辖区-闵行区&quot;: [121.388612, 31.118843],\n  &quot;上海市-市辖区-宝山区&quot;: [121.496563, 31.410279],\n  &quot;上海市-市辖区-嘉定区&quot;: [121.272595, 31.380155],\n  &quot;上海市-市辖区-浦东新区&quot;: [121.550455, 31.227348],\n  &quot;上海市-市辖区-金山区&quot;: [121.34848, 30.747852],\n  &quot;上海市-市辖区-松江区&quot;: [121.23448, 31.037135],\n  &quot;上海市-市辖区-青浦区&quot;: [121.130553, 31.155454],\n  &quot;上海市-市辖区-奉贤区&quot;: [121.480504, 30.92372],\n  &quot;上海市-市辖区-崇明区&quot;: [121.403557, 31.62857],\n  &quot;江苏省&quot;: [118.769552, 32.066777],\n  &quot;江苏省-南京市&quot;: [118.802422, 32.064653],\n  &quot;江苏省-南京市-玄武区&quot;: [118.804413, 32.054757],\n  &quot;江苏省-南京市-秦淮区&quot;: [118.800407, 32.045139],\n  &quot;江苏省-南京市-建邺区&quot;: [118.738569, 32.00937],\n  &quot;江苏省-南京市-鼓楼区&quot;: [118.776519, 32.072405],\n  &quot;江苏省-南京市-浦口区&quot;: [118.634604, 32.064679],\n  &quot;江苏省-南京市-栖霞区&quot;: [118.915423, 32.1026],\n  &quot;江苏省-南京市-雨花台区&quot;: [118.785445, 31.997859],\n  &quot;江苏省-南京市-江宁区&quot;: [118.846567, 31.958527],\n  &quot;江苏省-南京市-六合区&quot;: [118.827471, 32.328666],\n  &quot;江苏省-南京市-溧水区&quot;: [119.034404, 31.657284],\n  &quot;江苏省-南京市-高淳区&quot;: [118.898498, 31.333639],\n  &quot;江苏省-无锡市&quot;: [120.318583, 31.49881],\n  &quot;江苏省-无锡市-锡山区&quot;: [120.363426, 31.594762],\n  &quot;江苏省-无锡市-惠山区&quot;: [120.304596, 31.686741],\n  &quot;江苏省-无锡市-滨湖区&quot;: [120.291548, 31.53464],\n  &quot;江苏省-无锡市-梁溪区&quot;: [120.3096, 31.571645],\n  &quot;江苏省-无锡市-新吴区&quot;: [120.370396, 31.55485],\n  &quot;江苏省-无锡市-江阴市&quot;: [120.370396, 31.55485],\n  &quot;江苏省-无锡市-宜兴市&quot;: [119.831606, 31.342957],\n  &quot;江苏省-徐州市&quot;: [117.290575, 34.212667],\n  &quot;江苏省-徐州市-鼓楼区&quot;: [117.192579, 34.29376],\n  &quot;江苏省-徐州市-云龙区&quot;: [117.258424, 34.259087],\n  &quot;江苏省-徐州市-贾汪区&quot;: [117.46943, 34.44162],\n  &quot;江苏省-徐州市-泉山区&quot;: [117.20059, 34.249943],\n  &quot;江苏省-徐州市-铜山区&quot;: [117.17557, 34.1861],\n  &quot;江苏省-徐州市-丰县&quot;: [116.602582, 34.69977],\n  &quot;江苏省-徐州市-沛县&quot;: [116.942586, 34.765152],\n  &quot;江苏省-徐州市-睢宁县&quot;: [117.947433, 33.918789],\n  &quot;江苏省-徐州市-新沂市&quot;: [118.361537, 34.375611],\n  &quot;江苏省-徐州市-邳州市&quot;: [117.963411, 34.339753],\n  &quot;江苏省-常州市&quot;: [119.981485, 31.815796],\n  &quot;江苏省-常州市-天宁区&quot;: [119.980463, 31.78557],\n  &quot;江苏省-常州市-钟楼区&quot;: [119.908463, 31.807647],\n  &quot;江苏省-常州市-新北区&quot;: [119.977514, 31.836324],\n  &quot;江苏省-常州市-武进区&quot;: [119.948612, 31.706447],\n  &quot;江苏省-常州市-金坛区&quot;: [119.604571, 31.728893],\n  &quot;江苏省-常州市-溧阳市&quot;: [119.491506, 31.422102],\n  &quot;江苏省-苏州市&quot;: [120.592412, 31.303564],\n  &quot;江苏省-苏州市-虎丘区&quot;: [120.578472, 31.301933],\n  &quot;江苏省-苏州市-吴中区&quot;: [120.638508, 31.268261],\n  &quot;江苏省-苏州市-相城区&quot;: [120.648566, 31.37469],\n  &quot;江苏省-苏州市-姑苏区&quot;: [120.623455, 31.341831],\n  &quot;江苏省-苏州市-吴江区&quot;: [120.651567, 31.144644],\n  &quot;江苏省-苏州市-常熟市&quot;: [120.759496, 31.659538],\n  &quot;江苏省-苏州市-张家港市&quot;: [120.561554, 31.881141],\n  &quot;江苏省-苏州市-昆山市&quot;: [120.987452, 31.390863],\n  &quot;江苏省-苏州市-太仓市&quot;: [121.135595, 31.464599],\n  &quot;江苏省-南通市&quot;: [120.901592, 31.986549],\n  &quot;江苏省-南通市-崇川区&quot;: [120.86342, 32.015923],\n  &quot;江苏省-南通市-港闸区&quot;: [120.824452, 32.037345],\n  &quot;江苏省-南通市-通州区&quot;: [121.081425, 32.070356],\n  &quot;江苏省-南通市-海安县&quot;: [120.474433, 32.539196],\n  &quot;江苏省-南通市-如东县&quot;: [121.192438, 32.335873],\n  &quot;江苏省-南通市-启东市&quot;: [121.663474, 31.814233],\n  &quot;江苏省-南通市-如皋市&quot;: [120.579466, 32.377851],\n  &quot;江苏省-南通市-海门市&quot;: [121.188436, 31.873612],\n  &quot;江苏省-连云港市&quot;: [119.228621, 34.60225],\n  &quot;江苏省-连云港市-连云区&quot;: [119.346588, 34.765337],\n  &quot;江苏省-连云港市-海州区&quot;: [119.169408, 34.577456],\n  &quot;江苏省-连云港市-赣榆区&quot;: [119.179435, 34.847682],\n  &quot;江苏省-连云港市-东海县&quot;: [118.759565, 34.547919],\n  &quot;江苏省-连云港市-灌云县&quot;: [119.246534, 34.288616],\n  &quot;江苏省-连云港市-灌南县&quot;: [119.322538, 34.092591],\n  &quot;江苏省-淮安市&quot;: [119.021484, 33.616295],\n  &quot;江苏省-淮安市-淮安区&quot;: [119.147463, 33.509],\n  &quot;江苏省-淮安市-淮阴区&quot;: [119.041422, 33.63815],\n  &quot;江苏省-淮安市-清江浦区&quot;: [119.032414, 33.558562],\n  &quot;江苏省-淮安市-洪泽区&quot;: [118.879584, 33.299625],\n  &quot;江苏省-淮安市-涟水县&quot;: [119.266448, 33.787079],\n  &quot;江苏省-淮安市-盱眙县&quot;: [118.551441, 33.018255],\n  &quot;江苏省-淮安市-金湖县&quot;: [119.026469, 33.031284],\n  &quot;江苏省-盐城市&quot;: [120.167544, 33.355101],\n  &quot;江苏省-盐城市-亭湖区&quot;: [120.204578, 33.395893],\n  &quot;江苏省-盐城市-盐都区&quot;: [120.160503, 33.34402],\n  &quot;江苏省-盐城市-大丰区&quot;: [120.507439, 33.20476],\n  &quot;江苏省-盐城市-响水县&quot;: [119.584601, 34.204743],\n  &quot;江苏省-盐城市-滨海县&quot;: [119.827621, 33.995647],\n  &quot;江苏省-盐城市-阜宁县&quot;: [119.809581, 33.765079],\n  &quot;江苏省-盐城市-射阳县&quot;: [120.264446, 33.781014],\n  &quot;江苏省-盐城市-建湖县&quot;: [119.805531, 33.469833],\n  &quot;江苏省-盐城市-东台市&quot;: [120.326537, 32.872716],\n  &quot;江苏省-扬州市&quot;: [119.419419, 32.400677],\n  &quot;江苏省-扬州市-广陵区&quot;: [119.438505, 32.400661],\n  &quot;江苏省-扬州市-邗江区&quot;: [119.404385, 32.382751],\n  &quot;江苏省-扬州市-江都区&quot;: [119.576603, 32.440295],\n  &quot;江苏省-扬州市-宝应县&quot;: [119.365556, 33.247205],\n  &quot;江苏省-扬州市-仪征市&quot;: [119.191467, 32.27809],\n  &quot;江苏省-扬州市-高邮市&quot;: [119.465616, 32.787147],\n  &quot;江苏省-镇江市&quot;: [119.430489, 32.194716],\n  &quot;江苏省-镇江市-京口区&quot;: [119.475604, 32.203785],\n  &quot;江苏省-镇江市-润州区&quot;: [119.41844, 32.201495],\n  &quot;江苏省-镇江市-丹徒区&quot;: [119.440501, 32.13792],\n  &quot;江苏省-镇江市-丹阳市&quot;: [119.612501, 32.01592],\n  &quot;江苏省-镇江市-扬中市&quot;: [119.80352, 32.242967],\n  &quot;江苏省-镇江市-句容市&quot;: [119.175433, 31.950923],\n  &quot;江苏省-泰州市&quot;: [119.929566, 32.460675],\n  &quot;江苏省-泰州市-海陵区&quot;: [119.925525, 32.496732],\n  &quot;江苏省-泰州市-高港区&quot;: [119.888421, 32.324862],\n  &quot;江苏省-泰州市-姜堰区&quot;: [120.133398, 32.515234],\n  &quot;江苏省-泰州市-兴化市&quot;: [119.857514, 32.917824],\n  &quot;江苏省-泰州市-靖江市&quot;: [120.283532, 31.98817],\n  &quot;江苏省-泰州市-泰兴市&quot;: [120.058599, 32.177474],\n  &quot;江苏省-宿迁市&quot;: [118.281574, 33.96775],\n  &quot;江苏省-宿迁市-宿城区&quot;: [118.249567, 33.968678],\n  &quot;江苏省-宿迁市-宿豫区&quot;: [118.336401, 33.954804],\n  &quot;江苏省-宿迁市-沭阳县&quot;: [118.810419, 34.117454],\n  &quot;江苏省-宿迁市-泗阳县&quot;: [118.709466, 33.728328],\n  &quot;江苏省-宿迁市-泗洪县&quot;: [118.222416, 33.465733],\n  &quot;浙江省&quot;: [120.159533, 30.271548],\n  &quot;浙江省-杭州市&quot;: [120.215512, 30.253083],\n  &quot;浙江省-杭州市-上城区&quot;: [120.175579, 30.248398],\n  &quot;浙江省-杭州市-下城区&quot;: [120.187607, 30.286744],\n  &quot;浙江省-杭州市-江干区&quot;: [120.211539, 30.263311],\n  &quot;浙江省-杭州市-拱墅区&quot;: [120.148447, 30.324643],\n  &quot;浙江省-杭州市-西湖区&quot;: [120.136438, 30.265916],\n  &quot;浙江省-杭州市-滨江区&quot;: [120.218471, 30.214333],\n  &quot;浙江省-杭州市-萧山区&quot;: [120.218471, 30.214333],\n  &quot;浙江省-杭州市-余杭区&quot;: [120.306592, 30.424739],\n  &quot;浙江省-杭州市-富阳区&quot;: [119.966556, 30.054723],\n  &quot;浙江省-杭州市-桐庐县&quot;: [119.697599, 29.798585],\n  &quot;浙江省-杭州市-淳安县&quot;: [119.048392, 29.61495],\n  &quot;浙江省-杭州市-建德市&quot;: [119.287398, 29.481154],\n  &quot;浙江省-杭州市-临安市&quot;: [119.731517, 30.239806],\n  &quot;浙江省-宁波市&quot;: [121.628572, 29.866033],\n  &quot;浙江省-宁波市-海曙区&quot;: [121.557403, 29.865721],\n  &quot;浙江省-宁波市-江东区&quot;: [121.576533, 29.8733],\n  &quot;浙江省-宁波市-江北区&quot;: [121.560421, 29.892948],\n  &quot;浙江省-宁波市-北仑区&quot;: [121.850576, 29.904659],\n  &quot;浙江省-宁波市-镇海区&quot;: [121.722519, 29.954885],\n  &quot;浙江省-宁波市-鄞州区&quot;: [121.555427, 29.824206],\n  &quot;浙江省-宁波市-象山县&quot;: [121.875564, 29.482271],\n  &quot;浙江省-宁波市-宁海县&quot;: [121.436432, 29.294317],\n  &quot;浙江省-宁波市-余姚市&quot;: [121.160585, 30.042735],\n  &quot;浙江省-宁波市-慈溪市&quot;: [121.272596, 30.175257],\n  &quot;浙江省-宁波市-奉化市&quot;: [121.413528, 29.661146],\n  &quot;浙江省-温州市&quot;: [120.706477, 28.001085],\n  &quot;浙江省-温州市-鹿城区&quot;: [120.661586, 28.020352],\n  &quot;浙江省-温州市-龙湾区&quot;: [120.819468, 27.938652],\n  &quot;浙江省-温州市-瓯海区&quot;: [120.621447, 27.972857],\n  &quot;浙江省-温州市-洞头区&quot;: [121.163549, 27.84187],\n  &quot;浙江省-温州市-永嘉县&quot;: [120.688524, 28.15645],\n  &quot;浙江省-温州市-平阳县&quot;: [120.572515, 27.667724],\n  &quot;浙江省-温州市-苍南县&quot;: [120.433595, 27.523067],\n  &quot;浙江省-温州市-文成县&quot;: [120.097488, 27.793217],\n  &quot;浙江省-温州市-泰顺县&quot;: [119.723537, 27.562171],\n  &quot;浙江省-温州市-瑞安市&quot;: [120.661582, 27.783951],\n  &quot;浙江省-温州市-乐清市&quot;: [120.992502, 28.11818],\n  &quot;浙江省-嘉兴市&quot;: [120.763552, 30.750975],\n  &quot;浙江省-嘉兴市-南湖区&quot;: [120.78961, 30.751547],\n  &quot;浙江省-嘉兴市-秀洲区&quot;: [120.715437, 30.770207],\n  &quot;浙江省-嘉兴市-嘉善县&quot;: [120.932511, 30.837122],\n  &quot;浙江省-嘉兴市-海盐县&quot;: [120.952445, 30.531873],\n  &quot;浙江省-嘉兴市-海宁市&quot;: [120.686565, 30.517924],\n  &quot;浙江省-嘉兴市-平湖市&quot;: [121.022575, 30.682241],\n  &quot;浙江省-嘉兴市-桐乡市&quot;: [120.571543, 30.636311],\n  &quot;浙江省-湖州市&quot;: [120.094517, 30.898964],\n  &quot;浙江省-湖州市-吴兴区&quot;: [120.191605, 30.862955],\n  &quot;浙江省-湖州市-南浔区&quot;: [120.424601, 30.855243],\n  &quot;浙江省-湖州市-德清县&quot;: [119.983465, 30.548628],\n  &quot;浙江省-湖州市-长兴县&quot;: [119.917498, 31.032579],\n  &quot;浙江省-湖州市-安吉县&quot;: [119.686563, 30.644425],\n  &quot;浙江省-绍兴市&quot;: [120.585478, 30.036369],\n  &quot;浙江省-绍兴市-越城区&quot;: [120.588437, 29.99531],\n  &quot;浙江省-绍兴市-柯桥区&quot;: [120.451511, 30.079004],\n  &quot;浙江省-绍兴市-上虞区&quot;: [120.87451, 30.038243],\n  &quot;浙江省-绍兴市-新昌县&quot;: [120.91057, 29.505541],\n  &quot;浙江省-绍兴市-诸暨市&quot;: [120.253408, 29.714935],\n  &quot;浙江省-绍兴市-嵊州市&quot;: [120.837437, 29.567327],\n  &quot;浙江省-金华市&quot;: [119.653436, 29.084639],\n  &quot;浙江省-金华市-婺城区&quot;: [119.578593, 29.091775],\n  &quot;浙江省-金华市-金东区&quot;: [119.699582, 29.104765],\n  &quot;浙江省-金华市-武义县&quot;: [119.822566, 28.898244],\n  &quot;浙江省-金华市-浦江县&quot;: [119.898436, 29.458693],\n  &quot;浙江省-金华市-磐安县&quot;: [120.456513, 29.060103],\n  &quot;浙江省-金华市-兰溪市&quot;: [119.466599, 29.214044],\n  &quot;浙江省-金华市-义乌市&quot;: [120.081581, 29.31115],\n  &quot;浙江省-金华市-东阳市&quot;: [120.248422, 29.295861],\n  &quot;浙江省-金华市-永康市&quot;: [120.054551, 28.894204],\n  &quot;浙江省-衢州市&quot;: [118.866597, 28.975546],\n  &quot;浙江省-衢州市-柯城区&quot;: [118.877584, 28.974204],\n  &quot;浙江省-衢州市-衢江区&quot;: [118.965539, 28.986238],\n  &quot;浙江省-衢州市-常山县&quot;: [118.517557, 28.906998],\n  &quot;浙江省-衢州市-开化县&quot;: [118.421459, 29.143188],\n  &quot;浙江省-衢州市-龙游县&quot;: [119.178418, 29.034487],\n  &quot;浙江省-衢州市-江山市&quot;: [118.633583, 28.742868],\n  &quot;浙江省-舟山市&quot;: [122.213556, 29.990912],\n  &quot;浙江省-舟山市-定海区&quot;: [122.113601, 30.025462],\n  &quot;浙江省-舟山市-普陀区&quot;: [122.331544, 29.976836],\n  &quot;浙江省-舟山市-岱山县&quot;: [122.232605, 30.269656],\n  &quot;浙江省-舟山市-嵊泗县&quot;: [122.457588, 30.731274],\n  &quot;浙江省-台州市&quot;: [121.427435, 28.662194],\n  &quot;浙江省-台州市-椒江区&quot;: [121.449408, 28.679258],\n  &quot;浙江省-台州市-黄岩区&quot;: [121.268566, 28.655334],\n  &quot;浙江省-台州市-路桥区&quot;: [121.371578, 28.586947],\n  &quot;浙江省-台州市-玉环县&quot;: [121.238513, 28.141863],\n  &quot;浙江省-台州市-三门县&quot;: [121.402554, 29.110355],\n  &quot;浙江省-台州市-天台县&quot;: [121.013553, 29.149514],\n  &quot;浙江省-台州市-仙居县&quot;: [120.735435, 28.853226],\n  &quot;浙江省-台州市-温岭市&quot;: [121.392589, 28.377655],\n  &quot;浙江省-台州市-临海市&quot;: [121.151585, 28.864049],\n  &quot;浙江省-丽水市&quot;: [119.929573, 28.473278],\n  &quot;浙江省-丽水市-莲都区&quot;: [119.919519, 28.451745],\n  &quot;浙江省-丽水市-青田县&quot;: [120.296573, 28.145488],\n  &quot;浙江省-丽水市-缙云县&quot;: [120.097478, 28.665215],\n  &quot;浙江省-丽水市-遂昌县&quot;: [119.282435, 28.598455],\n  &quot;浙江省-丽水市-松阳县&quot;: [119.488544, 28.455056],\n  &quot;浙江省-丽水市-云和县&quot;: [119.579597, 28.12147],\n  &quot;浙江省-丽水市-庆元县&quot;: [119.069487, 27.625432],\n  &quot;浙江省-丽水市-景宁畲族自治县&quot;: [119.64243, 27.979554],\n  &quot;浙江省-丽水市-龙泉市&quot;: [119.148445, 28.080509],\n  &quot;安徽省&quot;: [117.33054, 31.734294],\n  &quot;安徽省-合肥市&quot;: [117.233443, 31.826578],\n  &quot;安徽省-合肥市-瑶海区&quot;: [117.315587, 31.863787],\n  &quot;安徽省-合肥市-庐阳区&quot;: [117.271459, 31.884887],\n  &quot;安徽省-合肥市-蜀山区&quot;: [117.266461, 31.857378],\n  &quot;安徽省-合肥市-包河区&quot;: [117.316576, 31.799293],\n  &quot;安徽省-合肥市-长丰县&quot;: [117.17356, 32.483723],\n  &quot;安徽省-合肥市-肥东县&quot;: [117.475401, 31.89389],\n  &quot;安徽省-合肥市-肥西县&quot;: [117.164558, 31.712962],\n  &quot;安徽省-合肥市-庐江县&quot;: [117.293577, 31.261328],\n  &quot;安徽省-合肥市-巢湖市&quot;: [117.895576, 31.629002],\n  &quot;安徽省-芜湖市&quot;: [118.439431, 31.358537],\n  &quot;安徽省-芜湖市-镜湖区&quot;: [118.392606, 31.345867],\n  &quot;安徽省-芜湖市-弋江区&quot;: [118.37958, 31.317566],\n  &quot;安徽省-芜湖市-鸠江区&quot;: [118.397588, 31.375805],\n  &quot;安徽省-芜湖市-三山区&quot;: [118.274602, 31.22528],\n  &quot;安徽省-芜湖市-芜湖县&quot;: [118.582443, 31.141239],\n  &quot;安徽省-芜湖市-繁昌县&quot;: [118.205424, 31.107959],\n  &quot;安徽省-芜湖市-南陵县&quot;: [118.340418, 30.92026],\n  &quot;安徽省-芜湖市-无为县&quot;: [118.071407, 31.340204],\n  &quot;安徽省-蚌埠市&quot;: [117.395513, 32.921524],\n  &quot;安徽省-蚌埠市-龙子湖区&quot;: [117.399513, 32.948644],\n  &quot;安徽省-蚌埠市-蚌山区&quot;: [117.379441, 32.923379],\n  &quot;安徽省-蚌埠市-禹会区&quot;: [117.348452, 32.93531],\n  &quot;安徽省-蚌埠市-淮上区&quot;: [117.366383, 32.970547],\n  &quot;安徽省-蚌埠市-怀远县&quot;: [117.211506, 32.976004],\n  &quot;安徽省-蚌埠市-五河县&quot;: [117.887561, 33.132709],\n  &quot;安徽省-蚌埠市-固镇县&quot;: [117.323548, 33.323274],\n  &quot;安徽省-淮南市&quot;: [117.006389, 32.631847],\n  &quot;安徽省-淮南市-大通区&quot;: [117.059583, 32.63727],\n  &quot;安徽省-淮南市-田家庵区&quot;: [117.023445, 32.653323],\n  &quot;安徽省-淮南市-谢家集区&quot;: [116.865439, 32.606255],\n  &quot;安徽省-淮南市-八公山区&quot;: [116.840564, 32.637137],\n  &quot;安徽省-淮南市-潘集区&quot;: [116.841581, 32.777955],\n  &quot;安徽省-淮南市-凤台县&quot;: [116.717573, 32.715104],\n  &quot;安徽省-淮南市-寿县&quot;: [116.805563, 32.561546],\n  &quot;安徽省-马鞍山市&quot;: [118.51358, 31.676266],\n  &quot;安徽省-马鞍山市-花山区&quot;: [118.499606, 31.725473],\n  &quot;安徽省-马鞍山市-雨山区&quot;: [118.505597, 31.687745],\n  &quot;安徽省-马鞍山市-博望区&quot;: [118.504605, 31.576649],\n  &quot;安徽省-马鞍山市-当涂县&quot;: [118.504605, 31.576649],\n  &quot;安徽省-马鞍山市-含山县&quot;: [118.129204, 31.740485],\n  &quot;安徽省-马鞍山市-和县&quot;: [118.359513, 31.748244],\n  &quot;安徽省-淮北市&quot;: [116.804537, 33.961656],\n  &quot;安徽省-淮北市-杜集区&quot;: [116.834612, 33.997285],\n  &quot;安徽省-淮北市-相山区&quot;: [116.800521, 33.965827],\n  &quot;安徽省-淮北市-烈山区&quot;: [116.819599, 33.901574],\n  &quot;安徽省-淮北市-濉溪县&quot;: [116.772389, 33.921629],\n  &quot;安徽省-铜陵市&quot;: [117.818477, 30.951233],\n  &quot;安徽省-铜陵市-铜官区&quot;: [117.821457, 30.940386],\n  &quot;安徽省-铜陵市-义安区&quot;: [117.798568, 30.958512],\n  &quot;安徽省-铜陵市-郊区&quot;: [117.80755, 30.897741],\n  &quot;安徽省-铜陵市-枞阳县&quot;: [117.226437, 30.705671],\n  &quot;安徽省-安庆市&quot;: [117.063604, 30.530957],\n  &quot;安徽省-安庆市-迎江区&quot;: [117.097514, 30.517523],\n  &quot;安徽省-安庆市-大观区&quot;: [117.040538, 30.518232],\n  &quot;安徽省-安庆市-宜秀区&quot;: [116.993441, 30.619676],\n  &quot;安徽省-安庆市-怀宁县&quot;: [116.836593, 30.7394],\n  &quot;安徽省-安庆市-潜山县&quot;: [116.587611, 30.636756],\n  &quot;安徽省-安庆市-太湖县&quot;: [116.315476, 30.460113],\n  &quot;安徽省-安庆市-宿松县&quot;: [116.135524, 30.159787],\n  &quot;安徽省-安庆市-望江县&quot;: [116.70059, 30.129968],\n  &quot;安徽省-安庆市-岳西县&quot;: [116.366555, 30.855228],\n  &quot;安徽省-安庆市-桐城市&quot;: [116.980466, 31.041969],\n  &quot;安徽省-黄山市&quot;: [118.345437, 29.72189],\n  &quot;安徽省-黄山市-屯溪区&quot;: [118.321418, 29.702144],\n  &quot;安徽省-黄山市-黄山区&quot;: [118.14761, 30.278651],\n  &quot;安徽省-黄山市-徽州区&quot;: [118.343436, 29.834221],\n  &quot;安徽省-黄山市-歙县&quot;: [118.42146, 29.866288],\n  &quot;安徽省-黄山市-休宁县&quot;: [118.20543, 29.795459],\n  &quot;安徽省-黄山市-黟县&quot;: [117.944477, 29.931047],\n  &quot;安徽省-黄山市-祁门县&quot;: [117.723393, 29.860344],\n  &quot;安徽省-滁州市&quot;: [118.339406, 32.261271],\n  &quot;安徽省-滁州市-琅琊区&quot;: [118.312441, 32.300867],\n  &quot;安徽省-滁州市-南谯区&quot;: [118.423482, 32.206132],\n  &quot;安徽省-滁州市-来安县&quot;: [118.442412, 32.45845],\n  &quot;安徽省-滁州市-全椒县&quot;: [118.280584, 32.09194],\n  &quot;安徽省-滁州市-定远县&quot;: [117.704471, 32.537047],\n  &quot;安徽省-滁州市-凤阳县&quot;: [117.538585, 32.880977],\n  &quot;安徽省-滁州市-天长市&quot;: [118.950489, 32.794116],\n  &quot;安徽省-滁州市-明光市&quot;: [117.99551, 32.783023],\n  &quot;安徽省-阜阳市&quot;: [115.820436, 32.896061],\n  &quot;安徽省-阜阳市-颍州区&quot;: [115.813411, 32.889625],\n  &quot;安徽省-阜阳市-颍东区&quot;: [115.863617, 32.917362],\n  &quot;安徽省-阜阳市-颍泉区&quot;: [115.815426, 32.931314],\n  &quot;安徽省-阜阳市-临泉县&quot;: [115.267616, 33.04596],\n  &quot;安徽省-阜阳市-太和县&quot;: [115.628615, 33.16596],\n  &quot;安徽省-阜阳市-阜南县&quot;: [115.602546, 32.664097],\n  &quot;安徽省-阜阳市-颍上县&quot;: [116.263477, 32.659028],\n  &quot;安徽省-阜阳市-界首市&quot;: [115.38061, 33.262775],\n  &quot;安徽省-宿州市&quot;: [116.970544, 33.652095],\n  &quot;安徽省-宿州市-埇桥区&quot;: [116.98348, 33.646131],\n  &quot;安徽省-宿州市-砀山县&quot;: [116.372524, 34.448428],\n  &quot;安徽省-宿州市-萧县&quot;: [116.953585, 34.194269],\n  &quot;安徽省-宿州市-灵璧县&quot;: [117.564557, 33.547892],\n  &quot;安徽省-宿州市-泗县&quot;: [117.91659, 33.488695],\n  &quot;安徽省-六安市&quot;: [116.52641, 31.741451],\n  &quot;安徽省-六安市-金安区&quot;: [116.545438, 31.756288],\n  &quot;安徽省-六安市-裕安区&quot;: [116.48655, 31.743626],\n  &quot;安徽省-六安市-叶集区&quot;: [115.947476, 31.835263],\n  &quot;安徽省-六安市-霍邱县&quot;: [115.947476, 31.835263],\n  &quot;安徽省-六安市-舒城县&quot;: [116.955602, 31.467692],\n  &quot;安徽省-六安市-金寨县&quot;: [115.940441, 31.733462],\n  &quot;安徽省-六安市-霍山县&quot;: [116.339576, 31.398571],\n  &quot;安徽省-亳州市&quot;: [115.784463, 33.850643],\n  &quot;安徽省-亳州市-谯城区&quot;: [115.785472, 33.882663],\n  &quot;安徽省-亳州市-涡阳县&quot;: [116.221609, 33.498567],\n  &quot;安徽省-亳州市-蒙城县&quot;: [116.571589, 33.271658],\n  &quot;安徽省-亳州市-利辛县&quot;: [116.191494, 33.155596],\n  &quot;安徽省-池州市&quot;: [117.498421, 30.670884],\n  &quot;安徽省-池州市-贵池区&quot;: [117.57449, 30.693858],\n  &quot;安徽省-池州市-东至县&quot;: [117.034481, 30.116535],\n  &quot;安徽省-池州市-石台县&quot;: [117.492394, 30.21653],\n  &quot;安徽省-池州市-青阳县&quot;: [117.853431, 30.645634],\n  &quot;安徽省-宣城市&quot;: [118.765534, 30.946602],\n  &quot;安徽省-宣城市-宣州区&quot;: [118.762549, 30.952158],\n  &quot;安徽省-宣城市-郎溪县&quot;: [119.186466, 31.132682],\n  &quot;安徽省-宣城市-广德县&quot;: [119.427476, 30.883667],\n  &quot;安徽省-宣城市-泾县&quot;: [118.426435, 30.694672],\n  &quot;安徽省-宣城市-绩溪县&quot;: [118.585444, 30.073292],\n  &quot;安徽省-宣城市-旌德县&quot;: [118.546467, 30.292481],\n  &quot;安徽省-宣城市-宁国市&quot;: [118.98961, 30.639352],\n  &quot;福建省&quot;: [119.302447, 26.106339],\n  &quot;福建省-福州市&quot;: [119.30347, 26.080429],\n  &quot;福建省-福州市-鼓楼区&quot;: [119.310492, 26.088114],\n  &quot;福建省-福州市-台江区&quot;: [119.320528, 26.058528],\n  &quot;福建省-福州市-仓山区&quot;: [119.280432, 26.052842],\n  &quot;福建省-福州市-马尾区&quot;: [119.445519, 26.004534],\n  &quot;福建省-福州市-晋安区&quot;: [119.334579, 26.087214],\n  &quot;福建省-福州市-闽侯县&quot;: [119.138482, 26.156035],\n  &quot;福建省-福州市-连江县&quot;: [119.546479, 26.203583],\n  &quot;福建省-福州市-罗源县&quot;: [119.55648, 26.495496],\n  &quot;福建省-福州市-闽清县&quot;: [118.869577, 26.226848],\n  &quot;福建省-福州市-永泰县&quot;: [118.938431, 25.872787],\n  &quot;福建省-福州市-平潭县&quot;: [119.796501, 25.5047],\n  &quot;福建省-福州市-福清市&quot;: [119.390465, 25.726343],\n  &quot;福建省-福州市-长乐市&quot;: [119.529438, 25.969257],\n  &quot;福建省-厦门市&quot;: [118.096435, 24.485407],\n  &quot;福建省-厦门市-思明区&quot;: [118.088408, 24.451948],\n  &quot;福建省-厦门市-海沧区&quot;: [118.039562, 24.490326],\n  &quot;福建省-厦门市-湖里区&quot;: [118.153588, 24.517573],\n  &quot;福建省-厦门市-集美区&quot;: [118.103435, 24.582019],\n  &quot;福建省-厦门市-同安区&quot;: [118.158563, 24.729114],\n  &quot;福建省-厦门市-翔安区&quot;: [118.254576, 24.624216],\n  &quot;福建省-莆田市&quot;: [119.014521, 25.459865],\n  &quot;福建省-莆田市-城厢区&quot;: [119.001536, 25.424344],\n  &quot;福建省-莆田市-涵江区&quot;: [119.122567, 25.464464],\n  &quot;福建省-莆田市-荔城区&quot;: [119.019482, 25.439754],\n  &quot;福建省-莆田市-秀屿区&quot;: [119.111571, 25.323654],\n  &quot;福建省-莆田市-仙游县&quot;: [118.698454, 25.368291],\n  &quot;福建省-三明市&quot;: [117.645521, 26.269737],\n  &quot;福建省-三明市-梅列区&quot;: [117.65255, 26.277336],\n  &quot;福建省-三明市-三元区&quot;: [117.614415, 26.240219],\n  &quot;福建省-三明市-明溪县&quot;: [117.208518, 26.361854],\n  &quot;福建省-三明市-清流县&quot;: [116.823593, 26.183357],\n  &quot;福建省-三明市-宁化县&quot;: [116.660426, 26.267956],\n  &quot;福建省-三明市-大田县&quot;: [117.85344, 25.698933],\n  &quot;福建省-三明市-尤溪县&quot;: [118.19744, 26.176218],\n  &quot;福建省-三明市-沙县&quot;: [117.798561, 26.402813],\n  &quot;福建省-三明市-将乐县&quot;: [117.477409, 26.73521],\n  &quot;福建省-三明市-泰宁县&quot;: [117.182596, 26.90566],\n  &quot;福建省-三明市-建宁县&quot;: [116.852506, 26.836825],\n  &quot;福建省-三明市-永安市&quot;: [117.371443, 25.948144],\n  &quot;福建省-泉州市&quot;: [118.682446, 24.879952],\n  &quot;福建省-泉州市-鲤城区&quot;: [118.593481, 24.913354],\n  &quot;福建省-泉州市-丰泽区&quot;: [118.61958, 24.89497],\n  &quot;福建省-泉州市-洛江区&quot;: [118.677416, 24.946214],\n  &quot;福建省-泉州市-泉港区&quot;: [118.922433, 25.13965],\n  &quot;福建省-泉州市-惠安县&quot;: [118.803416, 25.03695],\n  &quot;福建省-泉州市-安溪县&quot;: [118.192425, 25.06176],\n  &quot;福建省-泉州市-永春县&quot;: [118.300486, 25.327974],\n  &quot;福建省-泉州市-德化县&quot;: [118.24755, 25.497309],\n  &quot;福建省-泉州市-金门县&quot;: [118.330415, 24.440445],\n  &quot;福建省-泉州市-石狮市&quot;: [118.654519, 24.737665],\n  &quot;福建省-泉州市-晋江市&quot;: [118.558431, 24.787825],\n  &quot;福建省-泉州市-南安市&quot;: [118.392572, 24.966362],\n  &quot;福建省-漳州市&quot;: [117.653576, 24.51893],\n  &quot;福建省-漳州市-芗城区&quot;: [117.66059, 24.516268],\n  &quot;福建省-漳州市-龙文区&quot;: [117.716455, 24.50951],\n  &quot;福建省-漳州市-云霄县&quot;: [117.346448, 23.964073],\n  &quot;福建省-漳州市-漳浦县&quot;: [117.620443, 24.123462],\n  &quot;福建省-漳州市-诏安县&quot;: [117.182559, 23.717054],\n  &quot;福建省-漳州市-长泰县&quot;: [117.765553, 24.631244],\n  &quot;福建省-漳州市-东山县&quot;: [117.43656, 23.706895],\n  &quot;福建省-漳州市-南靖县&quot;: [117.363446, 24.520852],\n  &quot;福建省-漳州市-平和县&quot;: [117.322552, 24.368365],\n  &quot;福建省-漳州市-华安县&quot;: [117.540586, 25.010068],\n  &quot;福建省-漳州市-龙海市&quot;: [117.824451, 24.45294],\n  &quot;福建省-南平市&quot;: [118.0595, 27.292158],\n  &quot;福建省-南平市-延平区&quot;: [118.188451, 26.643808],\n  &quot;福建省-南平市-建阳区&quot;: [118.127525, 27.337502],\n  &quot;福建省-南平市-顺昌县&quot;: [117.816519, 26.799104],\n  &quot;福建省-南平市-浦城县&quot;: [118.547439, 27.92339],\n  &quot;福建省-南平市-光泽县&quot;: [117.340482, 27.547273],\n  &quot;福建省-南平市-松溪县&quot;: [118.791454, 27.532555],\n  &quot;福建省-南平市-政和县&quot;: [118.863587, 27.371749],\n  &quot;福建省-南平市-邵武市&quot;: [117.49942, 27.34647],\n  &quot;福建省-南平市-武夷山市&quot;: [118.041577, 27.762554],\n  &quot;福建省-南平市-建瓯市&quot;: [118.311461, 27.028955],\n  &quot;福建省-龙岩市&quot;: [117.023448, 25.08122],\n  &quot;福建省-龙岩市-新罗区&quot;: [117.043543, 25.104078],\n  &quot;福建省-龙岩市-永定区&quot;: [116.892447, 24.869137],\n  &quot;福建省-龙岩市-长汀县&quot;: [116.363568, 25.839185],\n  &quot;福建省-龙岩市-上杭县&quot;: [116.426443, 25.05557],\n  &quot;福建省-龙岩市-武平县&quot;: [116.107589, 25.100855],\n  &quot;福建省-龙岩市-连城县&quot;: [116.760446, 25.716337],\n  &quot;福建省-龙岩市-漳平市&quot;: [117.426556, 25.295743],\n  &quot;福建省-宁德市&quot;: [119.554511, 26.672242],\n  &quot;福建省-宁德市-蕉城区&quot;: [119.533442, 26.666739],\n  &quot;福建省-宁德市-霞浦县&quot;: [120.011427, 26.891349],\n  &quot;福建省-宁德市-古田县&quot;: [118.752578, 26.583262],\n  &quot;福建省-宁德市-屏南县&quot;: [118.992596, 26.914265],\n  &quot;福建省-宁德市-寿宁县&quot;: [119.511425, 27.46665],\n  &quot;福建省-宁德市-周宁县&quot;: [119.345567, 27.110239],\n  &quot;福建省-宁德市-柘荣县&quot;: [119.907457, 27.239962],\n  &quot;福建省-宁德市-福安市&quot;: [119.654406, 27.094324],\n  &quot;福建省-宁德市-福鼎市&quot;: [120.223452, 27.330525],\n  &quot;江西省&quot;: [115.915423, 28.681691],\n  &quot;江西省-南昌市&quot;: [115.864589, 28.689455],\n  &quot;江西省-南昌市-东湖区&quot;: [115.905466, 28.691259],\n  &quot;江西省-南昌市-西湖区&quot;: [115.883536, 28.661977],\n  &quot;江西省-南昌市-青云谱区&quot;: [115.931416, 28.627236],\n  &quot;江西省-南昌市-湾里区&quot;: [115.737596, 28.720195],\n  &quot;江西省-南昌市-青山湖区&quot;: [115.968552, 28.687596],\n  &quot;江西省-南昌市-新建区&quot;: [115.821451, 28.698749],\n  &quot;江西省-南昌市-南昌县&quot;: [115.95046, 28.551604],\n  &quot;江西省-南昌市-安义县&quot;: [115.555441, 28.850794],\n  &quot;江西省-南昌市-进贤县&quot;: [116.248538, 28.382759],\n  &quot;江西省-景德镇市&quot;: [117.184576, 29.274248],\n  &quot;江西省-景德镇市-昌江区&quot;: [117.190579, 29.278854],\n  &quot;江西省-景德镇市-珠山区&quot;: [117.209548, 29.305778],\n  &quot;江西省-景德镇市-浮梁县&quot;: [117.221466, 29.357788],\n  &quot;江西省-景德镇市-乐平市&quot;: [117.158511, 28.984364],\n  &quot;江西省-萍乡市&quot;: [113.861496, 27.628393],\n  &quot;江西省-萍乡市-安源区&quot;: [113.87744, 27.621308],\n  &quot;江西省-萍乡市-湘东区&quot;: [113.7405, 27.645875],\n  &quot;江西省-萍乡市-莲花县&quot;: [113.968541, 27.133463],\n  &quot;江西省-萍乡市-上栗县&quot;: [113.801538, 27.886416],\n  &quot;江西省-萍乡市-芦溪县&quot;: [114.036519, 27.636605],\n  &quot;江西省-九江市&quot;: [116.007535, 29.711341],\n  &quot;江西省-九江市-濂溪区&quot;: [115.995599, 29.677495],\n  &quot;江西省-九江市-浔阳区&quot;: [115.996558, 29.733094],\n  &quot;江西省-九江市-九江县&quot;: [115.917402, 29.614805],\n  &quot;江西省-九江市-武宁县&quot;: [115.107442, 29.262352],\n  &quot;江西省-九江市-修水县&quot;: [114.553568, 29.031176],\n  &quot;江西省-九江市-永修县&quot;: [115.815407, 29.028006],\n  &quot;江西省-九江市-德安县&quot;: [115.762578, 29.319172],\n  &quot;江西省-九江市-都昌县&quot;: [116.210552, 29.278965],\n  &quot;江西省-九江市-湖口县&quot;: [116.258471, 29.737132],\n  &quot;江西省-九江市-彭泽县&quot;: [116.55551, 29.902122],\n  &quot;江西省-九江市-瑞昌市&quot;: [115.68743, 29.681951],\n  &quot;江西省-九江市-共青城市&quot;: [115.762578, 29.319172],\n  &quot;江西省-九江市-庐山市&quot;: [116.051426, 29.454539],\n  &quot;江西省-新余市&quot;: [114.923535, 27.823579],\n  &quot;江西省-新余市-渝水区&quot;: [114.951424, 27.80684],\n  &quot;江西省-新余市-分宜县&quot;: [114.698472, 27.820731],\n  &quot;江西省-鹰潭市&quot;: [117.075575, 28.265787],\n  &quot;江西省-鹰潭市-月湖区&quot;: [117.043548, 28.245078],\n  &quot;江西省-鹰潭市-余江县&quot;: [116.824594, 28.215354],\n  &quot;江西省-鹰潭市-贵溪市&quot;: [117.251399, 28.298735],\n  &quot;江西省-赣州市&quot;: [114.940503, 25.835176],\n  &quot;江西省-赣州市-章贡区&quot;: [114.927551, 25.823747],\n  &quot;江西省-赣州市-南康区&quot;: [114.771538, 25.667053],\n  &quot;江西省-赣州市-赣县&quot;: [115.01857, 25.866385],\n  &quot;江西省-赣州市-信丰县&quot;: [114.929521, 25.391975],\n  &quot;江西省-赣州市-大余县&quot;: [114.368407, 25.407637],\n  &quot;江西省-赣州市-上犹县&quot;: [114.558549, 25.790519],\n  &quot;江西省-赣州市-崇义县&quot;: [114.314572, 25.687687],\n  &quot;江西省-赣州市-安远县&quot;: [115.400559, 25.142743],\n  &quot;江西省-赣州市-龙南县&quot;: [114.796554, 24.916599],\n  &quot;江西省-赣州市-定南县&quot;: [115.034564, 24.789784],\n  &quot;江西省-赣州市-全南县&quot;: [114.536582, 24.748206],\n  &quot;江西省-赣州市-宁都县&quot;: [116.015494, 26.47598],\n  &quot;江西省-赣州市-于都县&quot;: [115.421499, 25.957894],\n  &quot;江西省-赣州市-兴国县&quot;: [115.369552, 26.343883],\n  &quot;江西省-赣州市-会昌县&quot;: [115.79246, 25.606662],\n  &quot;江西省-赣州市-寻乌县&quot;: [115.653515, 24.969447],\n  &quot;江西省-赣州市-石城县&quot;: [116.352594, 26.318972],\n  &quot;江西省-赣州市-瑞金市&quot;: [116.033421, 25.891666],\n  &quot;江西省-吉安市&quot;: [115.000511, 27.119727],\n  &quot;江西省-吉安市-吉州区&quot;: [115.001539, 27.149315],\n  &quot;江西省-吉安市-青原区&quot;: [115.021561, 27.087663],\n  &quot;江西省-吉安市-吉安县&quot;: [114.914591, 27.044989],\n  &quot;江西省-吉安市-吉水县&quot;: [115.14257, 27.23526],\n  &quot;江西省-吉安市-峡江县&quot;: [115.322403, 27.588235],\n  &quot;江西省-吉安市-新干县&quot;: [115.393595, 27.746081],\n  &quot;江西省-吉安市-永丰县&quot;: [115.447402, 27.324342],\n  &quot;江西省-吉安市-泰和县&quot;: [114.915591, 26.795697],\n  &quot;江西省-吉安市-遂川县&quot;: [114.527562, 26.319517],\n  &quot;江西省-吉安市-万安县&quot;: [114.792577, 26.464073],\n  &quot;江西省-吉安市-安福县&quot;: [114.626478, 27.399076],\n  &quot;江西省-吉安市-永新县&quot;: [114.249415, 26.951537],\n  &quot;江西省-吉安市-井冈山市&quot;: [114.295556, 26.75371],\n  &quot;江西省-宜春市&quot;: [114.423564, 27.820856],\n  &quot;江西省-宜春市-袁州区&quot;: [114.434561, 27.802583],\n  &quot;江西省-宜春市-奉新县&quot;: [115.406551, 28.694029],\n  &quot;江西省-宜春市-万载县&quot;: [114.452537, 28.112133],\n  &quot;江西省-宜春市-上高县&quot;: [114.931541, 28.238815],\n  &quot;江西省-宜春市-宜丰县&quot;: [114.700858, 28.400373],\n  &quot;江西省-宜春市-靖安县&quot;: [115.369553, 28.867082],\n  &quot;江西省-宜春市-铜鼓县&quot;: [114.377411, 28.527083],\n  &quot;江西省-宜春市-丰城市&quot;: [115.777478, 28.166614],\n  &quot;江西省-宜春市-樟树市&quot;: [115.552419, 28.062153],\n  &quot;江西省-宜春市-高安市&quot;: [115.382565, 28.422857],\n  &quot;江西省-抚州市&quot;: [116.364539, 27.954892],\n  &quot;江西省-抚州市-临川区&quot;: [116.31849, 27.940459],\n  &quot;江西省-抚州市-南城县&quot;: [116.643399, 27.576241],\n  &quot;江西省-抚州市-黎川县&quot;: [116.914507, 27.28834],\n  &quot;江西省-抚州市-南丰县&quot;: [116.531404, 27.224734],\n  &quot;江西省-抚州市-崇仁县&quot;: [116.083549, 27.75908],\n  &quot;江西省-抚州市-乐安县&quot;: [115.837496, 27.43408],\n  &quot;江西省-抚州市-宜黄县&quot;: [116.242542, 27.560563],\n  &quot;江西省-抚州市-金溪县&quot;: [116.760404, 27.925329],\n  &quot;江西省-抚州市-资溪县&quot;: [117.06657, 27.711846],\n  &quot;江西省-抚州市-东乡县&quot;: [116.609542, 28.253977],\n  &quot;江西省-抚州市-广昌县&quot;: [116.342561, 26.848454],\n  &quot;江西省-上饶市&quot;: [117.94946, 28.460626],\n  &quot;江西省-上饶市-信州区&quot;: [117.973412, 28.437628],\n  &quot;江西省-上饶市-广丰区&quot;: [118.19742, 28.442615],\n  &quot;江西省-上饶市-上饶县&quot;: [117.915584, 28.454187],\n  &quot;江西省-上饶市-玉山县&quot;: [118.251563, 28.68775],\n  &quot;江西省-上饶市-铅山县&quot;: [117.716422, 28.321505],\n  &quot;江西省-上饶市-横峰县&quot;: [117.602397, 28.41344],\n  &quot;江西省-上饶市-弋阳县&quot;: [117.455506, 28.384082],\n  &quot;江西省-上饶市-余干县&quot;: [116.701601, 28.707866],\n  &quot;江西省-上饶市-鄱阳县&quot;: [116.710566, 29.011453],\n  &quot;江西省-上饶市-万年县&quot;: [117.064599, 28.700054],\n  &quot;江西省-上饶市-婺源县&quot;: [117.868445, 29.254039],\n  &quot;江西省-上饶市-德兴市&quot;: [117.58548, 28.952565],\n  &quot;山东省&quot;: [117.027442, 36.674857],\n  &quot;山东省-济南市&quot;: [117.126399, 36.656554],\n  &quot;山东省-济南市-历下区&quot;: [117.082567, 36.672163],\n  &quot;山东省-济南市-市中区&quot;: [117.004399, 36.657552],\n  &quot;山东省-济南市-槐荫区&quot;: [116.907458, 36.657562],\n  &quot;山东省-济南市-天桥区&quot;: [116.993399, 36.684068],\n  &quot;山东省-济南市-历城区&quot;: [117.07159, 36.685656],\n  &quot;山东省-济南市-长清区&quot;: [116.758387, 36.560216],\n  &quot;山东省-济南市-平阴县&quot;: [116.462617, 36.294861],\n  &quot;山东省-济南市-济阳县&quot;: [117.180621, 36.983971],\n  &quot;山东省-济南市-商河县&quot;: [117.16353, 37.314971],\n  &quot;山东省-济南市-章丘市&quot;: [117.532565, 36.685533],\n  &quot;山东省-青岛市&quot;: [120.389455, 36.072227],\n  &quot;山东省-青岛市-市南区&quot;: [120.418585, 36.081466],\n  &quot;山东省-青岛市-市北区&quot;: [120.381404, 36.09345],\n  &quot;山东省-青岛市-黄岛区&quot;: [120.204547, 35.966383],\n  &quot;山东省-青岛市-崂山区&quot;: [120.475397, 36.113499],\n  &quot;山东省-青岛市-李沧区&quot;: [120.439603, 36.151025],\n  &quot;山东省-青岛市-城阳区&quot;: [120.402527, 36.312886],\n  &quot;山东省-青岛市-胶州市&quot;: [120.039535, 36.270349],\n  &quot;山东省-青岛市-即墨市&quot;: [120.453536, 36.394749],\n  &quot;山东省-青岛市-平度市&quot;: [119.994414, 36.782692],\n  &quot;山东省-青岛市-莱西市&quot;: [120.524556, 36.893956],\n  &quot;山东省-淄博市&quot;: [118.061453, 36.819086],\n  &quot;山东省-淄博市-淄川区&quot;: [117.973412, 36.649835],\n  &quot;山东省-淄博市-张店区&quot;: [118.024591, 36.811942],\n  &quot;山东省-淄博市-博山区&quot;: [117.868469, 36.500848],\n  &quot;山东省-淄博市-临淄区&quot;: [118.315395, 36.832294],\n  &quot;山东省-淄博市-周村区&quot;: [117.876482, 36.808994],\n  &quot;山东省-淄博市-桓台县&quot;: [118.104434, 36.965608],\n  &quot;山东省-淄博市-高青县&quot;: [117.833394, 37.177269],\n  &quot;山东省-淄博市-沂源县&quot;: [118.177489, 36.190917],\n  &quot;山东省-枣庄市&quot;: [117.330542, 34.815994],\n  &quot;山东省-枣庄市-市中区&quot;: [117.562566, 34.869963],\n  &quot;山东省-枣庄市-薛城区&quot;: [117.269458, 34.801125],\n  &quot;山东省-枣庄市-峄城区&quot;: [117.596391, 34.7786],\n  &quot;山东省-枣庄市-台儿庄区&quot;: [117.740425, 34.568763],\n  &quot;山东省-枣庄市-山亭区&quot;: [117.467443, 35.105692],\n  &quot;山东省-枣庄市-滕州市&quot;: [117.172565, 35.120035],\n  &quot;山东省-东营市&quot;: [118.681385, 37.439642],\n  &quot;山东省-东营市-东营区&quot;: [118.588463, 37.454847],\n  &quot;山东省-东营市-河口区&quot;: [118.532505, 37.89112],\n  &quot;山东省-东营市-垦利区&quot;: [118.581432, 37.578555],\n  &quot;山东省-东营市-利津县&quot;: [118.261618, 37.49586],\n  &quot;山东省-东营市-广饶县&quot;: [118.413499, 37.059638],\n  &quot;山东省-烟台市&quot;: [121.454415, 37.470038],\n  &quot;山东省-烟台市-芝罘区&quot;: [121.40654, 37.546313],\n  &quot;山东省-烟台市-福山区&quot;: [121.274605, 37.503668],\n  &quot;山东省-烟台市-牟平区&quot;: [121.606549, 37.392915],\n  &quot;山东省-烟台市-莱山区&quot;: [121.451381, 37.517649],\n  &quot;山东省-烟台市-长岛县&quot;: [120.74343, 37.927628],\n  &quot;山东省-烟台市-龙口市&quot;: [120.485369, 37.652555],\n  &quot;山东省-烟台市-莱阳市&quot;: [120.718414, 36.984636],\n  &quot;山东省-烟台市-莱州市&quot;: [119.948593, 37.182637],\n  &quot;山东省-烟台市-蓬莱市&quot;: [120.765562, 37.816439],\n  &quot;山东省-烟台市-招远市&quot;: [120.440602, 37.361137],\n  &quot;山东省-烟台市-栖霞市&quot;: [120.856417, 37.341418],\n  &quot;山东省-烟台市-海阳市&quot;: [121.180458, 36.69327],\n  &quot;山东省-潍坊市&quot;: [119.168378, 36.712652],\n  &quot;山东省-潍坊市-潍城区&quot;: [119.031429, 36.732854],\n  &quot;山东省-潍坊市-寒亭区&quot;: [119.226615, 36.780744],\n  &quot;山东省-潍坊市-坊子区&quot;: [119.172401, 36.660742],\n  &quot;山东省-潍坊市-奎文区&quot;: [119.139471, 36.712752],\n  &quot;山东省-潍坊市-临朐县&quot;: [118.54945, 36.51913],\n  &quot;山东省-潍坊市-昌乐县&quot;: [118.836488, 36.712996],\n  &quot;山东省-潍坊市-青州市&quot;: [118.486537, 36.690417],\n  &quot;山东省-潍坊市-诸城市&quot;: [119.416402, 36.002009],\n  &quot;山东省-潍坊市-寿光市&quot;: [118.797415, 36.861922],\n  &quot;山东省-潍坊市-安丘市&quot;: [119.225608, 36.483842],\n  &quot;山东省-潍坊市-高密市&quot;: [119.762411, 36.388957],\n  &quot;山东省-潍坊市-昌邑市&quot;: [119.404406, 36.865161],\n  &quot;山东省-济宁市&quot;: [116.593612, 35.420177],\n  &quot;山东省-济宁市-任城区&quot;: [116.55447, 35.493731],\n  &quot;山东省-济宁市-兖州区&quot;: [116.805536, 35.599737],\n  &quot;山东省-济宁市-微山县&quot;: [117.135414, 34.813315],\n  &quot;山东省-济宁市-鱼台县&quot;: [116.657393, 35.017888],\n  &quot;山东省-济宁市-金乡县&quot;: [116.31853, 35.072569],\n  &quot;山东省-济宁市-嘉祥县&quot;: [116.348613, 35.413255],\n  &quot;山东省-济宁市-汶上县&quot;: [116.505441, 35.717055],\n  &quot;山东省-济宁市-泗水县&quot;: [117.257429, 35.6706],\n  &quot;山东省-济宁市-梁山县&quot;: [116.10262, 35.808064],\n  &quot;山东省-济宁市-曲阜市&quot;: [116.993416, 35.587372],\n  &quot;山东省-济宁市-邹城市&quot;: [117.014404, 35.407521],\n  &quot;山东省-泰安市&quot;: [117.094495, 36.205858],\n  &quot;山东省-泰安市-泰山区&quot;: [117.141411, 36.199445],\n  &quot;山东省-泰安市-岱岳区&quot;: [117.048556, 36.193291],\n  &quot;山东省-泰安市-宁阳县&quot;: [116.812579, 35.764539],\n  &quot;山东省-泰安市-东平县&quot;: [116.477594, 35.941908],\n  &quot;山东省-泰安市-新泰市&quot;: [117.774606, 35.91462],\n  &quot;山东省-泰安市-肥城市&quot;: [116.775401, 36.188811],\n  &quot;山东省-威海市&quot;: [122.127541, 37.516431],\n  &quot;山东省-威海市-环翠区&quot;: [122.129538, 37.507968],\n  &quot;山东省-威海市-文登区&quot;: [122.064428, 37.200113],\n  &quot;山东省-威海市-荣成市&quot;: [122.492505, 37.171318],\n  &quot;山东省-威海市-乳山市&quot;: [121.546429, 36.925177],\n  &quot;山东省-日照市&quot;: [119.533415, 35.422839],\n  &quot;山东省-日照市-东港区&quot;: [119.468624, 35.431049],\n  &quot;山东省-日照市-岚山区&quot;: [119.32553, 35.127432],\n  &quot;山东省-日照市-五莲县&quot;: [119.21558, 35.755697],\n  &quot;山东省-日照市-莒县&quot;: [118.843538, 35.585872],\n  &quot;山东省-莱芜市&quot;: [117.68355, 36.219472],\n  &quot;山东省-莱芜市-莱城区&quot;: [117.666591, 36.208841],\n  &quot;山东省-莱芜市-钢城区&quot;: [117.817496, 36.064719],\n  &quot;山东省-临沂市&quot;: [118.363533, 35.110671],\n  &quot;山东省-临沂市-兰山区&quot;: [118.3545, 35.05734],\n  &quot;山东省-临沂市-罗庄区&quot;: [118.291513, 35.002504],\n  &quot;山东省-临沂市-河东区&quot;: [118.409547, 35.095676],\n  &quot;山东省-临沂市-沂南县&quot;: [118.471492, 35.556098],\n  &quot;山东省-临沂市-郯城县&quot;: [118.373587, 34.619226],\n  &quot;山东省-临沂市-沂水县&quot;: [118.634617, 35.796181],\n  &quot;山东省-临沂市-兰陵县&quot;: [118.077409, 34.863616],\n  &quot;山东省-临沂市-费县&quot;: [117.984425, 35.272304],\n  &quot;山东省-临沂市-平邑县&quot;: [117.646541, 35.51202],\n  &quot;山东省-临沂市-莒南县&quot;: [118.841541, 35.180812],\n  &quot;山东省-临沂市-蒙阴县&quot;: [117.951415, 35.716347],\n  &quot;山东省-临沂市-临沭县&quot;: [118.657495, 34.926019],\n  &quot;山东省-德州市&quot;: [116.365557, 37.441308],\n  &quot;山东省-德州市-德城区&quot;: [116.305449, 37.456993],\n  &quot;山东省-德州市-陵城区&quot;: [116.77141, 37.476844],\n  &quot;山东省-德州市-宁津县&quot;: [116.806538, 37.658019],\n  &quot;山东省-德州市-庆云县&quot;: [117.391452, 37.781585],\n  &quot;山东省-德州市-临邑县&quot;: [116.873404, 37.196169],\n  &quot;山东省-德州市-齐河县&quot;: [116.769387, 36.789945],\n  &quot;山东省-德州市-平原县&quot;: [116.440505, 37.171221],\n  &quot;山东省-德州市-夏津县&quot;: [116.008534, 36.954155],\n  &quot;山东省-德州市-武城县&quot;: [116.075506, 37.219222],\n  &quot;山东省-德州市-乐陵市&quot;: [117.238406, 37.735925],\n  &quot;山东省-德州市-禹城市&quot;: [116.644371, 36.940242],\n  &quot;山东省-聊城市&quot;: [115.991588, 36.462758],\n  &quot;山东省-聊城市-东昌府区&quot;: [115.994587, 36.440378],\n  &quot;山东省-聊城市-阳谷县&quot;: [115.798396, 36.120816],\n  &quot;山东省-聊城市-莘县&quot;: [115.677397, 36.239907],\n  &quot;山东省-聊城市-茌平县&quot;: [116.261455, 36.586785],\n  &quot;山东省-聊城市-东阿县&quot;: [116.254493, 36.340958],\n  &quot;山东省-聊城市-冠县&quot;: [115.449396, 36.490243],\n  &quot;山东省-聊城市-高唐县&quot;: [116.235604, 36.851591],\n  &quot;山东省-聊城市-临清市&quot;: [115.71147, 36.844289],\n  &quot;山东省-滨州市&quot;: [117.977404, 37.388196],\n  &quot;山东省-滨州市-滨城区&quot;: [118.026604, 37.436843],\n  &quot;山东省-滨州市-沾化区&quot;: [118.105454, 37.705298],\n  &quot;山东省-滨州市-惠民县&quot;: [117.51651, 37.495803],\n  &quot;山东省-滨州市-阳信县&quot;: [117.584437, 37.647338],\n  &quot;山东省-滨州市-无棣县&quot;: [117.632457, 37.777567],\n  &quot;山东省-滨州市-博兴县&quot;: [118.117493, 37.160477],\n  &quot;山东省-滨州市-邹平县&quot;: [117.749478, 36.870032],\n  &quot;山东省-菏泽市&quot;: [115.487545, 35.239407],\n  &quot;山东省-菏泽市-牡丹区&quot;: [115.423443, 35.257018],\n  &quot;山东省-菏泽市-定陶区&quot;: [115.579437, 35.077275],\n  &quot;山东省-菏泽市-曹县&quot;: [115.548457, 34.831809],\n  &quot;山东省-菏泽市-单县&quot;: [116.111584, 34.784658],\n  &quot;山东省-菏泽市-成武县&quot;: [115.896519, 34.958606],\n  &quot;山东省-菏泽市-巨野县&quot;: [116.210258, 35.402062],\n  &quot;山东省-菏泽市-郓城县&quot;: [115.950451, 35.605902],\n  &quot;山东省-菏泽市-鄄城县&quot;: [115.516607, 35.569204],\n  &quot;山东省-菏泽市-东明县&quot;: [115.096417, 35.295702],\n  &quot;河南省&quot;: [113.759384, 34.771713],\n  &quot;河南省-郑州市&quot;: [113.631419, 34.753439],\n  &quot;河南省-郑州市-中原区&quot;: [113.619476, 34.754451],\n  &quot;河南省-郑州市-二七区&quot;: [113.64641, 34.731045],\n  &quot;河南省-郑州市-管城回族区&quot;: [113.683525, 34.759674],\n  &quot;河南省-郑州市-金水区&quot;: [113.666448, 34.80607],\n  &quot;河南省-郑州市-上街区&quot;: [113.315497, 34.808819],\n  &quot;河南省-郑州市-惠济区&quot;: [113.623455, 34.87352],\n  &quot;河南省-郑州市-中牟县&quot;: [113.982485, 34.725011],\n  &quot;河南省-郑州市-巩义市&quot;: [113.028431, 34.754097],\n  &quot;河南省-郑州市-荥阳市&quot;: [113.389423, 34.793811],\n  &quot;河南省-郑州市-新密市&quot;: [113.397391, 34.545898],\n  &quot;河南省-郑州市-新郑市&quot;: [113.746434, 34.401766],\n  &quot;河南省-郑州市-登封市&quot;: [113.056423, 34.459697],\n  &quot;河南省-开封市&quot;: [114.314593, 34.802886],\n  &quot;河南省-开封市-龙亭区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-顺河回族区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-鼓楼区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-禹王台区&quot;: [114.361413, 34.822036],\n  &quot;河南省-开封市-金明区&quot;: [114.229635, 34.798756],\n  &quot;河南省-开封市-祥符区&quot;: [114.452186, 34.726004],\n  &quot;河南省-开封市-杞县&quot;: [114.789592, 34.554857],\n  &quot;河南省-开封市-通许县&quot;: [114.473436, 34.486772],\n  &quot;河南省-开封市-尉氏县&quot;: [114.199561, 34.417228],\n  &quot;河南省-开封市-兰考县&quot;: [114.827461, 34.828493],\n  &quot;河南省-洛阳市&quot;: [112.459421, 34.624263],\n  &quot;河南省-洛阳市-老城区&quot;: [112.476504, 34.689601],\n  &quot;河南省-洛阳市-西工区&quot;: [112.4344, 34.666768],\n  &quot;河南省-洛阳市-瀍河回族区&quot;: [112.506604, 34.685462],\n  &quot;河南省-洛阳市-涧西区&quot;: [112.402552, 34.663469],\n  &quot;河南省-洛阳市-吉利区&quot;: [112.595478, 34.907013],\n  &quot;河南省-洛阳市-洛龙区&quot;: [112.470469, 34.624705],\n  &quot;河南省-洛阳市-孟津县&quot;: [112.451418, 34.831732],\n  &quot;河南省-洛阳市-新安县&quot;: [112.14061, 34.734383],\n  &quot;河南省-洛阳市-栾川县&quot;: [111.622427, 33.791822],\n  &quot;河南省-洛阳市-嵩县&quot;: [112.092408, 34.140722],\n  &quot;河南省-洛阳市-汝阳县&quot;: [112.479503, 34.159843],\n  &quot;河南省-洛阳市-宜阳县&quot;: [112.179465, 34.541047],\n  &quot;河南省-洛阳市-洛宁县&quot;: [111.659587, 34.394985],\n  &quot;河南省-洛阳市-伊川县&quot;: [112.432407, 34.427646],\n  &quot;河南省-洛阳市-偃师市&quot;: [112.796421, 34.733797],\n  &quot;河南省-平顶山市&quot;: [113.199529, 33.772051],\n  &quot;河南省-平顶山市-新华区&quot;: [113.30044, 33.743657],\n  &quot;河南省-平顶山市-卫东区&quot;: [113.341611, 33.740376],\n  &quot;河南省-平顶山市-石龙区&quot;: [112.905455, 33.904754],\n  &quot;河南省-平顶山市-湛河区&quot;: [113.250515, 33.68579],\n  &quot;河南省-平顶山市-宝丰县&quot;: [113.061447, 33.874746],\n  &quot;河南省-平顶山市-叶县&quot;: [113.363582, 33.632492],\n  &quot;河南省-平顶山市-鲁山县&quot;: [112.914434, 33.744879],\n  &quot;河南省-平顶山市-郏县&quot;: [113.219606, 33.977486],\n  &quot;河南省-平顶山市-舞钢市&quot;: [113.53141, 33.299431],\n  &quot;河南省-平顶山市-汝州市&quot;: [112.85055, 34.172768],\n  &quot;河南省-安阳市&quot;: [114.3995, 36.105941],\n  &quot;河南省-安阳市-文峰区&quot;: [114.363374, 36.096833],\n  &quot;河南省-安阳市-北关区&quot;: [114.362382, 36.113132],\n  &quot;河南省-安阳市-殷都区&quot;: [114.309598, 36.115758],\n  &quot;河南省-安阳市-龙安区&quot;: [114.307593, 36.082753],\n  &quot;河南省-安阳市-安阳县&quot;: [114.238382, 36.218907],\n  &quot;河南省-安阳市-汤阴县&quot;: [114.363409, 35.927644],\n  &quot;河南省-安阳市-滑县&quot;: [114.525553, 35.581045],\n  &quot;河南省-安阳市-内黄县&quot;: [114.907589, 35.97695],\n  &quot;河南省-安阳市-林州市&quot;: [113.82559, 36.088853],\n  &quot;河南省-鹤壁市&quot;: [114.303594, 35.752357],\n  &quot;河南省-鹤壁市-鹤山区&quot;: [114.169555, 35.96028],\n  &quot;河南省-鹤壁市-山城区&quot;: [114.190621, 35.90337],\n  &quot;河南省-鹤壁市-淇滨区&quot;: [114.305591, 35.746953],\n  &quot;河南省-鹤壁市-浚县&quot;: [114.557608, 35.681917],\n  &quot;河南省-鹤壁市-淇县&quot;: [114.21549, 35.627277],\n  &quot;河南省-新乡市&quot;: [113.9336, 35.30964],\n  &quot;河南省-新乡市-红旗区&quot;: [113.881416, 35.310136],\n  &quot;河南省-新乡市-卫滨区&quot;: [113.872439, 35.308459],\n  &quot;河南省-新乡市-凤泉区&quot;: [113.912459, 35.375665],\n  &quot;河南省-新乡市-牧野区&quot;: [113.915513, 35.321023],\n  &quot;河南省-新乡市-新乡县&quot;: [113.811594, 35.196564],\n  &quot;河南省-新乡市-获嘉县&quot;: [113.663417, 35.265809],\n  &quot;河南省-新乡市-原阳县&quot;: [113.946624, 35.071164],\n  &quot;河南省-新乡市-延津县&quot;: [114.211512, 35.147807],\n  &quot;河南省-新乡市-封丘县&quot;: [114.425606, 35.046858],\n  &quot;河南省-新乡市-长垣县&quot;: [114.67561, 35.207198],\n  &quot;河南省-新乡市-卫辉市&quot;: [114.071601, 35.404069],\n  &quot;河南省-新乡市-辉县市&quot;: [113.811573, 35.467958],\n  &quot;河南省-焦作市&quot;: [113.248548, 35.220963],\n  &quot;河南省-焦作市-解放区&quot;: [113.237572, 35.24631],\n  &quot;河南省-焦作市-中站区&quot;: [113.189448, 35.242617],\n  &quot;河南省-焦作市-马村区&quot;: [113.328544, 35.261894],\n  &quot;河南省-焦作市-山阳区&quot;: [113.260484, 35.220272],\n  &quot;河南省-焦作市-修武县&quot;: [113.454582, 35.229323],\n  &quot;河南省-焦作市-博爱县&quot;: [113.070478, 35.177308],\n  &quot;河南省-焦作市-武陟县&quot;: [113.408396, 35.105838],\n  &quot;河南省-焦作市-温县&quot;: [113.086569, 34.946135],\n  &quot;河南省-焦作市-沁阳市&quot;: [112.957517, 35.093786],\n  &quot;河南省-焦作市-孟州市&quot;: [112.797395, 34.913598],\n  &quot;河南省-濮阳市&quot;: [115.035597, 35.767593],\n  &quot;河南省-濮阳市-华龙区&quot;: [115.080413, 35.783633],\n  &quot;河南省-濮阳市-清丰县&quot;: [115.110472, 35.891308],\n  &quot;河南省-濮阳市-南乐县&quot;: [115.211386, 36.076031],\n  &quot;河南省-濮阳市-范县&quot;: [115.510586, 35.857655],\n  &quot;河南省-濮阳市-台前县&quot;: [115.878568, 35.975013],\n  &quot;河南省-濮阳市-濮阳县&quot;: [115.035584, 35.717889],\n  &quot;河南省-许昌市&quot;: [113.858476, 34.041432],\n  &quot;河南省-许昌市-魏都区&quot;: [113.829596, 34.030861],\n  &quot;河南省-许昌市-许昌县&quot;: [113.829615, 34.129967],\n  &quot;河南省-许昌市-鄢陵县&quot;: [114.18562, 34.107963],\n  &quot;河南省-许昌市-襄城县&quot;: [113.513431, 33.856968],\n  &quot;河南省-许昌市-禹州市&quot;: [113.495505, 34.146082],\n  &quot;河南省-许昌市-长葛市&quot;: [113.774421, 34.223016],\n  &quot;河南省-漯河市&quot;: [114.023421, 33.587711],\n  &quot;河南省-漯河市-源汇区&quot;: [113.990414, 33.578423],\n  &quot;河南省-漯河市-郾城区&quot;: [114.013394, 33.593416],\n  &quot;河南省-漯河市-召陵区&quot;: [114.100467, 33.592468],\n  &quot;河南省-漯河市-舞阳县&quot;: [113.61549, 33.443578],\n  &quot;河南省-漯河市-临颍县&quot;: [113.937578, 33.832692],\n  &quot;河南省-三门峡市&quot;: [111.206533, 34.778327],\n  &quot;河南省-三门峡市-湖滨区&quot;: [111.195574, 34.775997],\n  &quot;河南省-三门峡市-陕州区&quot;: [111.109451, 34.726915],\n  &quot;河南省-三门峡市-渑池县&quot;: [111.768542, 34.773197],\n  &quot;河南省-三门峡市-卢氏县&quot;: [111.054564, 34.059925],\n  &quot;河南省-三门峡市-义马市&quot;: [111.880515, 34.753028],\n  &quot;河南省-三门峡市-灵宝市&quot;: [110.900408, 34.523143],\n  &quot;河南省-南阳市&quot;: [112.534501, 32.996562],\n  &quot;河南省-南阳市-宛城区&quot;: [112.546454, 33.00987],\n  &quot;河南省-南阳市-卧龙区&quot;: [112.541462, 32.992484],\n  &quot;河南省-南阳市-南召县&quot;: [112.435425, 33.496186],\n  &quot;河南省-南阳市-方城县&quot;: [113.018503, 33.260539],\n  &quot;河南省-南阳市-西峡县&quot;: [111.480398, 33.313316],\n  &quot;河南省-南阳市-镇平县&quot;: [112.241544, 33.039719],\n  &quot;河南省-南阳市-内乡县&quot;: [111.855425, 33.051203],\n  &quot;河南省-南阳市-淅川县&quot;: [111.497432, 33.144185],\n  &quot;河南省-南阳市-社旗县&quot;: [112.954493, 33.062237],\n  &quot;河南省-南阳市-唐河县&quot;: [112.813424, 32.687721],\n  &quot;河南省-南阳市-新野县&quot;: [112.36655, 32.526632],\n  &quot;河南省-南阳市-桐柏县&quot;: [113.434473, 32.385131],\n  &quot;河南省-南阳市-邓州市&quot;: [112.09342, 32.693917],\n  &quot;河南省-商丘市&quot;: [115.662449, 34.420202],\n  &quot;河南省-商丘市-梁园区&quot;: [115.620602, 34.449471],\n  &quot;河南省-商丘市-睢阳区&quot;: [115.659476, 34.394152],\n  &quot;河南省-商丘市-民权县&quot;: [115.154576, 34.652479],\n  &quot;河南省-商丘市-睢县&quot;: [115.078411, 34.451617],\n  &quot;河南省-商丘市-宁陵县&quot;: [115.320418, 34.466634],\n  &quot;河南省-商丘市-柘城县&quot;: [115.312435, 34.09736],\n  &quot;河南省-商丘市-虞城县&quot;: [115.834473, 34.405332],\n  &quot;河南省-商丘市-夏邑县&quot;: [116.137512, 34.243523],\n  &quot;河南省-商丘市-永城市&quot;: [116.455566, 33.934801],\n  &quot;河南省-信阳市&quot;: [114.097483, 32.153015],\n  &quot;河南省-信阳市-浉河区&quot;: [114.065581, 32.122554],\n  &quot;河南省-信阳市-平桥区&quot;: [114.132407, 32.107325],\n  &quot;河南省-信阳市-罗山县&quot;: [114.51953, 32.20915],\n  &quot;河南省-信阳市-光山县&quot;: [114.925533, 32.015907],\n  &quot;河南省-信阳市-新县&quot;: [114.885525, 31.649738],\n  &quot;河南省-信阳市-商城县&quot;: [115.413513, 31.804345],\n  &quot;河南省-信阳市-固始县&quot;: [115.660488, 32.174174],\n  &quot;河南省-信阳市-潢川县&quot;: [115.058471, 32.137531],\n  &quot;河南省-信阳市-淮滨县&quot;: [115.426439, 32.47947],\n  &quot;河南省-信阳市-息县&quot;: [114.747453, 32.348956],\n  &quot;河南省-周口市&quot;: [114.703483, 33.631829],\n  &quot;河南省-周口市-川汇区&quot;: [114.657602, 33.652997],\n  &quot;河南省-周口市-扶沟县&quot;: [114.40151, 34.065906],\n  &quot;河南省-周口市-西华县&quot;: [114.535597, 33.773215],\n  &quot;河南省-周口市-商水县&quot;: [114.618416, 33.548877],\n  &quot;河南省-周口市-沈丘县&quot;: [115.105455, 33.415691],\n  &quot;河南省-周口市-郸城县&quot;: [115.183478, 33.650828],\n  &quot;河南省-周口市-淮阳县&quot;: [114.892586, 33.737347],\n  &quot;河南省-周口市-太康县&quot;: [114.844384, 34.070038],\n  &quot;河南省-周口市-鹿邑县&quot;: [115.490585, 33.867173],\n  &quot;河南省-周口市-项城市&quot;: [114.881514, 33.473007],\n  &quot;河南省-驻马店市&quot;: [114.028471, 33.017842],\n  &quot;河南省-驻马店市-驿城区&quot;: [114.000387, 32.97952],\n  &quot;河南省-驻马店市-西平县&quot;: [114.027474, 33.393861],\n  &quot;河南省-驻马店市-上蔡县&quot;: [114.270487, 33.268511],\n  &quot;河南省-驻马店市-平舆县&quot;: [114.625429, 32.967982],\n  &quot;河南省-驻马店市-正阳县&quot;: [114.399497, 32.611641],\n  &quot;河南省-驻马店市-确山县&quot;: [114.032495, 32.808176],\n  &quot;河南省-驻马店市-泌阳县&quot;: [113.333558, 32.729731],\n  &quot;河南省-驻马店市-汝南县&quot;: [114.369409, 33.013141],\n  &quot;河南省-驻马店市-遂平县&quot;: [114.019441, 33.151971],\n  &quot;河南省-驻马店市-新蔡县&quot;: [114.992469, 32.755269],\n  &quot;河南省-济源市&quot;: [112.608581, 35.072907],\n  &quot;湖北省&quot;: [114.348441, 30.5516],\n  &quot;湖北省-武汉市&quot;: [114.311582, 30.598467],\n  &quot;湖北省-武汉市-江岸区&quot;: [114.316579, 30.605403],\n  &quot;湖北省-武汉市-江汉区&quot;: [114.277506, 30.607282],\n  &quot;湖北省-武汉市-硚口区&quot;: [114.22146, 30.587584],\n  &quot;湖北省-武汉市-汉阳区&quot;: [114.225446, 30.560052],\n  &quot;湖北省-武汉市-武昌区&quot;: [114.322549, 30.559567],\n  &quot;湖北省-武汉市-青山区&quot;: [114.391493, 30.646593],\n  &quot;湖北省-武汉市-洪山区&quot;: [114.350456, 30.506334],\n  &quot;湖北省-武汉市-东西湖区&quot;: [114.143459, 30.62592],\n  &quot;湖北省-武汉市-汉南区&quot;: [114.091515, 30.314809],\n  &quot;湖北省-武汉市-蔡甸区&quot;: [114.03548, 30.588114],\n  &quot;湖北省-武汉市-江夏区&quot;: [114.328551, 30.381564],\n  &quot;湖北省-武汉市-黄陂区&quot;: [114.382454, 30.887534],\n  &quot;湖北省-武汉市-新洲区&quot;: [114.807543, 30.847244],\n  &quot;湖北省-黄石市&quot;: [115.045533, 30.205208],\n  &quot;湖北省-黄石市-黄石港区&quot;: [115.072417, 30.229053],\n  &quot;湖北省-黄石市-西塞山区&quot;: [115.116481, 30.210695],\n  &quot;湖北省-黄石市-下陆区&quot;: [114.967416, 30.180046],\n  &quot;湖北省-黄石市-铁山区&quot;: [114.907571, 30.212251],\n  &quot;湖北省-黄石市-阳新县&quot;: [115.221427, 29.836542],\n  &quot;湖北省-黄石市-大冶市&quot;: [114.986436, 30.101668],\n  &quot;湖北省-十堰市&quot;: [110.80453, 32.635062],\n  &quot;湖北省-十堰市-茅箭区&quot;: [110.81958, 32.597287],\n  &quot;湖北省-十堰市-张湾区&quot;: [110.775424, 32.6584],\n  &quot;湖北省-十堰市-郧阳区&quot;: [110.818577, 32.840592],\n  &quot;湖北省-十堰市-郧西县&quot;: [110.432473, 32.999167],\n  &quot;湖北省-十堰市-竹山县&quot;: [110.235582, 32.230304],\n  &quot;湖北省-十堰市-竹溪县&quot;: [109.721542, 32.32412],\n  &quot;湖北省-十堰市-房县&quot;: [110.747462, 32.061685],\n  &quot;湖北省-十堰市-丹江口市&quot;: [111.519532, 32.546253],\n  &quot;湖北省-宜昌市&quot;: [111.292549, 30.697446],\n  &quot;湖北省-宜昌市-西陵区&quot;: [111.29256, 30.716749],\n  &quot;湖北省-宜昌市-伍家岗区&quot;: [111.367422, 30.650737],\n  &quot;湖北省-宜昌市-点军区&quot;: [111.274471, 30.69933],\n  &quot;湖北省-宜昌市-猇亭区&quot;: [111.441574, 30.536466],\n  &quot;湖北省-宜昌市-夷陵区&quot;: [111.33253, 30.774833],\n  &quot;湖北省-宜昌市-远安县&quot;: [111.64653, 31.066628],\n  &quot;湖北省-宜昌市-兴山县&quot;: [110.753446, 31.354464],\n  &quot;湖北省-宜昌市-秭归县&quot;: [110.984449, 30.831932],\n  &quot;湖北省-宜昌市-长阳土家族自治县&quot;: [111.213507, 30.478646],\n  &quot;湖北省-宜昌市-五峰土家族自治县&quot;: [111.052581, 30.171156],\n  &quot;湖北省-宜昌市-宜都市&quot;: [111.456516, 30.384404],\n  &quot;湖北省-宜昌市-当阳市&quot;: [111.794569, 30.826989],\n  &quot;湖北省-宜昌市-枝江市&quot;: [111.76654, 30.431731],\n  &quot;湖北省-襄阳市&quot;: [112.128537, 32.014797],\n  &quot;湖北省-襄阳市-襄城区&quot;: [112.140572, 32.016175],\n  &quot;湖北省-襄阳市-樊城区&quot;: [112.142599, 32.050572],\n  &quot;湖北省-襄阳市-襄州区&quot;: [112.218434, 32.093376],\n  &quot;湖北省-襄阳市-南漳县&quot;: [111.845386, 31.78113],\n  &quot;湖北省-襄阳市-谷城县&quot;: [111.659576, 32.268983],\n  &quot;湖北省-襄阳市-保康县&quot;: [111.267441, 31.883847],\n  &quot;湖北省-襄阳市-老河口市&quot;: [111.681556, 32.39246],\n  &quot;湖北省-襄阳市-枣阳市&quot;: [112.778471, 32.13473],\n  &quot;湖北省-襄阳市-宜城市&quot;: [112.264611, 31.72547],\n  &quot;湖北省-鄂州市&quot;: [114.901607, 30.396572],\n  &quot;湖北省-鄂州市-梁子湖区&quot;: [114.691507, 30.105907],\n  &quot;湖北省-鄂州市-华容区&quot;: [114.736426, 30.5406],\n  &quot;湖北省-鄂州市-鄂城区&quot;: [114.8986, 30.406389],\n  &quot;湖北省-荆门市&quot;: [112.206393, 31.041733],\n  &quot;湖北省-荆门市-东宝区&quot;: [112.208388, 31.058429],\n  &quot;湖北省-荆门市-掇刀区&quot;: [112.214428, 30.979911],\n  &quot;湖北省-荆门市-京山县&quot;: [113.126548, 31.024331],\n  &quot;湖北省-荆门市-沙洋县&quot;: [112.595485, 30.715315],\n  &quot;湖北省-荆门市-钟祥市&quot;: [112.594471, 31.17403],\n  &quot;湖北省-孝感市&quot;: [113.92251, 30.930689],\n  &quot;湖北省-孝感市-孝南区&quot;: [113.91749, 30.922978],\n  &quot;湖北省-孝感市-孝昌县&quot;: [114.004409, 31.26454],\n  &quot;湖北省-孝感市-大悟县&quot;: [114.133413, 31.56722],\n  &quot;湖北省-孝感市-云梦县&quot;: [113.759412, 31.027218],\n  &quot;湖北省-孝感市-应城市&quot;: [113.579567, 30.933977],\n  &quot;湖北省-孝感市-安陆市&quot;: [113.695583, 31.261415],\n  &quot;湖北省-孝感市-汉川市&quot;: [113.845549, 30.666914],\n  &quot;湖北省-荆州市&quot;: [112.245523, 30.340842],\n  &quot;湖北省-荆州市-沙市区&quot;: [112.261577, 30.316572],\n  &quot;湖北省-荆州市-荆州区&quot;: [112.196414, 30.358989],\n  &quot;湖北省-荆州市-公安县&quot;: [112.236502, 30.064401],\n  &quot;湖北省-荆州市-监利县&quot;: [112.91142, 29.845735],\n  &quot;湖北省-荆州市-江陵县&quot;: [112.431452, 30.048043],\n  &quot;湖北省-荆州市-石首市&quot;: [112.43142, 29.727034],\n  &quot;湖北省-荆州市-洪湖市&quot;: [113.482553, 29.83277],\n  &quot;湖北省-荆州市-松滋市&quot;: [111.77358, 30.175342],\n  &quot;湖北省-黄冈市&quot;: [114.87849, 30.459359],\n  &quot;湖北省-黄冈市-黄州区&quot;: [114.886532, 30.440224],\n  &quot;湖北省-黄冈市-团风县&quot;: [114.878524, 30.649368],\n  &quot;湖北省-黄冈市-红安县&quot;: [114.624426, 31.294297],\n  &quot;湖北省-黄冈市-罗田县&quot;: [115.405547, 30.78891],\n  &quot;湖北省-黄冈市-英山县&quot;: [115.687422, 30.74135],\n  &quot;湖北省-黄冈市-浠水县&quot;: [115.271569, 30.457461],\n  &quot;湖北省-黄冈市-蕲春县&quot;: [115.442399, 30.232535],\n  &quot;湖北省-黄冈市-黄梅县&quot;: [115.950462, 30.076605],\n  &quot;湖北省-黄冈市-麻城市&quot;: [115.016562, 31.176996],\n  &quot;湖北省-黄冈市-武穴市&quot;: [115.567392, 29.850441],\n  &quot;湖北省-咸宁市&quot;: [114.328519, 29.847056],\n  &quot;湖北省-咸宁市-咸安区&quot;: [114.30457, 29.858154],\n  &quot;湖北省-咸宁市-嘉鱼县&quot;: [113.94557, 29.976354],\n  &quot;湖北省-咸宁市-通城县&quot;: [113.823568, 29.250858],\n  &quot;湖北省-咸宁市-崇阳县&quot;: [114.046563, 29.561334],\n  &quot;湖北省-咸宁市-通山县&quot;: [114.489393, 29.612634],\n  &quot;湖北省-咸宁市-赤壁市&quot;: [113.906437, 29.730666],\n  &quot;湖北省-随州市&quot;: [113.38945, 31.696517],\n  &quot;湖北省-随州市-曾都区&quot;: [113.377513, 31.722123],\n  &quot;湖北省-随州市-随县&quot;: [113.377513, 31.722123],\n  &quot;湖北省-随州市-广水市&quot;: [113.832593, 31.622476],\n  &quot;湖北省-恩施土家族苗族自治州&quot;: [109.494593, 30.27794],\n  &quot;湖北省-恩施土家族苗族自治州-恩施市&quot;: [109.48655, 30.301037],\n  &quot;湖北省-恩施土家族苗族自治州-利川市&quot;: [108.942481, 30.297203],\n  &quot;湖北省-恩施土家族苗族自治州-建始县&quot;: [109.728556, 30.607907],\n  &quot;湖北省-恩施土家族苗族自治州-巴东县&quot;: [110.347575, 31.048064],\n  &quot;湖北省-恩施土家族苗族自治州-宣恩县&quot;: [109.497568, 29.992604],\n  &quot;湖北省-恩施土家族苗族自治州-咸丰县&quot;: [109.146608, 29.671078],\n  &quot;湖北省-恩施土家族苗族自治州-来凤县&quot;: [109.413495, 29.499444],\n  &quot;湖北省-恩施土家族苗族自治州-鹤峰县&quot;: [110.040424, 29.896116],\n  &quot;湖北省-仙桃市&quot;: [113.461591, 30.368272],\n  &quot;湖北省-潜江市&quot;: [112.905474, 30.408358],\n  &quot;湖北省-天门市&quot;: [113.172409, 30.669622],\n  &quot;湖北省-神农架林区&quot;: [110.682525, 31.750496],\n  &quot;湖南省&quot;: [112.989603, 28.11827],\n  &quot;湖南省-长沙市&quot;: [112.945473, 28.234889],\n  &quot;湖南省-长沙市-芙蓉区&quot;: [113.039408, 28.191913],\n  &quot;湖南省-长沙市-天心区&quot;: [112.996592, 28.118211],\n  &quot;湖南省-长沙市-岳麓区&quot;: [112.937448, 28.241489],\n  &quot;湖南省-长沙市-开福区&quot;: [112.992585, 28.261379],\n  &quot;湖南省-长沙市-雨花区&quot;: [113.042422, 28.142233],\n  &quot;湖南省-长沙市-望城区&quot;: [112.824466, 28.367403],\n  &quot;湖南省-长沙市-长沙县&quot;: [113.087559, 28.251818],\n  &quot;湖南省-长沙市-宁乡县&quot;: [112.558407, 28.284105],\n  &quot;湖南省-长沙市-浏阳市&quot;: [113.649398, 28.169832],\n  &quot;湖南省-株洲市&quot;: [113.140471, 27.833568],\n  &quot;湖南省-株洲市-荷塘区&quot;: [113.180452, 27.862156],\n  &quot;湖南省-株洲市-芦淞区&quot;: [113.158419, 27.791509],\n  &quot;湖南省-株洲市-石峰区&quot;: [113.124568, 27.880705],\n  &quot;湖南省-株洲市-天元区&quot;: [113.089541, 27.833084],\n  &quot;湖南省-株洲市-株洲县&quot;: [113.150427, 27.704323],\n  &quot;湖南省-株洲市-攸县&quot;: [113.351578, 27.005772],\n  &quot;湖南省-株洲市-茶陵县&quot;: [113.545472, 26.783589],\n  &quot;湖南省-株洲市-炎陵县&quot;: [113.779419, 26.496061],\n  &quot;湖南省-株洲市-醴陵市&quot;: [113.503483, 27.652325],\n  &quot;湖南省-湘潭市&quot;: [112.950464, 27.835702],\n  &quot;湖南省-湘潭市-雨湖区&quot;: [112.91345, 27.862467],\n  &quot;湖南省-湘潭市-岳塘区&quot;: [112.975589, 27.877721],\n  &quot;湖南省-湘潭市-湘潭县&quot;: [112.957505, 27.784983],\n  &quot;湖南省-湘潭市-湘乡市&quot;: [112.541492, 27.740191],\n  &quot;湖南省-湘潭市-韶山市&quot;: [112.533499, 27.921044],\n  &quot;湖南省-衡阳市&quot;: [112.578447, 26.899576],\n  &quot;湖南省-衡阳市-珠晖区&quot;: [112.626594, 26.900265],\n  &quot;湖南省-衡阳市-雁峰区&quot;: [112.623588, 26.894368],\n  &quot;湖南省-衡阳市-石鼓区&quot;: [112.60453, 26.948962],\n  &quot;湖南省-衡阳市-蒸湘区&quot;: [112.573444, 26.91772],\n  &quot;湖南省-衡阳市-南岳区&quot;: [112.745574, 27.23836],\n  &quot;湖南省-衡阳市-衡阳县&quot;: [112.377553, 26.975295],\n  &quot;湖南省-衡阳市-衡南县&quot;: [112.684403, 26.744532],\n  &quot;湖南省-衡阳市-衡山县&quot;: [112.875563, 27.235996],\n  &quot;湖南省-衡阳市-衡东县&quot;: [112.959495, 27.087043],\n  &quot;湖南省-衡阳市-祁东县&quot;: [112.096447, 26.805995],\n  &quot;湖南省-衡阳市-耒阳市&quot;: [112.866597, 26.428066],\n  &quot;湖南省-衡阳市-常宁市&quot;: [112.405561, 26.42672],\n  &quot;湖南省-邵阳市&quot;: [111.474433, 27.24527],\n  &quot;湖南省-邵阳市-双清区&quot;: [111.503442, 27.239109],\n  &quot;湖南省-邵阳市-大祥区&quot;: [111.445528, 27.227014],\n  &quot;湖南省-邵阳市-北塔区&quot;: [111.458497, 27.251536],\n  &quot;湖南省-邵阳市-邵东县&quot;: [111.750491, 27.264507],\n  &quot;湖南省-邵阳市-新邵县&quot;: [111.464449, 27.327132],\n  &quot;湖南省-邵阳市-邵阳县&quot;: [111.280508, 26.996528],\n  &quot;湖南省-邵阳市-隆回县&quot;: [111.039507, 27.119946],\n  &quot;湖南省-邵阳市-洞口县&quot;: [110.582579, 27.065975],\n  &quot;湖南省-邵阳市-绥宁县&quot;: [110.16242, 26.588423],\n  &quot;湖南省-邵阳市-新宁县&quot;: [110.863491, 26.439724],\n  &quot;湖南省-邵阳市-城步苗族自治县&quot;: [110.328537, 26.396203],\n  &quot;湖南省-邵阳市-武冈市&quot;: [110.638408, 26.732899],\n  &quot;湖南省-岳阳市&quot;: [113.135489, 29.363178],\n  &quot;湖南省-岳阳市-岳阳楼区&quot;: [113.136481, 29.377995],\n  &quot;湖南省-岳阳市-云溪区&quot;: [113.278407, 29.479907],\n  &quot;湖南省-岳阳市-君山区&quot;: [113.012517, 29.467129],\n  &quot;湖南省-岳阳市-岳阳县&quot;: [113.122544, 29.150269],\n  &quot;湖南省-岳阳市-华容县&quot;: [112.547462, 29.536286],\n  &quot;湖南省-岳阳市-湘阴县&quot;: [112.889522, 28.676676],\n  &quot;湖南省-岳阳市-平江县&quot;: [113.587604, 28.707564],\n  &quot;湖南省-岳阳市-汨罗市&quot;: [113.073493, 28.812455],\n  &quot;湖南省-岳阳市-临湘市&quot;: [113.456562, 29.482801],\n  &quot;湖南省-常德市&quot;: [111.705452, 29.03775],\n  &quot;湖南省-常德市-武陵区&quot;: [111.689545, 29.060783],\n  &quot;湖南省-常德市-鼎城区&quot;: [111.687522, 29.024443],\n  &quot;湖南省-常德市-安乡县&quot;: [112.177506, 29.41732],\n  &quot;湖南省-常德市-汉寿县&quot;: [111.976412, 28.912288],\n  &quot;湖南省-常德市-澧县&quot;: [111.765534, 29.638946],\n  &quot;湖南省-常德市-临澧县&quot;: [111.653585, 29.446544],\n  &quot;湖南省-常德市-桃源县&quot;: [111.495407, 28.908694],\n  &quot;湖南省-常德市-石门县&quot;: [111.386451, 29.590366],\n  &quot;湖南省-常德市-津市市&quot;: [111.884517, 29.611259],\n  &quot;湖南省-张家界市&quot;: [110.485533, 29.122816],\n  &quot;湖南省-张家界市-永定区&quot;: [110.544432, 29.126191],\n  &quot;湖南省-张家界市-武陵源区&quot;: [110.557499, 29.351681],\n  &quot;湖南省-张家界市-慈利县&quot;: [111.145471, 29.435987],\n  &quot;湖南省-张家界市-桑植县&quot;: [110.170413, 29.405923],\n  &quot;湖南省-益阳市&quot;: [112.361516, 28.559711],\n  &quot;湖南省-益阳市-资阳区&quot;: [112.330435, 28.597235],\n  &quot;湖南省-益阳市-赫山区&quot;: [112.380598, 28.584984],\n  &quot;湖南省-益阳市-南县&quot;: [112.402542, 29.36707],\n  &quot;湖南省-益阳市-桃江县&quot;: [112.162541, 28.523871],\n  &quot;湖南省-益阳市-安化县&quot;: [111.219493, 28.380054],\n  &quot;湖南省-益阳市-沅江市&quot;: [112.360532, 28.850234],\n  &quot;湖南省-郴州市&quot;: [113.02146, 25.776683],\n  &quot;湖南省-郴州市-北湖区&quot;: [113.017482, 25.790815],\n  &quot;湖南省-郴州市-苏仙区&quot;: [113.048423, 25.806737],\n  &quot;湖南省-郴州市-桂阳县&quot;: [112.74056, 25.759775],\n  &quot;湖南省-郴州市-宜章县&quot;: [112.955479, 25.405714],\n  &quot;湖南省-郴州市-永兴县&quot;: [113.122533, 26.132968],\n  &quot;湖南省-郴州市-嘉禾县&quot;: [112.375584, 25.593422],\n  &quot;湖南省-郴州市-临武县&quot;: [112.570411, 25.282527],\n  &quot;湖南省-郴州市-汝城县&quot;: [113.691545, 25.556057],\n  &quot;湖南省-郴州市-桂东县&quot;: [113.951594, 26.083174],\n  &quot;湖南省-郴州市-安仁县&quot;: [113.275424, 26.715683],\n  &quot;湖南省-郴州市-资兴市&quot;: [113.242556, 25.981874],\n  &quot;湖南省-永州市&quot;: [111.619455, 26.425864],\n  &quot;湖南省-永州市-零陵区&quot;: [111.637502, 26.227682],\n  &quot;湖南省-永州市-冷水滩区&quot;: [111.598426, 26.467706],\n  &quot;湖南省-永州市-祁阳县&quot;: [111.84742, 26.586435],\n  &quot;湖南省-永州市-东安县&quot;: [111.323542, 26.398288],\n  &quot;湖南省-永州市-双牌县&quot;: [111.667594, 25.967169],\n  &quot;湖南省-永州市-道县&quot;: [111.607404, 25.53253],\n  &quot;湖南省-永州市-江永县&quot;: [111.350437, 25.279721],\n  &quot;湖南省-永州市-宁远县&quot;: [111.952453, 25.577052],\n  &quot;湖南省-永州市-蓝山县&quot;: [112.203435, 25.375935],\n  &quot;湖南省-永州市-新田县&quot;: [112.210409, 25.909826],\n  &quot;湖南省-永州市-江华瑶族自治县&quot;: [111.585452, 25.191349],\n  &quot;湖南省-怀化市&quot;: [110.008514, 27.575161],\n  &quot;湖南省-怀化市-鹤城区&quot;: [110.0464, 27.585226],\n  &quot;湖南省-怀化市-中方县&quot;: [109.951462, 27.446081],\n  &quot;湖南省-怀化市-沅陵县&quot;: [110.400431, 28.459018],\n  &quot;湖南省-怀化市-辰溪县&quot;: [110.190487, 28.012605],\n  &quot;湖南省-怀化市-溆浦县&quot;: [110.601551, 27.913963],\n  &quot;湖南省-怀化市-会同县&quot;: [109.741586, 26.893384],\n  &quot;湖南省-怀化市-麻阳苗族自治县&quot;: [109.809436, 27.87193],\n  &quot;湖南省-怀化市-新晃侗族自治县&quot;: [109.181472, 27.358783],\n  &quot;湖南省-怀化市-芷江侗族自治县&quot;: [109.691402, 27.449513],\n  &quot;湖南省-怀化市-靖州苗族侗族自治县&quot;: [109.702452, 26.581321],\n  &quot;湖南省-怀化市-通道侗族自治县&quot;: [109.790445, 26.16422],\n  &quot;湖南省-怀化市-洪江市&quot;: [109.84351, 27.215077],\n  &quot;湖南省-娄底市&quot;: [112.001503, 27.703209],\n  &quot;湖南省-娄底市-娄星区&quot;: [112.008558, 27.735605],\n  &quot;湖南省-娄底市-双峰县&quot;: [112.18146, 27.462983],\n  &quot;湖南省-娄底市-新化县&quot;: [111.334515, 27.732667],\n  &quot;湖南省-娄底市-冷水江市&quot;: [111.44154, 27.692059],\n  &quot;湖南省-娄底市-涟源市&quot;: [111.670562, 27.698168],\n  &quot;湖南省-湘西土家族苗族自治州&quot;: [109.745577, 28.317369],\n  &quot;湖南省-湘西土家族苗族自治州-吉首市&quot;: [109.704449, 28.267493],\n  &quot;湖南省-湘西土家族苗族自治州-泸溪县&quot;: [110.226599, 28.221873],\n  &quot;湖南省-湘西土家族苗族自治州-凤凰县&quot;: [109.605527, 27.953848],\n  &quot;湖南省-湘西土家族苗族自治州-花垣县&quot;: [109.488562, 28.57791],\n  &quot;湖南省-湘西土家族苗族自治州-保靖县&quot;: [109.666474, 28.705969],\n  &quot;湖南省-湘西土家族苗族自治州-古丈县&quot;: [109.957507, 28.623084],\n  &quot;湖南省-湘西土家族苗族自治州-永顺县&quot;: [109.863586, 28.985774],\n  &quot;湖南省-湘西土家族苗族自治州-龙山县&quot;: [109.450416, 29.464122],\n  &quot;广东省&quot;: [113.272429, 23.137949],\n  &quot;广东省-广州市&quot;: [113.271431, 23.135336],\n  &quot;广东省-广州市-荔湾区&quot;: [113.250502, 23.131791],\n  &quot;广东省-广州市-越秀区&quot;: [113.273426, 23.13526],\n  &quot;广东省-广州市-海珠区&quot;: [113.32354, 23.088981],\n  &quot;广东省-广州市-天河区&quot;: [113.368509, 23.130358],\n  &quot;广东省-广州市-白云区&quot;: [113.279433, 23.164317],\n  &quot;广东省-广州市-黄埔区&quot;: [113.466563, 23.112058],\n  &quot;广东省-广州市-番禺区&quot;: [113.39047, 22.943831],\n  &quot;广东省-广州市-花都区&quot;: [113.226576, 23.411162],\n  &quot;广东省-广州市-南沙区&quot;: [113.531436, 22.807929],\n  &quot;广东省-广州市-从化区&quot;: [113.593585, 23.553986],\n  &quot;广东省-广州市-增城区&quot;: [113.817546, 23.266592],\n  &quot;广东省-韶关市&quot;: [113.603527, 24.815881],\n  &quot;广东省-韶关市-武江区&quot;: [113.594556, 24.798486],\n  &quot;广东省-韶关市-浈江区&quot;: [113.617477, 24.810414],\n  &quot;广东省-韶关市-曲江区&quot;: [113.611501, 24.688408],\n  &quot;广东省-韶关市-始兴县&quot;: [114.068567, 24.958558],\n  &quot;广东省-韶关市-仁化县&quot;: [113.755443, 25.092288],\n  &quot;广东省-韶关市-翁源县&quot;: [114.136427, 24.356594],\n  &quot;广东省-韶关市-乳源瑶族自治县&quot;: [113.282431, 24.782333],\n  &quot;广东省-韶关市-新丰县&quot;: [114.213512, 24.065547],\n  &quot;广东省-韶关市-乐昌市&quot;: [113.354579, 25.135592],\n  &quot;广东省-韶关市-南雄市&quot;: [114.318579, 25.123527],\n  &quot;广东省-深圳市&quot;: [114.064552, 22.548457],\n  &quot;广东省-深圳市-罗湖区&quot;: [114.137432, 22.554485],\n  &quot;广东省-深圳市-福田区&quot;: [114.061547, 22.528466],\n  &quot;广东省-深圳市-南山区&quot;: [113.936539, 22.5385],\n  &quot;广东省-深圳市-宝安区&quot;: [113.890427, 22.560033],\n  &quot;广东省-深圳市-龙岗区&quot;: [114.254455, 22.726017],\n  &quot;广东省-深圳市-盐田区&quot;: [114.24343, 22.563438],\n  &quot;广东省-珠海市&quot;: [113.582555, 22.276565],\n  &quot;广东省-珠海市-香洲区&quot;: [113.550472, 22.273004],\n  &quot;广东省-珠海市-斗门区&quot;: [113.303467, 22.215516],\n  &quot;广东省-珠海市-金湾区&quot;: [113.369517, 22.152577],\n  &quot;广东省-汕头市&quot;: [116.688529, 23.359092],\n  &quot;广东省-汕头市-龙湖区&quot;: [116.723525, 23.377776],\n  &quot;广东省-汕头市-金平区&quot;: [116.70955, 23.37175],\n  &quot;广东省-汕头市-濠江区&quot;: [116.733517, 23.291546],\n  &quot;广东省-汕头市-潮阳区&quot;: [116.608515, 23.270855],\n  &quot;广东省-汕头市-潮南区&quot;: [116.439491, 23.256341],\n  &quot;广东省-汕头市-澄海区&quot;: [116.762425, 23.472341],\n  &quot;广东省-汕头市-南澳县&quot;: [117.030496, 23.427812],\n  &quot;广东省-佛山市&quot;: [113.128512, 23.027759],\n  &quot;广东省-佛山市-禅城区&quot;: [113.129505, 23.015374],\n  &quot;广东省-佛山市-南海区&quot;: [113.149446, 23.035011],\n  &quot;广东省-佛山市-顺德区&quot;: [113.300453, 22.810453],\n  &quot;广东省-佛山市-三水区&quot;: [112.903471, 23.16192],\n  &quot;广东省-佛山市-高明区&quot;: [112.899472, 22.90635],\n  &quot;广东省-江门市&quot;: [113.088556, 22.584604],\n  &quot;广东省-江门市-蓬江区&quot;: [113.084546, 22.601066],\n  &quot;广东省-江门市-江海区&quot;: [113.117557, 22.566115],\n  &quot;广东省-江门市-新会区&quot;: [113.038455, 22.465113],\n  &quot;广东省-江门市-台山市&quot;: [112.800445, 22.257923],\n  &quot;广东省-江门市-开平市&quot;: [112.704464, 22.382499],\n  &quot;广东省-江门市-鹤山市&quot;: [112.970527, 22.771169],\n  &quot;广东省-江门市-恩平市&quot;: [112.311438, 22.189035],\n  &quot;广东省-湛江市&quot;: [110.365554, 21.276723],\n  &quot;广东省-湛江市-赤坎区&quot;: [110.372533, 21.272135],\n  &quot;广东省-湛江市-霞山区&quot;: [110.404425, 21.198227],\n  &quot;广东省-湛江市-坡头区&quot;: [110.462567, 21.250377],\n  &quot;广东省-湛江市-麻章区&quot;: [110.340579, 21.269189],\n  &quot;广东省-湛江市-遂溪县&quot;: [110.256515, 21.383103],\n  &quot;广东省-湛江市-徐闻县&quot;: [110.182473, 20.331724],\n  &quot;广东省-湛江市-廉江市&quot;: [110.292448, 21.615816],\n  &quot;广东省-湛江市-雷州市&quot;: [110.102581, 20.919881],\n  &quot;广东省-湛江市-吴川市&quot;: [110.78645, 21.447263],\n  &quot;广东省-茂名市&quot;: [110.931543, 21.669064],\n  &quot;广东省-茂名市-茂南区&quot;: [110.925546, 21.647152],\n  &quot;广东省-茂名市-电白区&quot;: [111.020471, 21.520351],\n  &quot;广东省-茂名市-高州市&quot;: [110.859474, 21.924049],\n  &quot;广东省-茂名市-化州市&quot;: [110.646431, 21.670231],\n  &quot;广东省-茂名市-信宜市&quot;: [110.953582, 22.360093],\n  &quot;广东省-肇庆市&quot;: [112.471489, 23.052889],\n  &quot;广东省-肇庆市-端州区&quot;: [112.49156, 23.057564],\n  &quot;广东省-肇庆市-鼎湖区&quot;: [112.574434, 23.164308],\n  &quot;广东省-肇庆市-高要区&quot;: [112.464446, 23.031896],\n  &quot;广东省-肇庆市-广宁县&quot;: [112.447424, 23.641036],\n  &quot;广东省-肇庆市-怀集县&quot;: [112.191469, 23.917842],\n  &quot;广东省-肇庆市-封开县&quot;: [111.518526, 23.429769],\n  &quot;广东省-肇庆市-德庆县&quot;: [111.791554, 23.151373],\n  &quot;广东省-肇庆市-四会市&quot;: [112.740579, 23.332381],\n  &quot;广东省-惠州市&quot;: [114.423558, 23.116359],\n  &quot;广东省-惠州市-惠城区&quot;: [114.38949, 23.089726],\n  &quot;广东省-惠州市-惠阳区&quot;: [114.463464, 22.794721],\n  &quot;广东省-惠州市-博罗县&quot;: [114.296573, 23.178806],\n  &quot;广东省-惠州市-惠东县&quot;: [114.726426, 22.991443],\n  &quot;广东省-惠州市-龙门县&quot;: [114.26143, 23.733838],\n  &quot;广东省-梅州市&quot;: [116.129537, 24.294178],\n  &quot;广东省-梅州市-梅江区&quot;: [116.123536, 24.315879],\n  &quot;广东省-梅州市-梅县区&quot;: [116.088562, 24.270999],\n  &quot;广东省-梅州市-大埔县&quot;: [116.701559, 24.353459],\n  &quot;广东省-梅州市-丰顺县&quot;: [116.188454, 23.745738],\n  &quot;广东省-梅州市-五华县&quot;: [115.782485, 23.938409],\n  &quot;广东省-梅州市-平远县&quot;: [115.897477, 24.572414],\n  &quot;广东省-梅州市-蕉岭县&quot;: [116.177439, 24.664993],\n  &quot;广东省-梅州市-兴宁市&quot;: [115.737579, 24.142294],\n  &quot;广东省-汕尾市&quot;: [115.381553, 22.791263],\n  &quot;广东省-汕尾市-城区&quot;: [115.371531, 22.784552],\n  &quot;广东省-汕尾市-海丰县&quot;: [115.329445, 22.972744],\n  &quot;广东省-汕尾市-陆河县&quot;: [115.666483, 23.307677],\n  &quot;广东省-汕尾市-陆丰市&quot;: [115.65849, 22.923636],\n  &quot;广东省-河源市&quot;: [114.707446, 23.749684],\n  &quot;广东省-河源市-源城区&quot;: [114.708439, 23.740298],\n  &quot;广东省-河源市-紫金县&quot;: [115.190448, 23.64143],\n  &quot;广东省-河源市-龙川县&quot;: [115.266555, 24.105851],\n  &quot;广东省-河源市-连平县&quot;: [114.495444, 24.375808],\n  &quot;广东省-河源市-和平县&quot;: [114.945449, 24.448253],\n  &quot;广东省-河源市-东源县&quot;: [114.753508, 23.794258],\n  &quot;广东省-阳江市&quot;: [111.988489, 21.86434],\n  &quot;广东省-阳江市-江城区&quot;: [111.961455, 21.868128],\n  &quot;广东省-阳江市-阳东区&quot;: [112.018579, 21.873997],\n  &quot;广东省-阳江市-阳西县&quot;: [111.624481, 21.758701],\n  &quot;广东省-阳江市-阳春市&quot;: [111.797536, 22.176015],\n  &quot;广东省-清远市&quot;: [113.062468, 23.68823],\n  &quot;广东省-清远市-清城区&quot;: [113.069477, 23.704022],\n  &quot;广东省-清远市-清新区&quot;: [112.991558, 23.75427],\n  &quot;广东省-清远市-佛冈县&quot;: [113.538441, 23.885475],\n  &quot;广东省-清远市-阳山县&quot;: [112.64752, 24.470944],\n  &quot;广东省-清远市-连山壮族瑶族自治县&quot;: [112.100426, 24.576846],\n  &quot;广东省-清远市-连南瑶族自治县&quot;: [112.293517, 24.731549],\n  &quot;广东省-清远市-英德市&quot;: [113.421443, 24.191939],\n  &quot;广东省-清远市-连州市&quot;: [112.383573, 24.786467],\n  &quot;广东省-东莞市&quot;: [113.75842, 23.027308],\n  &quot;广东省-中山市&quot;: [113.399422, 22.522315],\n  &quot;广东省-潮州市&quot;: [116.62947, 23.662623],\n  &quot;广东省-潮州市-湘桥区&quot;: [116.634462, 23.680687],\n  &quot;广东省-潮州市-潮安区&quot;: [116.684526, 23.468357],\n  &quot;广东省-潮州市-饶平县&quot;: [117.010449, 23.670347],\n  &quot;广东省-揭阳市&quot;: [116.378512, 23.55574],\n  &quot;广东省-揭阳市-榕城区&quot;: [116.373516, 23.530746],\n  &quot;广东省-揭阳市-揭东区&quot;: [116.418456, 23.572485],\n  &quot;广东省-揭阳市-揭西县&quot;: [115.848561, 23.4373],\n  &quot;广东省-揭阳市-惠来县&quot;: [116.301444, 23.039645],\n  &quot;广东省-揭阳市-普宁市&quot;: [116.172449, 23.303635],\n  &quot;广东省-云浮市&quot;: [112.051513, 22.920912],\n  &quot;广东省-云浮市-云城区&quot;: [112.050529, 22.933898],\n  &quot;广东省-云浮市-云安区&quot;: [112.009563, 23.076893],\n  &quot;广东省-云浮市-新兴县&quot;: [112.231497, 22.70189],\n  &quot;广东省-云浮市-郁南县&quot;: [111.541554, 23.240174],\n  &quot;广东省-云浮市-罗定市&quot;: [111.57648, 22.774296],\n  &quot;广西壮族自治区&quot;: [108.334521, 22.821269],\n  &quot;广西壮族自治区-南宁市&quot;: [108.373451, 22.822607],\n  &quot;广西壮族自治区-南宁市-兴宁区&quot;: [108.375445, 22.860291],\n  &quot;广西壮族自治区-南宁市-青秀区&quot;: [108.501439, 22.792227],\n  &quot;广西壮族自治区-南宁市-江南区&quot;: [108.279494, 22.787046],\n  &quot;广西壮族自治区-南宁市-西乡塘区&quot;: [108.319572, 22.839652],\n  &quot;广西壮族自治区-南宁市-良庆区&quot;: [108.327516, 22.762849],\n  &quot;广西壮族自治区-南宁市-邕宁区&quot;: [108.49342, 22.7646],\n  &quot;广西壮族自治区-南宁市-武鸣区&quot;: [108.281517, 23.164516],\n  &quot;广西壮族自治区-南宁市-隆安县&quot;: [107.702574, 23.171585],\n  &quot;广西壮族自治区-南宁市-马山县&quot;: [108.183562, 23.713878],\n  &quot;广西壮族自治区-南宁市-上林县&quot;: [108.611451, 23.438519],\n  &quot;广西壮族自治区-南宁市-宾阳县&quot;: [108.816502, 23.223701],\n  &quot;广西壮族自治区-南宁市-横县&quot;: [109.267568, 22.685573],\n  &quot;广西壮族自治区-柳州市&quot;: [109.434422, 24.331961],\n  &quot;广西壮族自治区-柳州市-城中区&quot;: [109.417482, 24.321314],\n  &quot;广西壮族自治区-柳州市-鱼峰区&quot;: [109.449416, 24.318522],\n  &quot;广西壮族自治区-柳州市-柳南区&quot;: [109.391552, 24.341579],\n  &quot;广西壮族自治区-柳州市-柳北区&quot;: [109.408532, 24.367867],\n  &quot;广西壮族自治区-柳州市-柳江区&quot;: [109.332444, 24.260815],\n  &quot;广西壮族自治区-柳州市-柳城县&quot;: [109.251562, 24.65637],\n  &quot;广西壮族自治区-柳州市-鹿寨县&quot;: [109.757554, 24.478622],\n  &quot;广西壮族自治区-柳州市-融安县&quot;: [109.404563, 25.230511],\n  &quot;广西壮族自治区-柳州市-融水苗族自治县&quot;: [109.262561, 25.072077],\n  &quot;广西壮族自治区-柳州市-三江侗族自治县&quot;: [109.614547, 25.78883],\n  &quot;广西壮族自治区-桂林市&quot;: [110.203545, 25.242886],\n  &quot;广西壮族自治区-桂林市-秀峰区&quot;: [110.270437, 25.279618],\n  &quot;广西壮族自治区-桂林市-叠彩区&quot;: [110.308463, 25.320233],\n  &quot;广西壮族自治区-桂林市-象山区&quot;: [110.287423, 25.26793],\n  &quot;广西壮族自治区-桂林市-七星区&quot;: [110.324538, 25.258567],\n  &quot;广西壮族自治区-桂林市-雁山区&quot;: [110.315479, 25.066214],\n  &quot;广西壮族自治区-桂林市-临桂区&quot;: [110.218587, 25.244302],\n  &quot;广西壮族自治区-桂林市-阳朔县&quot;: [110.503475, 24.784519],\n  &quot;广西壮族自治区-桂林市-灵川县&quot;: [110.332537, 25.41555],\n  &quot;广西壮族自治区-桂林市-全州县&quot;: [111.079569, 25.934343],\n  &quot;广西壮族自治区-桂林市-兴安县&quot;: [110.678516, 25.617567],\n  &quot;广西壮族自治区-桂林市-永福县&quot;: [109.989591, 24.985578],\n  &quot;广西壮族自治区-桂林市-灌阳县&quot;: [111.167552, 25.495121],\n  &quot;广西壮族自治区-桂林市-龙胜各族自治县&quot;: [110.017494, 25.804117],\n  &quot;广西壮族自治区-桂林市-资源县&quot;: [110.658439, 26.048569],\n  &quot;广西壮族自治区-桂林市-平乐县&quot;: [110.649446, 24.639632],\n  &quot;广西壮族自治区-桂林市-荔浦县&quot;: [110.401437, 24.494122],\n  &quot;广西壮族自治区-桂林市-恭城瑶族自治县&quot;: [110.83456, 24.837194],\n  &quot;广西壮族自治区-梧州市&quot;: [111.285517, 23.482745],\n  &quot;广西壮族自治区-梧州市-万秀区&quot;: [111.32752, 23.478846],\n  &quot;广西壮族自治区-梧州市-长洲区&quot;: [111.281499, 23.49151],\n  &quot;广西壮族自治区-梧州市-龙圩区&quot;: [111.285517, 23.482745],\n  &quot;广西壮族自治区-梧州市-苍梧县&quot;: [111.555547, 23.845998],\n  &quot;广西壮族自治区-梧州市-藤县&quot;: [110.921499, 23.38101],\n  &quot;广西壮族自治区-梧州市-蒙山县&quot;: [110.531417, 24.200017],\n  &quot;广西壮族自治区-梧州市-岑溪市&quot;: [111.001432, 22.924621],\n  &quot;广西壮族自治区-北海市&quot;: [109.126533, 21.486836],\n  &quot;广西壮族自治区-北海市-海城区&quot;: [109.124521, 21.481066],\n  &quot;广西壮族自治区-北海市-银海区&quot;: [109.146545, 21.454769],\n  &quot;广西壮族自治区-北海市-铁山港区&quot;: [109.428473, 21.535295],\n  &quot;广西壮族自治区-北海市-合浦县&quot;: [109.213439, 21.667006],\n  &quot;广西壮族自治区-防城港市&quot;: [108.360419, 21.693005],\n  &quot;广西壮族自治区-防城港市-港口区&quot;: [108.386483, 21.649566],\n  &quot;广西壮族自治区-防城港市-防城区&quot;: [108.360448, 21.775411],\n  &quot;广西壮族自治区-防城港市-上思县&quot;: [107.990443, 22.159914],\n  &quot;广西壮族自治区-防城港市-东兴市&quot;: [107.977489, 21.553615],\n  &quot;广西壮族自治区-钦州市&quot;: [108.66058, 21.986594],\n  &quot;广西壮族自治区-钦州市-钦南区&quot;: [108.664549, 21.945972],\n  &quot;广西壮族自治区-钦州市-钦北区&quot;: [108.638513, 22.020367],\n  &quot;广西壮族自治区-钦州市-灵山县&quot;: [109.297478, 22.422413],\n  &quot;广西壮族自治区-钦州市-浦北县&quot;: [109.563423, 22.277822],\n  &quot;广西壮族自治区-贵港市&quot;: [109.60552, 23.117448],\n  &quot;广西壮族自治区-贵港市-港北区&quot;: [109.578433, 23.117564],\n  &quot;广西壮族自治区-贵港市-港南区&quot;: [109.606553, 23.08124],\n  &quot;广西壮族自治区-贵港市-覃塘区&quot;: [109.459427, 23.133251],\n  &quot;广西壮族自治区-贵港市-平南县&quot;: [110.398452, 23.545506],\n  &quot;广西壮族自治区-贵港市-桂平市&quot;: [110.085526, 23.400049],\n  &quot;广西壮族自治区-玉林市&quot;: [110.188453, 22.659831],\n  &quot;广西壮族自治区-玉林市-玉州区&quot;: [110.157431, 22.634493],\n  &quot;广西壮族自治区-玉林市-福绵区&quot;: [110.157431, 22.634493],\n  &quot;广西壮族自治区-玉林市-容县&quot;: [110.56453, 22.863666],\n  &quot;广西壮族自治区-玉林市-陆川县&quot;: [110.270456, 22.327222],\n  &quot;广西壮族自治区-玉林市-博白县&quot;: [109.982553, 22.278675],\n  &quot;广西壮族自治区-玉林市-兴业县&quot;: [109.881552, 22.742268],\n  &quot;广西壮族自治区-玉林市-北流市&quot;: [110.36057, 22.713958],\n  &quot;广西壮族自治区-百色市&quot;: [106.624589, 23.908186],\n  &quot;广西壮族自治区-百色市-右江区&quot;: [106.625589, 23.907085],\n  &quot;广西壮族自治区-百色市-田阳县&quot;: [106.921413, 23.742006],\n  &quot;广西壮族自治区-百色市-田东县&quot;: [107.132499, 23.60313],\n  &quot;广西壮族自治区-百色市-平果县&quot;: [107.596571, 23.334923],\n  &quot;广西壮族自治区-百色市-德保县&quot;: [106.621583, 23.328994],\n  &quot;广西壮族自治区-百色市-那坡县&quot;: [105.839423, 23.393794],\n  &quot;广西壮族自治区-百色市-凌云县&quot;: [106.568416, 24.354015],\n  &quot;广西壮族自治区-百色市-乐业县&quot;: [106.56343, 24.783216],\n  &quot;广西壮族自治区-百色市-田林县&quot;: [106.234498, 24.300535],\n  &quot;广西壮族自治区-百色市-西林县&quot;: [105.100494, 24.495668],\n  &quot;广西壮族自治区-百色市-隆林各族自治县&quot;: [105.350459, 24.776814],\n  &quot;广西壮族自治区-百色市-靖西市&quot;: [106.424453, 23.140126],\n  &quot;广西壮族自治区-贺州市&quot;: [111.573526, 24.409451],\n  &quot;广西壮族自治区-贺州市-八步区&quot;: [111.558567, 24.417531],\n  &quot;广西壮族自治区-贺州市-平桂区&quot;: [111.478414, 24.462001],\n  &quot;广西壮族自治区-贺州市-昭平县&quot;: [110.817575, 24.175106],\n  &quot;广西壮族自治区-贺州市-钟山县&quot;: [111.309586, 24.531673],\n  &quot;广西壮族自治区-贺州市-富川瑶族自治县&quot;: [111.284511, 24.82016],\n  &quot;广西壮族自治区-河池市&quot;: [108.0915, 24.698912],\n  &quot;广西壮族自治区-河池市-金城江区&quot;: [108.043507, 24.695679],\n  &quot;广西壮族自治区-河池市-南丹县&quot;: [107.54748, 24.98185],\n  &quot;广西壮族自治区-河池市-天峨县&quot;: [107.178456, 25.005664],\n  &quot;广西壮族自治区-河池市-凤山县&quot;: [107.04842, 24.553218],\n  &quot;广西壮族自治区-河池市-东兰县&quot;: [107.380504, 24.516871],\n  &quot;广西壮族自治区-河池市-罗城仫佬族自治县&quot;: [108.911574, 24.783085],\n  &quot;广西壮族自治区-河池市-环江毛南族自治县&quot;: [108.264443, 24.832088],\n  &quot;广西壮族自治区-河池市-巴马瑶族自治县&quot;: [107.266481, 24.147265],\n  &quot;广西壮族自治区-河池市-都安瑶族自治县&quot;: [108.111458, 23.937331],\n  &quot;广西壮族自治区-河池市-大化瑶族自治县&quot;: [108.004411, 23.742818],\n  &quot;广西壮族自治区-河池市-宜州市&quot;: [108.643532, 24.491084],\n  &quot;广西壮族自治区-来宾市&quot;: [109.227458, 23.756547],\n  &quot;广西壮族自治区-来宾市-兴宾区&quot;: [109.241499, 23.733211],\n  &quot;广西壮族自治区-来宾市-忻城县&quot;: [108.672562, 24.071889],\n  &quot;广西壮族自治区-来宾市-象州县&quot;: [109.711462, 23.979681],\n  &quot;广西壮族自治区-来宾市-武宣县&quot;: [109.669442, 23.600404],\n  &quot;广西壮族自治区-来宾市-金秀瑶族自治县&quot;: [110.195506, 24.136319],\n  &quot;广西壮族自治区-来宾市-合山市&quot;: [108.892566, 23.81226],\n  &quot;广西壮族自治区-崇左市&quot;: [107.37152, 22.383117],\n  &quot;广西壮族自治区-崇左市-江州区&quot;: [107.359533, 22.411246],\n  &quot;广西壮族自治区-崇左市-扶绥县&quot;: [107.910465, 22.641097],\n  &quot;广西壮族自治区-崇左市-宁明县&quot;: [107.083524, 22.145885],\n  &quot;广西壮族自治区-崇左市-龙州县&quot;: [106.860582, 22.348299],\n  &quot;广西壮族自治区-崇左市-大新县&quot;: [107.207557, 22.836229],\n  &quot;广西壮族自治区-崇左市-天等县&quot;: [107.149473, 23.087506],\n  &quot;广西壮族自治区-崇左市-凭祥市&quot;: [106.773524, 22.100153],\n  &quot;海南省&quot;: [110.355537, 20.025802],\n  &quot;海南省-海口市&quot;: [110.325525, 20.044049],\n  &quot;海南省-海口市-秀英区&quot;: [110.300436, 20.013642],\n  &quot;海南省-海口市-龙华区&quot;: [110.335541, 20.036321],\n  &quot;海南省-海口市-琼山区&quot;: [110.360526, 20.009151],\n  &quot;海南省-海口市-美兰区&quot;: [110.373498, 20.034646],\n  &quot;海南省-三亚市&quot;: [109.518557, 18.258736],\n  &quot;海南省-三亚市-海棠区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-吉阳区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-天涯区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三亚市-崖州区&quot;: [109.7235, 18.337879],\n  &quot;海南省-三沙市&quot;: [111.673087, 16.497085],\n  &quot;海南省-儋州市&quot;: [109.587456, 19.527146],\n  &quot;海南省-五指山市&quot;: [109.52354, 18.780994],\n  &quot;海南省-琼海市&quot;: [110.480545, 19.264254],\n  &quot;海南省-文昌市&quot;: [110.804509, 19.549062],\n  &quot;海南省-万宁市&quot;: [110.399434, 18.800107],\n  &quot;海南省-东方市&quot;: [108.658567, 19.101105],\n  &quot;海南省-定安县&quot;: [110.365533, 19.68712],\n  &quot;海南省-屯昌县&quot;: [110.108577, 19.357375],\n  &quot;海南省-澄迈县&quot;: [110.013511, 19.744349],\n  &quot;海南省-临高县&quot;: [109.697443, 19.919475],\n  &quot;海南省-白沙黎族自治县&quot;: [109.457471, 19.231379],\n  &quot;海南省-昌江黎族自治县&quot;: [109.062464, 19.303998],\n  &quot;海南省-乐东黎族自治县&quot;: [109.180508, 18.755871],\n  &quot;海南省-陵水黎族自治县&quot;: [110.044464, 18.512332],\n  &quot;海南省-保亭黎族苗族自治县&quot;: [109.703482, 18.64691],\n  &quot;海南省-琼中黎族苗族自治县&quot;: [109.844511, 19.039164],\n  &quot;重庆市&quot;: [106.558434, 29.568996],\n  &quot;重庆市-市辖区&quot;: [106.558434, 29.568996],\n  &quot;重庆市-市辖区-万州区&quot;: [108.415558, 30.813622],\n  &quot;重庆市-市辖区-涪陵区&quot;: [107.39642, 29.709278],\n  &quot;重庆市-市辖区-渝中区&quot;: [106.57544, 29.55909],\n  &quot;重庆市-市辖区-大渡口区&quot;: [106.488534, 29.490107],\n  &quot;重庆市-市辖区-江北区&quot;: [106.580415, 29.612832],\n  &quot;重庆市-市辖区-沙坪坝区&quot;: [106.464465, 29.547193],\n  &quot;重庆市-市辖区-九龙坡区&quot;: [106.517559, 29.507928],\n  &quot;重庆市-市辖区-南岸区&quot;: [106.66843, 29.502683],\n  &quot;重庆市-市辖区-北碚区&quot;: [106.403569, 29.811603],\n  &quot;重庆市-市辖区-綦江区&quot;: [106.657484, 29.034114],\n  &quot;重庆市-市辖区-大足区&quot;: [105.728405, 29.713114],\n  &quot;重庆市-市辖区-渝北区&quot;: [106.637559, 29.723927],\n  &quot;重庆市-市辖区-巴南区&quot;: [106.547454, 29.408475],\n  &quot;重庆市-市辖区-黔江区&quot;: [108.777591, 29.538813],\n  &quot;重庆市-市辖区-长寿区&quot;: [107.087531, 29.86352],\n  &quot;重庆市-市辖区-江津区&quot;: [106.265598, 29.295884],\n  &quot;重庆市-市辖区-合川区&quot;: [106.282541, 29.978181],\n  &quot;重庆市-市辖区-永川区&quot;: [105.933499, 29.362046],\n  &quot;重庆市-市辖区-南川区&quot;: [107.105585, 29.163479],\n  &quot;重庆市-市辖区-璧山区&quot;: [106.233475, 29.598347],\n  &quot;重庆市-市辖区-铜梁区&quot;: [106.063449, 29.850509],\n  &quot;重庆市-市辖区-潼南区&quot;: [105.847399, 30.197314],\n  &quot;重庆市-市辖区-荣昌区&quot;: [105.60142, 29.411307],\n  &quot;重庆市-市辖区-开州区&quot;: [108.399498, 31.166644],\n  &quot;重庆市-县&quot;: [108.120414, 30.006109],\n  &quot;重庆市-县-梁平县&quot;: [107.7761, 30.660545],\n  &quot;重庆市-县-城口县&quot;: [108.671612, 31.953391],\n  &quot;重庆市-县-丰都县&quot;: [107.737481, 29.869413],\n  &quot;重庆市-县-垫江县&quot;: [107.339566, 30.333294],\n  &quot;重庆市-县-武隆县&quot;: [107.774902, 29.335005],\n  &quot;重庆市-县-忠县&quot;: [107.478814, 30.278161],\n  &quot;重庆市-县-云阳县&quot;: [108.703448, 30.936611],\n  &quot;重庆市-县-奉节县&quot;: [109.470473, 31.024602],\n  &quot;重庆市-县-巫山县&quot;: [109.885546, 31.080519],\n  &quot;重庆市-县-巫溪县&quot;: [109.576403, 31.40488],\n  &quot;重庆市-县-石柱土家族自治县&quot;: [109.576403, 31.40488],\n  &quot;重庆市-县-秀山土家族苗族自治县&quot;: [109.013574, 28.453448],\n  &quot;重庆市-县-酉阳土家族苗族自治县&quot;: [108.774586, 28.84704],\n  &quot;重庆市-县-彭水苗族土家族自治县&quot;: [108.172578, 29.299462],\n  &quot;四川省&quot;: [104.073467, 30.577543],\n  &quot;四川省-成都市&quot;: [104.081534, 30.655822],\n  &quot;四川省-成都市-锦江区&quot;: [104.089562, 30.661904],\n  &quot;四川省-成都市-青羊区&quot;: [104.067445, 30.680038],\n  &quot;四川省-成都市-金牛区&quot;: [104.057404, 30.697356],\n  &quot;四川省-成都市-武侯区&quot;: [104.049424, 30.648713],\n  &quot;四川省-成都市-成华区&quot;: [104.108592, 30.665589],\n  &quot;四川省-成都市-龙泉驿区&quot;: [104.281397, 30.562698],\n  &quot;四川省-成都市-青白江区&quot;: [104.257512, 30.884421],\n  &quot;四川省-成都市-新都区&quot;: [104.165393, 30.829407],\n  &quot;四川省-成都市-温江区&quot;: [103.863573, 30.688487],\n  &quot;四川省-成都市-双流区&quot;: [103.930392, 30.580399],\n  &quot;四川省-成都市-金堂县&quot;: [104.418443, 30.868358],\n  &quot;四川省-成都市-郫县&quot;: [103.905446, 30.799538],\n  &quot;四川省-成都市-大邑县&quot;: [103.52753, 30.593155],\n  &quot;四川省-成都市-蒲江县&quot;: [103.512571, 30.2025],\n  &quot;四川省-成都市-新津县&quot;: [103.817433, 30.416364],\n  &quot;四川省-成都市-都江堰市&quot;: [103.653534, 30.994257],\n  &quot;四川省-成都市-彭州市&quot;: [103.965561, 30.995564],\n  &quot;四川省-成都市-邛崃市&quot;: [103.470481, 30.416399],\n  &quot;四川省-成都市-崇州市&quot;: [103.679433, 30.636596],\n  &quot;四川省-成都市-简阳市&quot;: [104.569516, 30.3766],\n  &quot;四川省-自贡市&quot;: [104.784449, 29.345585],\n  &quot;四川省-自贡市-自流井区&quot;: [104.783447, 29.343499],\n  &quot;四川省-自贡市-贡井区&quot;: [104.721557, 29.351476],\n  &quot;四川省-自贡市-大安区&quot;: [104.780416, 29.369929],\n  &quot;四川省-自贡市-沿滩区&quot;: [104.880409, 29.278797],\n  &quot;四川省-自贡市-荣县&quot;: [104.423458, 29.451801],\n  &quot;四川省-自贡市-富顺县&quot;: [104.981494, 29.186886],\n  &quot;四川省-攀枝花市&quot;: [101.725541, 26.588033],\n  &quot;四川省-攀枝花市-东区&quot;: [101.710597, 26.552106],\n  &quot;四川省-攀枝花市-西区&quot;: [101.637413, 26.603868],\n  &quot;四川省-攀枝花市-仁和区&quot;: [101.74445, 26.504019],\n  &quot;四川省-攀枝花市-米易县&quot;: [102.11644, 26.896968],\n  &quot;四川省-攀枝花市-盐边县&quot;: [101.860499, 26.688767],\n  &quot;四川省-泸州市&quot;: [105.448524, 28.877668],\n  &quot;四川省-泸州市-江阳区&quot;: [105.441545, 28.884672],\n  &quot;四川省-泸州市-纳溪区&quot;: [105.377409, 28.77936],\n  &quot;四川省-泸州市-龙马潭区&quot;: [105.444544, 28.919012],\n  &quot;四川省-泸州市-泸县&quot;: [105.388456, 29.157626],\n  &quot;四川省-泸州市-合江县&quot;: [105.838432, 28.817793],\n  &quot;四川省-泸州市-叙永县&quot;: [105.451508, 28.161714],\n  &quot;四川省-泸州市-古蔺县&quot;: [105.819471, 28.044745],\n  &quot;四川省-德阳市&quot;: [104.404419, 31.133115],\n  &quot;四川省-德阳市-旌阳区&quot;: [104.423439, 31.148596],\n  &quot;四川省-德阳市-中江县&quot;: [104.68553, 31.038954],\n  &quot;四川省-德阳市-罗江县&quot;: [104.517414, 31.324179],\n  &quot;四川省-德阳市-广汉市&quot;: [104.288422, 30.982415],\n  &quot;四川省-德阳市-什邡市&quot;: [104.174427, 31.132889],\n  &quot;四川省-德阳市-绵竹市&quot;: [104.227609, 31.343592],\n  &quot;四川省-绵阳市&quot;: [104.685562, 31.473663],\n  &quot;四川省-绵阳市-涪城区&quot;: [104.76342, 31.461314],\n  &quot;四川省-绵阳市-游仙区&quot;: [104.772429, 31.479904],\n  &quot;四川省-绵阳市-安州区&quot;: [104.573555, 31.540751],\n  &quot;四川省-绵阳市-三台县&quot;: [105.10149, 31.101586],\n  &quot;四川省-绵阳市-盐亭县&quot;: [105.395503, 31.214319],\n  &quot;四川省-绵阳市-梓潼县&quot;: [105.177567, 31.648313],\n  &quot;四川省-绵阳市-北川羌族自治县&quot;: [104.361586, 31.963084],\n  &quot;四川省-绵阳市-平武县&quot;: [104.535422, 32.414682],\n  &quot;四川省-绵阳市-江油市&quot;: [104.752412, 31.784128],\n  &quot;四川省-广元市&quot;: [105.850423, 32.441616],\n  &quot;四川省-广元市-利州区&quot;: [105.852426, 32.440208],\n  &quot;四川省-广元市-昭化区&quot;: [105.969419, 32.329618],\n  &quot;四川省-广元市-朝天区&quot;: [105.896589, 32.649726],\n  &quot;四川省-广元市-旺苍县&quot;: [106.296491, 32.235097],\n  &quot;四川省-广元市-青川县&quot;: [105.245407, 32.581617],\n  &quot;四川省-广元市-剑阁县&quot;: [105.531576, 32.293479],\n  &quot;四川省-广元市-苍溪县&quot;: [105.941483, 31.738684],\n  &quot;四川省-遂宁市&quot;: [105.599422, 30.539098],\n  &quot;四川省-遂宁市-船山区&quot;: [105.574523, 30.531471],\n  &quot;四川省-遂宁市-安居区&quot;: [105.462467, 30.361496],\n  &quot;四川省-遂宁市-蓬溪县&quot;: [105.713446, 30.763751],\n  &quot;四川省-遂宁市-射洪县&quot;: [105.39451, 30.877139],\n  &quot;四川省-遂宁市-大英县&quot;: [105.243404, 30.60081],\n  &quot;四川省-内江市&quot;: [105.064588, 29.585887],\n  &quot;四川省-内江市-市中区&quot;: [105.074574, 29.59271],\n  &quot;四川省-内江市-东兴区&quot;: [105.082547, 29.598486],\n  &quot;四川省-内江市-威远县&quot;: [104.674498, 29.533635],\n  &quot;四川省-内江市-资中县&quot;: [104.858495, 29.770234],\n  &quot;四川省-内江市-隆昌县&quot;: [105.294572, 29.345245],\n  &quot;四川省-乐山市&quot;: [103.772538, 29.557941],\n  &quot;四川省-乐山市-市中区&quot;: [103.767559, 29.561364],\n  &quot;四川省-乐山市-沙湾区&quot;: [103.556436, 29.419272],\n  &quot;四川省-乐山市-五通桥区&quot;: [103.824455, 29.413185],\n  &quot;四川省-乐山市-金口河区&quot;: [103.085394, 29.250804],\n  &quot;四川省-乐山市-犍为县&quot;: [103.955507, 29.214219],\n  &quot;四川省-乐山市-井研县&quot;: [104.076511, 29.657303],\n  &quot;四川省-乐山市-夹江县&quot;: [103.57841, 29.743846],\n  &quot;四川省-乐山市-沐川县&quot;: [103.908467, 28.962888],\n  &quot;四川省-乐山市-峨边彝族自治县&quot;: [103.268577, 29.236089],\n  &quot;四川省-乐山市-马边彝族自治县&quot;: [103.552454, 28.841736],\n  &quot;四川省-乐山市-峨眉山市&quot;: [103.491546, 29.606976],\n  &quot;四川省-南充市&quot;: [106.117503, 30.843783],\n  &quot;四川省-南充市-顺庆区&quot;: [106.098411, 30.802753],\n  &quot;四川省-南充市-高坪区&quot;: [106.12554, 30.787255],\n  &quot;四川省-南充市-嘉陵区&quot;: [106.078433, 30.764896],\n  &quot;四川省-南充市-南部县&quot;: [106.043578, 31.353705],\n  &quot;四川省-南充市-营山县&quot;: [106.572408, 31.083003],\n  &quot;四川省-南充市-蓬安县&quot;: [106.418482, 31.034631],\n  &quot;四川省-南充市-仪陇县&quot;: [106.30943, 31.277597],\n  &quot;四川省-南充市-西充县&quot;: [105.907611, 31.000688],\n  &quot;四川省-南充市-阆中市&quot;: [106.011565, 31.564075],\n  &quot;四川省-眉山市&quot;: [103.856563, 30.082526],\n  &quot;四川省-眉山市-东坡区&quot;: [103.838525, 30.048272],\n  &quot;四川省-眉山市-彭山区&quot;: [103.879558, 30.198854],\n  &quot;四川省-眉山市-仁寿县&quot;: [104.140477, 30.001664],\n  &quot;四川省-眉山市-洪雅县&quot;: [103.379602, 29.910616],\n  &quot;四川省-眉山市-丹棱县&quot;: [103.519583, 30.020363],\n  &quot;四川省-眉山市-青神县&quot;: [103.853559, 29.837055],\n  &quot;四川省-宜宾市&quot;: [104.649404, 28.758007],\n  &quot;四川省-宜宾市-翠屏区&quot;: [104.626438, 28.772052],\n  &quot;四川省-宜宾市-南溪区&quot;: [104.976513, 28.851504],\n  &quot;四川省-宜宾市-宜宾县&quot;: [104.539443, 28.696246],\n  &quot;四川省-宜宾市-江安县&quot;: [105.073595, 28.72961],\n  &quot;四川省-宜宾市-长宁县&quot;: [104.927564, 28.588133],\n  &quot;四川省-宜宾市-高县&quot;: [104.524411, 28.442511],\n  &quot;四川省-宜宾市-珙县&quot;: [104.715575, 28.44432],\n  &quot;四川省-宜宾市-筠连县&quot;: [104.517406, 28.170174],\n  &quot;四川省-宜宾市-兴文县&quot;: [105.242402, 28.309905],\n  &quot;四川省-宜宾市-屏山县&quot;: [104.05945, 28.707647],\n  &quot;四川省-广安市&quot;: [106.639553, 30.461746],\n  &quot;四川省-广安市-广安区&quot;: [106.648531, 30.479768],\n  &quot;四川省-广安市-前锋区&quot;: [106.639553, 30.461746],\n  &quot;四川省-广安市-岳池县&quot;: [106.446411, 30.54412],\n  &quot;四川省-广安市-武胜县&quot;: [106.302462, 30.355496],\n  &quot;四川省-广安市-邻水县&quot;: [106.936403, 30.341073],\n  &quot;四川省-广安市-华蓥市&quot;: [106.789462, 30.396307],\n  &quot;四川省-达州市&quot;: [107.474594, 31.214308],\n  &quot;四川省-达州市-通川区&quot;: [107.511447, 31.220932],\n  &quot;四川省-达州市-达川区&quot;: [107.518411, 31.202393],\n  &quot;四川省-达州市-宣汉县&quot;: [107.733534, 31.359755],\n  &quot;四川省-达州市-开江县&quot;: [107.875425, 31.089372],\n  &quot;四川省-达州市-大竹县&quot;: [107.21158, 30.742077],\n  &quot;四川省-达州市-渠县&quot;: [106.979583, 30.842299],\n  &quot;四川省-达州市-万源市&quot;: [108.041541, 32.087421],\n  &quot;四川省-雅安市&quot;: [103.049543, 30.016793],\n  &quot;四川省-雅安市-雨城区&quot;: [103.039575, 30.011062],\n  &quot;四川省-雅安市-名山区&quot;: [103.115486, 30.075914],\n  &quot;四川省-雅安市-荥经县&quot;: [102.853436, 29.799194],\n  &quot;四川省-雅安市-汉源县&quot;: [102.658576, 29.350217],\n  &quot;四川省-雅安市-石棉县&quot;: [102.366405, 29.234305],\n  &quot;四川省-雅安市-天全县&quot;: [102.76453, 30.072473],\n  &quot;四川省-雅安市-芦山县&quot;: [102.934528, 30.149873],\n  &quot;四川省-雅安市-宝兴县&quot;: [102.821484, 30.374082],\n  &quot;四川省-巴中市&quot;: [106.751585, 31.872889],\n  &quot;四川省-巴中市-巴州区&quot;: [106.775513, 31.857686],\n  &quot;四川省-巴中市-恩阳区&quot;: [106.775513, 31.857686],\n  &quot;四川省-巴中市-通江县&quot;: [107.251517, 31.917714],\n  &quot;四川省-巴中市-南江县&quot;: [106.834483, 32.352532],\n  &quot;四川省-巴中市-平昌县&quot;: [107.110593, 31.566186],\n  &quot;四川省-资阳市&quot;: [104.634435, 30.134957],\n  &quot;四川省-资阳市-雁江区&quot;: [104.658424, 30.123753],\n  &quot;四川省-资阳市-安岳县&quot;: [105.342454, 30.103393],\n  &quot;四川省-资阳市-乐至县&quot;: [105.027477, 30.282348],\n  &quot;四川省-阿坝藏族羌族自治州&quot;: [102.231415, 31.905512],\n  &quot;四川省-阿坝藏族羌族自治州-马尔康市&quot;: [102.213502, 31.911748],\n  &quot;四川省-阿坝藏族羌族自治州-汶川县&quot;: [103.596518, 31.483005],\n  &quot;四川省-阿坝藏族羌族自治州-理县&quot;: [103.173511, 31.44255],\n  &quot;四川省-阿坝藏族羌族自治州-茂县&quot;: [103.85959, 31.686809],\n  &quot;四川省-阿坝藏族羌族自治州-松潘县&quot;: [103.61058, 32.661797],\n  &quot;四川省-阿坝藏族羌族自治州-九寨沟县&quot;: [104.249547, 33.257592],\n  &quot;四川省-阿坝藏族羌族自治州-金川县&quot;: [102.07061, 31.482006],\n  &quot;四川省-阿坝藏族羌族自治州-小金县&quot;: [102.369426, 31.002209],\n  &quot;四川省-阿坝藏族羌族自治州-黑水县&quot;: [102.996517, 32.067805],\n  &quot;四川省-阿坝藏族羌族自治州-壤塘县&quot;: [100.985583, 32.271093],\n  &quot;四川省-阿坝藏族羌族自治州-阿坝县&quot;: [101.71361, 32.908221],\n  &quot;四川省-阿坝藏族羌族自治州-若尔盖县&quot;: [102.974391, 33.584377],\n  &quot;四川省-阿坝藏族羌族自治州-红原县&quot;: [102.550615, 32.796605],\n  &quot;四川省-甘孜藏族自治州&quot;: [101.968547, 30.055279],\n  &quot;四川省-甘孜藏族自治州-康定市&quot;: [101.963555, 30.004407],\n  &quot;四川省-甘孜藏族自治州-泸定县&quot;: [102.241432, 29.920402],\n  &quot;四川省-甘孜藏族自治州-丹巴县&quot;: [101.896437, 30.88477],\n  &quot;四川省-甘孜藏族自治州-九龙县&quot;: [101.896437, 30.88477],\n  &quot;四川省-甘孜藏族自治州-雅江县&quot;: [101.0205, 30.037569],\n  &quot;四川省-甘孜藏族自治州-道孚县&quot;: [101.13154, 30.985326],\n  &quot;四川省-甘孜藏族自治州-炉霍县&quot;: [100.682397, 31.397992],\n  &quot;四川省-甘孜藏族自治州-甘孜县&quot;: [99.99921, 31.628957],\n  &quot;四川省-甘孜藏族自治州-新龙县&quot;: [100.318398, 30.94547],\n  &quot;四川省-甘孜藏族自治州-德格县&quot;: [98.587402, 31.812106],\n  &quot;四川省-甘孜藏族自治州-白玉县&quot;: [98.8311, 31.215314],\n  &quot;四川省-甘孜藏族自治州-石渠县&quot;: [98.109481, 32.984003],\n  &quot;四川省-甘孜藏族自治州-色达县&quot;: [100.339414, 32.27433],\n  &quot;四川省-甘孜藏族自治州-理塘县&quot;: [100.275575, 30.000031],\n  &quot;四川省-甘孜藏族自治州-巴塘县&quot;: [99.116727, 30.011662],\n  &quot;四川省-甘孜藏族自治州-乡城县&quot;: [99.80506, 28.936733],\n  &quot;四川省-甘孜藏族自治州-稻城县&quot;: [100.304462, 29.043122],\n  &quot;四川省-甘孜藏族自治州-得荣县&quot;: [99.292984, 28.71878],\n  &quot;四川省-凉山彝族自治州&quot;: [102.273503, 27.887752],\n  &quot;四川省-凉山彝族自治州-西昌市&quot;: [102.271484, 27.900581],\n  &quot;四川省-凉山彝族自治州-木里藏族自治县&quot;: [101.286397, 27.934599],\n  &quot;四川省-凉山彝族自治州-盐源县&quot;: [101.515429, 27.428155],\n  &quot;四川省-凉山彝族自治州-德昌县&quot;: [102.182596, 27.408504],\n  &quot;四川省-凉山彝族自治州-会理县&quot;: [102.251436, 26.6612],\n  &quot;四川省-凉山彝族自治州-会东县&quot;: [102.584462, 26.640824],\n  &quot;四川省-凉山彝族自治州-宁南县&quot;: [102.762526, 27.064605],\n  &quot;四川省-凉山彝族自治州-普格县&quot;: [102.546597, 27.381996],\n  &quot;四川省-凉山彝族自治州-布拖县&quot;: [102.818478, 27.712129],\n  &quot;四川省-凉山彝族自治州-金阳县&quot;: [103.254549, 27.702145],\n  &quot;四川省-凉山彝族自治州-昭觉县&quot;: [102.849423, 28.020506],\n  &quot;四川省-凉山彝族自治州-喜德县&quot;: [102.419567, 28.31271],\n  &quot;四川省-凉山彝族自治州-冕宁县&quot;: [102.183575, 28.555294],\n  &quot;四川省-凉山彝族自治州-越西县&quot;: [102.514474, 28.645828],\n  &quot;四川省-凉山彝族自治州-甘洛县&quot;: [102.778597, 28.964823],\n  &quot;四川省-凉山彝族自治州-美姑县&quot;: [103.138586, 28.33402],\n  &quot;四川省-凉山彝族自治州-雷波县&quot;: [103.578429, 28.268951],\n  &quot;贵州省&quot;: [106.714476, 26.60403],\n  &quot;贵州省-贵阳市&quot;: [106.714476, 26.60403],\n  &quot;贵州省-贵阳市-南明区&quot;: [106.720528, 26.574336],\n  &quot;贵州省-贵阳市-云岩区&quot;: [106.730535, 26.610381],\n  &quot;贵州省-贵阳市-花溪区&quot;: [106.676441, 26.415879],\n  &quot;贵州省-贵阳市-乌当区&quot;: [106.757558, 26.636529],\n  &quot;贵州省-贵阳市-白云区&quot;: [106.629597, 26.683588],\n  &quot;贵州省-贵阳市-观山湖区&quot;: [106.757558, 26.636529],\n  &quot;贵州省-贵阳市-开阳县&quot;: [106.97156, 27.063674],\n  &quot;贵州省-贵阳市-息烽县&quot;: [106.747562, 27.096475],\n  &quot;贵州省-贵阳市-修文县&quot;: [106.598492, 26.844862],\n  &quot;贵州省-贵阳市-清镇市&quot;: [106.477523, 26.561988],\n  &quot;贵州省-六盘水市&quot;: [104.837555, 26.598833],\n  &quot;贵州省-六盘水市-钟山区&quot;: [104.85053, 26.580704],\n  &quot;贵州省-六盘水市-六枝特区&quot;: [105.483429, 26.219214],\n  &quot;贵州省-六盘水市-水城县&quot;: [104.964566, 26.55372],\n  &quot;贵州省-六盘水市-盘县&quot;: [104.478582, 25.715651],\n  &quot;贵州省-遵义市&quot;: [106.933428, 27.731701],\n  &quot;贵州省-遵义市-红花岗区&quot;: [106.900497, 27.65087],\n  &quot;贵州省-遵义市-汇川区&quot;: [106.940458, 27.756343],\n  &quot;贵州省-遵义市-播州区&quot;: [106.836504, 27.542501],\n  &quot;贵州省-遵义市-桐梓县&quot;: [106.832489, 28.139468],\n  &quot;贵州省-遵义市-绥阳县&quot;: [107.197492, 27.95308],\n  &quot;贵州省-遵义市-正安县&quot;: [107.460575, 28.559092],\n  &quot;贵州省-遵义市-道真仡佬族苗族自治县&quot;: [107.619484, 28.86865],\n  &quot;贵州省-遵义市-务川仡佬族苗族自治县&quot;: [107.905456, 28.569077],\n  &quot;贵州省-遵义市-凤冈县&quot;: [107.723548, 27.960695],\n  &quot;贵州省-遵义市-湄潭县&quot;: [107.472599, 27.754498],\n  &quot;贵州省-遵义市-余庆县&quot;: [107.91146, 27.221379],\n  &quot;贵州省-遵义市-习水县&quot;: [106.203428, 28.339118],\n  &quot;贵州省-遵义市-赤水市&quot;: [105.703489, 28.596119],\n  &quot;贵州省-遵义市-仁怀市&quot;: [106.407527, 27.797752],\n  &quot;贵州省-安顺市&quot;: [105.954417, 26.259252],\n  &quot;贵州省-安顺市-西秀区&quot;: [105.972406, 26.251498],\n  &quot;贵州省-安顺市-平坝区&quot;: [106.263584, 26.411186],\n  &quot;贵州省-安顺市-普定县&quot;: [105.748486, 26.308233],\n  &quot;贵州省-安顺市-镇宁布依族苗族自治县&quot;: [105.776583, 26.063829],\n  &quot;贵州省-安顺市-关岭布依族苗族自治县&quot;: [105.625476, 25.949877],\n  &quot;贵州省-安顺市-紫云苗族布依族自治县&quot;: [106.090414, 25.757409],\n  &quot;贵州省-毕节市&quot;: [105.311581, 27.304095],\n  &quot;贵州省-毕节市-七星关区&quot;: [105.311581, 27.304095],\n  &quot;贵州省-毕节市-大方县&quot;: [105.611399, 27.165261],\n  &quot;贵州省-毕节市-黔西县&quot;: [106.038574, 27.014345],\n  &quot;贵州省-毕节市-金沙县&quot;: [106.226442, 27.465355],\n  &quot;贵州省-毕节市-织金县&quot;: [105.77759, 26.669222],\n  &quot;贵州省-毕节市-纳雍县&quot;: [105.389487, 26.783717],\n  &quot;贵州省-毕节市-威宁彝族回族苗族自治县&quot;: [104.282508, 26.875711],\n  &quot;贵州省-毕节市-赫章县&quot;: [104.733516, 27.129052],\n  &quot;贵州省-铜仁市&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-碧江区&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-万山区&quot;: [109.187435, 27.696773],\n  &quot;贵州省-铜仁市-江口县&quot;: [108.857371, 27.699558],\n  &quot;贵州省-铜仁市-玉屏侗族自治县&quot;: [109.024903, 27.455339],\n  &quot;贵州省-铜仁市-石阡县&quot;: [108.230464, 27.519722],\n  &quot;贵州省-铜仁市-思南县&quot;: [109.195295, 27.743042],\n  &quot;贵州省-铜仁市-印江土家族苗族自治县&quot;: [108.415088, 27.999307],\n  &quot;贵州省-铜仁市-德江县&quot;: [108.126401, 28.270733],\n  &quot;贵州省-铜仁市-沿河土家族自治县&quot;: [108.50793, 28.570124],\n  &quot;贵州省-铜仁市-松桃苗族自治县&quot;: [109.134326, 27.875214],\n  &quot;贵州省-黔西南布依族苗族自治州&quot;: [104.912492, 25.093967],\n  &quot;贵州省-黔西南布依族苗族自治州-兴义市&quot;: [104.902461, 25.098113],\n  &quot;贵州省-黔西南布依族苗族自治州-兴仁县&quot;: [105.192568, 25.440899],\n  &quot;贵州省-黔西南布依族苗族自治州-普安县&quot;: [104.959546, 25.789952],\n  &quot;贵州省-黔西南布依族苗族自治州-晴隆县&quot;: [105.225484, 25.841048],\n  &quot;贵州省-黔西南布依族苗族自治州-贞丰县&quot;: [105.65656, 25.392124],\n  &quot;贵州省-黔西南布依族苗族自治州-望谟县&quot;: [106.106445, 25.184355],\n  &quot;贵州省-黔西南布依族苗族自治州-册亨县&quot;: [105.818511, 24.989637],\n  &quot;贵州省-黔西南布依族苗族自治州-安龙县&quot;: [105.449543, 25.10399],\n  &quot;贵州省-黔东南苗族侗族自治州&quot;: [107.989446, 26.589703],\n  &quot;贵州省-黔东南苗族侗族自治州-凯里市&quot;: [107.987469, 26.573079],\n  &quot;贵州省-黔东南苗族侗族自治州-黄平县&quot;: [107.923548, 26.911289],\n  &quot;贵州省-黔东南苗族侗族自治州-施秉县&quot;: [108.13044, 27.039822],\n  &quot;贵州省-黔东南苗族侗族自治州-三穗县&quot;: [108.681545, 26.958666],\n  &quot;贵州省-黔东南苗族侗族自治州-镇远县&quot;: [108.436581, 27.054821],\n  &quot;贵州省-黔东南苗族侗族自治州-岑巩县&quot;: [108.822481, 27.179902],\n  &quot;贵州省-黔东南苗族侗族自治州-天柱县&quot;: [109.214446, 26.915804],\n  &quot;贵州省-黔东南苗族侗族自治州-锦屏县&quot;: [109.207438, 26.682632],\n  &quot;贵州省-黔东南苗族侗族自治州-剑河县&quot;: [108.447517, 26.734048],\n  &quot;贵州省-黔东南苗族侗族自治州-台江县&quot;: [108.328552, 26.672373],\n  &quot;贵州省-黔东南苗族侗族自治州-黎平县&quot;: [109.143567, 26.236874],\n  &quot;贵州省-黔东南苗族侗族自治州-榕江县&quot;: [108.527554, 25.937725],\n  &quot;贵州省-黔东南苗族侗族自治州-从江县&quot;: [108.911561, 25.759881],\n  &quot;贵州省-黔东南苗族侗族自治州-雷山县&quot;: [108.084529, 26.384205],\n  &quot;贵州省-黔东南苗族侗族自治州-麻江县&quot;: [107.595551, 26.496808],\n  &quot;贵州省-黔东南苗族侗族自治州-丹寨县&quot;: [107.795513, 26.204421],\n  &quot;贵州省-黔南布依族苗族自治州&quot;: [107.528403, 26.260616],\n  &quot;贵州省-黔南布依族苗族自治州-都匀市&quot;: [107.525404, 26.266118],\n  &quot;贵州省-黔南布依族苗族自治州-福泉市&quot;: [107.526433, 26.692526],\n  &quot;贵州省-黔南布依族苗族自治州-荔波县&quot;: [107.893409, 25.417098],\n  &quot;贵州省-黔南布依族苗族自治州-贵定县&quot;: [107.240554, 26.59066],\n  &quot;贵州省-黔南布依族苗族自治州-瓮安县&quot;: [107.477552, 27.084126],\n  &quot;贵州省-黔南布依族苗族自治州-独山县&quot;: [107.551498, 25.828288],\n  &quot;贵州省-黔南布依族苗族自治州-平塘县&quot;: [107.329567, 25.828202],\n  &quot;贵州省-黔南布依族苗族自治州-罗甸县&quot;: [106.758548, 25.430838],\n  &quot;贵州省-黔南布依族苗族自治州-长顺县&quot;: [106.458421, 26.028455],\n  &quot;贵州省-黔南布依族苗族自治州-龙里县&quot;: [106.986586, 26.459081],\n  &quot;贵州省-黔南布依族苗族自治州-惠水县&quot;: [106.663453, 26.13821],\n  &quot;贵州省-黔南布依族苗族自治州-三都水族自治县&quot;: [107.876429, 25.989479],\n  &quot;云南省&quot;: [102.716416, 25.051562],\n  &quot;云南省-昆明市&quot;: [102.852448, 24.873998],\n  &quot;云南省-昆明市-五华区&quot;: [102.713423, 25.049835],\n  &quot;云南省-昆明市-盘龙区&quot;: [102.758526, 25.122372],\n  &quot;云南省-昆明市-官渡区&quot;: [102.750482, 25.021196],\n  &quot;云南省-昆明市-西山区&quot;: [102.671557, 25.043199],\n  &quot;云南省-昆明市-东川区&quot;: [103.194452, 26.089054],\n  &quot;云南省-昆明市-呈贡区&quot;: [102.827473, 24.891871],\n  &quot;云南省-昆明市-晋宁县&quot;: [102.602418, 24.676099],\n  &quot;云南省-昆明市-富民县&quot;: [102.504473, 25.228085],\n  &quot;云南省-昆明市-宜良县&quot;: [103.147558, 24.925287],\n  &quot;云南省-昆明市-石林彝族自治县&quot;: [103.296508, 24.777702],\n  &quot;云南省-昆明市-嵩明县&quot;: [103.043564, 25.344409],\n  &quot;云南省-昆明市-禄劝彝族苗族自治县&quot;: [102.477423, 25.557672],\n  &quot;云南省-昆明市-寻甸回族彝族自治县&quot;: [103.263574, 25.563894],\n  &quot;云南省-昆明市-安宁市&quot;: [102.484409, 24.925602],\n  &quot;云南省-曲靖市&quot;: [103.802435, 25.496407],\n  &quot;云南省-曲靖市-麒麟区&quot;: [103.81143, 25.502102],\n  &quot;云南省-曲靖市-沾益区&quot;: [103.828485, 25.606631],\n  &quot;云南省-曲靖市-马龙县&quot;: [103.585447, 25.433966],\n  &quot;云南省-曲靖市-陆良县&quot;: [103.673432, 25.035639],\n  &quot;云南省-曲靖市-师宗县&quot;: [103.991556, 24.827995],\n  &quot;云南省-曲靖市-罗平县&quot;: [104.31551, 24.89052],\n  &quot;云南省-曲靖市-富源县&quot;: [104.261474, 25.68028],\n  &quot;云南省-曲靖市-会泽县&quot;: [103.303487, 26.424215],\n  &quot;云南省-曲靖市-宣威市&quot;: [104.111576, 26.225598],\n  &quot;云南省-玉溪市&quot;: [102.55356, 24.357711],\n  &quot;云南省-玉溪市-红塔区&quot;: [102.551565, 24.359801],\n  &quot;云南省-玉溪市-江川区&quot;: [102.760527, 24.293439],\n  &quot;云南省-玉溪市-澄江县&quot;: [102.914555, 24.679415],\n  &quot;云南省-玉溪市-通海县&quot;: [102.732423, 24.117891],\n  &quot;云南省-玉溪市-华宁县&quot;: [102.935492, 24.198581],\n  &quot;云南省-玉溪市-易门县&quot;: [102.169535, 24.677404],\n  &quot;云南省-玉溪市-峨山彝族自治县&quot;: [102.412565, 24.174774],\n  &quot;云南省-玉溪市-新平彝族傣族自治县&quot;: [101.996428, 24.076263],\n  &quot;云南省-玉溪市-元江哈尼族彝族傣族自治县&quot;: [102.004415, 23.603001],\n  &quot;云南省-保山市&quot;: [99.177273, 25.139039],\n  &quot;云南省-保山市-隆阳区&quot;: [99.172071, 25.126888],\n  &quot;云南省-保山市-施甸县&quot;: [99.195469, 24.728835],\n  &quot;云南省-保山市-龙陵县&quot;: [98.69575, 24.592547],\n  &quot;云南省-保山市-昌宁县&quot;: [99.611617, 24.833985],\n  &quot;云南省-保山市-腾冲市&quot;: [98.497595, 25.026617],\n  &quot;云南省-昭通市&quot;: [103.723512, 27.344084],\n  &quot;云南省-昭通市-昭阳区&quot;: [103.71347, 27.326144],\n  &quot;云南省-昭通市-鲁甸县&quot;: [103.564412, 27.193107],\n  &quot;云南省-昭通市-巧家县&quot;: [102.936519, 26.914705],\n  &quot;云南省-昭通市-盐津县&quot;: [104.241579, 28.114384],\n  &quot;云南省-昭通市-大关县&quot;: [103.897515, 27.754021],\n  &quot;云南省-昭通市-永善县&quot;: [103.644569, 28.234722],\n  &quot;云南省-昭通市-绥江县&quot;: [103.964552, 28.604278],\n  &quot;云南省-昭通市-镇雄县&quot;: [104.880404, 27.447795],\n  &quot;云南省-昭通市-彝良县&quot;: [104.054443, 27.63169],\n  &quot;云南省-昭通市-威信县&quot;: [105.055577, 27.852537],\n  &quot;云南省-昭通市-水富县&quot;: [104.422433, 28.636107],\n  &quot;云南省-丽江市&quot;: [100.232465, 26.860657],\n  &quot;云南省-丽江市-古城区&quot;: [100.23248, 26.883162],\n  &quot;云南省-丽江市-玉龙纳西族自治县&quot;: [100.243527, 26.827392],\n  &quot;云南省-丽江市-永胜县&quot;: [100.757581, 26.68995],\n  &quot;云南省-丽江市-华坪县&quot;: [101.27243, 26.635223],\n  &quot;云南省-丽江市-宁蒗彝族自治县&quot;: [100.85859, 27.287728],\n  &quot;云南省-普洱市&quot;: [100.97257, 22.830979],\n  &quot;云南省-普洱市-思茅区&quot;: [100.983555, 22.792498],\n  &quot;云南省-普洱市-宁洱哈尼族彝族自治县&quot;: [101.052442, 23.05459],\n  &quot;云南省-普洱市-墨江哈尼族自治县&quot;: [101.698584, 23.437726],\n  &quot;云南省-普洱市-景东彝族自治县&quot;: [100.838489, 24.451864],\n  &quot;云南省-普洱市-景谷傣族彝族自治县&quot;: [100.838489, 24.451864],\n  &quot;云南省-普洱市-镇沅彝族哈尼族拉祜族自治县&quot;: [101.115569, 24.010331],\n  &quot;云南省-普洱市-江城哈尼族彝族自治县&quot;: [101.868479, 22.591684],\n  &quot;云南省-普洱市-孟连傣族拉祜族佤族自治县&quot;: [99.590963, 22.335308],\n  &quot;云南省-普洱市-澜沧拉祜族自治县&quot;: [99.938588, 22.561832],\n  &quot;云南省-普洱市-西盟佤族自治县&quot;: [99.596622, 22.650656],\n  &quot;云南省-临沧市&quot;: [100.09544, 23.890469],\n  &quot;云南省-临沧市-临翔区&quot;: [100.088443, 23.901402],\n  &quot;云南省-临沧市-凤庆县&quot;: [99.934989, 24.586472],\n  &quot;云南省-临沧市-云县&quot;: [100.129531, 24.442807],\n  &quot;云南省-临沧市-永德县&quot;: [99.265076, 24.024871],\n  &quot;云南省-临沧市-镇康县&quot;: [98.831871, 23.768315],\n  &quot;云南省-临沧市-双江拉祜族佤族布朗族傣族自治县&quot;: [99.834131, 23.479837],\n  &quot;云南省-临沧市-耿马傣族佤族自治县&quot;: [99.403942, 23.543491],\n  &quot;云南省-临沧市-沧源佤族自治县&quot;: [99.252722, 23.152879],\n  &quot;云南省-楚雄彝族自治州&quot;: [101.534412, 25.051774],\n  &quot;云南省-楚雄彝族自治州-楚雄市&quot;: [101.552472, 25.03886],\n  &quot;云南省-楚雄彝族自治州-双柏县&quot;: [101.552472, 25.03886],\n  &quot;云南省-楚雄彝族自治州-牟定县&quot;: [101.553481, 25.318846],\n  &quot;云南省-楚雄彝族自治州-南华县&quot;: [101.280421, 25.198587],\n  &quot;云南省-楚雄彝族自治州-姚安县&quot;: [101.248527, 25.509775],\n  &quot;云南省-楚雄彝族自治州-大姚县&quot;: [101.330567, 25.727601],\n  &quot;云南省-楚雄彝族自治州-永仁县&quot;: [101.672493, 26.055566],\n  &quot;云南省-楚雄彝族自治州-元谋县&quot;: [101.880445, 25.710895],\n  &quot;云南省-楚雄彝族自治州-武定县&quot;: [102.410532, 25.53609],\n  &quot;云南省-楚雄彝族自治州-禄丰县&quot;: [102.085531, 25.155831],\n  &quot;云南省-红河哈尼族彝族自治州&quot;: [103.381549, 23.369996],\n  &quot;云南省-红河哈尼族彝族自治州-个旧市&quot;: [103.166519, 23.364942],\n  &quot;云南省-红河哈尼族彝族自治州-开远市&quot;: [103.166519, 23.364942],\n  &quot;云南省-红河哈尼族彝族自治州-蒙自市&quot;: [103.371546, 23.40208],\n  &quot;云南省-红河哈尼族彝族自治州-弥勒市&quot;: [103.421489, 24.417982],\n  &quot;云南省-红河哈尼族彝族自治州-屏边苗族自治县&quot;: [103.693432, 22.98999],\n  &quot;云南省-红河哈尼族彝族自治州-建水县&quot;: [102.83344, 23.640939],\n  &quot;云南省-红河哈尼族彝族自治州-石屏县&quot;: [102.502447, 23.712004],\n  &quot;云南省-红河哈尼族彝族自治州-泸西县&quot;: [103.772523, 24.538037],\n  &quot;云南省-红河哈尼族彝族自治州-元阳县&quot;: [102.841433, 23.226198],\n  &quot;云南省-红河哈尼族彝族自治州-红河县&quot;: [102.427551, 23.374489],\n  &quot;云南省-红河哈尼族彝族自治州-金平苗族瑶族傣族自治县&quot;: [102.427551, 23.374489],\n  &quot;云南省-红河哈尼族彝族自治州-绿春县&quot;: [102.398494, 23.000165],\n  &quot;云南省-红河哈尼族彝族自治州-河口瑶族自治县&quot;: [103.945444, 22.535466],\n  &quot;云南省-文山壮族苗族自治州&quot;: [104.222569, 23.405994],\n  &quot;云南省-文山壮族苗族自治州-文山市&quot;: [104.238544, 23.391944],\n  &quot;云南省-文山壮族苗族自治州-砚山县&quot;: [104.343551, 23.611487],\n  &quot;云南省-文山壮族苗族自治州-西畴县&quot;: [104.678525, 23.443271],\n  &quot;云南省-文山壮族苗族自治州-麻栗坡县&quot;: [104.709549, 23.131586],\n  &quot;云南省-文山壮族苗族自治州-马关县&quot;: [104.400415, 23.018994],\n  &quot;云南省-文山壮族苗族自治州-丘北县&quot;: [104.173442, 24.056994],\n  &quot;云南省-文山壮族苗族自治州-广南县&quot;: [105.061582, 24.052199],\n  &quot;云南省-文山壮族苗族自治州-富宁县&quot;: [105.63749, 23.63138],\n  &quot;云南省-西双版纳傣族自治州&quot;: [100.803447, 22.013601],\n  &quot;云南省-西双版纳傣族自治州-景洪市&quot;: [100.806443, 22.017004],\n  &quot;云南省-西双版纳傣族自治州-勐海县&quot;: [100.459446, 21.963434],\n  &quot;云南省-西双版纳傣族自治州-勐腊县&quot;: [101.571528, 21.465281],\n  &quot;云南省-大理白族自治州&quot;: [100.274583, 25.612128],\n  &quot;云南省-大理白族自治州-大理市&quot;: [100.236519, 25.597605],\n  &quot;云南省-大理白族自治州-漾濞彝族自治县&quot;: [100.236519, 25.597605],\n  &quot;云南省-大理白族自治州-祥云县&quot;: [100.557447, 25.489873],\n  &quot;云南省-大理白族自治州-宾川县&quot;: [100.578457, 25.835249],\n  &quot;云南省-大理白族自治州-弥渡县&quot;: [100.497586, 25.349336],\n  &quot;云南省-大理白族自治州-南涧彝族自治县&quot;: [100.497586, 25.349336],\n  &quot;云南省-大理白族自治州-巍山彝族回族自治县&quot;: [100.31346, 25.233439],\n  &quot;云南省-大理白族自治州-永平县&quot;: [99.547495, 25.470206],\n  &quot;云南省-大理白族自治州-云龙县&quot;: [99.377416, 25.891945],\n  &quot;云南省-大理白族自治州-洱源县&quot;: [99.96921, 26.120093],\n  &quot;云南省-大理白族自治州-剑川县&quot;: [99.912091, 26.542517],\n  &quot;云南省-大理白族自治州-鹤庆县&quot;: [100.182492, 26.566197],\n  &quot;云南省-德宏傣族景颇族自治州&quot;: [98.591359, 24.438011],\n  &quot;云南省-德宏傣族景颇族自治州-瑞丽市&quot;: [97.862486, 24.022817],\n  &quot;云南省-德宏傣族景颇族自治州-芒市&quot;: [97.862486, 24.022817],\n  &quot;云南省-德宏傣族景颇族自治州-梁河县&quot;: [98.303134, 24.810784],\n  &quot;云南省-德宏傣族景颇族自治州-盈江县&quot;: [97.938427, 24.711534],\n  &quot;云南省-德宏傣族景颇族自治州-陇川县&quot;: [97.79853, 24.189468],\n  &quot;云南省-怒江傈僳族自治州&quot;: [98.863288, 25.823707],\n  &quot;云南省-怒江傈僳族自治州-泸水市&quot;: [98.864586, 25.829027],\n  &quot;云南省-怒江傈僳族自治州-福贡县&quot;: [98.875649, 26.908055],\n  &quot;云南省-怒江傈僳族自治州-贡山独龙族怒族自治县&quot;: [98.672399, 27.747068],\n  &quot;云南省-怒江傈僳族自治州-兰坪白族普米族自治县&quot;: [99.423285, 26.459208],\n  &quot;云南省-迪庆藏族自治州&quot;: [99.70953, 27.825185],\n  &quot;云南省-迪庆藏族自治州-香格里拉市&quot;: [99.707445, 27.83576],\n  &quot;云南省-迪庆藏族自治州-德钦县&quot;: [98.924453, 28.470086],\n  &quot;云南省-迪庆藏族自治州-维西傈僳族自治县&quot;: [99.293466, 27.18317],\n  &quot;西藏自治区&quot;: [91.124342, 29.652894],\n  &quot;西藏自治区-拉萨市&quot;: [91.120824, 29.65004],\n  &quot;西藏自治区-拉萨市-城关区&quot;: [91.1451, 29.658331],\n  &quot;西藏自治区-拉萨市-堆龙德庆区&quot;: [91.009963, 29.651626],\n  &quot;西藏自治区-拉萨市-林周县&quot;: [91.269501, 29.898733],\n  &quot;西藏自治区-拉萨市-当雄县&quot;: [91.107452, 30.479222],\n  &quot;西藏自治区-拉萨市-尼木县&quot;: [90.17118, 29.437519],\n  &quot;西藏自治区-拉萨市-曲水县&quot;: [90.749959, 29.358987],\n  &quot;西藏自治区-拉萨市-达孜县&quot;: [91.356318, 29.675409],\n  &quot;西藏自治区-拉萨市-墨竹工卡县&quot;: [91.737266, 29.839753],\n  &quot;西藏自治区-日喀则市&quot;: [88.902952, 29.255583],\n  &quot;西藏自治区-日喀则市-桑珠孜区&quot;: [88.902952, 29.255583],\n  &quot;西藏自治区-日喀则市-南木林县&quot;: [89.108283, 29.688959],\n  &quot;西藏自治区-日喀则市-江孜县&quot;: [89.614958, 28.916435],\n  &quot;西藏自治区-日喀则市-定日县&quot;: [88.859425, 29.004648],\n  &quot;西藏自治区-日喀则市-萨迦县&quot;: [88.02935, 28.907594],\n  &quot;西藏自治区-日喀则市-拉孜县&quot;: [88.893863, 29.273927],\n  &quot;西藏自治区-日喀则市-昂仁县&quot;: [88.88319, 29.271424],\n  &quot;西藏自治区-日喀则市-谢通门县&quot;: [88.267177, 29.436132],\n  &quot;西藏自治区-日喀则市-白朗县&quot;: [89.267941, 29.116209],\n  &quot;西藏自治区-日喀则市-仁布县&quot;: [89.848427, 29.236361],\n  &quot;西藏自治区-日喀则市-康马县&quot;: [89.688245, 28.561444],\n  &quot;西藏自治区-日喀则市-定结县&quot;: [87.772377, 28.369911],\n  &quot;西藏自治区-日喀则市-仲巴县&quot;: [84.038117, 29.775982],\n  &quot;西藏自治区-日喀则市-亚东县&quot;: [88.896978, 29.275644],\n  &quot;西藏自治区-日喀则市-吉隆县&quot;: [88.662548, 29.401862],\n  &quot;西藏自治区-日喀则市-聂拉木县&quot;: [88.889064, 29.275236],\n  &quot;西藏自治区-日喀则市-萨嘎县&quot;: [88.647947, 29.079969],\n  &quot;西藏自治区-日喀则市-岗巴县&quot;: [89.322529, 29.277094],\n  &quot;西藏自治区-昌都市&quot;: [97.186654, 31.144249],\n  &quot;西藏自治区-昌都市-卡若区&quot;: [97.186654, 31.144249],\n  &quot;西藏自治区-昌都市-江达县&quot;: [98.224424, 31.505147],\n  &quot;西藏自治区-昌都市-贡觉县&quot;: [98.277334, 30.865967],\n  &quot;西藏自治区-昌都市-类乌齐县&quot;: [96.608489, 31.22509],\n  &quot;西藏自治区-昌都市-丁青县&quot;: [97.177402, 31.149643],\n  &quot;西藏自治区-昌都市-察雅县&quot;: [97.575976, 30.660119],\n  &quot;西藏自治区-昌都市-八宿县&quot;: [96.931495, 30.061833],\n  &quot;西藏自治区-昌都市-左贡县&quot;: [97.847367, 29.676849],\n  &quot;西藏自治区-昌都市-芒康县&quot;: [96.848134, 30.738561],\n  &quot;西藏自治区-昌都市-洛隆县&quot;: [97.399916, 31.06774],\n  &quot;西藏自治区-昌都市-边坝县&quot;: [94.714371, 30.939625],\n  &quot;西藏自治区-林芝市&quot;: [94.368058, 29.654042],\n  &quot;西藏自治区-林芝市-巴宜区&quot;: [94.367544, 29.641645],\n  &quot;西藏自治区-林芝市-工布江达县&quot;: [93.25242, 29.891368],\n  &quot;西藏自治区-林芝市-米林县&quot;: [94.219939, 29.220917],\n  &quot;西藏自治区-林芝市-墨脱县&quot;: [95.339495, 29.330938],\n  &quot;西藏自治区-林芝市-波密县&quot;: [95.7739, 29.86506],\n  &quot;西藏自治区-林芝市-察隅县&quot;: [97.47327, 28.667444],\n  &quot;西藏自治区-林芝市-朗县&quot;: [93.081368, 29.051902],\n  &quot;西藏自治区-山南市&quot;: [91.778675, 29.243027],\n  &quot;西藏自治区-山南市-乃东区&quot;: [91.778682, 29.234229],\n  &quot;西藏自治区-山南市-扎囊县&quot;: [91.343627, 29.251164],\n  &quot;西藏自治区-山南市-贡嘎县&quot;: [91.343627, 29.251164],\n  &quot;西藏自治区-山南市-桑日县&quot;: [92.021252, 29.267104],\n  &quot;西藏自治区-山南市-琼结县&quot;: [91.690101, 29.030866],\n  &quot;西藏自治区-山南市-曲松县&quot;: [92.205435, 29.071107],\n  &quot;西藏自治区-山南市-措美县&quot;: [91.439918, 28.444258],\n  &quot;西藏自治区-山南市-洛扎县&quot;: [90.855029, 28.391993],\n  &quot;西藏自治区-山南市-加查县&quot;: [92.601582, 29.144787],\n  &quot;西藏自治区-山南市-隆子县&quot;: [92.469078, 28.414441],\n  &quot;西藏自治区-山南市-错那县&quot;: [91.968115, 27.998343],\n  &quot;西藏自治区-山南市-浪卡子县&quot;: [90.404647, 28.973992],\n  &quot;西藏自治区-那曲地区&quot;: [92.057338, 31.482438],\n  &quot;西藏自治区-那曲地区-那曲县&quot;: [92.059847, 31.476117],\n  &quot;西藏自治区-那曲地区-嘉黎县&quot;: [93.238732, 30.647062],\n  &quot;西藏自治区-那曲地区-比如县&quot;: [93.685966, 31.486357],\n  &quot;西藏自治区-那曲地区-聂荣县&quot;: [92.308654, 32.113707],\n  &quot;西藏自治区-那曲地区-安多县&quot;: [91.688891, 32.271268],\n  &quot;西藏自治区-那曲地区-申扎县&quot;: [88.716481, 30.936393],\n  &quot;西藏自治区-那曲地区-索县&quot;: [93.792173, 31.892424],\n  &quot;西藏自治区-那曲地区-班戈县&quot;: [90.016708, 31.398728],\n  &quot;西藏自治区-那曲地区-巴青县&quot;: [94.059882, 31.924549],\n  &quot;西藏自治区-那曲地区-尼玛县&quot;: [87.243292, 31.790953],\n  &quot;西藏自治区-那曲地区-双湖县&quot;: [87.243292, 31.790953],\n  &quot;西藏自治区-阿里地区&quot;: [80.112777, 32.506866],\n  &quot;西藏自治区-阿里地区-普兰县&quot;: [81.183095, 30.300163],\n  &quot;西藏自治区-阿里地区-札达县&quot;: [79.809323, 31.485343],\n  &quot;西藏自治区-阿里地区-噶尔县&quot;: [80.102877, 32.497157],\n  &quot;西藏自治区-阿里地区-日土县&quot;: [79.739109, 33.387186],\n  &quot;西藏自治区-阿里地区-革吉县&quot;: [81.151664, 32.393356],\n  &quot;西藏自治区-阿里地区-改则县&quot;: [84.069113, 32.308357],\n  &quot;西藏自治区-阿里地区-措勤县&quot;: [84.069113, 32.308357],\n  &quot;陕西省&quot;: [108.960393, 34.275808],\n  &quot;陕西省-西安市&quot;: [108.946466, 34.347269],\n  &quot;陕西省-西安市-新城区&quot;: [108.967391, 34.272724],\n  &quot;陕西省-西安市-碑林区&quot;: [108.940498, 34.236474],\n  &quot;陕西省-西安市-莲湖区&quot;: [108.950426, 34.271017],\n  &quot;陕西省-西安市-灞桥区&quot;: [109.071415, 34.279128],\n  &quot;陕西省-西安市-未央区&quot;: [108.953401, 34.299148],\n  &quot;陕西省-西安市-雁塔区&quot;: [108.95144, 34.220635],\n  &quot;陕西省-西安市-阎良区&quot;: [109.232463, 34.668363],\n  &quot;陕西省-西安市-临潼区&quot;: [109.220436, 34.372747],\n  &quot;陕西省-西安市-长安区&quot;: [108.91358, 34.16329],\n  &quot;陕西省-西安市-高陵区&quot;: [109.094387, 34.541093],\n  &quot;陕西省-西安市-蓝田县&quot;: [109.329388, 34.157621],\n  &quot;陕西省-西安市-周至县&quot;: [108.228422, 34.169385],\n  &quot;陕西省-西安市-户县&quot;: [108.61142, 34.115021],\n  &quot;陕西省-铜川市&quot;: [108.952404, 34.902637],\n  &quot;陕西省-铜川市-王益区&quot;: [109.081417, 35.075322],\n  &quot;陕西省-铜川市-印台区&quot;: [109.106434, 35.120859],\n  &quot;陕西省-铜川市-耀州区&quot;: [108.986438, 34.91596],\n  &quot;陕西省-铜川市-宜君县&quot;: [109.123537, 35.404582],\n  &quot;陕西省-宝鸡市&quot;: [107.244575, 34.368916],\n  &quot;陕西省-宝鸡市-渭滨区&quot;: [107.156419, 34.377481],\n  &quot;陕西省-宝鸡市-金台区&quot;: [107.153424, 34.382351],\n  &quot;陕西省-宝鸡市-陈仓区&quot;: [107.393438, 34.360756],\n  &quot;陕西省-宝鸡市-凤翔县&quot;: [107.407379, 34.527616],\n  &quot;陕西省-宝鸡市-岐山县&quot;: [107.627447, 34.449777],\n  &quot;陕西省-宝鸡市-扶风县&quot;: [107.906453, 34.381463],\n  &quot;陕西省-宝鸡市-眉县&quot;: [107.756398, 34.280376],\n  &quot;陕西省-宝鸡市-陇县&quot;: [106.870584, 34.89878],\n  &quot;陕西省-宝鸡市-千阳县&quot;: [107.139466, 34.648545],\n  &quot;陕西省-宝鸡市-麟游县&quot;: [107.799514, 34.683749],\n  &quot;陕西省-宝鸡市-凤县&quot;: [106.522558, 33.916583],\n  &quot;陕西省-宝鸡市-太白县&quot;: [107.325529, 34.064248],\n  &quot;陕西省-咸阳市&quot;: [108.715422, 34.335476],\n  &quot;陕西省-咸阳市-秦都区&quot;: [108.712432, 34.335145],\n  &quot;陕西省-咸阳市-杨陵区&quot;: [108.091515, 34.278013],\n  &quot;陕西省-咸阳市-渭城区&quot;: [108.743451, 34.36811],\n  &quot;陕西省-咸阳市-三原县&quot;: [108.947447, 34.623079],\n  &quot;陕西省-咸阳市-泾阳县&quot;: [108.849379, 34.533317],\n  &quot;陕西省-咸阳市-乾县&quot;: [108.245378, 34.534018],\n  &quot;陕西省-咸阳市-礼泉县&quot;: [108.431615, 34.487391],\n  &quot;陕西省-咸阳市-永寿县&quot;: [108.148469, 34.698036],\n  &quot;陕西省-咸阳市-彬县&quot;: [108.084566, 35.049611],\n  &quot;陕西省-咸阳市-长武县&quot;: [107.805561, 35.211657],\n  &quot;陕西省-咸阳市-旬邑县&quot;: [108.340467, 35.117964],\n  &quot;陕西省-咸阳市-淳化县&quot;: [108.587442, 34.804777],\n  &quot;陕西省-咸阳市-武功县&quot;: [108.206551, 34.266138],\n  &quot;陕西省-咸阳市-兴平市&quot;: [108.496394, 34.305477],\n  &quot;陕西省-渭南市&quot;: [109.51659, 34.505716],\n  &quot;陕西省-渭南市-临渭区&quot;: [109.498596, 34.504],\n  &quot;陕西省-渭南市-华州区&quot;: [109.778477, 34.518731],\n  &quot;陕西省-渭南市-潼关县&quot;: [110.252508, 34.550327],\n  &quot;陕西省-渭南市-大荔县&quot;: [109.948453, 34.801833],\n  &quot;陕西省-渭南市-合阳县&quot;: [110.155396, 35.243872],\n  &quot;陕西省-渭南市-澄城县&quot;: [109.938434, 35.196573],\n  &quot;陕西省-渭南市-蒲城县&quot;: [109.592497, 34.961274],\n  &quot;陕西省-渭南市-白水县&quot;: [109.597521, 35.183288],\n  &quot;陕西省-渭南市-富平县&quot;: [109.186437, 34.75726],\n  &quot;陕西省-渭南市-韩城市&quot;: [110.449553, 35.482087],\n  &quot;陕西省-渭南市-华阴市&quot;: [110.098601, 34.5718],\n  &quot;陕西省-延安市&quot;: [109.496582, 36.591111],\n  &quot;陕西省-延安市-宝塔区&quot;: [109.499594, 36.59689],\n  &quot;陕西省-延安市-安塞区&quot;: [109.335419, 36.870098],\n  &quot;陕西省-延安市-延长县&quot;: [110.018472, 36.585329],\n  &quot;陕西省-延安市-延川县&quot;: [110.20054, 36.884137],\n  &quot;陕西省-延安市-子长县&quot;: [109.68139, 37.148817],\n  &quot;陕西省-延安市-志丹县&quot;: [108.775577, 36.828021],\n  &quot;陕西省-延安市-吴起县&quot;: [108.18259, 36.932576],\n  &quot;陕西省-延安市-甘泉县&quot;: [109.357524, 36.282689],\n  &quot;陕西省-延安市-富县&quot;: [109.386597, 35.993368],\n  &quot;陕西省-延安市-洛川县&quot;: [109.438404, 35.7683],\n  &quot;陕西省-延安市-宜川县&quot;: [110.175413, 36.056397],\n  &quot;陕西省-延安市-黄龙县&quot;: [109.846549, 35.590234],\n  &quot;陕西省-延安市-黄陵县&quot;: [109.269606, 35.585076],\n  &quot;陕西省-汉中市&quot;: [107.02943, 33.0738],\n  &quot;陕西省-汉中市-汉台区&quot;: [107.038402, 33.074191],\n  &quot;陕西省-汉中市-南郑县&quot;: [106.942433, 33.005615],\n  &quot;陕西省-汉中市-城固县&quot;: [107.340613, 33.162399],\n  &quot;陕西省-汉中市-洋县&quot;: [107.552464, 33.228863],\n  &quot;陕西省-汉中市-西乡县&quot;: [107.773393, 32.989397],\n  &quot;陕西省-汉中市-勉县&quot;: [106.679426, 33.159805],\n  &quot;陕西省-汉中市-宁强县&quot;: [106.264589, 32.83538],\n  &quot;陕西省-汉中市-略阳县&quot;: [106.163544, 33.333194],\n  &quot;陕西省-汉中市-镇巴县&quot;: [107.901446, 32.542833],\n  &quot;陕西省-汉中市-留坝县&quot;: [106.927414, 33.623825],\n  &quot;陕西省-汉中市-佛坪县&quot;: [107.997424, 33.530693],\n  &quot;陕西省-榆林市&quot;: [109.741616, 38.290884],\n  &quot;陕西省-榆林市-榆阳区&quot;: [109.727559, 38.28242],\n  &quot;陕西省-榆林市-横山区&quot;: [109.300491, 37.968573],\n  &quot;陕西省-榆林市-神木县&quot;: [110.50543, 38.848544],\n  &quot;陕西省-榆林市-府谷县&quot;: [111.073628, 39.033796],\n  &quot;陕西省-榆林市-靖边县&quot;: [108.8006, 37.605063],\n  &quot;陕西省-榆林市-定边县&quot;: [107.60757, 37.60046],\n  &quot;陕西省-榆林市-绥德县&quot;: [110.269426, 37.508907],\n  &quot;陕西省-榆林市-米脂县&quot;: [110.190451, 37.761398],\n  &quot;陕西省-榆林市-佳县&quot;: [110.497477, 38.025612],\n  &quot;陕西省-榆林市-吴堡县&quot;: [110.746455, 37.45827],\n  &quot;陕西省-榆林市-清涧县&quot;: [110.127559, 37.094853],\n  &quot;陕西省-榆林市-子洲县&quot;: [110.042398, 37.617026],\n  &quot;陕西省-安康市&quot;: [109.035601, 32.690513],\n  &quot;陕西省-安康市-汉滨区&quot;: [109.033596, 32.701196],\n  &quot;陕西省-安康市-汉阴县&quot;: [108.515507, 32.899121],\n  &quot;陕西省-安康市-石泉县&quot;: [108.254427, 33.044602],\n  &quot;陕西省-安康市-宁陕县&quot;: [108.320564, 33.316555],\n  &quot;陕西省-安康市-紫阳县&quot;: [108.541594, 32.525786],\n  &quot;陕西省-安康市-岚皋县&quot;: [108.908615, 32.312881],\n  &quot;陕西省-安康市-平利县&quot;: [109.368547, 32.394804],\n  &quot;陕西省-安康市-镇坪县&quot;: [109.533497, 31.889643],\n  &quot;陕西省-安康市-旬阳县&quot;: [109.371557, 32.839864],\n  &quot;陕西省-安康市-白河县&quot;: [110.119587, 32.814846],\n  &quot;陕西省-商洛市&quot;: [109.924418, 33.878634],\n  &quot;陕西省-商洛市-商州区&quot;: [109.947472, 33.868855],\n  &quot;陕西省-商洛市-洛南县&quot;: [110.154427, 34.097071],\n  &quot;陕西省-商洛市-丹凤县&quot;: [110.33356, 33.701537],\n  &quot;陕西省-商洛市-商南县&quot;: [110.888408, 33.537533],\n  &quot;陕西省-商洛市-山阳县&quot;: [109.888549, 33.537968],\n  &quot;陕西省-商洛市-镇安县&quot;: [109.159575, 33.429045],\n  &quot;陕西省-商洛市-柞水县&quot;: [109.120502, 33.692026],\n  &quot;甘肃省&quot;: [103.832478, 36.065465],\n  &quot;甘肃省-兰州市&quot;: [103.840521, 36.067235],\n  &quot;甘肃省-兰州市-城关区&quot;: [103.831475, 36.063181],\n  &quot;甘肃省-兰州市-七里河区&quot;: [103.792414, 36.072129],\n  &quot;甘肃省-兰州市-西固区&quot;: [103.63458, 36.094109],\n  &quot;甘肃省-兰州市-安宁区&quot;: [103.725535, 36.109754],\n  &quot;甘肃省-兰州市-红古区&quot;: [102.865428, 36.351863],\n  &quot;甘肃省-兰州市-永登县&quot;: [103.266624, 36.742095],\n  &quot;甘肃省-兰州市-皋兰县&quot;: [103.953464, 36.338142],\n  &quot;甘肃省-兰州市-榆中县&quot;: [104.119566, 35.848851],\n  &quot;甘肃省-嘉峪关市&quot;: [98.296204, 39.77796],\n  &quot;甘肃省-金昌市&quot;: [102.194606, 38.52582],\n  &quot;甘肃省-金昌市-金川区&quot;: [102.200586, 38.525772],\n  &quot;甘肃省-金昌市-永昌县&quot;: [101.979464, 38.252941],\n  &quot;甘肃省-白银市&quot;: [104.144451, 36.550825],\n  &quot;甘肃省-白银市-白银区&quot;: [104.155413, 36.541464],\n  &quot;甘肃省-白银市-平川区&quot;: [104.831614, 36.733499],\n  &quot;甘肃省-白银市-靖远县&quot;: [104.682515, 36.577096],\n  &quot;甘肃省-白银市-会宁县&quot;: [105.059607, 35.698508],\n  &quot;甘肃省-白银市-景泰县&quot;: [104.069444, 37.187406],\n  &quot;甘肃省-天水市&quot;: [105.731417, 34.587412],\n  &quot;甘肃省-天水市-秦州区&quot;: [105.730415, 34.587316],\n  &quot;甘肃省-天水市-麦积区&quot;: [105.895597, 34.576337],\n  &quot;甘肃省-天水市-清水县&quot;: [106.143595, 34.753883],\n  &quot;甘肃省-天水市-秦安县&quot;: [105.681575, 34.864876],\n  &quot;甘肃省-天水市-甘谷县&quot;: [105.342475, 34.7383],\n  &quot;甘肃省-天水市-武山县&quot;: [104.897428, 34.727669],\n  &quot;甘肃省-天水市-张家川回族自治县&quot;: [106.21139, 34.994905],\n  &quot;甘肃省-武威市&quot;: [102.644554, 37.934378],\n  &quot;甘肃省-武威市-凉州区&quot;: [102.648575, 37.934122],\n  &quot;甘肃省-武威市-民勤县&quot;: [103.1004, 38.630625],\n  &quot;甘肃省-武威市-古浪县&quot;: [102.90363, 37.475802],\n  &quot;甘肃省-武威市-天祝藏族自治县&quot;: [103.148621, 36.977596],\n  &quot;甘肃省-张掖市&quot;: [100.456411, 38.932066],\n  &quot;甘肃省-张掖市-甘州区&quot;: [100.484558, 38.934781],\n  &quot;甘肃省-张掖市-肃南裕固族自治县&quot;: [99.621905, 38.8431],\n  &quot;甘肃省-张掖市-民乐县&quot;: [100.819429, 38.436842],\n  &quot;甘肃省-张掖市-临泽县&quot;: [100.170555, 39.158514],\n  &quot;甘肃省-张掖市-高台县&quot;: [99.82576, 39.383646],\n  &quot;甘肃省-张掖市-山丹县&quot;: [101.095616, 38.790453],\n  &quot;甘肃省-平凉市&quot;: [106.671442, 35.549232],\n  &quot;甘肃省-平凉市-崆峒区&quot;: [106.681415, 35.548815],\n  &quot;甘肃省-平凉市-泾川县&quot;: [107.374518, 35.338669],\n  &quot;甘肃省-平凉市-灵台县&quot;: [107.627461, 35.071582],\n  &quot;甘肃省-平凉市-崇信县&quot;: [107.041415, 35.308616],\n  &quot;甘肃省-平凉市-华亭县&quot;: [106.659486, 35.223551],\n  &quot;甘肃省-平凉市-庄浪县&quot;: [106.042586, 35.208192],\n  &quot;甘肃省-平凉市-静宁县&quot;: [105.738416, 35.528257],\n  &quot;甘肃省-酒泉市&quot;: [98.500685, 39.738469],\n  &quot;甘肃省-酒泉市-肃州区&quot;: [98.514322, 39.751246],\n  &quot;甘肃省-酒泉市-金塔县&quot;: [98.908368, 39.990029],\n  &quot;甘肃省-酒泉市-瓜州县&quot;: [95.788736, 40.526106],\n  &quot;甘肃省-酒泉市-肃北蒙古族自治县&quot;: [94.883692, 39.51833],\n  &quot;甘肃省-酒泉市-阿克塞哈萨克族自治县&quot;: [94.34676, 39.640045],\n  &quot;甘肃省-酒泉市-玉门市&quot;: [97.051712, 40.29762],\n  &quot;甘肃省-酒泉市-敦煌市&quot;: [94.668527, 40.147867],\n  &quot;甘肃省-庆阳市&quot;: [107.649386, 35.715216],\n  &quot;甘肃省-庆阳市-西峰区&quot;: [107.657391, 35.736864],\n  &quot;甘肃省-庆阳市-庆城县&quot;: [107.888406, 36.021726],\n  &quot;甘肃省-庆阳市-环县&quot;: [107.31447, 36.574427],\n  &quot;甘肃省-庆阳市-华池县&quot;: [107.99639, 36.467575],\n  &quot;甘肃省-庆阳市-合水县&quot;: [108.026447, 35.825262],\n  &quot;甘肃省-庆阳市-正宁县&quot;: [108.366375, 35.498219],\n  &quot;甘肃省-庆阳市-宁县&quot;: [107.934571, 35.507933],\n  &quot;甘肃省-庆阳市-镇原县&quot;: [107.207576, 35.683231],\n  &quot;甘肃省-定西市&quot;: [104.63242, 35.586833],\n  &quot;甘肃省-定西市-安定区&quot;: [104.6165, 35.5856],\n  &quot;甘肃省-定西市-通渭县&quot;: [105.248404, 35.217217],\n  &quot;甘肃省-定西市-陇西县&quot;: [104.641381, 35.010197],\n  &quot;甘肃省-定西市-渭源县&quot;: [104.221584, 35.142392],\n  &quot;甘肃省-定西市-临洮县&quot;: [103.865601, 35.400587],\n  &quot;甘肃省-定西市-漳县&quot;: [104.478595, 34.85425],\n  &quot;甘肃省-定西市-岷县&quot;: [104.043396, 34.444408],\n  &quot;甘肃省-陇南市&quot;: [104.928575, 33.40662],\n  &quot;甘肃省-陇南市-武都区&quot;: [104.932593, 33.398072],\n  &quot;甘肃省-陇南市-成县&quot;: [105.748478, 33.756635],\n  &quot;甘肃省-陇南市-文县&quot;: [104.689558, 32.949601],\n  &quot;甘肃省-陇南市-宕昌县&quot;: [104.399386, 34.053486],\n  &quot;甘肃省-陇南市-康县&quot;: [105.615392, 33.335376],\n  &quot;甘肃省-陇南市-西和县&quot;: [105.30761, 34.016787],\n  &quot;甘肃省-陇南市-礼县&quot;: [105.183591, 34.194685],\n  &quot;甘肃省-陇南市-徽县&quot;: [106.094418, 33.775194],\n  &quot;甘肃省-陇南市-两当县&quot;: [106.311419, 33.915123],\n  &quot;甘肃省-临夏回族自治州&quot;: [103.216391, 35.607562],\n  &quot;甘肃省-临夏回族自治州-临夏市&quot;: [103.249549, 35.609899],\n  &quot;甘肃省-临夏回族自治州-临夏县&quot;: [103.002514, 35.497398],\n  &quot;甘肃省-临夏回族自治州-康乐县&quot;: [103.715476, 35.37611],\n  &quot;甘肃省-临夏回族自治州-永靖县&quot;: [103.292507, 35.96333],\n  &quot;甘肃省-临夏回族自治州-广河县&quot;: [103.58241, 35.494101],\n  &quot;甘肃省-临夏回族自治州-和政县&quot;: [103.357524, 35.43059],\n  &quot;甘肃省-临夏回族自治州-东乡族自治县&quot;: [103.395613, 35.66933],\n  &quot;甘肃省-临夏回族自治州-积石山保安族东乡族撒拉族自治县&quot;: [\n    102.882518, 35.723499\n  ],\n  &quot;甘肃省-甘南藏族自治州&quot;: [102.917585, 34.98914],\n  &quot;甘肃省-甘南藏族自治州-合作市&quot;: [102.917572, 35.005935],\n  &quot;甘肃省-甘南藏族自治州-临潭县&quot;: [103.360533, 34.698639],\n  &quot;甘肃省-甘南藏族自治州-卓尼县&quot;: [103.513616, 34.594916],\n  &quot;甘肃省-甘南藏族自治州-舟曲县&quot;: [104.37749, 33.790815],\n  &quot;甘肃省-甘南藏族自治州-迭部县&quot;: [103.22844, 34.06202],\n  &quot;甘肃省-甘南藏族自治州-玛曲县&quot;: [102.0786, 34.003358],\n  &quot;甘肃省-甘南藏族自治州-碌曲县&quot;: [102.494424, 34.597087],\n  &quot;甘肃省-甘南藏族自治州-夏河县&quot;: [102.528577, 35.208324],\n  &quot;青海省&quot;: [101.786462, 36.627159],\n  &quot;青海省-西宁市&quot;: [101.78445, 36.623385],\n  &quot;青海省-西宁市-城东区&quot;: [101.809569, 36.605708],\n  &quot;青海省-西宁市-城中区&quot;: [101.790484, 36.6288],\n  &quot;青海省-西宁市-城西区&quot;: [101.772414, 36.634497],\n  &quot;青海省-西宁市-城北区&quot;: [101.772405, 36.656294],\n  &quot;青海省-西宁市-大通回族土族自治县&quot;: [101.692564, 36.932666],\n  &quot;青海省-西宁市-湟中县&quot;: [101.578617, 36.506628],\n  &quot;青海省-西宁市-湟源县&quot;: [101.262449, 36.688588],\n  &quot;青海省-海东市&quot;: [102.110444, 36.508511],\n  &quot;青海省-海东市-乐都区&quot;: [102.408566, 36.48782],\n  &quot;青海省-海东市-平安区&quot;: [102.114428, 36.506554],\n  &quot;青海省-海东市-民和回族土族自治县&quot;: [102.83639, 36.325561],\n  &quot;青海省-海东市-互助土族自治县&quot;: [101.964569, 36.850022],\n  &quot;青海省-海东市-化隆回族自治县&quot;: [102.270448, 36.100988],\n  &quot;青海省-海东市-循化撒拉族自治县&quot;: [102.495385, 35.856667],\n  &quot;青海省-海北藏族自治州&quot;: [100.907434, 36.960663],\n  &quot;青海省-海北藏族自治州-门源回族自治县&quot;: [101.628438, 37.382181],\n  &quot;青海省-海北藏族自治州-祁连县&quot;: [100.259622, 38.182925],\n  &quot;青海省-海北藏族自治州-海晏县&quot;: [101.000586, 36.902376],\n  &quot;青海省-海北藏族自治州-刚察县&quot;: [100.153606, 37.32732],\n  &quot;青海省-黄南藏族自治州&quot;: [102.022428, 35.525805],\n  &quot;青海省-黄南藏族自治州-同仁县&quot;: [102.025438, 35.521865],\n  &quot;青海省-黄南藏族自治州-尖扎县&quot;: [102.037507, 35.944284],\n  &quot;青海省-黄南藏族自治州-泽库县&quot;: [101.473595, 35.042014],\n  &quot;青海省-黄南藏族自治州-河南蒙古族自治县&quot;: [101.622473, 34.740396],\n  &quot;青海省-海南藏族自治州&quot;: [100.626621, 36.292102],\n  &quot;青海省-海南藏族自治州-共和县&quot;: [100.626623, 36.288703],\n  &quot;青海省-海南藏族自治州-同德县&quot;: [100.585424, 35.259858],\n  &quot;青海省-海南藏族自治州-贵德县&quot;: [101.439533, 36.046158],\n  &quot;青海省-海南藏族自治州-兴海县&quot;: [99.99438, 35.59463],\n  &quot;青海省-海南藏族自治州-贵南县&quot;: [100.753593, 35.592415],\n  &quot;青海省-果洛藏族自治州&quot;: [100.251592, 34.477194],\n  &quot;青海省-果洛藏族自治州-玛沁县&quot;: [100.245564, 34.483569],\n  &quot;青海省-果洛藏族自治州-班玛县&quot;: [100.743605, 32.938504],\n  &quot;青海省-果洛藏族自治州-甘德县&quot;: [99.907511, 33.975004],\n  &quot;青海省-果洛藏族自治州-达日县&quot;: [99.65801, 33.754937],\n  &quot;青海省-果洛藏族自治州-久治县&quot;: [101.488532, 33.434773],\n  &quot;青海省-果洛藏族自治州-玛多县&quot;: [98.215884, 34.920749],\n  &quot;青海省-玉树藏族自治州&quot;: [97.013181, 33.01098],\n  &quot;青海省-玉树藏族自治州-玉树市&quot;: [97.015376, 32.999556],\n  &quot;青海省-玉树藏族自治州-杂多县&quot;: [95.306965, 32.899241],\n  &quot;青海省-玉树藏族自治州-称多县&quot;: [97.115, 33.374226],\n  &quot;青海省-玉树藏族自治州-治多县&quot;: [95.619794, 33.857953],\n  &quot;青海省-玉树藏族自治州-囊谦县&quot;: [96.486918, 32.209194],\n  &quot;青海省-玉树藏族自治州-曲麻莱县&quot;: [95.80375, 34.132299],\n  &quot;青海省-海西蒙古族藏族自治州&quot;: [97.376299, 37.38275],\n  &quot;青海省-海西蒙古族藏族自治州-格尔木市&quot;: [94.93331, 36.412371],\n  &quot;青海省-海西蒙古族藏族自治州-德令哈市&quot;: [97.36747, 37.375346],\n  &quot;青海省-海西蒙古族藏族自治州-乌兰县&quot;: [98.486736, 36.935748],\n  &quot;青海省-海西蒙古族藏族自治州-都兰县&quot;: [98.102705, 36.307611],\n  &quot;青海省-海西蒙古族藏族自治州-天峻县&quot;: [99.029243, 37.306903],\n  &quot;宁夏回族自治区&quot;: [106.265605, 38.476878],\n  &quot;宁夏回族自治区-银川市&quot;: [106.238494, 38.49246],\n  &quot;宁夏回族自治区-银川市-兴庆区&quot;: [106.295494, 38.479579],\n  &quot;宁夏回族自治区-银川市-西夏区&quot;: [106.156581, 38.496817],\n  &quot;宁夏回族自治区-银川市-金凤区&quot;: [106.249561, 38.478695],\n  &quot;宁夏回族自治区-银川市-永宁县&quot;: [106.259605, 38.283001],\n  &quot;宁夏回族自治区-银川市-贺兰县&quot;: [106.356518, 38.560407],\n  &quot;宁夏回族自治区-银川市-灵武市&quot;: [106.34644, 38.108659],\n  &quot;宁夏回族自治区-石嘴山市&quot;: [106.3906, 38.989683],\n  &quot;宁夏回族自治区-石嘴山市-大武口区&quot;: [106.37461, 39.024848],\n  &quot;宁夏回族自治区-石嘴山市-惠农区&quot;: [106.78843, 39.245388],\n  &quot;宁夏回族自治区-石嘴山市-平罗县&quot;: [106.536518, 38.919607],\n  &quot;宁夏回族自治区-吴忠市&quot;: [106.205371, 38.003713],\n  &quot;宁夏回族自治区-吴忠市-利通区&quot;: [106.219407, 37.990746],\n  &quot;宁夏回族自治区-吴忠市-红寺堡区&quot;: [106.068421, 37.431882],\n  &quot;宁夏回族自治区-吴忠市-盐池县&quot;: [107.41338, 37.789296],\n  &quot;宁夏回族自治区-吴忠市-同心县&quot;: [105.920599, 36.98627],\n  &quot;宁夏回族自治区-吴忠市-青铜峡市&quot;: [106.08537, 38.027412],\n  &quot;宁夏回族自治区-固原市&quot;: [106.248577, 36.021617],\n  &quot;宁夏回族自治区-固原市-原州区&quot;: [106.294515, 36.009368],\n  &quot;宁夏回族自治区-固原市-西吉县&quot;: [105.735386, 35.970076],\n  &quot;宁夏回族自治区-固原市-隆德县&quot;: [106.118498, 35.631762],\n  &quot;宁夏回族自治区-固原市-泾源县&quot;: [106.337393, 35.504362],\n  &quot;宁夏回族自治区-固原市-彭阳县&quot;: [106.644544, 35.855405],\n  &quot;宁夏回族自治区-中卫市&quot;: [105.203571, 37.505701],\n  &quot;宁夏回族自治区-中卫市-沙坡头区&quot;: [105.203571, 37.505701],\n  &quot;宁夏回族自治区-中卫市-中宁县&quot;: [105.691537, 37.497421],\n  &quot;宁夏回族自治区-中卫市-海原县&quot;: [105.650555, 36.570781],\n  &quot;新疆维吾尔自治区&quot;: [87.633473, 43.799238],\n  &quot;新疆维吾尔自治区-乌鲁木齐市&quot;: [87.62444, 43.830763],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-天山区&quot;: [87.638408, 43.800271],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-沙依巴克区&quot;: [87.60467, 43.807262],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-新市区&quot;: [87.575908, 43.861394],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-水磨沟区&quot;: [87.575908, 43.861394],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-头屯河区&quot;: [87.434507, 43.882653],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-达坂城区&quot;: [88.317398, 43.369943],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-米东区&quot;: [87.662134, 43.979247],\n  &quot;新疆维吾尔自治区-乌鲁木齐市-乌鲁木齐县&quot;: [87.416029, 43.477086],\n  &quot;新疆维吾尔自治区-克拉玛依市&quot;: [84.895901, 45.585675],\n  &quot;新疆维吾尔自治区-克拉玛依市-独山子区&quot;: [84.893613, 44.334407],\n  &quot;新疆维吾尔自治区-克拉玛依市-克拉玛依区&quot;: [84.866222, 45.596624],\n  &quot;新疆维吾尔自治区-克拉玛依市-白碱滩区&quot;: [85.13951, 45.693952],\n  &quot;新疆维吾尔自治区-克拉玛依市-乌尔禾区&quot;: [85.700305, 46.095295],\n  &quot;新疆维吾尔自治区-吐鲁番市&quot;: [89.192459, 42.948549],\n  &quot;新疆维吾尔自治区-吐鲁番市-高昌区&quot;: [89.192459, 42.948549],\n  &quot;新疆维吾尔自治区-吐鲁番市-鄯善县&quot;: [90.220094, 42.874759],\n  &quot;新疆维吾尔自治区-吐鲁番市-托克逊县&quot;: [88.660164, 42.798546],\n  &quot;新疆维吾尔自治区-哈密市&quot;: [93.521308, 42.832856],\n  &quot;新疆维吾尔自治区-哈密市-伊州区&quot;: [93.519883, 42.825878],\n  &quot;新疆维吾尔自治区-哈密市-巴里坤哈萨克自治县&quot;: [93.022931, 43.605689],\n  &quot;新疆维吾尔自治区-哈密市-伊吾县&quot;: [94.703826, 43.260677],\n  &quot;新疆维吾尔自治区-昌吉回族自治州&quot;: [87.315002, 44.016854],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-昌吉市&quot;: [87.273865, 44.020127],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-阜康市&quot;: [87.273865, 44.020127],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-呼图壁县&quot;: [86.905144, 44.197655],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-玛纳斯县&quot;: [86.220643, 44.310063],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-奇台县&quot;: [89.601081, 44.026898],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-吉木萨尔县&quot;: [89.187123, 44.005718],\n  &quot;新疆维吾尔自治区-昌吉回族自治州-木垒哈萨克自治县&quot;: [90.292515, 43.840308],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州&quot;: [82.072915, 44.912196],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-博乐市&quot;: [82.057972, 44.86001],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-阿拉山口市&quot;: [82.057972, 44.86001],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-精河县&quot;: [82.900655, 44.606646],\n  &quot;新疆维吾尔自治区-博尔塔拉蒙古自治州-温泉县&quot;: [81.031146, 44.974857],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州&quot;: [86.151714, 41.770287],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-库尔勒市&quot;: [86.181494, 41.732373],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-轮台县&quot;: [86.181494, 41.732373],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-尉犁县&quot;: [86.266037, 41.350123],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-若羌县&quot;: [88.175324, 39.028991],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-且末县&quot;: [85.53599, 38.151388],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-焉耆回族自治县&quot;: [86.581222, 42.064851],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-和静县&quot;: [86.390398, 42.329365],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-和硕县&quot;: [86.883689, 42.288065],\n  &quot;新疆维吾尔自治区-巴音郭楞蒙古自治州-博湖县&quot;: [86.638469, 41.98643],\n  &quot;新疆维吾尔自治区-阿克苏地区&quot;: [80.266943, 41.17503],\n  &quot;新疆维吾尔自治区-阿克苏地区-阿克苏市&quot;: [80.269927, 41.17386],\n  &quot;新疆维吾尔自治区-阿克苏地区-温宿县&quot;: [80.245564, 41.282567],\n  &quot;新疆维吾尔自治区-阿克苏地区-库车县&quot;: [82.968459, 41.723448],\n  &quot;新疆维吾尔自治区-阿克苏地区-沙雅县&quot;: [82.788824, 41.227749],\n  &quot;新疆维吾尔自治区-阿克苏地区-新和县&quot;: [82.615823, 41.554],\n  &quot;新疆维吾尔自治区-阿克苏地区-拜城县&quot;: [81.858516, 41.800707],\n  &quot;新疆维吾尔自治区-阿克苏地区-乌什县&quot;: [79.230869, 41.220871],\n  &quot;新疆维吾尔自治区-阿克苏地区-阿瓦提县&quot;: [80.381849, 40.649359],\n  &quot;新疆维吾尔自治区-阿克苏地区-柯坪县&quot;: [79.053214, 40.514055],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州&quot;: [76.174309, 39.720471],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿图什市&quot;: [76.174906, 39.722079],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿克陶县&quot;: [75.953725, 39.153889],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-阿合奇县&quot;: [75.953725, 39.153889],\n  &quot;新疆维吾尔自治区-克孜勒苏柯尔克孜自治州-乌恰县&quot;: [75.265334, 39.725124],\n  &quot;新疆维吾尔自治区-喀什地区&quot;: [75.996391, 39.476097],\n  &quot;新疆维吾尔自治区-喀什地区-喀什市&quot;: [76.000313, 39.47365],\n  &quot;新疆维吾尔自治区-喀什地区-疏附县&quot;: [75.869169, 39.381292],\n  &quot;新疆维吾尔自治区-喀什地区-疏勒县&quot;: [76.056614, 39.406709],\n  &quot;新疆维吾尔自治区-喀什地区-英吉沙县&quot;: [76.182075, 38.935671],\n  &quot;新疆维吾尔自治区-喀什地区-泽普县&quot;: [77.266559, 38.190725],\n  &quot;新疆维吾尔自治区-喀什地区-莎车县&quot;: [77.252437, 38.420157],\n  &quot;新疆维吾尔自治区-喀什地区-叶城县&quot;: [77.420098, 37.889167],\n  &quot;新疆维吾尔自治区-喀什地区-麦盖提县&quot;: [77.658824, 38.911194],\n  &quot;新疆维吾尔自治区-喀什地区-岳普湖县&quot;: [76.784148, 39.239387],\n  &quot;新疆维吾尔自治区-喀什地区-伽师县&quot;: [76.730386, 39.493852],\n  &quot;新疆维吾尔自治区-喀什地区-巴楚县&quot;: [78.555701, 39.790788],\n  &quot;新疆维吾尔自治区-喀什地区-塔什库尔干塔吉克自治县&quot;: [75.230805, 37.779046],\n  &quot;新疆维吾尔自治区-和田地区&quot;: [79.928507, 37.120446],\n  &quot;新疆维吾尔自治区-和田地区-和田市&quot;: [79.920212, 37.118336],\n  &quot;新疆维吾尔自治区-和田地区-和田县&quot;: [79.866216, 37.090362],\n  &quot;新疆维吾尔自治区-和田地区-墨玉县&quot;: [79.735479, 37.282993],\n  &quot;新疆维吾尔自治区-和田地区-皮山县&quot;: [78.289871, 37.627249],\n  &quot;新疆维吾尔自治区-和田地区-洛浦县&quot;: [80.195388, 37.079611],\n  &quot;新疆维吾尔自治区-和田地区-策勒县&quot;: [80.813201, 37.004122],\n  &quot;新疆维吾尔自治区-和田地区-于田县&quot;: [81.683783, 36.862954],\n  &quot;新疆维吾尔自治区-和田地区-民丰县&quot;: [82.702713, 37.070257],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州&quot;: [81.330538, 43.922723],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-伊宁市&quot;: [81.284242, 43.915299],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-奎屯市&quot;: [84.909449, 44.432057],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-霍尔果斯市&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-伊宁县&quot;: [81.533906, 43.982909],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-察布查尔锡伯自治县&quot;: [81.157925, 43.84669],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-霍城县&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-巩留县&quot;: [80.885281, 44.06225],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-新源县&quot;: [83.267022, 43.435927],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-昭苏县&quot;: [81.137378, 43.163497],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-特克斯县&quot;: [81.842587, 43.224248],\n  &quot;新疆维吾尔自治区-伊犁哈萨克自治州-尼勒克县&quot;: [82.518007, 43.804595],\n  &quot;新疆维吾尔自治区-塔城地区&quot;: [82.987236, 46.750948],\n  &quot;新疆维吾尔自治区-塔城地区-塔城市&quot;: [82.985532, 46.754347],\n  &quot;新疆维吾尔自治区-塔城地区-乌苏市&quot;: [84.720088, 44.424048],\n  &quot;新疆维吾尔自治区-塔城地区-额敏县&quot;: [83.633374, 46.531885],\n  &quot;新疆维吾尔自治区-塔城地区-沙湾县&quot;: [85.626145, 44.331949],\n  &quot;新疆维吾尔自治区-塔城地区-托里县&quot;: [83.612909, 45.942743],\n  &quot;新疆维吾尔自治区-塔城地区-裕民县&quot;: [82.989439, 46.207454],\n  &quot;新疆维吾尔自治区-塔城地区-和布克赛尔蒙古自治县&quot;: [85.735009, 46.798685],\n  &quot;新疆维吾尔自治区-阿勒泰地区&quot;: [88.147926, 47.850728],\n  &quot;新疆维吾尔自治区-阿勒泰地区-阿勒泰市&quot;: [88.139227, 47.832753],\n  &quot;新疆维吾尔自治区-阿勒泰地区-布尔津县&quot;: [86.88136, 47.707952],\n  &quot;新疆维吾尔自治区-阿勒泰地区-富蕴县&quot;: [89.531953, 46.999951],\n  &quot;新疆维吾尔自治区-阿勒泰地区-福海县&quot;: [87.493157, 47.118141],\n  &quot;新疆维吾尔自治区-阿勒泰地区-哈巴河县&quot;: [86.424818, 48.066149],\n  &quot;新疆维吾尔自治区-阿勒泰地区-青河县&quot;: [90.389444, 46.680194],\n  &quot;新疆维吾尔自治区-阿勒泰地区-吉木乃县&quot;: [85.880818, 47.449018],\n  &quot;新疆维吾尔自治区-石河子市&quot;: [86.086886, 44.311976],\n  &quot;新疆维吾尔自治区-阿拉尔市&quot;: [81.287354, 40.553264],\n  &quot;新疆维吾尔自治区-图木舒克市&quot;: [79.075616, 39.871209],\n  &quot;新疆维吾尔自治区-五家渠市&quot;: [87.549937, 44.172445],\n  &quot;新疆维吾尔自治区-铁门关市&quot;: [86.181494, 41.732373],\n  &quot;香港特别行政区&quot;: [114.173825, 22.337784],\n  &quot;香港特别行政区-中西區&quot;: [114.159491, 22.291343],\n  &quot;香港特别行政区-灣仔區&quot;: [114.18355, 22.283159],\n  &quot;香港特别行政区-東區&quot;: [114.235426, 22.287684],\n  &quot;香港特别行政区-南區&quot;: [114.165543, 22.251947],\n  &quot;香港特别行政区-油尖旺區&quot;: [114.178545, 22.306584],\n  &quot;香港特别行政区-深水埗區&quot;: [114.181574, 22.345029],\n  &quot;香港特别行政区-九龍城區&quot;: [114.198554, 22.325723],\n  &quot;香港特别行政区-黃大仙區&quot;: [114.205553, 22.344517],\n  &quot;香港特别行政区-觀塘區&quot;: [114.237431, 22.316804],\n  &quot;香港特别行政区-荃灣區&quot;: [114.126441, 22.378244],\n  &quot;香港特别行政区-屯門區&quot;: [113.987456, 22.393585],\n  &quot;香港特别行政区-元朗區&quot;: [114.03851, 22.448565],\n  &quot;香港特别行政区-北區&quot;: [114.149484, 22.498024],\n  &quot;香港特别行政区-大埔區&quot;: [114.175565, 22.453814],\n  &quot;香港特别行政区-西貢區&quot;: [114.283525, 22.385077],\n  &quot;香港特别行政区-沙田區&quot;: [114.198551, 22.388522],\n  &quot;香港特别行政区-葵青區&quot;: [114.143475, 22.366619],\n  &quot;香港特别行政区-離島區&quot;: [113.951547, 22.286066],\n  &quot;澳门特别行政区&quot;: [113.560161, 22.214787],\n  &quot;澳门特别行政区-花地瑪堂區&quot;: [113.55751, 22.212784],\n  &quot;澳门特别行政区-花王堂區&quot;: [113.550294, 22.202058],\n  &quot;澳门特别行政区-望德堂區&quot;: [113.561514, 22.202511],\n  &quot;澳门特别行政区-大堂區&quot;: [113.561167, 22.192801],\n  &quot;澳门特别行政区-風順堂區&quot;: [113.545451, 22.192783],\n  &quot;澳门特别行政区-嘉模堂區&quot;: [113.565515, 22.163142],\n  &quot;澳门特别行政区-路氹填海區&quot;: [113.570544, 22.146272],\n  &quot;台湾省&quot;: [86.181494, 41.732373],\n  &quot;台湾省-台北市 &quot;: [121.539414, 25.073653],\n  &quot;台湾省-高雄市&quot;: [120.315994, 22.679904],\n  &quot;曾母暗沙&quot;: [111.79862, 4.008237]\n&#125;\n</code></pre>"},{"title":"JAVA-注解和反射","date":"2021-04-17T16:50:44.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# 注解和反射\n\n<!--more-->\n\n重中之重，很多主流框架的实现都使用了注解和反射原理\n\n## 注解 `java.annotation`\n\n## 什么是注解\n\nAnnotation 是从 JDK1.5 开始引入的新技术；\n\nAnnotation 的作用：\n\n- 不是程序本身，可以对程序作出解释（这一点和注释 comment 没什么区别）；\n- 可以被其他程序（比如：编译器等）读取；\n\nAnnotation 的格式：\n\n- 注解是以 “@注释名” 在代码中存在的，还可以添加一些参数值，例如：\n\n- @SuppressWarnings(value=\"unchecked\")；\n\nAnnotation 在哪里使用？\n\n- 可以附加在 package，class，method，field 上面，相当于添加额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问；\n\n## 内置注解\n\n- `@Override` 定义在`java.lang.Override` 中，此注释只适用于修辞手法，表示一个方法声明打算重写超类中的另一个方法声明\n- `@Deprecated` 定义在`java.lang.Deprecated` 中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择\n- `@SuppressWarnings` 定义在 `java.lang.SuppressWarnings` 中，用来抑制编译时的警告信息，与前两个有所不同的是需要添加一个参数才能正常使用，这些参数都是定义好的\n\n```java\n@SuppressWarnings(\"all\")\n@SuppressWarnings(\"unchecked\")\n@SuppressWarnings(value = {\"unchecked\", \"deprecation\"})\n...\n```\n\n## 元注解\n\n元注解的作用就是负责注解其他注解，java 定义了 4 个标准的 meta-annotation 类型，他们被用来提供对其他 annotation 类型作说明\n\n```\n☆ @Target //用于描述注解的适用范围\n☆ @Retention //表示在什么级别保存该注释信息，用于描述注解的生命周期(source < class  < RUNTIME)\n@Document // 说明该注解将被包含在javadoc中\n@Inherited // 说明子类可以继承父类中的该注解\n```\n\n## 自定义注解\n\n使用@interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口\n\n分析：\n\n1. @interface 用来声明一个注解，格式 `public @inteface 注解名 { content }`\n2. 其中的每一个方法实际上是声明了一个配置参数\n3. 方法的名称就是参数的名称\n4. 返回值类型就是参数的类型（返回值只能是基本类型 class、String、 enum）\n5. 可以通过 default 来声明参数的默认值\n6. 如果只有一个参数成员，一般参数名为 value\n7. 注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0 作为默认值\n\n```java\n//测试元注解\npublic class Test02 {\n    // 注解可以显示赋值 如果没有默认值，就必须给注解赋值\n    @MyAnnotation(name = \"shan\", age = 24)\n    public void test(){\n    }\n}\n//定义一个注解\n//Target表示我们的注解可以用在哪些地方\n@Target(value = {ElementType.METHOD, ElementType.TYPE})\n//Retention 表示我们的注解在什么地方还有效\n//Runtime > class > source\n@Retention(RetentionPolicy.RUNTIME)\n//@Documented 表示是否将我们的注解生成在JAVADoc中\n@Documented\n//@Inherited 子类可以继承父类的注解\n@Inherited\n@interface MyAnnotation {\n\n}\n```\n\n## 反射机制\n\n### 静态|动态语言\n\n#### 动态语言\n\n是一类在运动时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n\n#### 静态语言\n\n与动态语言相对应的，运行时结构不可变的语言就是静态语言，如 java、c、c++；\n\njava 不是动态语言，但 java 可以称之为“准动态语言”。即 java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。java 的动态性让编程的时候更加灵活。\n\n![image-20210414143319605](img/article/JAVA-注解和反射-20210418/image-20210414143319605.png)\n\n**优点**：\n\n​ 可以动态实现创建对象和编译，体现出很大的灵活性；\n\n**缺点**：\n\n​ 对性能有影响，使用反射基本上是一种解释操作。我们可以告诉 JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。\n\n一个类在内存中只有一个 Class 对象；\n\n一个类加载后，类的整个结构都会被封装在 class 对象中；\n\n```java\npublic class Test02 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c1);\n\n        Class c2 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c2.hashCode());\n        Class c3 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c3.hashCode());\n        Class c4 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c4.hashCode());\n\n    }\n}\n\nclass User {\n    private String name;\n    private int id;\n    private int age;\n\n    public User() {\n    }\n\n    public User(String name, int id, int age) {\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", id=\" + id +\n                \", age=\" + age +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n//运行结果\nclass com.annotation.reflection.User\n460141958\n460141958\n460141958\n```\n\n## Class 类\n\n![image-20210414150428147](img/article/JAVA-注解和反射-20210418/image-20210414150428147.png)\n\n**对象照镜子可以得到的信息**：\n\n某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构（Class/interface/enum/annotation/primitive type/void[]) 的有关信息。\n\n- Class 本身也是一个类；\n- Class 对象只能由系统建立对象；\n- 一个加载的类在 JVM 中只会有一个 Class 实例；\n- 一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件；\n- 每个类的实例都会记得自己是由哪个 Class 实例所生成；\n- 通过 Class 可以完整的得到一个类中的所有被加持的结构；\n- Class 类是 Reflection 的根源，针对任何你想动态加载，运行的类，唯有先获得相应的 Class 对象；\n\n![image-20210414153626283](img/article/JAVA-注解和反射-20210418/image-20210414153626283.png)\n\n**获取 Class 类的实例**\n\n- 若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。\n  - Class cl = Person.class；\n- 已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象\n  - Class cl = person。getClass()；\n- 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassFoundException\n  - Class cl = Class。forName(\"demo01.Student\");\n- 内置基本数据类型可以直接用类名.Type；\n- 还可以利用 ClassLoader，之后讲\n\n演示：\n\n```java\n//测试class 类的创建方式有哪些\npublic class Test03 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person = new Student();\n        System.out.println(\"这个人是：\" + person.name);\n\n        // 方式一 ： 通过对象获得\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式二 ： forname 获得\n        Class c2 = Class.forName(\"com.annotation.reflection.Student\");\n        System.out.println(c2.hashCode());\n\n        //方式三 ： 通过类名.class 获得\n        Class<Student> c3 = Student.class;\n        System.out.println(c3.hashCode());\n\n        //方式四 ： 内置基本数据类型可以直接用类名.Type；\n        Class<Integer> type = Integer.TYPE;\n        System.out.println(type.hashCode());\n\n        //获得父类类型\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\nclass Person {\n    String name;\n    public Person() {}\n    public Person(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nclass Student extends Person {\n    public Student() {\n        this.name = \"学生\";\n    }\n}\nclass Teacher extends Person{\n    public Teacher(){\n        this.name = \"Teac\";\n    }\n}\n\n//结果\n这个人是：学生\n460141958\n460141958\n460141958\n1163157884\nclass com.annotation.reflection.Person\n```\n\n## 类加载内存分析\n\n### 类的加载与 ClassLoader 的理解\n\n- 加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象。\n\n- 链接：将 java 类的二进制代码合并到 JVM 的运行状态之中的过程。\n  - 验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题；\n  - 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法去中进行分配；\n  - 解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程；\n- 初始化：\n  - 执行类构造器 <clinit>() 方法的过程。类构造器<clinit>() 方法是由编译期自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。\n  - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n  - 虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确加锁和同步。\n\n## 类初始化\n\n- **类的主动引用（一定会发生类的初始化）**\n  - 当虚拟机启动，先初始化 main 方法所在的类；\n  - new 一个类的对象；\n  - 调用类的静态成员（除了 final 常量）和静态方法；\n  - 使用`java.lang.reflect`包的方法对类进行反射调用；\n  - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类；\n- **类的被动引用（不会发生类的初始化）**\n  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过子类引用父类的静态变量，不会导致自类初始化；\n  - 通过数组定义类引用，不会触发此类的初始化；\n  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\n\n![image-20210414170751285](img/article/JAVA-注解和反射-20210418/image-20210414170751285.png)\n\n```java\npublic class Test05 {\n    static {\n        System.out.println(\"Main 被加载\");\n    }\n    public static void main(String[] args) {\n        // 1. 主动引用\n        Son son = new Son();\n        // 2. 反射也会产生主动引用\n        try {\n            Class.forName(\"com.annotation.reflection.Son\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        // 不会产生类的引用方法\n        System.out.println(Son.b);\n        Son[] array = new Son[100];\n    }\n}\nclass Father {\n    static int b = 2;\n    static {\n        System.out.println(\"父类被加载\");\n    }\n}\nclass Son extends Father {\n    static {\n        System.out.println(\"子类被加载\");\n        m = 300;\n    }\n    static int m = 100;\n    static final int M = 1;\n}\n```\n\n## 类加载器的作用\n\n- 类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区中类数据的访问入口。\n\n- 类缓存：标准的 javaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象。\n\n![image-20210414173909852](img/article/JAVA-注解和反射-20210418/image-20210414173909852.png)\n\n![image-20210414173959254](img/article/JAVA-注解和反射-20210418/image-20210414173959254.png)\n\n## 获得运行时类的完整结构\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 获取类的信息\npublic class Test07 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class c1 = Class.forName(\"com.annotation.reflection.User\");\n\n        // 获得类的名字\n        System.out.println(c1.getName()); // 获得包名 + 类名\n        System.out.println(c1.getSimpleName());\n\n        // 获得类的属性\n        System.out.println(\"------------\");\n        Field[] fields = c1.getFields(); // 只能找到public属性\n\n        fields = c1.getDeclaredFields(); // 找到全部的属性\n\n        for (Field field : fields){\n            System.out.println(field);\n        }\n\n        // 获得指定属性的值\n        Field name = c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(\"------------\");\n        Method[] methods = c1.getMethods();// 获得本类及其父类的全部public方法\n        for (Method method : methods){\n            System.out.println(\"正常的：\" + method);\n        }\n        methods = c1.getDeclaredMethods(); // 获得本类的全部方法\n        for (Method method : methods){\n            System.out.println(\"getDeclaredMethods：\" + method);\n        }\n\n        // 获得指定方法\n        // 重载\n        Method getName = c1.getMethod(\"getName\", null);\n        Method setName = c1.getMethod(\"setName\", String.class);\n        System.out.println(getName);\n        System.out.println(setName);\n\n        // 获得指定的构造器\n        System.out.println(\"--------------\");\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor constructor : constructors){\n            System.out.println(constructor);\n        }\n        constructors  = c1.getDeclaredConstructors();\n        for (Constructor constructor : constructors){\n            System.out.println(constructor);\n        }\n\n        // 获得指定的构造器\n        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        System.out.println(\"指定的：\" + declaredConstructor);\n    }\n}\n```\n\n## 动态创建对象执行方法\n\n有了 Class 对象，能做什么？\n\n- 创建类的对象：调用 Class 对象的 newInstance()方法\n  - 类必须有一个无参构造器。\n  - 类的构造器的访问权限需要足够。\n- **思考：难道没有无参的构造器就不能创建对象了吗？**\n  - 只要在操作的时候明确的调用类中的构造器，并将参数传递进去后，才可以实例化操作\n  - 步骤如下：\n    - 通过 Class1 类的`getDeclaredConstructor(Class ... parameterTypes) `取得本类的指定形参类型的构造器；\n    - 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；\n    - 通过 Constructor 实例化对象；\n\n**调用指定方法：**\n\n- 通过反射，调用类中的方法，通过 Method 类完成；\n\n  - 通过 Class 类的`getMethod(String name, Class ... parameterTypes)`方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型；\n  - 之后使用`Object invoke(Object obj, Object[] args)` 进行调用，并向方法中传递要设置的 obj 对象的参数信息；\n\n  ![image-20210414184512856](img/article/JAVA-注解和反射-20210418/image-20210414184512856.png)\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n//通过反射动态创建对象\npublic class Test08 {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        //获得Class对象\n        Class<?> c1 = Class.forName(\"com.annotation.reflection.User\");\n\n        //构造一个对象\n        User user = (User)c1.newInstance(); //本质是调用了类的无参构造器\n        System.out.println(user);\n\n        //通过构造器创建对象\n        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        User user2 = (User)constructor.newInstance(\"shan\", 001, 18);\n        System.out.println(user2);\n\n        //通过反射调用普通方法\n        User user3 = (User)c1.newInstance();\n        //通过反射获取一个方法\n        Method setName = c1.getDeclaredMethod(\"setName\", String.class);\n        //invoke 激活\n        //invoke（对象， “方法的值”）\n        setName.invoke(user3,\"shanx\");\n        System.out.println(user3.getName());\n\n        //通过反射操作属性\n        User user4 = (User)c1.newInstance();\n        Field name = c1.getDeclaredField(\"name\");\n        //默认状态下不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true); 此处true为关\n        // 会降低程序效率\n        name.setAccessible(true);\n        name.set(user4, \"shanx-2\");\n        System.out.println(user4.getName());\n\n    }\n}\n```\n\n## SetAccessible\n\n- Method 和 Field、Constructor 对象都有 setAccessible() 方法。\n- SetAccessible 作用是启动和禁用访问安全检查的开关。\n- 参数值为 true 则指示反射的对象在使用时应该取消 java 语言访问检查。\n  - 提高反射的效率。如果代码中必须用反射，而该句代码中需要频繁的被调用，那么请设置为 true。\n  - 使得原本无法访问的私有成员也可以访问。\n- 参数值为 false 则指示反射的对象应该实施 java 语言访问检查。\n\n```java\nimport java.lang.reflect.Method;\n\npublic class Test09 {\n    public static void test01() {\n        User user = new User();\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            user.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"普通方法执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    //反射方式调用\n    public static void test02() throws NoSuchMethodException {\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(\"getName\", null);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            getName.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"反射方式调用执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    //反射方式调用,关闭检测\n    public static void test03() throws NoSuchMethodException {\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(\"getName\", null);\n        getName.setAccessible(true);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            getName.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"反射方式调用,关闭检测执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        test01();\n        test02();\n        test03();\n    }\n}\n\n```\n\n## 反射操作泛型\n\n- java 采用泛型擦除的机制来引入泛型，java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有的泛型有关的类型全部擦除；\n- 为了通过反射操作这些类型，java 新增了 ParameterizedType, GenericArrayType，TypeVariable 和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型；\n  - ParameterizedType：表示一种参数化类型，比如 Collection<String>；\n  - GenericArrayType：表示一种元阿苏类型是参数化类型或者类型变量的数组模型；\n  - TypeVariable ：是各种类型变量的公共父接口；\n  - WildcardType ：代表一种通配符类型表达式；\n\n```java\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test10 {\n    public void test01(Map<String,User> map, List<User> list) {\n        System.out.println(\"test01\");\n    }\n\n    public Map<String, User> test02() {\n        System.out.println(\"test02\");\n        return null;\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        Method method = Test10.class.getMethod(\"test01\", Map.class, List.class);\n        Type[] genericParameterTypes = method.getGenericParameterTypes();\n        for (Type genericParameterType : genericParameterTypes) {\n            System.out.println(\"#\"+genericParameterTypes);\n            if (genericParameterType instanceof ParameterizedType) {\n                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                for (Type actualTypeArgument : actualTypeArguments) {\n                    System.out.println(actualTypeArgument);\n                }\n            }\n        }\n\n        method = Test10.class.getMethod(\"test02\",null);\n        Type genericReturnType = method.getGenericReturnType();\n        if (genericReturnType instanceof ParameterizedType) {\n            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n            for (Type actualTypeArgument : actualTypeArguments) {\n                System.out.println(actualTypeArgument);\n            }\n        }\n    }\n}\n\n```\n\n## 反射操作注解：练习 ORM\n\n什么是 ORM？\n\n- Object relationship Mapping --> 对象关系映射\n\n![image-20210414201814306](img/article/JAVA-注解和反射-20210418/image-20210414201814306.png)\n\n- 类和表结构对应\n- 属性和字段对应\n- 对象和记录对应\n\n要求：利用注解和反射完成类和表结构的映射关系。\n\n```java\n//orm\n\npublic class Test11 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class c1 = Class.forName(\"com.annotation.reflection.Stu\");\n\n        // 通过反射获得注解\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        // 获得注解的value的值\n        TableStu tableStu = (TableStu)c1.getAnnotation(TableStu.class);\n        String value = tableStu.value();\n        System.out.println(value);\n\n\n        // 获得类指定注解\n        Field f = c1.getDeclaredField(\"name\");\n        FieldStu annotation = f.getAnnotation(FieldStu.class);\n        System.out.println(annotation.columnName());\n        System.out.println(annotation.length());\n        System.out.println(annotation.type());\n    }\n}\n\n@TableStu(\"db_stu\")\nclass Stu{\n    @FieldStu(columnName = \"db_id\", type = \"int\", length = 10)\n    private int id;\n    @FieldStu(columnName = \"db_age\", type = \"int\", length = 10)\n    private int age;\n    @FieldStu(columnName = \"db_name\", type = \"varchar\", length = 3)\n    private String name;\n\n    public Stu() {\n    }\n\n    public Stu(int id, int age, String name) {\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Stu{\" +\n                \"id=\" + id +\n                \", age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// 类名的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface TableStu{\n    String value();\n}\n\n// 属性的注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FieldStu{\n    String columnName();\n    String type();\n    int length();\n}\n```\n","source":"_posts/JAVA-注解和反射-20210418.md","raw":"---\ntitle: JAVA-注解和反射\ndate: 2021-04-18 00:50:44\ntags:\n  - java基础\n  - 狂神说\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# 注解和反射\n\n<!--more-->\n\n重中之重，很多主流框架的实现都使用了注解和反射原理\n\n## 注解 `java.annotation`\n\n## 什么是注解\n\nAnnotation 是从 JDK1.5 开始引入的新技术；\n\nAnnotation 的作用：\n\n- 不是程序本身，可以对程序作出解释（这一点和注释 comment 没什么区别）；\n- 可以被其他程序（比如：编译器等）读取；\n\nAnnotation 的格式：\n\n- 注解是以 “@注释名” 在代码中存在的，还可以添加一些参数值，例如：\n\n- @SuppressWarnings(value=\"unchecked\")；\n\nAnnotation 在哪里使用？\n\n- 可以附加在 package，class，method，field 上面，相当于添加额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问；\n\n## 内置注解\n\n- `@Override` 定义在`java.lang.Override` 中，此注释只适用于修辞手法，表示一个方法声明打算重写超类中的另一个方法声明\n- `@Deprecated` 定义在`java.lang.Deprecated` 中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择\n- `@SuppressWarnings` 定义在 `java.lang.SuppressWarnings` 中，用来抑制编译时的警告信息，与前两个有所不同的是需要添加一个参数才能正常使用，这些参数都是定义好的\n\n```java\n@SuppressWarnings(\"all\")\n@SuppressWarnings(\"unchecked\")\n@SuppressWarnings(value = {\"unchecked\", \"deprecation\"})\n...\n```\n\n## 元注解\n\n元注解的作用就是负责注解其他注解，java 定义了 4 个标准的 meta-annotation 类型，他们被用来提供对其他 annotation 类型作说明\n\n```\n☆ @Target //用于描述注解的适用范围\n☆ @Retention //表示在什么级别保存该注释信息，用于描述注解的生命周期(source < class  < RUNTIME)\n@Document // 说明该注解将被包含在javadoc中\n@Inherited // 说明子类可以继承父类中的该注解\n```\n\n## 自定义注解\n\n使用@interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口\n\n分析：\n\n1. @interface 用来声明一个注解，格式 `public @inteface 注解名 { content }`\n2. 其中的每一个方法实际上是声明了一个配置参数\n3. 方法的名称就是参数的名称\n4. 返回值类型就是参数的类型（返回值只能是基本类型 class、String、 enum）\n5. 可以通过 default 来声明参数的默认值\n6. 如果只有一个参数成员，一般参数名为 value\n7. 注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0 作为默认值\n\n```java\n//测试元注解\npublic class Test02 {\n    // 注解可以显示赋值 如果没有默认值，就必须给注解赋值\n    @MyAnnotation(name = \"shan\", age = 24)\n    public void test(){\n    }\n}\n//定义一个注解\n//Target表示我们的注解可以用在哪些地方\n@Target(value = {ElementType.METHOD, ElementType.TYPE})\n//Retention 表示我们的注解在什么地方还有效\n//Runtime > class > source\n@Retention(RetentionPolicy.RUNTIME)\n//@Documented 表示是否将我们的注解生成在JAVADoc中\n@Documented\n//@Inherited 子类可以继承父类的注解\n@Inherited\n@interface MyAnnotation {\n\n}\n```\n\n## 反射机制\n\n### 静态|动态语言\n\n#### 动态语言\n\n是一类在运动时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n\n#### 静态语言\n\n与动态语言相对应的，运行时结构不可变的语言就是静态语言，如 java、c、c++；\n\njava 不是动态语言，但 java 可以称之为“准动态语言”。即 java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。java 的动态性让编程的时候更加灵活。\n\n![image-20210414143319605](img/article/JAVA-注解和反射-20210418/image-20210414143319605.png)\n\n**优点**：\n\n​ 可以动态实现创建对象和编译，体现出很大的灵活性；\n\n**缺点**：\n\n​ 对性能有影响，使用反射基本上是一种解释操作。我们可以告诉 JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。\n\n一个类在内存中只有一个 Class 对象；\n\n一个类加载后，类的整个结构都会被封装在 class 对象中；\n\n```java\npublic class Test02 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c1);\n\n        Class c2 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c2.hashCode());\n        Class c3 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c3.hashCode());\n        Class c4 = Class.forName(\"com.annotation.reflection.User\");\n        System.out.println(c4.hashCode());\n\n    }\n}\n\nclass User {\n    private String name;\n    private int id;\n    private int age;\n\n    public User() {\n    }\n\n    public User(String name, int id, int age) {\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", id=\" + id +\n                \", age=\" + age +\n                '}';\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n//运行结果\nclass com.annotation.reflection.User\n460141958\n460141958\n460141958\n```\n\n## Class 类\n\n![image-20210414150428147](img/article/JAVA-注解和反射-20210418/image-20210414150428147.png)\n\n**对象照镜子可以得到的信息**：\n\n某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构（Class/interface/enum/annotation/primitive type/void[]) 的有关信息。\n\n- Class 本身也是一个类；\n- Class 对象只能由系统建立对象；\n- 一个加载的类在 JVM 中只会有一个 Class 实例；\n- 一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件；\n- 每个类的实例都会记得自己是由哪个 Class 实例所生成；\n- 通过 Class 可以完整的得到一个类中的所有被加持的结构；\n- Class 类是 Reflection 的根源，针对任何你想动态加载，运行的类，唯有先获得相应的 Class 对象；\n\n![image-20210414153626283](img/article/JAVA-注解和反射-20210418/image-20210414153626283.png)\n\n**获取 Class 类的实例**\n\n- 若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。\n  - Class cl = Person.class；\n- 已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象\n  - Class cl = person。getClass()；\n- 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassFoundException\n  - Class cl = Class。forName(\"demo01.Student\");\n- 内置基本数据类型可以直接用类名.Type；\n- 还可以利用 ClassLoader，之后讲\n\n演示：\n\n```java\n//测试class 类的创建方式有哪些\npublic class Test03 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person = new Student();\n        System.out.println(\"这个人是：\" + person.name);\n\n        // 方式一 ： 通过对象获得\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式二 ： forname 获得\n        Class c2 = Class.forName(\"com.annotation.reflection.Student\");\n        System.out.println(c2.hashCode());\n\n        //方式三 ： 通过类名.class 获得\n        Class<Student> c3 = Student.class;\n        System.out.println(c3.hashCode());\n\n        //方式四 ： 内置基本数据类型可以直接用类名.Type；\n        Class<Integer> type = Integer.TYPE;\n        System.out.println(type.hashCode());\n\n        //获得父类类型\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\nclass Person {\n    String name;\n    public Person() {}\n    public Person(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nclass Student extends Person {\n    public Student() {\n        this.name = \"学生\";\n    }\n}\nclass Teacher extends Person{\n    public Teacher(){\n        this.name = \"Teac\";\n    }\n}\n\n//结果\n这个人是：学生\n460141958\n460141958\n460141958\n1163157884\nclass com.annotation.reflection.Person\n```\n\n## 类加载内存分析\n\n### 类的加载与 ClassLoader 的理解\n\n- 加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象。\n\n- 链接：将 java 类的二进制代码合并到 JVM 的运行状态之中的过程。\n  - 验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题；\n  - 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法去中进行分配；\n  - 解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程；\n- 初始化：\n  - 执行类构造器 <clinit>() 方法的过程。类构造器<clinit>() 方法是由编译期自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。\n  - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n  - 虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确加锁和同步。\n\n## 类初始化\n\n- **类的主动引用（一定会发生类的初始化）**\n  - 当虚拟机启动，先初始化 main 方法所在的类；\n  - new 一个类的对象；\n  - 调用类的静态成员（除了 final 常量）和静态方法；\n  - 使用`java.lang.reflect`包的方法对类进行反射调用；\n  - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类；\n- **类的被动引用（不会发生类的初始化）**\n  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过子类引用父类的静态变量，不会导致自类初始化；\n  - 通过数组定义类引用，不会触发此类的初始化；\n  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\n\n![image-20210414170751285](img/article/JAVA-注解和反射-20210418/image-20210414170751285.png)\n\n```java\npublic class Test05 {\n    static {\n        System.out.println(\"Main 被加载\");\n    }\n    public static void main(String[] args) {\n        // 1. 主动引用\n        Son son = new Son();\n        // 2. 反射也会产生主动引用\n        try {\n            Class.forName(\"com.annotation.reflection.Son\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        // 不会产生类的引用方法\n        System.out.println(Son.b);\n        Son[] array = new Son[100];\n    }\n}\nclass Father {\n    static int b = 2;\n    static {\n        System.out.println(\"父类被加载\");\n    }\n}\nclass Son extends Father {\n    static {\n        System.out.println(\"子类被加载\");\n        m = 300;\n    }\n    static int m = 100;\n    static final int M = 1;\n}\n```\n\n## 类加载器的作用\n\n- 类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区中类数据的访问入口。\n\n- 类缓存：标准的 javaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象。\n\n![image-20210414173909852](img/article/JAVA-注解和反射-20210418/image-20210414173909852.png)\n\n![image-20210414173959254](img/article/JAVA-注解和反射-20210418/image-20210414173959254.png)\n\n## 获得运行时类的完整结构\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 获取类的信息\npublic class Test07 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class c1 = Class.forName(\"com.annotation.reflection.User\");\n\n        // 获得类的名字\n        System.out.println(c1.getName()); // 获得包名 + 类名\n        System.out.println(c1.getSimpleName());\n\n        // 获得类的属性\n        System.out.println(\"------------\");\n        Field[] fields = c1.getFields(); // 只能找到public属性\n\n        fields = c1.getDeclaredFields(); // 找到全部的属性\n\n        for (Field field : fields){\n            System.out.println(field);\n        }\n\n        // 获得指定属性的值\n        Field name = c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(\"------------\");\n        Method[] methods = c1.getMethods();// 获得本类及其父类的全部public方法\n        for (Method method : methods){\n            System.out.println(\"正常的：\" + method);\n        }\n        methods = c1.getDeclaredMethods(); // 获得本类的全部方法\n        for (Method method : methods){\n            System.out.println(\"getDeclaredMethods：\" + method);\n        }\n\n        // 获得指定方法\n        // 重载\n        Method getName = c1.getMethod(\"getName\", null);\n        Method setName = c1.getMethod(\"setName\", String.class);\n        System.out.println(getName);\n        System.out.println(setName);\n\n        // 获得指定的构造器\n        System.out.println(\"--------------\");\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor constructor : constructors){\n            System.out.println(constructor);\n        }\n        constructors  = c1.getDeclaredConstructors();\n        for (Constructor constructor : constructors){\n            System.out.println(constructor);\n        }\n\n        // 获得指定的构造器\n        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        System.out.println(\"指定的：\" + declaredConstructor);\n    }\n}\n```\n\n## 动态创建对象执行方法\n\n有了 Class 对象，能做什么？\n\n- 创建类的对象：调用 Class 对象的 newInstance()方法\n  - 类必须有一个无参构造器。\n  - 类的构造器的访问权限需要足够。\n- **思考：难道没有无参的构造器就不能创建对象了吗？**\n  - 只要在操作的时候明确的调用类中的构造器，并将参数传递进去后，才可以实例化操作\n  - 步骤如下：\n    - 通过 Class1 类的`getDeclaredConstructor(Class ... parameterTypes) `取得本类的指定形参类型的构造器；\n    - 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；\n    - 通过 Constructor 实例化对象；\n\n**调用指定方法：**\n\n- 通过反射，调用类中的方法，通过 Method 类完成；\n\n  - 通过 Class 类的`getMethod(String name, Class ... parameterTypes)`方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型；\n  - 之后使用`Object invoke(Object obj, Object[] args)` 进行调用，并向方法中传递要设置的 obj 对象的参数信息；\n\n  ![image-20210414184512856](img/article/JAVA-注解和反射-20210418/image-20210414184512856.png)\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n//通过反射动态创建对象\npublic class Test08 {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        //获得Class对象\n        Class<?> c1 = Class.forName(\"com.annotation.reflection.User\");\n\n        //构造一个对象\n        User user = (User)c1.newInstance(); //本质是调用了类的无参构造器\n        System.out.println(user);\n\n        //通过构造器创建对象\n        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        User user2 = (User)constructor.newInstance(\"shan\", 001, 18);\n        System.out.println(user2);\n\n        //通过反射调用普通方法\n        User user3 = (User)c1.newInstance();\n        //通过反射获取一个方法\n        Method setName = c1.getDeclaredMethod(\"setName\", String.class);\n        //invoke 激活\n        //invoke（对象， “方法的值”）\n        setName.invoke(user3,\"shanx\");\n        System.out.println(user3.getName());\n\n        //通过反射操作属性\n        User user4 = (User)c1.newInstance();\n        Field name = c1.getDeclaredField(\"name\");\n        //默认状态下不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true); 此处true为关\n        // 会降低程序效率\n        name.setAccessible(true);\n        name.set(user4, \"shanx-2\");\n        System.out.println(user4.getName());\n\n    }\n}\n```\n\n## SetAccessible\n\n- Method 和 Field、Constructor 对象都有 setAccessible() 方法。\n- SetAccessible 作用是启动和禁用访问安全检查的开关。\n- 参数值为 true 则指示反射的对象在使用时应该取消 java 语言访问检查。\n  - 提高反射的效率。如果代码中必须用反射，而该句代码中需要频繁的被调用，那么请设置为 true。\n  - 使得原本无法访问的私有成员也可以访问。\n- 参数值为 false 则指示反射的对象应该实施 java 语言访问检查。\n\n```java\nimport java.lang.reflect.Method;\n\npublic class Test09 {\n    public static void test01() {\n        User user = new User();\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            user.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"普通方法执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    //反射方式调用\n    public static void test02() throws NoSuchMethodException {\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(\"getName\", null);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            getName.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"反射方式调用执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    //反射方式调用,关闭检测\n    public static void test03() throws NoSuchMethodException {\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(\"getName\", null);\n        getName.setAccessible(true);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 1000000000; i++) {\n            getName.getName();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"反射方式调用,关闭检测执行10亿次：\" + (endTime-startTime) + \"ms\");\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        test01();\n        test02();\n        test03();\n    }\n}\n\n```\n\n## 反射操作泛型\n\n- java 采用泛型擦除的机制来引入泛型，java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有的泛型有关的类型全部擦除；\n- 为了通过反射操作这些类型，java 新增了 ParameterizedType, GenericArrayType，TypeVariable 和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型；\n  - ParameterizedType：表示一种参数化类型，比如 Collection<String>；\n  - GenericArrayType：表示一种元阿苏类型是参数化类型或者类型变量的数组模型；\n  - TypeVariable ：是各种类型变量的公共父接口；\n  - WildcardType ：代表一种通配符类型表达式；\n\n```java\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test10 {\n    public void test01(Map<String,User> map, List<User> list) {\n        System.out.println(\"test01\");\n    }\n\n    public Map<String, User> test02() {\n        System.out.println(\"test02\");\n        return null;\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        Method method = Test10.class.getMethod(\"test01\", Map.class, List.class);\n        Type[] genericParameterTypes = method.getGenericParameterTypes();\n        for (Type genericParameterType : genericParameterTypes) {\n            System.out.println(\"#\"+genericParameterTypes);\n            if (genericParameterType instanceof ParameterizedType) {\n                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                for (Type actualTypeArgument : actualTypeArguments) {\n                    System.out.println(actualTypeArgument);\n                }\n            }\n        }\n\n        method = Test10.class.getMethod(\"test02\",null);\n        Type genericReturnType = method.getGenericReturnType();\n        if (genericReturnType instanceof ParameterizedType) {\n            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n            for (Type actualTypeArgument : actualTypeArguments) {\n                System.out.println(actualTypeArgument);\n            }\n        }\n    }\n}\n\n```\n\n## 反射操作注解：练习 ORM\n\n什么是 ORM？\n\n- Object relationship Mapping --> 对象关系映射\n\n![image-20210414201814306](img/article/JAVA-注解和反射-20210418/image-20210414201814306.png)\n\n- 类和表结构对应\n- 属性和字段对应\n- 对象和记录对应\n\n要求：利用注解和反射完成类和表结构的映射关系。\n\n```java\n//orm\n\npublic class Test11 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class c1 = Class.forName(\"com.annotation.reflection.Stu\");\n\n        // 通过反射获得注解\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        // 获得注解的value的值\n        TableStu tableStu = (TableStu)c1.getAnnotation(TableStu.class);\n        String value = tableStu.value();\n        System.out.println(value);\n\n\n        // 获得类指定注解\n        Field f = c1.getDeclaredField(\"name\");\n        FieldStu annotation = f.getAnnotation(FieldStu.class);\n        System.out.println(annotation.columnName());\n        System.out.println(annotation.length());\n        System.out.println(annotation.type());\n    }\n}\n\n@TableStu(\"db_stu\")\nclass Stu{\n    @FieldStu(columnName = \"db_id\", type = \"int\", length = 10)\n    private int id;\n    @FieldStu(columnName = \"db_age\", type = \"int\", length = 10)\n    private int age;\n    @FieldStu(columnName = \"db_name\", type = \"varchar\", length = 3)\n    private String name;\n\n    public Stu() {\n    }\n\n    public Stu(int id, int age, String name) {\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Stu{\" +\n                \"id=\" + id +\n                \", age=\" + age +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}\n\n// 类名的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface TableStu{\n    String value();\n}\n\n// 属性的注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FieldStu{\n    String columnName();\n    String type();\n    int length();\n}\n```\n","slug":"JAVA-注解和反射-20210418","published":1,"updated":"2022-06-14T04:09:00.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1e0016y4w18gtidu9s","content":"<h1 id=\"注解和反射\"><a href=\"#注解和反射\" class=\"headerlink\" title=\"注解和反射\"></a>注解和反射</h1><span id=\"more\"></span>\n\n<p>重中之重，很多主流框架的实现都使用了注解和反射原理</p>\n<h2 id=\"注解-java-annotation\"><a href=\"#注解-java-annotation\" class=\"headerlink\" title=\"注解 java.annotation\"></a>注解 <code>java.annotation</code></h2><h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>Annotation 是从 JDK1.5 开始引入的新技术；</p>\n<p>Annotation 的作用：</p>\n<ul>\n<li>不是程序本身，可以对程序作出解释（这一点和注释 comment 没什么区别）；</li>\n<li>可以被其他程序（比如：编译器等）读取；</li>\n</ul>\n<p>Annotation 的格式：</p>\n<ul>\n<li><p>注解是以 “@注释名” 在代码中存在的，还可以添加一些参数值，例如：</p>\n</li>\n<li><p>@SuppressWarnings(value=”unchecked”)；</p>\n</li>\n</ul>\n<p>Annotation 在哪里使用？</p>\n<ul>\n<li>可以附加在 package，class，method，field 上面，相当于添加额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问；</li>\n</ul>\n<h2 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h2><ul>\n<li><code>@Override</code> 定义在<code>java.lang.Override</code> 中，此注释只适用于修辞手法，表示一个方法声明打算重写超类中的另一个方法声明</li>\n<li><code>@Deprecated</code> 定义在<code>java.lang.Deprecated</code> 中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择</li>\n<li><code>@SuppressWarnings</code> 定义在 <code>java.lang.SuppressWarnings</code> 中，用来抑制编译时的警告信息，与前两个有所不同的是需要添加一个参数才能正常使用，这些参数都是定义好的</li>\n</ul>\n<pre><code class=\"java\">@SuppressWarnings(&quot;all&quot;)\n@SuppressWarnings(&quot;unchecked&quot;)\n@SuppressWarnings(value = &#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)\n...\n</code></pre>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p>元注解的作用就是负责注解其他注解，java 定义了 4 个标准的 meta-annotation 类型，他们被用来提供对其他 annotation 类型作说明</p>\n<pre><code>☆ @Target //用于描述注解的适用范围\n☆ @Retention //表示在什么级别保存该注释信息，用于描述注解的生命周期(source &lt; class  &lt; RUNTIME)\n@Document // 说明该注解将被包含在javadoc中\n@Inherited // 说明子类可以继承父类中的该注解\n</code></pre>\n<h2 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h2><p>使用@interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口</p>\n<p>分析：</p>\n<ol>\n<li>@interface 用来声明一个注解，格式 <code>public @inteface 注解名 &#123; content &#125;</code></li>\n<li>其中的每一个方法实际上是声明了一个配置参数</li>\n<li>方法的名称就是参数的名称</li>\n<li>返回值类型就是参数的类型（返回值只能是基本类型 class、String、 enum）</li>\n<li>可以通过 default 来声明参数的默认值</li>\n<li>如果只有一个参数成员，一般参数名为 value</li>\n<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0 作为默认值</li>\n</ol>\n<pre><code class=\"java\">//测试元注解\npublic class Test02 &#123;\n    // 注解可以显示赋值 如果没有默认值，就必须给注解赋值\n    @MyAnnotation(name = &quot;shan&quot;, age = 24)\n    public void test()&#123;\n    &#125;\n&#125;\n//定义一个注解\n//Target表示我们的注解可以用在哪些地方\n@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)\n//Retention 表示我们的注解在什么地方还有效\n//Runtime &gt; class &gt; source\n@Retention(RetentionPolicy.RUNTIME)\n//@Documented 表示是否将我们的注解生成在JAVADoc中\n@Documented\n//@Inherited 子类可以继承父类的注解\n@Inherited\n@interface MyAnnotation &#123;\n\n&#125;\n</code></pre>\n<h2 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h2><h3 id=\"静态-动态语言\"><a href=\"#静态-动态语言\" class=\"headerlink\" title=\"静态|动态语言\"></a>静态|动态语言</h3><h4 id=\"动态语言\"><a href=\"#动态语言\" class=\"headerlink\" title=\"动态语言\"></a>动态语言</h4><p>是一类在运动时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>\n<h4 id=\"静态语言\"><a href=\"#静态语言\" class=\"headerlink\" title=\"静态语言\"></a>静态语言</h4><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言，如 java、c、c++；</p>\n<p>java 不是动态语言，但 java 可以称之为“准动态语言”。即 java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。java 的动态性让编程的时候更加灵活。</p>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414143319605.png\" alt=\"image-20210414143319605\"></p>\n<p><strong>优点</strong>：</p>\n<p>​ 可以动态实现创建对象和编译，体现出很大的灵活性；</p>\n<p><strong>缺点</strong>：</p>\n<p>​ 对性能有影响，使用反射基本上是一种解释操作。我们可以告诉 JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。</p>\n<p>一个类在内存中只有一个 Class 对象；</p>\n<p>一个类加载后，类的整个结构都会被封装在 class 对象中；</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c1);\n\n        Class c2 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c2.hashCode());\n        Class c3 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c3.hashCode());\n        Class c4 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c4.hashCode());\n\n    &#125;\n&#125;\n\nclass User &#123;\n    private String name;\n    private int id;\n    private int age;\n\n    public User() &#123;\n    &#125;\n\n    public User(String name, int id, int age) &#123;\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, id=&quot; + id +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\n//运行结果\nclass com.annotation.reflection.User\n460141958\n460141958\n460141958\n</code></pre>\n<h2 id=\"Class-类\"><a href=\"#Class-类\" class=\"headerlink\" title=\"Class 类\"></a>Class 类</h2><p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414150428147.png\" alt=\"image-20210414150428147\"></p>\n<p><strong>对象照镜子可以得到的信息</strong>：</p>\n<p>某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构（Class/interface/enum/annotation/primitive type/void[]) 的有关信息。</p>\n<ul>\n<li>Class 本身也是一个类；</li>\n<li>Class 对象只能由系统建立对象；</li>\n<li>一个加载的类在 JVM 中只会有一个 Class 实例；</li>\n<li>一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件；</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成；</li>\n<li>通过 Class 可以完整的得到一个类中的所有被加持的结构；</li>\n<li>Class 类是 Reflection 的根源，针对任何你想动态加载，运行的类，唯有先获得相应的 Class 对象；</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414153626283.png\" alt=\"image-20210414153626283\"></p>\n<p><strong>获取 Class 类的实例</strong></p>\n<ul>\n<li>若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。<ul>\n<li>Class cl = Person.class；</li>\n</ul>\n</li>\n<li>已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象<ul>\n<li>Class cl = person。getClass()；</li>\n</ul>\n</li>\n<li>已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassFoundException<ul>\n<li>Class cl = Class。forName(“demo01.Student”);</li>\n</ul>\n</li>\n<li>内置基本数据类型可以直接用类名.Type；</li>\n<li>还可以利用 ClassLoader，之后讲</li>\n</ul>\n<p>演示：</p>\n<pre><code class=\"java\">//测试class 类的创建方式有哪些\npublic class Test03 &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Person person = new Student();\n        System.out.println(&quot;这个人是：&quot; + person.name);\n\n        // 方式一 ： 通过对象获得\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式二 ： forname 获得\n        Class c2 = Class.forName(&quot;com.annotation.reflection.Student&quot;);\n        System.out.println(c2.hashCode());\n\n        //方式三 ： 通过类名.class 获得\n        Class&lt;Student&gt; c3 = Student.class;\n        System.out.println(c3.hashCode());\n\n        //方式四 ： 内置基本数据类型可以直接用类名.Type；\n        Class&lt;Integer&gt; type = Integer.TYPE;\n        System.out.println(type.hashCode());\n\n        //获得父类类型\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    &#125;\n&#125;\n\nclass Person &#123;\n    String name;\n    public Person() &#123;&#125;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\nclass Student extends Person &#123;\n    public Student() &#123;\n        this.name = &quot;学生&quot;;\n    &#125;\n&#125;\nclass Teacher extends Person&#123;\n    public Teacher()&#123;\n        this.name = &quot;Teac&quot;;\n    &#125;\n&#125;\n\n//结果\n这个人是：学生\n460141958\n460141958\n460141958\n1163157884\nclass com.annotation.reflection.Person\n</code></pre>\n<h2 id=\"类加载内存分析\"><a href=\"#类加载内存分析\" class=\"headerlink\" title=\"类加载内存分析\"></a>类加载内存分析</h2><h3 id=\"类的加载与-ClassLoader-的理解\"><a href=\"#类的加载与-ClassLoader-的理解\" class=\"headerlink\" title=\"类的加载与 ClassLoader 的理解\"></a>类的加载与 ClassLoader 的理解</h3><ul>\n<li><p>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象。</p>\n</li>\n<li><p>链接：将 java 类的二进制代码合并到 JVM 的运行状态之中的过程。</p>\n<ul>\n<li>验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题；</li>\n<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法去中进行分配；</li>\n<li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程；</li>\n</ul>\n</li>\n<li><p>初始化：</p>\n<ul>\n<li>执行类构造器 <clinit>() 方法的过程。类构造器<clinit>() 方法是由编译期自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>\n<li>虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确加锁和同步。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类初始化\"><a href=\"#类初始化\" class=\"headerlink\" title=\"类初始化\"></a>类初始化</h2><ul>\n<li><strong>类的主动引用（一定会发生类的初始化）</strong><ul>\n<li>当虚拟机启动，先初始化 main 方法所在的类；</li>\n<li>new 一个类的对象；</li>\n<li>调用类的静态成员（除了 final 常量）和静态方法；</li>\n<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用；</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类；</li>\n</ul>\n</li>\n<li><strong>类的被动引用（不会发生类的初始化）</strong><ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过子类引用父类的静态变量，不会导致自类初始化；</li>\n<li>通过数组定义类引用，不会触发此类的初始化；</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414170751285.png\" alt=\"image-20210414170751285\"></p>\n<pre><code class=\"java\">public class Test05 &#123;\n    static &#123;\n        System.out.println(&quot;Main 被加载&quot;);\n    &#125;\n    public static void main(String[] args) &#123;\n        // 1. 主动引用\n        Son son = new Son();\n        // 2. 反射也会产生主动引用\n        try &#123;\n            Class.forName(&quot;com.annotation.reflection.Son&quot;);\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        // 不会产生类的引用方法\n        System.out.println(Son.b);\n        Son[] array = new Son[100];\n    &#125;\n&#125;\nclass Father &#123;\n    static int b = 2;\n    static &#123;\n        System.out.println(&quot;父类被加载&quot;);\n    &#125;\n&#125;\nclass Son extends Father &#123;\n    static &#123;\n        System.out.println(&quot;子类被加载&quot;);\n        m = 300;\n    &#125;\n    static int m = 100;\n    static final int M = 1;\n&#125;\n</code></pre>\n<h2 id=\"类加载器的作用\"><a href=\"#类加载器的作用\" class=\"headerlink\" title=\"类加载器的作用\"></a>类加载器的作用</h2><ul>\n<li><p>类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区中类数据的访问入口。</p>\n</li>\n<li><p>类缓存：标准的 javaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象。</p>\n</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414173909852.png\" alt=\"image-20210414173909852\"></p>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414173959254.png\" alt=\"image-20210414173959254\"></p>\n<h2 id=\"获得运行时类的完整结构\"><a href=\"#获得运行时类的完整结构\" class=\"headerlink\" title=\"获得运行时类的完整结构\"></a>获得运行时类的完整结构</h2><pre><code class=\"java\">import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 获取类的信息\npublic class Test07 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n\n        // 获得类的名字\n        System.out.println(c1.getName()); // 获得包名 + 类名\n        System.out.println(c1.getSimpleName());\n\n        // 获得类的属性\n        System.out.println(&quot;------------&quot;);\n        Field[] fields = c1.getFields(); // 只能找到public属性\n\n        fields = c1.getDeclaredFields(); // 找到全部的属性\n\n        for (Field field : fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        // 获得指定属性的值\n        Field name = c1.getDeclaredField(&quot;name&quot;);\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(&quot;------------&quot;);\n        Method[] methods = c1.getMethods();// 获得本类及其父类的全部public方法\n        for (Method method : methods)&#123;\n            System.out.println(&quot;正常的：&quot; + method);\n        &#125;\n        methods = c1.getDeclaredMethods(); // 获得本类的全部方法\n        for (Method method : methods)&#123;\n            System.out.println(&quot;getDeclaredMethods：&quot; + method);\n        &#125;\n\n        // 获得指定方法\n        // 重载\n        Method getName = c1.getMethod(&quot;getName&quot;, null);\n        Method setName = c1.getMethod(&quot;setName&quot;, String.class);\n        System.out.println(getName);\n        System.out.println(setName);\n\n        // 获得指定的构造器\n        System.out.println(&quot;--------------&quot;);\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor constructor : constructors)&#123;\n            System.out.println(constructor);\n        &#125;\n        constructors  = c1.getDeclaredConstructors();\n        for (Constructor constructor : constructors)&#123;\n            System.out.println(constructor);\n        &#125;\n\n        // 获得指定的构造器\n        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        System.out.println(&quot;指定的：&quot; + declaredConstructor);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"动态创建对象执行方法\"><a href=\"#动态创建对象执行方法\" class=\"headerlink\" title=\"动态创建对象执行方法\"></a>动态创建对象执行方法</h2><p>有了 Class 对象，能做什么？</p>\n<ul>\n<li>创建类的对象：调用 Class 对象的 newInstance()方法<ul>\n<li>类必须有一个无参构造器。</li>\n<li>类的构造器的访问权限需要足够。</li>\n</ul>\n</li>\n<li><strong>思考：难道没有无参的构造器就不能创建对象了吗？</strong><ul>\n<li>只要在操作的时候明确的调用类中的构造器，并将参数传递进去后，才可以实例化操作</li>\n<li>步骤如下：<ul>\n<li>通过 Class1 类的<code>getDeclaredConstructor(Class ... parameterTypes) </code>取得本类的指定形参类型的构造器；</li>\n<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；</li>\n<li>通过 Constructor 实例化对象；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>调用指定方法：</strong></p>\n<ul>\n<li><p>通过反射，调用类中的方法，通过 Method 类完成；</p>\n<ul>\n<li>通过 Class 类的<code>getMethod(String name, Class ... parameterTypes)</code>方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型；</li>\n<li>之后使用<code>Object invoke(Object obj, Object[] args)</code> 进行调用，并向方法中传递要设置的 obj 对象的参数信息；</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414184512856.png\" alt=\"image-20210414184512856\"></p>\n</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n//通过反射动态创建对象\npublic class Test08 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;\n        //获得Class对象\n        Class&lt;?&gt; c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n\n        //构造一个对象\n        User user = (User)c1.newInstance(); //本质是调用了类的无参构造器\n        System.out.println(user);\n\n        //通过构造器创建对象\n        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        User user2 = (User)constructor.newInstance(&quot;shan&quot;, 001, 18);\n        System.out.println(user2);\n\n        //通过反射调用普通方法\n        User user3 = (User)c1.newInstance();\n        //通过反射获取一个方法\n        Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\n        //invoke 激活\n        //invoke（对象， “方法的值”）\n        setName.invoke(user3,&quot;shanx&quot;);\n        System.out.println(user3.getName());\n\n        //通过反射操作属性\n        User user4 = (User)c1.newInstance();\n        Field name = c1.getDeclaredField(&quot;name&quot;);\n        //默认状态下不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true); 此处true为关\n        // 会降低程序效率\n        name.setAccessible(true);\n        name.set(user4, &quot;shanx-2&quot;);\n        System.out.println(user4.getName());\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"SetAccessible\"><a href=\"#SetAccessible\" class=\"headerlink\" title=\"SetAccessible\"></a>SetAccessible</h2><ul>\n<li>Method 和 Field、Constructor 对象都有 setAccessible() 方法。</li>\n<li>SetAccessible 作用是启动和禁用访问安全检查的开关。</li>\n<li>参数值为 true 则指示反射的对象在使用时应该取消 java 语言访问检查。<ul>\n<li>提高反射的效率。如果代码中必须用反射，而该句代码中需要频繁的被调用，那么请设置为 true。</li>\n<li>使得原本无法访问的私有成员也可以访问。</li>\n</ul>\n</li>\n<li>参数值为 false 则指示反射的对象应该实施 java 语言访问检查。</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Method;\n\npublic class Test09 &#123;\n    public static void test01() &#123;\n        User user = new User();\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            user.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;普通方法执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    //反射方式调用\n    public static void test02() throws NoSuchMethodException &#123;\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            getName.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;反射方式调用执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    //反射方式调用,关闭检测\n    public static void test03() throws NoSuchMethodException &#123;\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\n        getName.setAccessible(true);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            getName.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;反射方式调用,关闭检测执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n        test01();\n        test02();\n        test03();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"反射操作泛型\"><a href=\"#反射操作泛型\" class=\"headerlink\" title=\"反射操作泛型\"></a>反射操作泛型</h2><ul>\n<li>java 采用泛型擦除的机制来引入泛型，java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有的泛型有关的类型全部擦除；</li>\n<li>为了通过反射操作这些类型，java 新增了 ParameterizedType, GenericArrayType，TypeVariable 和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型；<ul>\n<li>ParameterizedType：表示一种参数化类型，比如 Collection<String>；</li>\n<li>GenericArrayType：表示一种元阿苏类型是参数化类型或者类型变量的数组模型；</li>\n<li>TypeVariable ：是各种类型变量的公共父接口；</li>\n<li>WildcardType ：代表一种通配符类型表达式；</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test10 &#123;\n    public void test01(Map&lt;String,User&gt; map, List&lt;User&gt; list) &#123;\n        System.out.println(&quot;test01&quot;);\n    &#125;\n\n    public Map&lt;String, User&gt; test02() &#123;\n        System.out.println(&quot;test02&quot;);\n        return null;\n    &#125;\n\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n        Method method = Test10.class.getMethod(&quot;test01&quot;, Map.class, List.class);\n        Type[] genericParameterTypes = method.getGenericParameterTypes();\n        for (Type genericParameterType : genericParameterTypes) &#123;\n            System.out.println(&quot;#&quot;+genericParameterTypes);\n            if (genericParameterType instanceof ParameterizedType) &#123;\n                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                for (Type actualTypeArgument : actualTypeArguments) &#123;\n                    System.out.println(actualTypeArgument);\n                &#125;\n            &#125;\n        &#125;\n\n        method = Test10.class.getMethod(&quot;test02&quot;,null);\n        Type genericReturnType = method.getGenericReturnType();\n        if (genericReturnType instanceof ParameterizedType) &#123;\n            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n            for (Type actualTypeArgument : actualTypeArguments) &#123;\n                System.out.println(actualTypeArgument);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"反射操作注解：练习-ORM\"><a href=\"#反射操作注解：练习-ORM\" class=\"headerlink\" title=\"反射操作注解：练习 ORM\"></a>反射操作注解：练习 ORM</h2><p>什么是 ORM？</p>\n<ul>\n<li>Object relationship Mapping –&gt; 对象关系映射</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414201814306.png\" alt=\"image-20210414201814306\"></p>\n<ul>\n<li>类和表结构对应</li>\n<li>属性和字段对应</li>\n<li>对象和记录对应</li>\n</ul>\n<p>要求：利用注解和反射完成类和表结构的映射关系。</p>\n<pre><code class=\"java\">//orm\n\npublic class Test11 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.Stu&quot;);\n\n        // 通过反射获得注解\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation annotation : annotations) &#123;\n            System.out.println(annotation);\n        &#125;\n\n        // 获得注解的value的值\n        TableStu tableStu = (TableStu)c1.getAnnotation(TableStu.class);\n        String value = tableStu.value();\n        System.out.println(value);\n\n\n        // 获得类指定注解\n        Field f = c1.getDeclaredField(&quot;name&quot;);\n        FieldStu annotation = f.getAnnotation(FieldStu.class);\n        System.out.println(annotation.columnName());\n        System.out.println(annotation.length());\n        System.out.println(annotation.type());\n    &#125;\n&#125;\n\n@TableStu(&quot;db_stu&quot;)\nclass Stu&#123;\n    @FieldStu(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 10)\n    private int id;\n    @FieldStu(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 10)\n    private int age;\n    @FieldStu(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 3)\n    private String name;\n\n    public Stu() &#123;\n    &#125;\n\n    public Stu(int id, int age, String name) &#123;\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Stu&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, age=&quot; + age +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n// 类名的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface TableStu&#123;\n    String value();\n&#125;\n\n// 属性的注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FieldStu&#123;\n    String columnName();\n    String type();\n    int length();\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"注解和反射\"><a href=\"#注解和反射\" class=\"headerlink\" title=\"注解和反射\"></a>注解和反射</h1>","more":"<p>重中之重，很多主流框架的实现都使用了注解和反射原理</p>\n<h2 id=\"注解-java-annotation\"><a href=\"#注解-java-annotation\" class=\"headerlink\" title=\"注解 java.annotation\"></a>注解 <code>java.annotation</code></h2><h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><p>Annotation 是从 JDK1.5 开始引入的新技术；</p>\n<p>Annotation 的作用：</p>\n<ul>\n<li>不是程序本身，可以对程序作出解释（这一点和注释 comment 没什么区别）；</li>\n<li>可以被其他程序（比如：编译器等）读取；</li>\n</ul>\n<p>Annotation 的格式：</p>\n<ul>\n<li><p>注解是以 “@注释名” 在代码中存在的，还可以添加一些参数值，例如：</p>\n</li>\n<li><p>@SuppressWarnings(value=”unchecked”)；</p>\n</li>\n</ul>\n<p>Annotation 在哪里使用？</p>\n<ul>\n<li>可以附加在 package，class，method，field 上面，相当于添加额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问；</li>\n</ul>\n<h2 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a>内置注解</h2><ul>\n<li><code>@Override</code> 定义在<code>java.lang.Override</code> 中，此注释只适用于修辞手法，表示一个方法声明打算重写超类中的另一个方法声明</li>\n<li><code>@Deprecated</code> 定义在<code>java.lang.Deprecated</code> 中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择</li>\n<li><code>@SuppressWarnings</code> 定义在 <code>java.lang.SuppressWarnings</code> 中，用来抑制编译时的警告信息，与前两个有所不同的是需要添加一个参数才能正常使用，这些参数都是定义好的</li>\n</ul>\n<pre><code class=\"java\">@SuppressWarnings(&quot;all&quot;)\n@SuppressWarnings(&quot;unchecked&quot;)\n@SuppressWarnings(value = &#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)\n...\n</code></pre>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p>元注解的作用就是负责注解其他注解，java 定义了 4 个标准的 meta-annotation 类型，他们被用来提供对其他 annotation 类型作说明</p>\n<pre><code>☆ @Target //用于描述注解的适用范围\n☆ @Retention //表示在什么级别保存该注释信息，用于描述注解的生命周期(source &lt; class  &lt; RUNTIME)\n@Document // 说明该注解将被包含在javadoc中\n@Inherited // 说明子类可以继承父类中的该注解\n</code></pre>\n<h2 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h2><p>使用@interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口</p>\n<p>分析：</p>\n<ol>\n<li>@interface 用来声明一个注解，格式 <code>public @inteface 注解名 &#123; content &#125;</code></li>\n<li>其中的每一个方法实际上是声明了一个配置参数</li>\n<li>方法的名称就是参数的名称</li>\n<li>返回值类型就是参数的类型（返回值只能是基本类型 class、String、 enum）</li>\n<li>可以通过 default 来声明参数的默认值</li>\n<li>如果只有一个参数成员，一般参数名为 value</li>\n<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、0 作为默认值</li>\n</ol>\n<pre><code class=\"java\">//测试元注解\npublic class Test02 &#123;\n    // 注解可以显示赋值 如果没有默认值，就必须给注解赋值\n    @MyAnnotation(name = &quot;shan&quot;, age = 24)\n    public void test()&#123;\n    &#125;\n&#125;\n//定义一个注解\n//Target表示我们的注解可以用在哪些地方\n@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)\n//Retention 表示我们的注解在什么地方还有效\n//Runtime &gt; class &gt; source\n@Retention(RetentionPolicy.RUNTIME)\n//@Documented 表示是否将我们的注解生成在JAVADoc中\n@Documented\n//@Inherited 子类可以继承父类的注解\n@Inherited\n@interface MyAnnotation &#123;\n\n&#125;\n</code></pre>\n<h2 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h2><h3 id=\"静态-动态语言\"><a href=\"#静态-动态语言\" class=\"headerlink\" title=\"静态|动态语言\"></a>静态|动态语言</h3><h4 id=\"动态语言\"><a href=\"#动态语言\" class=\"headerlink\" title=\"动态语言\"></a>动态语言</h4><p>是一类在运动时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>\n<h4 id=\"静态语言\"><a href=\"#静态语言\" class=\"headerlink\" title=\"静态语言\"></a>静态语言</h4><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言，如 java、c、c++；</p>\n<p>java 不是动态语言，但 java 可以称之为“准动态语言”。即 java 有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。java 的动态性让编程的时候更加灵活。</p>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414143319605.png\" alt=\"image-20210414143319605\"></p>\n<p><strong>优点</strong>：</p>\n<p>​ 可以动态实现创建对象和编译，体现出很大的灵活性；</p>\n<p><strong>缺点</strong>：</p>\n<p>​ 对性能有影响，使用反射基本上是一种解释操作。我们可以告诉 JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。</p>\n<p>一个类在内存中只有一个 Class 对象；</p>\n<p>一个类加载后，类的整个结构都会被封装在 class 对象中；</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c1);\n\n        Class c2 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c2.hashCode());\n        Class c3 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c3.hashCode());\n        Class c4 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n        System.out.println(c4.hashCode());\n\n    &#125;\n&#125;\n\nclass User &#123;\n    private String name;\n    private int id;\n    private int age;\n\n    public User() &#123;\n    &#125;\n\n    public User(String name, int id, int age) &#123;\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, id=&quot; + id +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\n//运行结果\nclass com.annotation.reflection.User\n460141958\n460141958\n460141958\n</code></pre>\n<h2 id=\"Class-类\"><a href=\"#Class-类\" class=\"headerlink\" title=\"Class 类\"></a>Class 类</h2><p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414150428147.png\" alt=\"image-20210414150428147\"></p>\n<p><strong>对象照镜子可以得到的信息</strong>：</p>\n<p>某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构（Class/interface/enum/annotation/primitive type/void[]) 的有关信息。</p>\n<ul>\n<li>Class 本身也是一个类；</li>\n<li>Class 对象只能由系统建立对象；</li>\n<li>一个加载的类在 JVM 中只会有一个 Class 实例；</li>\n<li>一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件；</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成；</li>\n<li>通过 Class 可以完整的得到一个类中的所有被加持的结构；</li>\n<li>Class 类是 Reflection 的根源，针对任何你想动态加载，运行的类，唯有先获得相应的 Class 对象；</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414153626283.png\" alt=\"image-20210414153626283\"></p>\n<p><strong>获取 Class 类的实例</strong></p>\n<ul>\n<li>若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。<ul>\n<li>Class cl = Person.class；</li>\n</ul>\n</li>\n<li>已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象<ul>\n<li>Class cl = person。getClass()；</li>\n</ul>\n</li>\n<li>已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName()获取，可能抛出 ClassFoundException<ul>\n<li>Class cl = Class。forName(“demo01.Student”);</li>\n</ul>\n</li>\n<li>内置基本数据类型可以直接用类名.Type；</li>\n<li>还可以利用 ClassLoader，之后讲</li>\n</ul>\n<p>演示：</p>\n<pre><code class=\"java\">//测试class 类的创建方式有哪些\npublic class Test03 &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Person person = new Student();\n        System.out.println(&quot;这个人是：&quot; + person.name);\n\n        // 方式一 ： 通过对象获得\n        Class c1 = person.getClass();\n        System.out.println(c1.hashCode());\n\n        // 方式二 ： forname 获得\n        Class c2 = Class.forName(&quot;com.annotation.reflection.Student&quot;);\n        System.out.println(c2.hashCode());\n\n        //方式三 ： 通过类名.class 获得\n        Class&lt;Student&gt; c3 = Student.class;\n        System.out.println(c3.hashCode());\n\n        //方式四 ： 内置基本数据类型可以直接用类名.Type；\n        Class&lt;Integer&gt; type = Integer.TYPE;\n        System.out.println(type.hashCode());\n\n        //获得父类类型\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    &#125;\n&#125;\n\nclass Person &#123;\n    String name;\n    public Person() &#123;&#125;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\nclass Student extends Person &#123;\n    public Student() &#123;\n        this.name = &quot;学生&quot;;\n    &#125;\n&#125;\nclass Teacher extends Person&#123;\n    public Teacher()&#123;\n        this.name = &quot;Teac&quot;;\n    &#125;\n&#125;\n\n//结果\n这个人是：学生\n460141958\n460141958\n460141958\n1163157884\nclass com.annotation.reflection.Person\n</code></pre>\n<h2 id=\"类加载内存分析\"><a href=\"#类加载内存分析\" class=\"headerlink\" title=\"类加载内存分析\"></a>类加载内存分析</h2><h3 id=\"类的加载与-ClassLoader-的理解\"><a href=\"#类的加载与-ClassLoader-的理解\" class=\"headerlink\" title=\"类的加载与 ClassLoader 的理解\"></a>类的加载与 ClassLoader 的理解</h3><ul>\n<li><p>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象。</p>\n</li>\n<li><p>链接：将 java 类的二进制代码合并到 JVM 的运行状态之中的过程。</p>\n<ul>\n<li>验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题；</li>\n<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法去中进行分配；</li>\n<li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程；</li>\n</ul>\n</li>\n<li><p>初始化：</p>\n<ul>\n<li>执行类构造器 <clinit>() 方法的过程。类构造器<clinit>() 方法是由编译期自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>\n<li>虚拟机会保证一个类的<clinit>() 方法在多线程环境中被正确加锁和同步。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类初始化\"><a href=\"#类初始化\" class=\"headerlink\" title=\"类初始化\"></a>类初始化</h2><ul>\n<li><strong>类的主动引用（一定会发生类的初始化）</strong><ul>\n<li>当虚拟机启动，先初始化 main 方法所在的类；</li>\n<li>new 一个类的对象；</li>\n<li>调用类的静态成员（除了 final 常量）和静态方法；</li>\n<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用；</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类；</li>\n</ul>\n</li>\n<li><strong>类的被动引用（不会发生类的初始化）</strong><ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过子类引用父类的静态变量，不会导致自类初始化；</li>\n<li>通过数组定义类引用，不会触发此类的初始化；</li>\n<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414170751285.png\" alt=\"image-20210414170751285\"></p>\n<pre><code class=\"java\">public class Test05 &#123;\n    static &#123;\n        System.out.println(&quot;Main 被加载&quot;);\n    &#125;\n    public static void main(String[] args) &#123;\n        // 1. 主动引用\n        Son son = new Son();\n        // 2. 反射也会产生主动引用\n        try &#123;\n            Class.forName(&quot;com.annotation.reflection.Son&quot;);\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        // 不会产生类的引用方法\n        System.out.println(Son.b);\n        Son[] array = new Son[100];\n    &#125;\n&#125;\nclass Father &#123;\n    static int b = 2;\n    static &#123;\n        System.out.println(&quot;父类被加载&quot;);\n    &#125;\n&#125;\nclass Son extends Father &#123;\n    static &#123;\n        System.out.println(&quot;子类被加载&quot;);\n        m = 300;\n    &#125;\n    static int m = 100;\n    static final int M = 1;\n&#125;\n</code></pre>\n<h2 id=\"类加载器的作用\"><a href=\"#类加载器的作用\" class=\"headerlink\" title=\"类加载器的作用\"></a>类加载器的作用</h2><ul>\n<li><p>类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区中类数据的访问入口。</p>\n</li>\n<li><p>类缓存：标准的 javaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象。</p>\n</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414173909852.png\" alt=\"image-20210414173909852\"></p>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414173959254.png\" alt=\"image-20210414173959254\"></p>\n<h2 id=\"获得运行时类的完整结构\"><a href=\"#获得运行时类的完整结构\" class=\"headerlink\" title=\"获得运行时类的完整结构\"></a>获得运行时类的完整结构</h2><pre><code class=\"java\">import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n// 获取类的信息\npublic class Test07 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n\n        // 获得类的名字\n        System.out.println(c1.getName()); // 获得包名 + 类名\n        System.out.println(c1.getSimpleName());\n\n        // 获得类的属性\n        System.out.println(&quot;------------&quot;);\n        Field[] fields = c1.getFields(); // 只能找到public属性\n\n        fields = c1.getDeclaredFields(); // 找到全部的属性\n\n        for (Field field : fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        // 获得指定属性的值\n        Field name = c1.getDeclaredField(&quot;name&quot;);\n        System.out.println(name);\n\n        // 获得类的方法\n        System.out.println(&quot;------------&quot;);\n        Method[] methods = c1.getMethods();// 获得本类及其父类的全部public方法\n        for (Method method : methods)&#123;\n            System.out.println(&quot;正常的：&quot; + method);\n        &#125;\n        methods = c1.getDeclaredMethods(); // 获得本类的全部方法\n        for (Method method : methods)&#123;\n            System.out.println(&quot;getDeclaredMethods：&quot; + method);\n        &#125;\n\n        // 获得指定方法\n        // 重载\n        Method getName = c1.getMethod(&quot;getName&quot;, null);\n        Method setName = c1.getMethod(&quot;setName&quot;, String.class);\n        System.out.println(getName);\n        System.out.println(setName);\n\n        // 获得指定的构造器\n        System.out.println(&quot;--------------&quot;);\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor constructor : constructors)&#123;\n            System.out.println(constructor);\n        &#125;\n        constructors  = c1.getDeclaredConstructors();\n        for (Constructor constructor : constructors)&#123;\n            System.out.println(constructor);\n        &#125;\n\n        // 获得指定的构造器\n        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        System.out.println(&quot;指定的：&quot; + declaredConstructor);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"动态创建对象执行方法\"><a href=\"#动态创建对象执行方法\" class=\"headerlink\" title=\"动态创建对象执行方法\"></a>动态创建对象执行方法</h2><p>有了 Class 对象，能做什么？</p>\n<ul>\n<li>创建类的对象：调用 Class 对象的 newInstance()方法<ul>\n<li>类必须有一个无参构造器。</li>\n<li>类的构造器的访问权限需要足够。</li>\n</ul>\n</li>\n<li><strong>思考：难道没有无参的构造器就不能创建对象了吗？</strong><ul>\n<li>只要在操作的时候明确的调用类中的构造器，并将参数传递进去后，才可以实例化操作</li>\n<li>步骤如下：<ul>\n<li>通过 Class1 类的<code>getDeclaredConstructor(Class ... parameterTypes) </code>取得本类的指定形参类型的构造器；</li>\n<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数；</li>\n<li>通过 Constructor 实例化对象；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>调用指定方法：</strong></p>\n<ul>\n<li><p>通过反射，调用类中的方法，通过 Method 类完成；</p>\n<ul>\n<li>通过 Class 类的<code>getMethod(String name, Class ... parameterTypes)</code>方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型；</li>\n<li>之后使用<code>Object invoke(Object obj, Object[] args)</code> 进行调用，并向方法中传递要设置的 obj 对象的参数信息；</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414184512856.png\" alt=\"image-20210414184512856\"></p>\n</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n//通过反射动态创建对象\npublic class Test08 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;\n        //获得Class对象\n        Class&lt;?&gt; c1 = Class.forName(&quot;com.annotation.reflection.User&quot;);\n\n        //构造一个对象\n        User user = (User)c1.newInstance(); //本质是调用了类的无参构造器\n        System.out.println(user);\n\n        //通过构造器创建对象\n        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);\n        User user2 = (User)constructor.newInstance(&quot;shan&quot;, 001, 18);\n        System.out.println(user2);\n\n        //通过反射调用普通方法\n        User user3 = (User)c1.newInstance();\n        //通过反射获取一个方法\n        Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);\n        //invoke 激活\n        //invoke（对象， “方法的值”）\n        setName.invoke(user3,&quot;shanx&quot;);\n        System.out.println(user3.getName());\n\n        //通过反射操作属性\n        User user4 = (User)c1.newInstance();\n        Field name = c1.getDeclaredField(&quot;name&quot;);\n        //默认状态下不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true); 此处true为关\n        // 会降低程序效率\n        name.setAccessible(true);\n        name.set(user4, &quot;shanx-2&quot;);\n        System.out.println(user4.getName());\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"SetAccessible\"><a href=\"#SetAccessible\" class=\"headerlink\" title=\"SetAccessible\"></a>SetAccessible</h2><ul>\n<li>Method 和 Field、Constructor 对象都有 setAccessible() 方法。</li>\n<li>SetAccessible 作用是启动和禁用访问安全检查的开关。</li>\n<li>参数值为 true 则指示反射的对象在使用时应该取消 java 语言访问检查。<ul>\n<li>提高反射的效率。如果代码中必须用反射，而该句代码中需要频繁的被调用，那么请设置为 true。</li>\n<li>使得原本无法访问的私有成员也可以访问。</li>\n</ul>\n</li>\n<li>参数值为 false 则指示反射的对象应该实施 java 语言访问检查。</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Method;\n\npublic class Test09 &#123;\n    public static void test01() &#123;\n        User user = new User();\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            user.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;普通方法执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    //反射方式调用\n    public static void test02() throws NoSuchMethodException &#123;\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            getName.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;反射方式调用执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    //反射方式调用,关闭检测\n    public static void test03() throws NoSuchMethodException &#123;\n        User user = new User();\n        Class c1 = user.getClass();\n        Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);\n        getName.setAccessible(true);\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 1000000000; i++) &#123;\n            getName.getName();\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;反射方式调用,关闭检测执行10亿次：&quot; + (endTime-startTime) + &quot;ms&quot;);\n    &#125;\n\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n        test01();\n        test02();\n        test03();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"反射操作泛型\"><a href=\"#反射操作泛型\" class=\"headerlink\" title=\"反射操作泛型\"></a>反射操作泛型</h2><ul>\n<li>java 采用泛型擦除的机制来引入泛型，java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有的泛型有关的类型全部擦除；</li>\n<li>为了通过反射操作这些类型，java 新增了 ParameterizedType, GenericArrayType，TypeVariable 和 WildcardType 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类型；<ul>\n<li>ParameterizedType：表示一种参数化类型，比如 Collection<String>；</li>\n<li>GenericArrayType：表示一种元阿苏类型是参数化类型或者类型变量的数组模型；</li>\n<li>TypeVariable ：是各种类型变量的公共父接口；</li>\n<li>WildcardType ：代表一种通配符类型表达式；</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"java\">import java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test10 &#123;\n    public void test01(Map&lt;String,User&gt; map, List&lt;User&gt; list) &#123;\n        System.out.println(&quot;test01&quot;);\n    &#125;\n\n    public Map&lt;String, User&gt; test02() &#123;\n        System.out.println(&quot;test02&quot;);\n        return null;\n    &#125;\n\n    public static void main(String[] args) throws NoSuchMethodException &#123;\n        Method method = Test10.class.getMethod(&quot;test01&quot;, Map.class, List.class);\n        Type[] genericParameterTypes = method.getGenericParameterTypes();\n        for (Type genericParameterType : genericParameterTypes) &#123;\n            System.out.println(&quot;#&quot;+genericParameterTypes);\n            if (genericParameterType instanceof ParameterizedType) &#123;\n                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                for (Type actualTypeArgument : actualTypeArguments) &#123;\n                    System.out.println(actualTypeArgument);\n                &#125;\n            &#125;\n        &#125;\n\n        method = Test10.class.getMethod(&quot;test02&quot;,null);\n        Type genericReturnType = method.getGenericReturnType();\n        if (genericReturnType instanceof ParameterizedType) &#123;\n            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();\n            for (Type actualTypeArgument : actualTypeArguments) &#123;\n                System.out.println(actualTypeArgument);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"反射操作注解：练习-ORM\"><a href=\"#反射操作注解：练习-ORM\" class=\"headerlink\" title=\"反射操作注解：练习 ORM\"></a>反射操作注解：练习 ORM</h2><p>什么是 ORM？</p>\n<ul>\n<li>Object relationship Mapping –&gt; 对象关系映射</li>\n</ul>\n<p><img src=\"img/article/JAVA-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84-20210418/image-20210414201814306.png\" alt=\"image-20210414201814306\"></p>\n<ul>\n<li>类和表结构对应</li>\n<li>属性和字段对应</li>\n<li>对象和记录对应</li>\n</ul>\n<p>要求：利用注解和反射完成类和表结构的映射关系。</p>\n<pre><code class=\"java\">//orm\n\npublic class Test11 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;\n        Class c1 = Class.forName(&quot;com.annotation.reflection.Stu&quot;);\n\n        // 通过反射获得注解\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation annotation : annotations) &#123;\n            System.out.println(annotation);\n        &#125;\n\n        // 获得注解的value的值\n        TableStu tableStu = (TableStu)c1.getAnnotation(TableStu.class);\n        String value = tableStu.value();\n        System.out.println(value);\n\n\n        // 获得类指定注解\n        Field f = c1.getDeclaredField(&quot;name&quot;);\n        FieldStu annotation = f.getAnnotation(FieldStu.class);\n        System.out.println(annotation.columnName());\n        System.out.println(annotation.length());\n        System.out.println(annotation.type());\n    &#125;\n&#125;\n\n@TableStu(&quot;db_stu&quot;)\nclass Stu&#123;\n    @FieldStu(columnName = &quot;db_id&quot;, type = &quot;int&quot;, length = 10)\n    private int id;\n    @FieldStu(columnName = &quot;db_age&quot;, type = &quot;int&quot;, length = 10)\n    private int age;\n    @FieldStu(columnName = &quot;db_name&quot;, type = &quot;varchar&quot;, length = 3)\n    private String name;\n\n    public Stu() &#123;\n    &#125;\n\n    public Stu(int id, int age, String name) &#123;\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Stu&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, age=&quot; + age +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n// 类名的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface TableStu&#123;\n    String value();\n&#125;\n\n// 属性的注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface FieldStu&#123;\n    String columnName();\n    String type();\n    int length();\n&#125;\n</code></pre>"},{"title":"JAVA-网络编程","date":"2021-04-12T14:50:21.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n\n\n# 网络编程\n\n<!--more-->\n\n## 概述\n\n类似于平信信件\n\n其中涉及计算机网络基本概念，网络编程的目的就是传播交流信息、数据交换、通信；达到的效果是需要如何准确定位到网络上的一台主机（IP、端口、资源），对主机进行数据传输\n\n与JAVAWEB网页编程的B/S架构不同，网络编程是C/S编程。\n\n计算机网络是指将[地理](https://baike.baidu.com/item/地理)位置不同的具有独立功能的多台[计算机](https://baike.baidu.com/item/计算机/140338)及其外部设备，通过通信线路连接起来，在[网络操作系统](https://baike.baidu.com/item/网络操作系统/3997)，[网络管理软件](https://baike.baidu.com/item/网络管理软件/6579078)及[网络通信协议](https://baike.baidu.com/item/网络通信协议/4438611)的管理和协调下，实现[资源共享](https://baike.baidu.com/item/资源共享/233480)和信息传递的计算机系统。\n\n\n\n### 网络编程的目的：\n\n交流信息，数据交换，通信。\n\n### 想要达到这个效果需要什么\n\n1. 如何准确地定位网络上的一台主机，192.168.0.176：3553   IP :  端口，定位到这个计算机上的某个资源。\n2. 找到了这个主机，如何传输数据？\n3. javaweb : 网页编程  B/S             网络编程 ：TCP/IP 、C/S\n\n\n\n## 网络通信的要素\n\n如何实现网络的通信？\n\n1. **通信双方的ip**、**端口号**\n2. **规则**：TCP/IP 、OSI\n\n小结：\n\n1. 网络编程中两个主要的问题\n   - 如何准确定位到网络上一台或多台主机\n   - 找到主机之后如何进行通信\n2. 网络编程中的要素\n   - IP和端口号\n   - 网络通信协议 UDP TCP/IP\n3. 万物皆对象\n\n\n\n## IP\n\nip地址：InetAddress\n\n- 唯一定位一台网络上的计算机\n\n- 127.0.0.1 本机localhost\n\n- ip地址的分类\n\n  - ipv4 / ipv6\n\n    - IPV4 127.0.0.1 四个字节组成  42亿    2011年已被用尽\n\n    - IPV6 128位、8个无符号整数组成  abcde\n\n      `2834:4bba:aacb:0013:1241:1aaa:1341:6254`\n\n  - 公网 (互联网）- 私网（局域网）\n\n    - ABCD类地址\n\n- 域名：记忆IP问题\n\n获取相关信息\n\n```java\npublic class TestInterAddress {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\");\n            System.out.println(inetAddress1);\n\n            InetAddress inetAddress2 = InetAddress.getByName(\"localhost\");\n            System.out.println(inetAddress2);\n\n            InetAddress inetAddress3 = InetAddress.getLocalHost();\n            System.out.println(inetAddress3);\n\n            InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\", 8080);\n            System.out.println(inetSocketAddress);\n\n            //查询网站IP地址\n            InetAddress inetAddress4 = InetAddress.getByName(\"www.baidu.com\");\n            System.out.println(inetAddress4);\n\n            System.out.println( inetAddress4.getCanonicalHostName());\n            System.out.println( inetAddress4.getHostAddress());\n            System.out.println( inetAddress4.getHostName());\n            System.out.println( inetAddress4.getClass());\n\n\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n## 端口\n\n端口表示计算机上的一个程序的进程：\n\n* 不同的进程有不同的端口号，用来区分软件。\n\n* 被规定范围 0 - 65535\n\n* TCP，UDP ：65535*2   TCP 用80  UDP也可以用80  单个协议下，端口号不能冲突\n\n* 端口分类\n\n  * 公有端口 0-1023 系统进程使用，尽量不用\n    * HTTP : 80\n    * HTTPS : 443\n    * FTP : 21\n    * Telent : 23\n  * 程序注册端口，1024-49151，分配用户或者程序\n    * Tomcat : 8080\n    * MySql : 3306\n    * Oracle ：1521\n    * postgre : 5432\n  * 动态，私有：49152 - 65535\n\n  ```java\n  netstat -ano 查看所有端口\n      \n  netstat -ano|findstr \"5900\"   查看指定端口\n      \n  tasklist|findstr \"8696\"  查看指定端口的进程\n      \n  任务管理器  ctrl + shift + esc\n  ```\n\n  \n\n## 通信协议\n\n协议：约定，就好比我们现在说的是普通话；\n\n网络通信协议：速率，传输码率，代码结构，传输控制......\n\n问题：非常的复杂？\n\n大事化小：分层；\n\nTCP/IP协议簇：**实际上是一组协议**\n\n重要：\n\n* TCP:：用户传输协议；\n* UDP：用户数据报协议；\n\n* IP：网络互连协议；\n\nTCP / UDP对比\n\n* **TCP**： 连接稳定、`三次握手四次挥手`、客户端与服务端、传输需要释放效率低；\n* **UDP**: 不连接不稳定、客户端服务端无明确界限、无需准备、 DDOS洪泛攻击；\n\n\n\n## TCP\n\n客户端\n\n1. 连接服务器 Socket；\n2. 发送消息；\n\n```java\n//客户端\npublic class TcpClientDemo1 {\n    public static void main(String[] args) {\n        Socket socket = null;\n        OutputStream os = null;\n        try {\n            //要知道服务器的地址\n            InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\");\n            int port = 9999;\n            //创建一个socket连接\n            socket = new Socket(serverIP, port);\n            //发送消息\n            os = socket.getOutputStream();\n            os.write(\"message！\".getBytes());\n        }catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (os!=null){\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n服务器\n\n1. 建立服务的端口 ServerSocket；\n2. 等待用户的链接 accept；\n3. 接收用户的消息；\n\n```java\n//服务端\npublic class TcpServerDemo1 {\n    public static void main(String[] args) throws Exception {\n\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream is = null;\n        ByteArrayOutputStream bs = null;\n        try {\n            //有一个服务器地址\n             serverSocket = new ServerSocket(9999);\n            //等待客户端连接\n            socket = serverSocket.accept();\n            //读取客户端的信息\n            is = socket.getInputStream();\n            //管道流\n            bs = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = is.read(buffer)) != -1) {\n                bs.write(buffer, 0, len);\n            }\n            System.out.println(bs.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (bs != null) {\n                try {\n                    bs.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (is != null) {\n                try {\n                    is.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (socket != null) {\n                try {\n                    socket.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n## TCP文件上传\n\n客户端\n\n```java\n//客户端提交文件\npublic class TcpClientDemo2 {\n    public static void main(String[] args) {\n        Socket socket = null;\n        OutputStream os = null;\n        FileInputStream fis = null;\n        try {\n            //创建一个socket连接\n            socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9000);\n            //创建一个输出流\n            os = socket.getOutputStream();\n            //读取文件\n            fis = new FileInputStream(new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\bg17.jpg\"));\n            //写出文件\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len=fis.read(buffer))!=-1) {\n                os.write(buffer, 0, len);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            if (fis!=null) {\n                try {\n                    fis.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (os!=null) {\n                try {\n                    os.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null) {\n                try {\n                    socket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n服务端\n\n```java\n//服务端接收文件\npublic class TcpServerDemo2 {\n    public static void main(String[] args) {\n        //创建服务\n        ServerSocket serverSocket = null;\n        //监听客户端的连接\n        Socket socket = null;\n        //获取输入流\n        InputStream is = null;\n        //文件输出\n        FileOutputStream fos = null;\n\n        try {\n            serverSocket = new ServerSocket(9000);\n            socket = serverSocket.accept(); //阻塞式监听，会一直等待客户端连接\n            is = socket.getInputStream();\n            fos = new FileOutputStream(new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\\" + Math.random()*1000000000 + \".jpg\"));\n            byte[] buffer = new byte[1024];\n            int len = 0;\n            while ((len=is.read(buffer))!=-1){\n                fos.write(buffer, 0, len);\n                System.out.println(\"接收文件.....\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            if (fos!=null) {\n                try {\n                    fos.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (is!=null) {\n                try {\n                    is.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null) {\n                try {\n                    socket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket!=null) {\n                try {\n                    serverSocket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## Tomcat\n\n服务端\n\n- 自定义 S\n- Tomcat服务器 S : JAVA后台开发\n\n客户端\n\n- 自定义 C\n- 浏览器 B\n\n\n\n## UDP\n\nClient1\n\n```java\npublic static void main(String[] args) throws Exception {\n        //建立一个socket\n        DatagramSocket socket = new DatagramSocket();\n\n        //建个包\n        String msg = \"hello my friend!!\";\n\n        //发送给谁\n        InetAddress localhost = InetAddress.getByName(\"localhost\");\n        int port = 9090;\n\n        //数据，数据的长度起始，要发送给谁；\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port);\n\n        //发送包\n        socket.send(datagramPacket);\n\n    }\n```\n\nClient2\n\n```java\npublic static void main(String[] args) throws Exception {\n        //开放端口\n        DatagramSocket socket = new DatagramSocket(9090);\n\n        //接收数据包\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n\n        socket.receive(packet);  //阻塞接受\n\n        System.out.println(new String(packet.getData(), 0, packet.getLength() ));\n\n        socket.close();\n    }\n```\n\n\n\n## 案例：UDP实现聊天\n\n```java\n//发送方\npublic static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 准备数据 从控制台读取 system.in\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        while (true){\n            String data = reader.readLine();\n            byte[] datas = data.getBytes();\n            DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666));\n\n            socket.send(packet);\n            if(data.equals(\"bye\")) {\n                break;\n            }\n        }\n        socket.close();\n    }\n```\n\n\n\n```java\n//接收方\n public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(6666);\n\n        while(true){\n            // prepare receive the packet\n            byte[] container = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n            socket.receive(packet); // 阻塞式接收\n\n            // 断开连接 bye\n            byte[] data = packet.getData();\n            String receiveData = new String(data, 0, data.length);\n            System.out.print(receiveData);\n            if (receiveData.equals(\"bye\")) break;\n        }\n        socket.close();\n    }\n```\n\n\n\n多线程：实现同时收发\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class TalkReceive implements Runnable {\n    DatagramSocket socket = null;\n    private int port;\n    private String msgFrom;\n    public TalkReceive(int port, String msgFrom){\n        this.port = port;\n        this.msgFrom = msgFrom;\n        try {\n            socket = new DatagramSocket(port);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void run() {\n        try {\n            while(true){\n                // prepare receive the packet\n                byte[] container = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n                socket.receive(packet); // 阻塞式接收\n\n                // 断开连接 bye\n                byte[] data = packet.getData();\n                String receiveData = new String(data, 0, data.length);\n                System.out.println(msgFrom + \":\" + receiveData);\n                if (receiveData.equals(\"bye\")) break;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\npublic class TalkSend implements Runnable {\n    DatagramSocket socket = null;\n    BufferedReader reader = null;\n    private int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) {\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n        try{\n            socket = new DatagramSocket(fromPort);\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true){\n            String data = null;\n            try {\n                data = reader.readLine();\n                byte[] datas = data.getBytes();\n                DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort));\n\n                socket.send(packet);\n                if(data.equals(\"bye\")) {\n                    break;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n```java\npublic class TalkStu {\n    public static void main(String[] args) {\n        // 开启两个线程\n        new Thread(new TalkSend(7878, \"localhost\", 9988)).start();\n        new Thread(new TalkReceive(8899, \"teac\")).start();\n    }\n}\n```\n\n\n\n```java\npublic class TalkTeac {\n    public static void main(String[] args) {\n        new Thread(new TalkSend(5555, \"localhost\", 8899)).start();\n        new Thread(new TalkReceive(9988, \"Stu\")).start();\n    }\n}\n```\n\n\n\n\n\n## URL\n\n统一资源定位符：定位资源，定位互联网上的某一个资源\n\nDNS域名解析  :     协议：// ip 地址：端口/ 项目名 / 资源\n\n\n\n下载网络资源:\n\n```java\npublic class UrlDownload {\n    public static void main(String[] args) throws Exception {\n        // 1. download Address\n        URL url = new URL(\"url\"); // 网络资源地址\n        // 2. connect HTTP\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n\n        FileOutputStream fos = new FileOutputStream(\"fileName.txt\"); // 下来的命名\n\n        byte[] buffer = new byte[1024];\n        int len;\n        while((len = inputStream.read(buffer)) != -1){\n            fos.write(buffer, 0, len); // 写出数据\n        }\n        fos.close();\n        inputStream.close();\n        urlConnection.disconnect(); // 断开连接\n    }\n}\n```\n\n","source":"_posts/JAVA-网络编程-20210418.md","raw":"---\ntitle: JAVA-网络编程\ndate: 2021-04-12 22:50:21\ntags:\n- java基础\n- 狂神说\ncategories: \n- java\ncover:\n- https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n\n\n# 网络编程\n\n<!--more-->\n\n## 概述\n\n类似于平信信件\n\n其中涉及计算机网络基本概念，网络编程的目的就是传播交流信息、数据交换、通信；达到的效果是需要如何准确定位到网络上的一台主机（IP、端口、资源），对主机进行数据传输\n\n与JAVAWEB网页编程的B/S架构不同，网络编程是C/S编程。\n\n计算机网络是指将[地理](https://baike.baidu.com/item/地理)位置不同的具有独立功能的多台[计算机](https://baike.baidu.com/item/计算机/140338)及其外部设备，通过通信线路连接起来，在[网络操作系统](https://baike.baidu.com/item/网络操作系统/3997)，[网络管理软件](https://baike.baidu.com/item/网络管理软件/6579078)及[网络通信协议](https://baike.baidu.com/item/网络通信协议/4438611)的管理和协调下，实现[资源共享](https://baike.baidu.com/item/资源共享/233480)和信息传递的计算机系统。\n\n\n\n### 网络编程的目的：\n\n交流信息，数据交换，通信。\n\n### 想要达到这个效果需要什么\n\n1. 如何准确地定位网络上的一台主机，192.168.0.176：3553   IP :  端口，定位到这个计算机上的某个资源。\n2. 找到了这个主机，如何传输数据？\n3. javaweb : 网页编程  B/S             网络编程 ：TCP/IP 、C/S\n\n\n\n## 网络通信的要素\n\n如何实现网络的通信？\n\n1. **通信双方的ip**、**端口号**\n2. **规则**：TCP/IP 、OSI\n\n小结：\n\n1. 网络编程中两个主要的问题\n   - 如何准确定位到网络上一台或多台主机\n   - 找到主机之后如何进行通信\n2. 网络编程中的要素\n   - IP和端口号\n   - 网络通信协议 UDP TCP/IP\n3. 万物皆对象\n\n\n\n## IP\n\nip地址：InetAddress\n\n- 唯一定位一台网络上的计算机\n\n- 127.0.0.1 本机localhost\n\n- ip地址的分类\n\n  - ipv4 / ipv6\n\n    - IPV4 127.0.0.1 四个字节组成  42亿    2011年已被用尽\n\n    - IPV6 128位、8个无符号整数组成  abcde\n\n      `2834:4bba:aacb:0013:1241:1aaa:1341:6254`\n\n  - 公网 (互联网）- 私网（局域网）\n\n    - ABCD类地址\n\n- 域名：记忆IP问题\n\n获取相关信息\n\n```java\npublic class TestInterAddress {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\");\n            System.out.println(inetAddress1);\n\n            InetAddress inetAddress2 = InetAddress.getByName(\"localhost\");\n            System.out.println(inetAddress2);\n\n            InetAddress inetAddress3 = InetAddress.getLocalHost();\n            System.out.println(inetAddress3);\n\n            InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\", 8080);\n            System.out.println(inetSocketAddress);\n\n            //查询网站IP地址\n            InetAddress inetAddress4 = InetAddress.getByName(\"www.baidu.com\");\n            System.out.println(inetAddress4);\n\n            System.out.println( inetAddress4.getCanonicalHostName());\n            System.out.println( inetAddress4.getHostAddress());\n            System.out.println( inetAddress4.getHostName());\n            System.out.println( inetAddress4.getClass());\n\n\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n\n## 端口\n\n端口表示计算机上的一个程序的进程：\n\n* 不同的进程有不同的端口号，用来区分软件。\n\n* 被规定范围 0 - 65535\n\n* TCP，UDP ：65535*2   TCP 用80  UDP也可以用80  单个协议下，端口号不能冲突\n\n* 端口分类\n\n  * 公有端口 0-1023 系统进程使用，尽量不用\n    * HTTP : 80\n    * HTTPS : 443\n    * FTP : 21\n    * Telent : 23\n  * 程序注册端口，1024-49151，分配用户或者程序\n    * Tomcat : 8080\n    * MySql : 3306\n    * Oracle ：1521\n    * postgre : 5432\n  * 动态，私有：49152 - 65535\n\n  ```java\n  netstat -ano 查看所有端口\n      \n  netstat -ano|findstr \"5900\"   查看指定端口\n      \n  tasklist|findstr \"8696\"  查看指定端口的进程\n      \n  任务管理器  ctrl + shift + esc\n  ```\n\n  \n\n## 通信协议\n\n协议：约定，就好比我们现在说的是普通话；\n\n网络通信协议：速率，传输码率，代码结构，传输控制......\n\n问题：非常的复杂？\n\n大事化小：分层；\n\nTCP/IP协议簇：**实际上是一组协议**\n\n重要：\n\n* TCP:：用户传输协议；\n* UDP：用户数据报协议；\n\n* IP：网络互连协议；\n\nTCP / UDP对比\n\n* **TCP**： 连接稳定、`三次握手四次挥手`、客户端与服务端、传输需要释放效率低；\n* **UDP**: 不连接不稳定、客户端服务端无明确界限、无需准备、 DDOS洪泛攻击；\n\n\n\n## TCP\n\n客户端\n\n1. 连接服务器 Socket；\n2. 发送消息；\n\n```java\n//客户端\npublic class TcpClientDemo1 {\n    public static void main(String[] args) {\n        Socket socket = null;\n        OutputStream os = null;\n        try {\n            //要知道服务器的地址\n            InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\");\n            int port = 9999;\n            //创建一个socket连接\n            socket = new Socket(serverIP, port);\n            //发送消息\n            os = socket.getOutputStream();\n            os.write(\"message！\".getBytes());\n        }catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (os!=null){\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n服务器\n\n1. 建立服务的端口 ServerSocket；\n2. 等待用户的链接 accept；\n3. 接收用户的消息；\n\n```java\n//服务端\npublic class TcpServerDemo1 {\n    public static void main(String[] args) throws Exception {\n\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream is = null;\n        ByteArrayOutputStream bs = null;\n        try {\n            //有一个服务器地址\n             serverSocket = new ServerSocket(9999);\n            //等待客户端连接\n            socket = serverSocket.accept();\n            //读取客户端的信息\n            is = socket.getInputStream();\n            //管道流\n            bs = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = is.read(buffer)) != -1) {\n                bs.write(buffer, 0, len);\n            }\n            System.out.println(bs.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (bs != null) {\n                try {\n                    bs.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (is != null) {\n                try {\n                    is.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (socket != null) {\n                try {\n                    socket.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                }catch (Exception e){\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n## TCP文件上传\n\n客户端\n\n```java\n//客户端提交文件\npublic class TcpClientDemo2 {\n    public static void main(String[] args) {\n        Socket socket = null;\n        OutputStream os = null;\n        FileInputStream fis = null;\n        try {\n            //创建一个socket连接\n            socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9000);\n            //创建一个输出流\n            os = socket.getOutputStream();\n            //读取文件\n            fis = new FileInputStream(new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\bg17.jpg\"));\n            //写出文件\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len=fis.read(buffer))!=-1) {\n                os.write(buffer, 0, len);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            if (fis!=null) {\n                try {\n                    fis.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (os!=null) {\n                try {\n                    os.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null) {\n                try {\n                    socket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n服务端\n\n```java\n//服务端接收文件\npublic class TcpServerDemo2 {\n    public static void main(String[] args) {\n        //创建服务\n        ServerSocket serverSocket = null;\n        //监听客户端的连接\n        Socket socket = null;\n        //获取输入流\n        InputStream is = null;\n        //文件输出\n        FileOutputStream fos = null;\n\n        try {\n            serverSocket = new ServerSocket(9000);\n            socket = serverSocket.accept(); //阻塞式监听，会一直等待客户端连接\n            is = socket.getInputStream();\n            fos = new FileOutputStream(new File(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\\" + Math.random()*1000000000 + \".jpg\"));\n            byte[] buffer = new byte[1024];\n            int len = 0;\n            while ((len=is.read(buffer))!=-1){\n                fos.write(buffer, 0, len);\n                System.out.println(\"接收文件.....\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //关闭资源\n            if (fos!=null) {\n                try {\n                    fos.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (is!=null) {\n                try {\n                    is.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket!=null) {\n                try {\n                    socket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket!=null) {\n                try {\n                    serverSocket.close();\n                }catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## Tomcat\n\n服务端\n\n- 自定义 S\n- Tomcat服务器 S : JAVA后台开发\n\n客户端\n\n- 自定义 C\n- 浏览器 B\n\n\n\n## UDP\n\nClient1\n\n```java\npublic static void main(String[] args) throws Exception {\n        //建立一个socket\n        DatagramSocket socket = new DatagramSocket();\n\n        //建个包\n        String msg = \"hello my friend!!\";\n\n        //发送给谁\n        InetAddress localhost = InetAddress.getByName(\"localhost\");\n        int port = 9090;\n\n        //数据，数据的长度起始，要发送给谁；\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port);\n\n        //发送包\n        socket.send(datagramPacket);\n\n    }\n```\n\nClient2\n\n```java\npublic static void main(String[] args) throws Exception {\n        //开放端口\n        DatagramSocket socket = new DatagramSocket(9090);\n\n        //接收数据包\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n\n        socket.receive(packet);  //阻塞接受\n\n        System.out.println(new String(packet.getData(), 0, packet.getLength() ));\n\n        socket.close();\n    }\n```\n\n\n\n## 案例：UDP实现聊天\n\n```java\n//发送方\npublic static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 准备数据 从控制台读取 system.in\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        while (true){\n            String data = reader.readLine();\n            byte[] datas = data.getBytes();\n            DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666));\n\n            socket.send(packet);\n            if(data.equals(\"bye\")) {\n                break;\n            }\n        }\n        socket.close();\n    }\n```\n\n\n\n```java\n//接收方\n public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(6666);\n\n        while(true){\n            // prepare receive the packet\n            byte[] container = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n            socket.receive(packet); // 阻塞式接收\n\n            // 断开连接 bye\n            byte[] data = packet.getData();\n            String receiveData = new String(data, 0, data.length);\n            System.out.print(receiveData);\n            if (receiveData.equals(\"bye\")) break;\n        }\n        socket.close();\n    }\n```\n\n\n\n多线程：实现同时收发\n\n```java\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class TalkReceive implements Runnable {\n    DatagramSocket socket = null;\n    private int port;\n    private String msgFrom;\n    public TalkReceive(int port, String msgFrom){\n        this.port = port;\n        this.msgFrom = msgFrom;\n        try {\n            socket = new DatagramSocket(port);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void run() {\n        try {\n            while(true){\n                // prepare receive the packet\n                byte[] container = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n                socket.receive(packet); // 阻塞式接收\n\n                // 断开连接 bye\n                byte[] data = packet.getData();\n                String receiveData = new String(data, 0, data.length);\n                System.out.println(msgFrom + \":\" + receiveData);\n                if (receiveData.equals(\"bye\")) break;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\npublic class TalkSend implements Runnable {\n    DatagramSocket socket = null;\n    BufferedReader reader = null;\n    private int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) {\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n        try{\n            socket = new DatagramSocket(fromPort);\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true){\n            String data = null;\n            try {\n                data = reader.readLine();\n                byte[] datas = data.getBytes();\n                DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort));\n\n                socket.send(packet);\n                if(data.equals(\"bye\")) {\n                    break;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n```java\npublic class TalkStu {\n    public static void main(String[] args) {\n        // 开启两个线程\n        new Thread(new TalkSend(7878, \"localhost\", 9988)).start();\n        new Thread(new TalkReceive(8899, \"teac\")).start();\n    }\n}\n```\n\n\n\n```java\npublic class TalkTeac {\n    public static void main(String[] args) {\n        new Thread(new TalkSend(5555, \"localhost\", 8899)).start();\n        new Thread(new TalkReceive(9988, \"Stu\")).start();\n    }\n}\n```\n\n\n\n\n\n## URL\n\n统一资源定位符：定位资源，定位互联网上的某一个资源\n\nDNS域名解析  :     协议：// ip 地址：端口/ 项目名 / 资源\n\n\n\n下载网络资源:\n\n```java\npublic class UrlDownload {\n    public static void main(String[] args) throws Exception {\n        // 1. download Address\n        URL url = new URL(\"url\"); // 网络资源地址\n        // 2. connect HTTP\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n\n        FileOutputStream fos = new FileOutputStream(\"fileName.txt\"); // 下来的命名\n\n        byte[] buffer = new byte[1024];\n        int len;\n        while((len = inputStream.read(buffer)) != -1){\n            fos.write(buffer, 0, len); // 写出数据\n        }\n        fos.close();\n        inputStream.close();\n        urlConnection.disconnect(); // 断开连接\n    }\n}\n```\n\n","slug":"JAVA-网络编程-20210418","published":1,"updated":"2022-04-07T17:25:27.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1f0018y4w1bqax3foy","content":"<h1 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h1><span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>类似于平信信件</p>\n<p>其中涉及计算机网络基本概念，网络编程的目的就是传播交流信息、数据交换、通信；达到的效果是需要如何准确定位到网络上的一台主机（IP、端口、资源），对主机进行数据传输</p>\n<p>与JAVAWEB网页编程的B/S架构不同，网络编程是C/S编程。</p>\n<p>计算机网络是指将<a href=\"https://baike.baidu.com/item/%E5%9C%B0%E7%90%86\">地理</a>位置不同的具有独立功能的多台<a href=\"https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338\">计算机</a>及其外部设备，通过通信线路连接起来，在<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997\">网络操作系统</a>，<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078\">网络管理软件</a>及<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611\">网络通信协议</a>的管理和协调下，实现<a href=\"https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480\">资源共享</a>和信息传递的计算机系统。</p>\n<h3 id=\"网络编程的目的：\"><a href=\"#网络编程的目的：\" class=\"headerlink\" title=\"网络编程的目的：\"></a>网络编程的目的：</h3><p>交流信息，数据交换，通信。</p>\n<h3 id=\"想要达到这个效果需要什么\"><a href=\"#想要达到这个效果需要什么\" class=\"headerlink\" title=\"想要达到这个效果需要什么\"></a>想要达到这个效果需要什么</h3><ol>\n<li>如何准确地定位网络上的一台主机，192.168.0.176：3553   IP :  端口，定位到这个计算机上的某个资源。</li>\n<li>找到了这个主机，如何传输数据？</li>\n<li>javaweb : 网页编程  B/S             网络编程 ：TCP/IP 、C/S</li>\n</ol>\n<h2 id=\"网络通信的要素\"><a href=\"#网络通信的要素\" class=\"headerlink\" title=\"网络通信的要素\"></a>网络通信的要素</h2><p>如何实现网络的通信？</p>\n<ol>\n<li><strong>通信双方的ip</strong>、<strong>端口号</strong></li>\n<li><strong>规则</strong>：TCP/IP 、OSI</li>\n</ol>\n<p>小结：</p>\n<ol>\n<li>网络编程中两个主要的问题<ul>\n<li>如何准确定位到网络上一台或多台主机</li>\n<li>找到主机之后如何进行通信</li>\n</ul>\n</li>\n<li>网络编程中的要素<ul>\n<li>IP和端口号</li>\n<li>网络通信协议 UDP TCP/IP</li>\n</ul>\n</li>\n<li>万物皆对象</li>\n</ol>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p>ip地址：InetAddress</p>\n<ul>\n<li><p>唯一定位一台网络上的计算机</p>\n</li>\n<li><p>127.0.0.1 本机localhost</p>\n</li>\n<li><p>ip地址的分类</p>\n<ul>\n<li><p>ipv4 / ipv6</p>\n<ul>\n<li><p>IPV4 127.0.0.1 四个字节组成  42亿    2011年已被用尽</p>\n</li>\n<li><p>IPV6 128位、8个无符号整数组成  abcde</p>\n<p><code>2834:4bba:aacb:0013:1241:1aaa:1341:6254</code></p>\n</li>\n</ul>\n</li>\n<li><p>公网 (互联网）- 私网（局域网）</p>\n<ul>\n<li>ABCD类地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>域名：记忆IP问题</p>\n</li>\n</ul>\n<p>获取相关信息</p>\n<pre><code class=\"java\">public class TestInterAddress &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            InetAddress inetAddress1 = InetAddress.getByName(&quot;127.0.0.1&quot;);\n            System.out.println(inetAddress1);\n\n            InetAddress inetAddress2 = InetAddress.getByName(&quot;localhost&quot;);\n            System.out.println(inetAddress2);\n\n            InetAddress inetAddress3 = InetAddress.getLocalHost();\n            System.out.println(inetAddress3);\n\n            InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 8080);\n            System.out.println(inetSocketAddress);\n\n            //查询网站IP地址\n            InetAddress inetAddress4 = InetAddress.getByName(&quot;www.baidu.com&quot;);\n            System.out.println(inetAddress4);\n\n            System.out.println( inetAddress4.getCanonicalHostName());\n            System.out.println( inetAddress4.getHostAddress());\n            System.out.println( inetAddress4.getHostName());\n            System.out.println( inetAddress4.getClass());\n\n\n        &#125;catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>端口表示计算机上的一个程序的进程：</p>\n<ul>\n<li><p>不同的进程有不同的端口号，用来区分软件。</p>\n</li>\n<li><p>被规定范围 0 - 65535</p>\n</li>\n<li><p>TCP，UDP ：65535*2   TCP 用80  UDP也可以用80  单个协议下，端口号不能冲突</p>\n</li>\n<li><p>端口分类</p>\n<ul>\n<li>公有端口 0-1023 系统进程使用，尽量不用<ul>\n<li>HTTP : 80</li>\n<li>HTTPS : 443</li>\n<li>FTP : 21</li>\n<li>Telent : 23</li>\n</ul>\n</li>\n<li>程序注册端口，1024-49151，分配用户或者程序<ul>\n<li>Tomcat : 8080</li>\n<li>MySql : 3306</li>\n<li>Oracle ：1521</li>\n<li>postgre : 5432</li>\n</ul>\n</li>\n<li>动态，私有：49152 - 65535</li>\n</ul>\n<pre><code class=\"java\">netstat -ano 查看所有端口\n    \nnetstat -ano|findstr &quot;5900&quot;   查看指定端口\n    \ntasklist|findstr &quot;8696&quot;  查看指定端口的进程\n    \n任务管理器  ctrl + shift + esc\n</code></pre>\n</li>\n</ul>\n<h2 id=\"通信协议\"><a href=\"#通信协议\" class=\"headerlink\" title=\"通信协议\"></a>通信协议</h2><p>协议：约定，就好比我们现在说的是普通话；</p>\n<p>网络通信协议：速率，传输码率，代码结构，传输控制……</p>\n<p>问题：非常的复杂？</p>\n<p>大事化小：分层；</p>\n<p>TCP/IP协议簇：<strong>实际上是一组协议</strong></p>\n<p>重要：</p>\n<ul>\n<li><p>TCP:：用户传输协议；</p>\n</li>\n<li><p>UDP：用户数据报协议；</p>\n</li>\n<li><p>IP：网络互连协议；</p>\n</li>\n</ul>\n<p>TCP / UDP对比</p>\n<ul>\n<li><strong>TCP</strong>： 连接稳定、<code>三次握手四次挥手</code>、客户端与服务端、传输需要释放效率低；</li>\n<li><strong>UDP</strong>: 不连接不稳定、客户端服务端无明确界限、无需准备、 DDOS洪泛攻击；</li>\n</ul>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>客户端</p>\n<ol>\n<li>连接服务器 Socket；</li>\n<li>发送消息；</li>\n</ol>\n<pre><code class=\"java\">//客户端\npublic class TcpClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        Socket socket = null;\n        OutputStream os = null;\n        try &#123;\n            //要知道服务器的地址\n            InetAddress serverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\n            int port = 9999;\n            //创建一个socket连接\n            socket = new Socket(serverIP, port);\n            //发送消息\n            os = socket.getOutputStream();\n            os.write(&quot;message！&quot;.getBytes());\n        &#125;catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (os!=null)&#123;\n                try &#123;\n                    os.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>服务器</p>\n<ol>\n<li>建立服务的端口 ServerSocket；</li>\n<li>等待用户的链接 accept；</li>\n<li>接收用户的消息；</li>\n</ol>\n<pre><code class=\"java\">//服务端\npublic class TcpServerDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream is = null;\n        ByteArrayOutputStream bs = null;\n        try &#123;\n            //有一个服务器地址\n             serverSocket = new ServerSocket(9999);\n            //等待客户端连接\n            socket = serverSocket.accept();\n            //读取客户端的信息\n            is = socket.getInputStream();\n            //管道流\n            bs = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = is.read(buffer)) != -1) &#123;\n                bs.write(buffer, 0, len);\n            &#125;\n            System.out.println(bs.toString());\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (bs != null) &#123;\n                try &#123;\n                    bs.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (is != null) &#123;\n                try &#123;\n                    is.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket != null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (serverSocket != null) &#123;\n                try &#123;\n                    serverSocket.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"TCP文件上传\"><a href=\"#TCP文件上传\" class=\"headerlink\" title=\"TCP文件上传\"></a>TCP文件上传</h2><p>客户端</p>\n<pre><code class=\"java\">//客户端提交文件\npublic class TcpClientDemo2 &#123;\n    public static void main(String[] args) &#123;\n        Socket socket = null;\n        OutputStream os = null;\n        FileInputStream fis = null;\n        try &#123;\n            //创建一个socket连接\n            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9000);\n            //创建一个输出流\n            os = socket.getOutputStream();\n            //读取文件\n            fis = new FileInputStream(new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\bg17.jpg&quot;));\n            //写出文件\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len=fis.read(buffer))!=-1) &#123;\n                os.write(buffer, 0, len);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            if (fis!=null) &#123;\n                try &#123;\n                    fis.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (os!=null) &#123;\n                try &#123;\n                    os.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>服务端</p>\n<pre><code class=\"java\">//服务端接收文件\npublic class TcpServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        //创建服务\n        ServerSocket serverSocket = null;\n        //监听客户端的连接\n        Socket socket = null;\n        //获取输入流\n        InputStream is = null;\n        //文件输出\n        FileOutputStream fos = null;\n\n        try &#123;\n            serverSocket = new ServerSocket(9000);\n            socket = serverSocket.accept(); //阻塞式监听，会一直等待客户端连接\n            is = socket.getInputStream();\n            fos = new FileOutputStream(new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\&quot; + Math.random()*1000000000 + &quot;.jpg&quot;));\n            byte[] buffer = new byte[1024];\n            int len = 0;\n            while ((len=is.read(buffer))!=-1)&#123;\n                fos.write(buffer, 0, len);\n                System.out.println(&quot;接收文件.....&quot;);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            if (fos!=null) &#123;\n                try &#123;\n                    fos.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (is!=null) &#123;\n                try &#123;\n                    is.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (serverSocket!=null) &#123;\n                try &#123;\n                    serverSocket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>服务端</p>\n<ul>\n<li>自定义 S</li>\n<li>Tomcat服务器 S : JAVA后台开发</li>\n</ul>\n<p>客户端</p>\n<ul>\n<li>自定义 C</li>\n<li>浏览器 B</li>\n</ul>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>Client1</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        //建立一个socket\n        DatagramSocket socket = new DatagramSocket();\n\n        //建个包\n        String msg = &quot;hello my friend!!&quot;;\n\n        //发送给谁\n        InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\n        int port = 9090;\n\n        //数据，数据的长度起始，要发送给谁；\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port);\n\n        //发送包\n        socket.send(datagramPacket);\n\n    &#125;\n</code></pre>\n<p>Client2</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        //开放端口\n        DatagramSocket socket = new DatagramSocket(9090);\n\n        //接收数据包\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n\n        socket.receive(packet);  //阻塞接受\n\n        System.out.println(new String(packet.getData(), 0, packet.getLength() ));\n\n        socket.close();\n    &#125;\n</code></pre>\n<h2 id=\"案例：UDP实现聊天\"><a href=\"#案例：UDP实现聊天\" class=\"headerlink\" title=\"案例：UDP实现聊天\"></a>案例：UDP实现聊天</h2><pre><code class=\"java\">//发送方\npublic static void main(String[] args) throws Exception &#123;\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 准备数据 从控制台读取 system.in\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        while (true)&#123;\n            String data = reader.readLine();\n            byte[] datas = data.getBytes();\n            DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(&quot;localhost&quot;, 6666));\n\n            socket.send(packet);\n            if(data.equals(&quot;bye&quot;)) &#123;\n                break;\n            &#125;\n        &#125;\n        socket.close();\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//接收方\n public static void main(String[] args) throws Exception &#123;\n        DatagramSocket socket = new DatagramSocket(6666);\n\n        while(true)&#123;\n            // prepare receive the packet\n            byte[] container = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n            socket.receive(packet); // 阻塞式接收\n\n            // 断开连接 bye\n            byte[] data = packet.getData();\n            String receiveData = new String(data, 0, data.length);\n            System.out.print(receiveData);\n            if (receiveData.equals(&quot;bye&quot;)) break;\n        &#125;\n        socket.close();\n    &#125;\n</code></pre>\n<p>多线程：实现同时收发</p>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class TalkReceive implements Runnable &#123;\n    DatagramSocket socket = null;\n    private int port;\n    private String msgFrom;\n    public TalkReceive(int port, String msgFrom)&#123;\n        this.port = port;\n        this.msgFrom = msgFrom;\n        try &#123;\n            socket = new DatagramSocket(port);\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            while(true)&#123;\n                // prepare receive the packet\n                byte[] container = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n                socket.receive(packet); // 阻塞式接收\n\n                // 断开连接 bye\n                byte[] data = packet.getData();\n                String receiveData = new String(data, 0, data.length);\n                System.out.println(msgFrom + &quot;:&quot; + receiveData);\n                if (receiveData.equals(&quot;bye&quot;)) break;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\npublic class TalkSend implements Runnable &#123;\n    DatagramSocket socket = null;\n    BufferedReader reader = null;\n    private int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) &#123;\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n        try&#123;\n            socket = new DatagramSocket(fromPort);\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        while (true)&#123;\n            String data = null;\n            try &#123;\n                data = reader.readLine();\n                byte[] datas = data.getBytes();\n                DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort));\n\n                socket.send(packet);\n                if(data.equals(&quot;bye&quot;)) &#123;\n                    break;\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class TalkStu &#123;\n    public static void main(String[] args) &#123;\n        // 开启两个线程\n        new Thread(new TalkSend(7878, &quot;localhost&quot;, 9988)).start();\n        new Thread(new TalkReceive(8899, &quot;teac&quot;)).start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class TalkTeac &#123;\n    public static void main(String[] args) &#123;\n        new Thread(new TalkSend(5555, &quot;localhost&quot;, 8899)).start();\n        new Thread(new TalkReceive(9988, &quot;Stu&quot;)).start();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>统一资源定位符：定位资源，定位互联网上的某一个资源</p>\n<p>DNS域名解析  :     协议：// ip 地址：端口/ 项目名 / 资源</p>\n<p>下载网络资源:</p>\n<pre><code class=\"java\">public class UrlDownload &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1. download Address\n        URL url = new URL(&quot;url&quot;); // 网络资源地址\n        // 2. connect HTTP\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n\n        FileOutputStream fos = new FileOutputStream(&quot;fileName.txt&quot;); // 下来的命名\n\n        byte[] buffer = new byte[1024];\n        int len;\n        while((len = inputStream.read(buffer)) != -1)&#123;\n            fos.write(buffer, 0, len); // 写出数据\n        &#125;\n        fos.close();\n        inputStream.close();\n        urlConnection.disconnect(); // 断开连接\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h1>","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>类似于平信信件</p>\n<p>其中涉及计算机网络基本概念，网络编程的目的就是传播交流信息、数据交换、通信；达到的效果是需要如何准确定位到网络上的一台主机（IP、端口、资源），对主机进行数据传输</p>\n<p>与JAVAWEB网页编程的B/S架构不同，网络编程是C/S编程。</p>\n<p>计算机网络是指将<a href=\"https://baike.baidu.com/item/%E5%9C%B0%E7%90%86\">地理</a>位置不同的具有独立功能的多台<a href=\"https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338\">计算机</a>及其外部设备，通过通信线路连接起来，在<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997\">网络操作系统</a>，<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078\">网络管理软件</a>及<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611\">网络通信协议</a>的管理和协调下，实现<a href=\"https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480\">资源共享</a>和信息传递的计算机系统。</p>\n<h3 id=\"网络编程的目的：\"><a href=\"#网络编程的目的：\" class=\"headerlink\" title=\"网络编程的目的：\"></a>网络编程的目的：</h3><p>交流信息，数据交换，通信。</p>\n<h3 id=\"想要达到这个效果需要什么\"><a href=\"#想要达到这个效果需要什么\" class=\"headerlink\" title=\"想要达到这个效果需要什么\"></a>想要达到这个效果需要什么</h3><ol>\n<li>如何准确地定位网络上的一台主机，192.168.0.176：3553   IP :  端口，定位到这个计算机上的某个资源。</li>\n<li>找到了这个主机，如何传输数据？</li>\n<li>javaweb : 网页编程  B/S             网络编程 ：TCP/IP 、C/S</li>\n</ol>\n<h2 id=\"网络通信的要素\"><a href=\"#网络通信的要素\" class=\"headerlink\" title=\"网络通信的要素\"></a>网络通信的要素</h2><p>如何实现网络的通信？</p>\n<ol>\n<li><strong>通信双方的ip</strong>、<strong>端口号</strong></li>\n<li><strong>规则</strong>：TCP/IP 、OSI</li>\n</ol>\n<p>小结：</p>\n<ol>\n<li>网络编程中两个主要的问题<ul>\n<li>如何准确定位到网络上一台或多台主机</li>\n<li>找到主机之后如何进行通信</li>\n</ul>\n</li>\n<li>网络编程中的要素<ul>\n<li>IP和端口号</li>\n<li>网络通信协议 UDP TCP/IP</li>\n</ul>\n</li>\n<li>万物皆对象</li>\n</ol>\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p>ip地址：InetAddress</p>\n<ul>\n<li><p>唯一定位一台网络上的计算机</p>\n</li>\n<li><p>127.0.0.1 本机localhost</p>\n</li>\n<li><p>ip地址的分类</p>\n<ul>\n<li><p>ipv4 / ipv6</p>\n<ul>\n<li><p>IPV4 127.0.0.1 四个字节组成  42亿    2011年已被用尽</p>\n</li>\n<li><p>IPV6 128位、8个无符号整数组成  abcde</p>\n<p><code>2834:4bba:aacb:0013:1241:1aaa:1341:6254</code></p>\n</li>\n</ul>\n</li>\n<li><p>公网 (互联网）- 私网（局域网）</p>\n<ul>\n<li>ABCD类地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>域名：记忆IP问题</p>\n</li>\n</ul>\n<p>获取相关信息</p>\n<pre><code class=\"java\">public class TestInterAddress &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            InetAddress inetAddress1 = InetAddress.getByName(&quot;127.0.0.1&quot;);\n            System.out.println(inetAddress1);\n\n            InetAddress inetAddress2 = InetAddress.getByName(&quot;localhost&quot;);\n            System.out.println(inetAddress2);\n\n            InetAddress inetAddress3 = InetAddress.getLocalHost();\n            System.out.println(inetAddress3);\n\n            InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 8080);\n            System.out.println(inetSocketAddress);\n\n            //查询网站IP地址\n            InetAddress inetAddress4 = InetAddress.getByName(&quot;www.baidu.com&quot;);\n            System.out.println(inetAddress4);\n\n            System.out.println( inetAddress4.getCanonicalHostName());\n            System.out.println( inetAddress4.getHostAddress());\n            System.out.println( inetAddress4.getHostName());\n            System.out.println( inetAddress4.getClass());\n\n\n        &#125;catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h2><p>端口表示计算机上的一个程序的进程：</p>\n<ul>\n<li><p>不同的进程有不同的端口号，用来区分软件。</p>\n</li>\n<li><p>被规定范围 0 - 65535</p>\n</li>\n<li><p>TCP，UDP ：65535*2   TCP 用80  UDP也可以用80  单个协议下，端口号不能冲突</p>\n</li>\n<li><p>端口分类</p>\n<ul>\n<li>公有端口 0-1023 系统进程使用，尽量不用<ul>\n<li>HTTP : 80</li>\n<li>HTTPS : 443</li>\n<li>FTP : 21</li>\n<li>Telent : 23</li>\n</ul>\n</li>\n<li>程序注册端口，1024-49151，分配用户或者程序<ul>\n<li>Tomcat : 8080</li>\n<li>MySql : 3306</li>\n<li>Oracle ：1521</li>\n<li>postgre : 5432</li>\n</ul>\n</li>\n<li>动态，私有：49152 - 65535</li>\n</ul>\n<pre><code class=\"java\">netstat -ano 查看所有端口\n    \nnetstat -ano|findstr &quot;5900&quot;   查看指定端口\n    \ntasklist|findstr &quot;8696&quot;  查看指定端口的进程\n    \n任务管理器  ctrl + shift + esc\n</code></pre>\n</li>\n</ul>\n<h2 id=\"通信协议\"><a href=\"#通信协议\" class=\"headerlink\" title=\"通信协议\"></a>通信协议</h2><p>协议：约定，就好比我们现在说的是普通话；</p>\n<p>网络通信协议：速率，传输码率，代码结构，传输控制……</p>\n<p>问题：非常的复杂？</p>\n<p>大事化小：分层；</p>\n<p>TCP/IP协议簇：<strong>实际上是一组协议</strong></p>\n<p>重要：</p>\n<ul>\n<li><p>TCP:：用户传输协议；</p>\n</li>\n<li><p>UDP：用户数据报协议；</p>\n</li>\n<li><p>IP：网络互连协议；</p>\n</li>\n</ul>\n<p>TCP / UDP对比</p>\n<ul>\n<li><strong>TCP</strong>： 连接稳定、<code>三次握手四次挥手</code>、客户端与服务端、传输需要释放效率低；</li>\n<li><strong>UDP</strong>: 不连接不稳定、客户端服务端无明确界限、无需准备、 DDOS洪泛攻击；</li>\n</ul>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>客户端</p>\n<ol>\n<li>连接服务器 Socket；</li>\n<li>发送消息；</li>\n</ol>\n<pre><code class=\"java\">//客户端\npublic class TcpClientDemo1 &#123;\n    public static void main(String[] args) &#123;\n        Socket socket = null;\n        OutputStream os = null;\n        try &#123;\n            //要知道服务器的地址\n            InetAddress serverIP = InetAddress.getByName(&quot;127.0.0.1&quot;);\n            int port = 9999;\n            //创建一个socket连接\n            socket = new Socket(serverIP, port);\n            //发送消息\n            os = socket.getOutputStream();\n            os.write(&quot;message！&quot;.getBytes());\n        &#125;catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (os!=null)&#123;\n                try &#123;\n                    os.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null)&#123;\n                try &#123;\n                    socket.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>服务器</p>\n<ol>\n<li>建立服务的端口 ServerSocket；</li>\n<li>等待用户的链接 accept；</li>\n<li>接收用户的消息；</li>\n</ol>\n<pre><code class=\"java\">//服务端\npublic class TcpServerDemo1 &#123;\n    public static void main(String[] args) throws Exception &#123;\n\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream is = null;\n        ByteArrayOutputStream bs = null;\n        try &#123;\n            //有一个服务器地址\n             serverSocket = new ServerSocket(9999);\n            //等待客户端连接\n            socket = serverSocket.accept();\n            //读取客户端的信息\n            is = socket.getInputStream();\n            //管道流\n            bs = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = is.read(buffer)) != -1) &#123;\n                bs.write(buffer, 0, len);\n            &#125;\n            System.out.println(bs.toString());\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (bs != null) &#123;\n                try &#123;\n                    bs.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (is != null) &#123;\n                try &#123;\n                    is.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket != null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (serverSocket != null) &#123;\n                try &#123;\n                    serverSocket.close();\n                &#125;catch (Exception e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"TCP文件上传\"><a href=\"#TCP文件上传\" class=\"headerlink\" title=\"TCP文件上传\"></a>TCP文件上传</h2><p>客户端</p>\n<pre><code class=\"java\">//客户端提交文件\npublic class TcpClientDemo2 &#123;\n    public static void main(String[] args) &#123;\n        Socket socket = null;\n        OutputStream os = null;\n        FileInputStream fis = null;\n        try &#123;\n            //创建一个socket连接\n            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9000);\n            //创建一个输出流\n            os = socket.getOutputStream();\n            //读取文件\n            fis = new FileInputStream(new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\bg17.jpg&quot;));\n            //写出文件\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len=fis.read(buffer))!=-1) &#123;\n                os.write(buffer, 0, len);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            if (fis!=null) &#123;\n                try &#123;\n                    fis.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (os!=null) &#123;\n                try &#123;\n                    os.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>服务端</p>\n<pre><code class=\"java\">//服务端接收文件\npublic class TcpServerDemo2 &#123;\n    public static void main(String[] args) &#123;\n        //创建服务\n        ServerSocket serverSocket = null;\n        //监听客户端的连接\n        Socket socket = null;\n        //获取输入流\n        InputStream is = null;\n        //文件输出\n        FileOutputStream fos = null;\n\n        try &#123;\n            serverSocket = new ServerSocket(9000);\n            socket = serverSocket.accept(); //阻塞式监听，会一直等待客户端连接\n            is = socket.getInputStream();\n            fos = new FileOutputStream(new File(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\网络编程\\\\src\\\\com\\\\inte\\\\tcp\\\\&quot; + Math.random()*1000000000 + &quot;.jpg&quot;));\n            byte[] buffer = new byte[1024];\n            int len = 0;\n            while ((len=is.read(buffer))!=-1)&#123;\n                fos.write(buffer, 0, len);\n                System.out.println(&quot;接收文件.....&quot;);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            if (fos!=null) &#123;\n                try &#123;\n                    fos.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (is!=null) &#123;\n                try &#123;\n                    is.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (socket!=null) &#123;\n                try &#123;\n                    socket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (serverSocket!=null) &#123;\n                try &#123;\n                    serverSocket.close();\n                &#125;catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>服务端</p>\n<ul>\n<li>自定义 S</li>\n<li>Tomcat服务器 S : JAVA后台开发</li>\n</ul>\n<p>客户端</p>\n<ul>\n<li>自定义 C</li>\n<li>浏览器 B</li>\n</ul>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>Client1</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        //建立一个socket\n        DatagramSocket socket = new DatagramSocket();\n\n        //建个包\n        String msg = &quot;hello my friend!!&quot;;\n\n        //发送给谁\n        InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);\n        int port = 9090;\n\n        //数据，数据的长度起始，要发送给谁；\n        DatagramPacket datagramPacket = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, localhost, port);\n\n        //发送包\n        socket.send(datagramPacket);\n\n    &#125;\n</code></pre>\n<p>Client2</p>\n<pre><code class=\"java\">public static void main(String[] args) throws Exception &#123;\n        //开放端口\n        DatagramSocket socket = new DatagramSocket(9090);\n\n        //接收数据包\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n\n        socket.receive(packet);  //阻塞接受\n\n        System.out.println(new String(packet.getData(), 0, packet.getLength() ));\n\n        socket.close();\n    &#125;\n</code></pre>\n<h2 id=\"案例：UDP实现聊天\"><a href=\"#案例：UDP实现聊天\" class=\"headerlink\" title=\"案例：UDP实现聊天\"></a>案例：UDP实现聊天</h2><pre><code class=\"java\">//发送方\npublic static void main(String[] args) throws Exception &#123;\n        DatagramSocket socket = new DatagramSocket(8888);\n        // 准备数据 从控制台读取 system.in\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        while (true)&#123;\n            String data = reader.readLine();\n            byte[] datas = data.getBytes();\n            DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(&quot;localhost&quot;, 6666));\n\n            socket.send(packet);\n            if(data.equals(&quot;bye&quot;)) &#123;\n                break;\n            &#125;\n        &#125;\n        socket.close();\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//接收方\n public static void main(String[] args) throws Exception &#123;\n        DatagramSocket socket = new DatagramSocket(6666);\n\n        while(true)&#123;\n            // prepare receive the packet\n            byte[] container = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n            socket.receive(packet); // 阻塞式接收\n\n            // 断开连接 bye\n            byte[] data = packet.getData();\n            String receiveData = new String(data, 0, data.length);\n            System.out.print(receiveData);\n            if (receiveData.equals(&quot;bye&quot;)) break;\n        &#125;\n        socket.close();\n    &#125;\n</code></pre>\n<p>多线程：实现同时收发</p>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class TalkReceive implements Runnable &#123;\n    DatagramSocket socket = null;\n    private int port;\n    private String msgFrom;\n    public TalkReceive(int port, String msgFrom)&#123;\n        this.port = port;\n        this.msgFrom = msgFrom;\n        try &#123;\n            socket = new DatagramSocket(port);\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    @Override\n    public void run() &#123;\n        try &#123;\n            while(true)&#123;\n                // prepare receive the packet\n                byte[] container = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(container, 0, container.length);\n                socket.receive(packet); // 阻塞式接收\n\n                // 断开连接 bye\n                byte[] data = packet.getData();\n                String receiveData = new String(data, 0, data.length);\n                System.out.println(msgFrom + &quot;:&quot; + receiveData);\n                if (receiveData.equals(&quot;bye&quot;)) break;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\npublic class TalkSend implements Runnable &#123;\n    DatagramSocket socket = null;\n    BufferedReader reader = null;\n    private int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) &#123;\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n        try&#123;\n            socket = new DatagramSocket(fromPort);\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        while (true)&#123;\n            String data = null;\n            try &#123;\n                data = reader.readLine();\n                byte[] datas = data.getBytes();\n                DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort));\n\n                socket.send(packet);\n                if(data.equals(&quot;bye&quot;)) &#123;\n                    break;\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        socket.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class TalkStu &#123;\n    public static void main(String[] args) &#123;\n        // 开启两个线程\n        new Thread(new TalkSend(7878, &quot;localhost&quot;, 9988)).start();\n        new Thread(new TalkReceive(8899, &quot;teac&quot;)).start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class TalkTeac &#123;\n    public static void main(String[] args) &#123;\n        new Thread(new TalkSend(5555, &quot;localhost&quot;, 8899)).start();\n        new Thread(new TalkReceive(9988, &quot;Stu&quot;)).start();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>统一资源定位符：定位资源，定位互联网上的某一个资源</p>\n<p>DNS域名解析  :     协议：// ip 地址：端口/ 项目名 / 资源</p>\n<p>下载网络资源:</p>\n<pre><code class=\"java\">public class UrlDownload &#123;\n    public static void main(String[] args) throws Exception &#123;\n        // 1. download Address\n        URL url = new URL(&quot;url&quot;); // 网络资源地址\n        // 2. connect HTTP\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n\n        FileOutputStream fos = new FileOutputStream(&quot;fileName.txt&quot;); // 下来的命名\n\n        byte[] buffer = new byte[1024];\n        int len;\n        while((len = inputStream.read(buffer)) != -1)&#123;\n            fos.write(buffer, 0, len); // 写出数据\n        &#125;\n        fos.close();\n        inputStream.close();\n        urlConnection.disconnect(); // 断开连接\n    &#125;\n&#125;\n</code></pre>"},{"title":"JAVA-线程","date":"2021-04-11T16:02:31.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# 线程\n\n<!--more-->\n\n## 线程创建\n\nThread、Runnable、Callable\n\n**继承 Thread 类**和 **实现 Runnable 接口** 为重点，实现 Callable 接口仅作了解\n\n## Thread\n\n1. 自定义线程类继承 Thread 类\n2. 重写 run()方法，编写线程执行体\n3. 创建线程对象，调用 start()方法启动线程\n\n```java\n// 创建线程的方式：继承Thread类 、重写run（）方法、 调用start开启线程\n\n// 总结：线程开启不一定立即执行，由cpu进行调度执行\n\npublic class TestThread01 extends Thread {\n    @Override\n    public void run() {\n        // run方法线程体\n        for (int i = 0; i < 200; i++) {\n            System.out.println(\"正在执行线程----\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        // main主线程\n        // 创建一个线程对象\n        TestThread01 testThread01 = new TestThread01();\n        //调用start（）方法开启线程\n        testThread01.start();\n\n        for (int i = 0; i < 2000; i++) {\n            System.out.println(\"正在执行主方法******\" + i);\n        }\n    }\n}\n```\n\n### 实现多线程同步下载图片(commons-io)\n\n```java\n/**\n * 实现多线程同步下载图片\n */\npublic class TestThread2 extends Thread {\n    private String url;\n    private String name;\n\n    public TestThread2(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n    @Override\n    public void run() {\n        WebDownLoader webDownLoader = new WebDownLoader();\n        webDownLoader.downloader(url,name);\n        System.out.println(\"下载文件名为:\" + name);\n\n    }\n    public static void main(String[] args) {\n        TestThread2 t1 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestThread2 t2 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestThread2 t3 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\n//下载器\nclass WebDownLoader {\n    //下载方法\n    public void downloader(String url, String name) {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"io异常，downloader方法出现问题\");\n        }\n    }\n}\n```\n\n## 实现 Runable 接口\n\n1. 定义 MyRunnable 类实现 Runnable 接口\n2. 实现 run()方法，编写线程执行体\n3. 创建线程对象，调用 start()方法启动线程\n\n```java\npublic class TestRunable01 implements Runnable {\n    //run方法线程体\n    @Override\n    public void run() {\n        for (int i = 0; i < 200; i++) {\n            System.out.println(\"我在看代码--\" + i);\n        }\n    }\n\n    //执行下面代码\n    public static void main(String[] args) {\n        //main线程，主线程\n        //创建一个Runable接口的实现对象\n        TestRunable01 testRunable01 = new TestRunable01();\n\n        //创建线程对象，通过线程对象来开启线程，这种方式叫做代理\n        new Thread(testRunable01).start();\n\n        for (int i = 0; i < 20000; i++) {\n            System.out.println(\"我在学习多线程--\"  + i);\n        }\n    }\n}\n```\n\n### Runable-实现多线程同步下载图片(commons-io)\n\n```java\npackage com.thread.demo01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 实现多线程同步下载图片\n */\npublic class TestRunable02 extends Thread {\n    private String url;\n    private String name;\n\n    public TestRunable02(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n\n    @Override\n    public void run() {\n        WebDownLoader2 webDownLoader = new WebDownLoader2();\n        webDownLoader.downloader(url,name);\n        System.out.println(\"下载文件名为:\" + name);\n\n    }\n\n    public static void main(String[] args) {\n        TestThread2 t1 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestThread2 t2 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestThread2 t3 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    }\n\n}\n\n//下载器\nclass WebDownLoader2 {\n    //下载方法\n    public void downloader(String url, String name) {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"io异常，downloader方法出现问题\");\n        }\n    }\n}\n\n```\n\n## Thread 与 Runable 比较\n\n|          继承 Thread 类           |                         实现 Runnable 接口                         |\n| :-------------------------------: | :----------------------------------------------------------------: |\n| 子类继承 Thread 类具备多线程能力  |                  实现接口 Runnable 具有多线程能力                  |\n|    启动线程：子类对象.start();    |            启动线程：传入目标对象+Thread 对象.start();             |\n| 不建议使用：避免 OOP 单继承局限性 | 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 |\n\n## 买火车票的例子\n\n存在并发问题，会出现多个不同用户抢到同一张票的问题；\n\n```java\npackage com.thread.demo01;\n\n/**\n * 多个县城同时操作一个对象\n * 买火车票的例子\n */\npublic class TestThread03 implements Runnable {\n    //票数\n    private static int ticketNum = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNum<=0){\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TestThread03 ticket = new TestThread03();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\n```\n\n```java\n小明------拿到了第10张票------\n阿黄------拿到了第9张票------\n小二------拿到了第8张票------\n小明------拿到了第7张票------\n小二------拿到了第7张票------\n阿黄------拿到了第7张票------\n阿黄------拿到了第6张票------\n小二------拿到了第6张票------\n小明------拿到了第5张票------\n小明------拿到了第3张票------\n小二------拿到了第4张票------\n阿黄------拿到了第4张票------\n阿黄------拿到了第2张票------\n小二------拿到了第2张票------\n小明------拿到了第2张票------\n阿黄------拿到了第0张票------\n小二------拿到了第-1张票------\n小明------拿到了第1张票------\n```\n\n## 模拟龟兔赛跑\n\n```java\n/**\n * 模拟龟兔赛跑\n */\npublic class Race implements Runnable {\n    private static String winner;\n\n    @Override\n    public void run() {\n        for (int i = 0; i <= 100; i++) {\n\n            // 模拟兔子休息\n            if (Thread.currentThread().getName().equals(\"兔子\") && i%10 == 0){\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            //判断比赛是否结束\n            boolean flag = gameOver(i);\n            //出现winner，跳出\n            if (flag) {\n                break;\n            }\n\n            System.out.println(Thread.currentThread().getName() + \"-->跑了\" + i + \"米\");\n        }\n    }\n\n    //判断是否完成比赛\n    public boolean gameOver(int steps) {\n        if (winner != null) {//已经存在\n            return true;\n        }else {\n            if (steps == 100) {\n                winner = Thread.currentThread().getName();\n                System.out.println(\"winner is\" + winner);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Race race = new Race();\n\n        new Thread(race, \"兔子\").start();\n        new Thread(race, \"乌龟\").start();\n\n    }\n}\n\n```\n\n## 实现 Callable 接口（仅了解） 扩充\n\n1. 实现 Callable 接口，需要返回值类型\n2. 重写 call 方法，需要抛出异常\n3. 创建目标对象\n4. （1）创建执行服务 `ExecutorService ser=Executors.newFixedThreadPool(3);` //线程池，并发数\n5. （2）提交执行 `Future<Boolean> result = ser.submit(t1);`\n6. （3）获取结果 `boolean r1 = result.get();`\n7. （4）关闭服务 `ser.shutdownNow();`\n\n示例代码如下：\n\n```java\nimport java.util.concurrent.*;\n\npublic class TestCallable implements Callable {\n    private String url;\n    private String name;\n\n    public TestCallable(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    @Override\n    public Object call() throws Exception {\n        WebDownLoader wd = new WebDownLoader();\n        wd.downloader(url,name);\n        System.out.println(\"下载文件，名为---\" + name);\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        TestCallable t1 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestCallable t2 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestCallable t3 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n\n        //1.创建执行服务\n        ExecutorService serv = Executors.newFixedThreadPool(3); //线程池，并发数\n\n        //2.提交执行\n        Future<Boolean> r1 = serv.submit(t1);\n        Future<Boolean> r2 = serv.submit(t2);\n        Future<Boolean> r3 = serv.submit(t3);\n        //3.获取结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //4.关闭服务\n        serv.shutdownNow();\n    }\n}\n\n```\n\n## 静态代理--个人结婚与婚庆公司的例子\n\n```java\npackage com.thread.demo01;\n// 静态代理模式：\n// 真实对象和代理对象都要实现同一个接口\n// 代理对象要代理真实角色\n\n// 好处 ：\n// 1. 代理对象可以做很多真实对象做不了的事情\n// 2. 真实对象专注做自己的事情\n\npublic class StaticProxy {\n\n    public static void main(String[] args) {\n\n        You you = new You(); // 真实对象\n        new Thread(() -> System.out.println(\"i love you\")).start(); // lambda表达式\n\n//        //传统调用方式\n//        You you = new You();\n//        you.HappyMarry();\n\n        new WeddingCompany(new You()).HappyMarry();\n        //代理调用\n//        WeddingCompany weddingCompany = new WeddingCompany(new You());\n//        weddingCompany.HappyMarry();\n\n    }\n}\n\ninterface Marry {\n    void HappyMarry();\n}\n\n\n//真实角色，你去结婚\nclass You implements Marry {\n    @Override\n    public void HappyMarry() {\n        System.out.println(\"结婚，超开心(^_^)\"); //no-qinjiang\n    }\n}\n\n//代理角色，帮助你结婚, 起到帮助作用\nclass WeddingCompany implements Marry {\n    //代理谁 --> 真实目标角色\n    private Marry target;\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n    @Override\n    public void HappyMarry() {\n        before();\n        this.target.HappyMarry();\n        after();\n    }\n\n    private void before() {\n        System.out.println(\"布置婚礼现场\");\n    }\n\n    private void after() {\n        System.out.println(\"还债结尾款\");\n    }\n}\n```\n\n## Lambda 表达式\n\n为什么要使用 lambda 表达式\n\n1. 避免匿名内部类定义过多\n\n2. 可以让代码看起来更简洁\n\n3. 去掉无意义代码，留下核心逻辑\n\n   注：只有一行代码的情况下才能简化成一行；前提是接口为函数式接口\n\n理解函数式接口（Functional Interface）是学习 java8 lambda 表达式的关键所在\n\n函数式接口的定义：\n\n任何接口，如果只包含一个抽象方法，那么他就是一个函数式接口。\n\neg:\n\n```java\npublic interface Runable {\n    public abstract void run();\n}\n```\n\n对于函数式接口，我们可以通过 Lambda 表达式来创建该接口的对象。\n\n简化至 lambda 的步骤如下：\n\n```java\n//外部类，接口\npublic class TestLove {\n    public static void main(String[] args) {\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n\nclass Love implements ILove {\n    @Override\n    public void love(String a) {\n        System.out.println(\"I love --\" + a);\n    }\n}\n```\n\n```java\n//静态内部类\n\npublic class TestLove {\n    static class Love implements ILove {\n        @Override\n        public void love(String a) {\n            System.out.println(\"I love --\" + a);\n        }\n    }\n    public static void main(String[] args) {\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n\n\n```\n\n```java\npublic class TestLove {\n\n    public static void main(String[] args) {\n        class Love implements ILove {\n            @Override\n            public void love(String a) {\n                System.out.println(\"I love --\" + a);\n            }\n        }\n\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//匿名内部类\n\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove iLove = new ILove() {\n            @Override\n            public void love(String a) {\n                System.out.println(\"I love --\" + a);\n            }\n        };\n        iLove.love(\"zzz\");\n    }\n}\ninterface ILove { void love(String a);}\n```\n\n```java\n//lambda表达式\nublic class TestLove {\n    public static void main(String[] args) {\n\n        ILove love = (String a)-> {\n            System.out.println(\"I love --\" + a);\n        };\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化，去掉参数类型\n\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = (a)-> {\n            System.out.println(\"I love --\" + a);\n        };\n\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化括号\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = a-> {\n            System.out.println(\"I love --\" + a);\n        };\n\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化花括号，因为代码只有一行，有多行不可简化花括号\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = a-> System.out.println(\"I love --\" + a);\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n总结：\n\n1. lambda 表达式代码只有一行的情况下才能简化为一行，有多行时必须用花括号包裹；\n2. 前提示接口为函数式接口（只包含一个方法）；\n3. 多个参数也可以去掉参数类型，留就都留，去就都去，必须加上括号；\n\n## 线程状态\n\n![image-20210411183018803](img/article/JAVA-线程-20210418/image-20210411183018803.png)\n\n**线程的方法**\n\n![image-20210411183039107](img/article/JAVA-线程-20210418/image-20210411183039107.png)\n\n### 停止线程\n\n1. 不推荐使用 JDK 提供的`stop(); destroy();`方法；\n2. 推荐线程自己停止；\n3. 建议使用一个标志位进行终止变量；\n\n```java\n/**\n * 测试stop\n * 1. 建议线程正常停止--->利用次数；不建议死循环\n * 2. 建议使用标志位--->设置一个标志位\n * 3. 不要使用stop或者destory等过时或JDK不建议使用的方法\n */\npublic class TestStop implements Runnable {\n    //1. 设置一个标志位\n    private boolean flag = true;\n\n    @Override\n    public void run() {\n        int i = 0;\n        while (flag) {\n            System.out.println(\"run thread ----\" + i++);\n        }\n    }\n\n    //设置一个公开的方法停止线程，转换标志位\n    public void stop() {\n        this.flag = false;\n    }\n\n    public static void main(String[] args) {\n        TestStop testStop = new TestStop();\n        new Thread(testStop).start();\n\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"main\" + i);\n            if (i==900) {\n                //调用stop方法切换标志为\n                testStop.stop();\n                System.out.println(\"该线程停止了\");\n                break;\n            }\n        }\n    }\n}\n```\n\n### 线程休眠\n\n1. sleep(时间) 指定当前线程阻塞的毫秒数；\n2. sleep 存在异常 InterruptException；\n3. sleep 时间达到后线程进入就绪状态；\n4. sleep 可以模拟网络延时，倒计时等；\n5. 每一个对象都有一个锁，sleep 不会释放锁；\n\n```java\n//模拟倒计时 10s\npublic class TestSleep2 {\n    public static void main(String[] args) throws InterruptedException {\n        tenDown();\n    }\n\n    public static void tenDown() throws InterruptedException {\n        int num = 10;\n        while (true) {\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if (num <= 0) {\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n//获取当前系统时间\npublic class TestSleep2 {\n    public static void main(String[] args) throws InterruptedException {\n        Date startTime = new Date(System.currentTimeMillis());\n        while (true) {\n            Thread.sleep(1000);\n            System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime));\n            startTime = new Date(System.currentTimeMillis());\n        }\n\n    }\n}\n```\n\n### 线程礼让\n\n1. 礼让线程，让当前正在执行的线程暂停，但不阻塞；\n2. 将线程从运行状态转为就绪状态；\n3. **让 cpu 重新调度，礼让不一定成功！看 CPU 心情；**\n\n```java\n/**\n * 测试礼让程序\n * 礼让不一定成功，看CPU心情\n */\npublic class TestYield implements Runnable {\n    public static void main(String[] args) {\n        TestYield testYield =  new TestYield();\n\n        new Thread(testYield, \"a\").start();\n        new Thread(testYield, \"b\").start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"线程开始执行\");\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + \"线程停止执行\");\n    }\n}\n\n//每次结果 都！不！一！样！ ？？？？？？？？？  -_-|||\n```\n\n### 合并线程\n\n1. join 合并线程，待此线程执行完成后再执行其他线程，其他线程阻塞；\n2. 可以想象成插队；\n3. join 前是交替执行；并不是不执行！！！\n\n```java\npublic class TestJoin implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0; i < 500; i++) {\n            System.out.println(\"★ VIP Thread ☆\" + i);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        TestJoin testJoin = new TestJoin();\n        Thread thread = new Thread(testJoin);\n        thread.start();\n\n        // 主线程\n        for (int i = 0; i < 500; i++) {\n            if(i == 200){\n                thread.join(); // 插队\n            }\n            System.out.println(\"main\" + i);\n        }\n    }\n}\n```\n\n### 线程状态观测\n\n**Thread.state**\n\n```java\n/**\n * 观察测试线程的状态\n */\npublic class TestState {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n                for (int i = 0; i < 5; i++) {\n            try {\n                Thread.sleep(1000);\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n        });\n\n        System.out.println(\"---------------\");\n\n        //观察状态\n        Thread.State state = thread.getState();\n        System.out.println(state); //NEW\n\n        //观察启动后\n        thread.start();\n        state = thread.getState();\n        System.out.println(state); //RUN\n\n        while (state != Thread.State.TERMINATED) { //只要线程不终止，就一直输出状态\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            state = thread.getState();  //更新线程状态\n            System.out.println(state);\n        }\n\n        thread.start();  //死亡的线程不能再启动，必须再new一个\n\n    }\n}\n```\n\n### 多线程优先级\n\n1. java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，调度器按照优先级决定应该调度哪个线程来执行；\n2. 线程的优先级用数字表示，范围从 1~10 ；\n   1. `Thread.MAX_PRIORITY = 10;`\n   2. `Thread.MIN_PRIORITY = 1;`\n   3. `Thread.NORM_PRIORITY = 5;`\n3. 使用以下方式改变或获取优先级 `getPriority().setPriority(int xxx);`\n\n优先级低只是意味着获得调度的概率低，并不是高优先级必然先调用 （性能倒置问题）；\n\n```java\npublic class TestPriority {\n    public static void main(String[] args) {\n        //主线程默认优先级\n        System.out.println(Thread.currentThread().getName() + \"---main---->\" + Thread.currentThread().getPriority());\n        MyPriority myPriority = new MyPriority();\n        Thread t1 = new Thread(myPriority);\n        Thread t2 = new Thread(myPriority);\n        Thread t3 = new Thread(myPriority);\n        Thread t4 = new Thread(myPriority);\n        Thread t5 = new Thread(myPriority);\n        Thread t6 = new Thread(myPriority);\n\n        t1.start();\n\n        t2.setPriority(1);\n        t2.start();\n\n        t3.setPriority(4);\n        t3.start();\n\n        t4.setPriority(Thread.MAX_PRIORITY);  //MAX_PRIORITY=10\n        t4.start();\n\n        t5.setPriority(Thread.MIN_PRIORITY); // min 为最小 1\n        t5.start();\n    }\n}\n\nclass MyPriority implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"---MyPriority---->\" + Thread.currentThread().getPriority());\n    }\n}\n```\n\n### 守护（daemon）线程\n\n1. 线程分为用户线程和守护线程；\n2. 虚拟机必须确保用户线程执行完毕；\n3. 虚拟机不用等待守护线程执行完毕；\n4. 如，后台记录操作日志，监控内存，垃圾回收等待；\n\n```java\n//测试守护线程\npublic class TestDaemon {\n    public static void main(String[] args) {\n        God god = new God();\n        Human human = new Human();\n\n        Thread thread = new Thread(god);\n        thread.setDaemon(true);  //默认是false表示用户线程，正常的线程都是用户线程\n\n        thread.start();  // 用户线程启动\n        new Thread(human).start();  //人类，用户线程启动\n\n    }\n\n}\n\n// 上帝\nclass God implements Runnable{\n\n    @Override\n    public void run() {\n        while(true){ // 按理来说不会结束 但作为守护线程在用户线程结束后 随之结束（可能会伴随虚拟机关闭的一点点延迟）\n            System.out.println(\"legends never die！\");\n        }\n    }\n}\n\n// 人类\nclass Human implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 365; i++) {\n            System.out.println(\"happy live！\");\n        }\n        System.out.println(\"Byebye, the worllllllllld!\");  //nope!!!!!!!!!!\n    }\n}\n```\n\n## 线程同步\n\n并发：同一个对象被多个线程同时操作；\n\n处理多线程问题时，多线程访问一个对象，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的**等待池**形成队列，等待前面线程使用完毕再让下一个线程使用\n\n### 三个不安全案例\n\n#### 不安全买票\n\n```java\n//不安全买票\n// 线程不安全，有负数\npublic class UnsafeBuyTicket {\n    public static void main(String[] args) {\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, \"牡丹\").start();\n        new Thread(station, \"井盖\").start();\n        new Thread(station, \"肥鯮 \").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() {\n        // 买票\n        while(true){\n            try {\n                buy();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void buy() throws InterruptedException {\n        // 判断是否有票\n        if(ticketNum <= 0){\n            flag = false;\n            return;\n        }\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + \"买到了\" + ticketNum--);\n    }\n}\n\n```\n\n#### 不安全取钱\n\n```java\n// 不安全取钱\n// 两个人去取钱\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        // 账户\n        Account account = new Account(100, \"存款金额\");\n        Drawing you = new Drawing(account, 50, \"你\");\n        Drawing gf = new Drawing(account, 100, \"对方\");\n        you.start();\n        gf.start();\n    }\n}\n\n// 账户\nclass Account{\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n// 银行 模拟取款\nclass Drawing extends Thread{\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name){\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    }\n\n    //取钱操作\n    @Override\n    public void run() {\n        // 判断有没有钱\n        if(account.money - drawingMoney < 0){\n            System.out.println(Thread.currentThread().getName() + \"钱不够，取不了咯！\");\n            return;\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + \"余额为：\" + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + \"手里的钱：\" + nowMoney);\n    }\n}\n\n```\n\n#### 不安全集合\n\n```java\npublic class UnSafeList {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(300);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n## 同步方法 - synchronized\n\n1. 由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 _synchronized_ 关键字，它包括两种用法：`synchronized` 方法和 `synchronized` 块；\n\n   同步方法 `public synchronized void method(int args){ }`；\n\n2. synchronized 方法控制对“对象”的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行；\n\n```java\n//买票\npublic class UnsafeBuyTicket {\n    public static void main(String[] args) {\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, \"牡丹\").start();\n        new Thread(station, \"井盖\").start();\n        new Thread(station, \"肥鯮 \").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() {\n        // 买票\n        while(true){\n            try {\n                buy();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n//synchronized\n    private synchronized void buy() throws InterruptedException {\n        // 判断是否有票\n        if(ticketNum <= 0){\n            flag = false;\n            return;\n        }\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + \"买到了\" + ticketNum--);\n    }\n}\n\n```\n\n**同步块**\n\n同步块：synchronized(Obj) {}\n\nObj 称为同步监视器\n\n1. Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器；\n2. 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this，就是这个对象本身，或者是 class【反射中讲解】\n\n同步监视器的执行过程：\n\n1. 第一个线程访问，锁定同步监视器，执行其中代码；\n2. 第二个线程访问，发现同步监视器被锁定，无法访问；\n3. 第一个线程访问完毕，解锁同步监视器；\n4. 第二个线程访问，发现同步监视器没有锁，然后锁定并反问；\n\n**synchronized () {}**\n\n```java\n// 两个人去取钱\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        // 账户\n        Account account = new Account(10000, \"存款金额\");\n        Drawing you = new Drawing(account, 50, \"你\");\n        Drawing gf = new Drawing(account, 100, \"对方\");\n        you.start();\n        gf.start();\n    }\n}\n\n// 账户\nclass Account{\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n// 银行 模拟取款\nclass Drawing extends Thread {\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name) {\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    }\n\n    //取钱操作\n    @Override\n    public void run() {\n         //锁的对象必须是变化的量\n        synchronized (account) {\n        // 判断有没有钱\n        if (account.money - drawingMoney < 0) {\n            System.out.println(Thread.currentThread().getName() + \"钱不够，取不了咯！\");\n            return;\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + \"余额为：\" + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + \"手里的钱：\" + nowMoney);\n    }\n}\n}\n\n```\n\n```java\npublic class UnSafeList {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                synchronized (list) {\n                    list.add(Thread.currentThread().getName());\n                }}).start();\n\n        }\n        try {\n            Thread.sleep(300);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n\n```\n\n## JUC 安全类型的集合-CopyOnWriteArrayList\n\n```java\npublic class TestJUC {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            new Thread( () ->{\n                list.add(Thread.currentThread().getName());\n            } ).start();\n\n            try {\n                Thread.sleep(30);\n            }catch (InterruptedException e){\n                e.printStackTrace();\n            }\n            System.out.println(list.size());\n        }\n\n    }\n}\n```\n\n## 死锁\n\n多个线程各自占用一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情况，某一个同步块同时拥有**两个以上对象的锁**时，就可能会发生”死锁“的问题。\n\n产生死锁的四个**必要**条件：\n\n1. 互斥：一个资源每次只能被一个进程使用\n2. 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3. 不剥夺：进程已获得的资源，在未用完之前，不能强行剥夺\n4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系\n\n上面四者只要想办法打破其中任意一个或者多个就可以避免死锁发生。\n\n```java\n// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(1, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n\n}\n\nclass Lipstick{\n}\nclass Mirror{\n}\n\nclass Makeup extends Thread{\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得镜子的锁\");\n                }\n            }\n\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得口红的锁\");\n                }\n            }\n\n\n\n        }\n    }\n}// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(0, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n}\nclass Lipstick{\n}\nclass Mirror{\n}\nclass Makeup extends Thread{\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得镜子的锁\");\n                }\n            }\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得口红的锁\");\n}}}}}\n```\n\n```java\n//代码块拿出来，不让互相抱死\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(1, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n\n}\n\nclass Lipstick{\n}\nclass Mirror{\n}\n\nclass Makeup extends Thread{\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n            }\n            synchronized (mirror){\n                // 获得镜子的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n            }\n\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n\n            }\n\n            synchronized (lipstick){\n                // 获得镜子的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n            }\n\n        }\n    }\n}\n```\n\n## Lock 锁 - 可重入锁\n\n```java\n//不安全\npublic class TestLock {\n    public static void main(String[] args) {\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\nclass TestLock2 implements Runnable {\n    //票数\n    int ticketNum = 10;\n\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNum > 0) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n            } else {\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n//加锁.sleep不会释放锁对象，所以sleep请加到lock前面。\npublic class TestLock {\n    public static void main(String[] args) {\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\nclass TestLock2 implements Runnable {\n    //票数\n    int ticketNum = 10;\n\n    //定义Lock锁\n    private final ReentrantLock lock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lock.lock();\n                if (ticketNum > 0) {\n                    System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n                }\n\n                else {\n                    break;\n                }\n            }finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n\n```java\nclass A{\n  private final ReentrantLock lock = new ReenTrantLock();\n  public void m(){\n    lock.lock();\n    try{\n      // 保证线程安全的代码\n    }\n    finally{\n\t\t\tlock.unlock();\n      // 如果同步代码有异常，要将unlock()写入finally语句块\n    }\n  }\n}\n```\n\n## synchronized 与 lock 的对比\n\n1. Lock 是显示锁，需要手动开启和关闭，synchronized 为隐式锁，出了作用域自动释放\n2. lock 只有代码块锁，synchronized 有代码块锁和方法锁\n3. 使用 lock 锁，jvm 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性\n4. 优先使用顺序\n   - Lock > 同步代码块（已经进入方法体，分配了相应资源）> 同步方法(在方法体之外)\n\n## 线程协作 - 生产者消费者问题\n\n线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n\n1. 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，有需要马上通知消费者消费\n2. 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n3. 在生产者消费者问题中，仅有 synchronized 是不够的\n   1. synchronized 可组织并发更新同一个共享资源，实现了同步\n   2. synchronized 不能用来实现不同线程之间的消息传递（通信）\n\nJava 提供了几个方法解决线程之间的通信问题\n\n| 方法名             | 作用                                                                  |\n| :----------------- | :-------------------------------------------------------------------- |\n| wait()             | 表示线程一直等待，直到其他线程通知，与 sleep（）不同，会释放锁        |\n| wait(long timeout) | 指定等待的毫秒数                                                      |\n| notify()           | 唤醒一个处于等待状态的线程                                            |\n| notifyAll()        | 唤醒同一个对象上所有调用 wait（）方法的线程，优先级别高的线程优先调度 |\n\n**注意：** 均是 Object 类的方法，都只能在同步方法或者同步代码快中使用，否则会抛出异常 `IllegalMonitorStateException`\n\n### 管程法\n\n1. 生产者：负责生产数据的模块（可能是方法、对象、线程、进程）\n\n2. 消费者：负责处理数据的模块（可能是方法、对象、线程、进程）\n\n3. 缓冲区：消费者不能直接使用生产者的数据，利用中间“缓冲区”\n\n   生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据\n\n```java\n// 测试 生产者消费者模型 --> 利用缓冲区解决：管程法\n// 有问题，会出现先消费后生产，要用队列实现\npublic class TestPC {\n    public static void main(String[] args) {\n        SynBuffer synBuffer = new SynBuffer();\n\n        new Producer(synBuffer).start();\n        new Consumer(synBuffer).start();\n    }\n}\n\n// 生产者\nclass Producer extends Thread{\n    SynBuffer buffer;\n    public Producer(SynBuffer buffer){\n        this.buffer = buffer;\n    }\n    // 生产\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"生产了\" + i +\"只鸡\");\n            try {\n                buffer.push(new Chicken(i));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread{\n    SynBuffer buffer;\n    public Consumer(SynBuffer buffer){\n        this.buffer = buffer;\n    }\n\n    // 消费\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            try {\n                System.out.println(\"消费了-->\" + buffer.pop().id +\"只鸡\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 产品\nclass Chicken{\n    int id; // 产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n// 缓冲区\nclass SynBuffer{\n\n    //容器大小\n    Chicken[] chickens = new Chicken[10];\n    // 容器计数器\n    int count = 0;\n\n    // 生产者放入产品\n    public synchronized void push(Chicken chicken) throws InterruptedException {\n        // 如果容器满了，需要等待消费者消费\n        if(count == chickens.length){\n            // 通知消费者消费，生产等待\n            this.wait();\n        }\n        // 如果没有满，需要丢入产品\n        chickens[count] = chicken;\n        count ++;\n        // 可以通知消费者消费了\n        this.notifyAll();\n    }\n\n    // 消费者消费产品\n    public synchronized Chicken pop() throws InterruptedException {\n        // 判断能否消费\n        if(count == 0){\n            /// 等待生产者生产，消费者等待\n            this.wait();\n        }\n        // 如果可以消费\n        count --;\n        Chicken chicken = chickens[count];\n        // 吃完了，通知生产者生产\n        this.notifyAll();\n\n        return chicken;\n    }\n}\n```\n\n### 信号灯法\n\n```java\npublic class TestPC2 {\n    public static void main(String[] args) {\n        TV tv = new TV();\n        new Player(tv).start();\n        new Watcher(tv).start();\n    }\n}\n\n// 生产者 --> 演员\nclass Player extends Thread{\n    TV tv;\n    public Player(TV tv){\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            if (i % 2 == 0){\n                this.tv.play(\"节目一：新闻联播\");\n            }else{\n                this.tv.play(\"节目二：法治在线\");\n            }\n        }\n    }\n}\n// 消费者 --> 观众\nclass Watcher extends Thread{\n    TV tv;\n    public Watcher(TV tv){\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            tv.watch();\n        }\n    }\n}\n\n// 产品 --> 节目\nclass TV{\n    // 演员表演，观众等待 T\n    // 观众观看，演员等待 F\n    String voice; // 表演的节目\n    boolean flag = true;\n    // 表演\n    public synchronized void play(String voice){\n\n        if (!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println(\"演员表演了:\" + voice);\n        // 通知观众观看\n        this.notifyAll(); // 通知唤醒\n        this.voice = voice;\n        this.flag = !this.flag;\n    }\n    // 观看\n    public synchronized void watch(){\n        if (flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"观看了：\" + voice);\n        // 通知演员表演\n        this.notifyAll();\n        this.flag = !this.flag;\n    }\n}\n\n```\n\n## 线程池\n\n背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的交通工具。\n\n好处：\n\n    1. 提高响应速度（减少创建新线程的时间）\n\n2. 降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 3. 便于线程管理 1. corePoolSize：最大线程数； 2. maxmumPoolSize：最大线程数； 3. keepAliveTime：线程没有任务时最多保持多长时间后会终止；\n\n## 使用线程池\n\n1. jdk5.0 线程池相关 API ：ExecutorService 和 Executors；\n2. ExecutorService ：真正的线程池接口。常见子类 ThreadPoolExecutor；\n   1. void execute(Runnable command) : 执行任务/命令，没有返回值，一般用来执行 Runnable；\n   2. <T>Future<T> submit(Callable<T> task): 执行任务，有返回值，一般用来执行 Callable；\n   3. void shutdown(): 关闭连接池；\n3. Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池；\n\n```java\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool {\n    public static void main(String[] args) {\n        // 1. 创建服务，创建线程池\n        // newFixedThreadPool 参数为线程池大小\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        // 2. 关闭连接\n        service.shutdown();\n    }\n}\n\nclass   MyThread implements Runnable{\n\n    @Override\n    public void run() {\n            System.out.println(Thread.currentThread().getName());\n    }\n}\n```\n\n## 总结\n\n```java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class summary {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        new MyThread1().start();\n\n        new Thread(new MyThread2()).start();\n\n        FutureTask<Integer> futureTask = new FutureTask<Integer>(new MyThread3());\n        new Thread(futureTask).start();\n        Integer integer = futureTask.get();\n        System.out.println(integer);\n    }\n}\n\n// 1. 继承Thread类\nclass MyThread1 extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"My Thread1\");\n    }\n}\n// 2. 实现Runnable接口\nclass MyThread2 implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(\"My Thread2\");\n    }\n}\n// 3. 实现Callable接口\nclass MyThread3 implements Callable<Integer>{\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(\"My Thread3\");\n        return 100;\n    }\n}\n\n```\n","source":"_posts/JAVA-线程-20210418.md","raw":"---\ntitle: JAVA-线程\ndate: 2021-04-12 00:02:31\ntags:\n  - java基础\n  - 狂神说\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# 线程\n\n<!--more-->\n\n## 线程创建\n\nThread、Runnable、Callable\n\n**继承 Thread 类**和 **实现 Runnable 接口** 为重点，实现 Callable 接口仅作了解\n\n## Thread\n\n1. 自定义线程类继承 Thread 类\n2. 重写 run()方法，编写线程执行体\n3. 创建线程对象，调用 start()方法启动线程\n\n```java\n// 创建线程的方式：继承Thread类 、重写run（）方法、 调用start开启线程\n\n// 总结：线程开启不一定立即执行，由cpu进行调度执行\n\npublic class TestThread01 extends Thread {\n    @Override\n    public void run() {\n        // run方法线程体\n        for (int i = 0; i < 200; i++) {\n            System.out.println(\"正在执行线程----\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        // main主线程\n        // 创建一个线程对象\n        TestThread01 testThread01 = new TestThread01();\n        //调用start（）方法开启线程\n        testThread01.start();\n\n        for (int i = 0; i < 2000; i++) {\n            System.out.println(\"正在执行主方法******\" + i);\n        }\n    }\n}\n```\n\n### 实现多线程同步下载图片(commons-io)\n\n```java\n/**\n * 实现多线程同步下载图片\n */\npublic class TestThread2 extends Thread {\n    private String url;\n    private String name;\n\n    public TestThread2(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n    @Override\n    public void run() {\n        WebDownLoader webDownLoader = new WebDownLoader();\n        webDownLoader.downloader(url,name);\n        System.out.println(\"下载文件名为:\" + name);\n\n    }\n    public static void main(String[] args) {\n        TestThread2 t1 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestThread2 t2 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestThread2 t3 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\n//下载器\nclass WebDownLoader {\n    //下载方法\n    public void downloader(String url, String name) {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"io异常，downloader方法出现问题\");\n        }\n    }\n}\n```\n\n## 实现 Runable 接口\n\n1. 定义 MyRunnable 类实现 Runnable 接口\n2. 实现 run()方法，编写线程执行体\n3. 创建线程对象，调用 start()方法启动线程\n\n```java\npublic class TestRunable01 implements Runnable {\n    //run方法线程体\n    @Override\n    public void run() {\n        for (int i = 0; i < 200; i++) {\n            System.out.println(\"我在看代码--\" + i);\n        }\n    }\n\n    //执行下面代码\n    public static void main(String[] args) {\n        //main线程，主线程\n        //创建一个Runable接口的实现对象\n        TestRunable01 testRunable01 = new TestRunable01();\n\n        //创建线程对象，通过线程对象来开启线程，这种方式叫做代理\n        new Thread(testRunable01).start();\n\n        for (int i = 0; i < 20000; i++) {\n            System.out.println(\"我在学习多线程--\"  + i);\n        }\n    }\n}\n```\n\n### Runable-实现多线程同步下载图片(commons-io)\n\n```java\npackage com.thread.demo01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 实现多线程同步下载图片\n */\npublic class TestRunable02 extends Thread {\n    private String url;\n    private String name;\n\n    public TestRunable02(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n\n    @Override\n    public void run() {\n        WebDownLoader2 webDownLoader = new WebDownLoader2();\n        webDownLoader.downloader(url,name);\n        System.out.println(\"下载文件名为:\" + name);\n\n    }\n\n    public static void main(String[] args) {\n        TestThread2 t1 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestThread2 t2 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestThread2 t3 = new TestThread2\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    }\n\n}\n\n//下载器\nclass WebDownLoader2 {\n    //下载方法\n    public void downloader(String url, String name) {\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"io异常，downloader方法出现问题\");\n        }\n    }\n}\n\n```\n\n## Thread 与 Runable 比较\n\n|          继承 Thread 类           |                         实现 Runnable 接口                         |\n| :-------------------------------: | :----------------------------------------------------------------: |\n| 子类继承 Thread 类具备多线程能力  |                  实现接口 Runnable 具有多线程能力                  |\n|    启动线程：子类对象.start();    |            启动线程：传入目标对象+Thread 对象.start();             |\n| 不建议使用：避免 OOP 单继承局限性 | 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 |\n\n## 买火车票的例子\n\n存在并发问题，会出现多个不同用户抢到同一张票的问题；\n\n```java\npackage com.thread.demo01;\n\n/**\n * 多个县城同时操作一个对象\n * 买火车票的例子\n */\npublic class TestThread03 implements Runnable {\n    //票数\n    private static int ticketNum = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNum<=0){\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TestThread03 ticket = new TestThread03();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\n```\n\n```java\n小明------拿到了第10张票------\n阿黄------拿到了第9张票------\n小二------拿到了第8张票------\n小明------拿到了第7张票------\n小二------拿到了第7张票------\n阿黄------拿到了第7张票------\n阿黄------拿到了第6张票------\n小二------拿到了第6张票------\n小明------拿到了第5张票------\n小明------拿到了第3张票------\n小二------拿到了第4张票------\n阿黄------拿到了第4张票------\n阿黄------拿到了第2张票------\n小二------拿到了第2张票------\n小明------拿到了第2张票------\n阿黄------拿到了第0张票------\n小二------拿到了第-1张票------\n小明------拿到了第1张票------\n```\n\n## 模拟龟兔赛跑\n\n```java\n/**\n * 模拟龟兔赛跑\n */\npublic class Race implements Runnable {\n    private static String winner;\n\n    @Override\n    public void run() {\n        for (int i = 0; i <= 100; i++) {\n\n            // 模拟兔子休息\n            if (Thread.currentThread().getName().equals(\"兔子\") && i%10 == 0){\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            //判断比赛是否结束\n            boolean flag = gameOver(i);\n            //出现winner，跳出\n            if (flag) {\n                break;\n            }\n\n            System.out.println(Thread.currentThread().getName() + \"-->跑了\" + i + \"米\");\n        }\n    }\n\n    //判断是否完成比赛\n    public boolean gameOver(int steps) {\n        if (winner != null) {//已经存在\n            return true;\n        }else {\n            if (steps == 100) {\n                winner = Thread.currentThread().getName();\n                System.out.println(\"winner is\" + winner);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Race race = new Race();\n\n        new Thread(race, \"兔子\").start();\n        new Thread(race, \"乌龟\").start();\n\n    }\n}\n\n```\n\n## 实现 Callable 接口（仅了解） 扩充\n\n1. 实现 Callable 接口，需要返回值类型\n2. 重写 call 方法，需要抛出异常\n3. 创建目标对象\n4. （1）创建执行服务 `ExecutorService ser=Executors.newFixedThreadPool(3);` //线程池，并发数\n5. （2）提交执行 `Future<Boolean> result = ser.submit(t1);`\n6. （3）获取结果 `boolean r1 = result.get();`\n7. （4）关闭服务 `ser.shutdownNow();`\n\n示例代码如下：\n\n```java\nimport java.util.concurrent.*;\n\npublic class TestCallable implements Callable {\n    private String url;\n    private String name;\n\n    public TestCallable(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    @Override\n    public Object call() throws Exception {\n        WebDownLoader wd = new WebDownLoader();\n        wd.downloader(url,name);\n        System.out.println(\"下载文件，名为---\" + name);\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        TestCallable t1 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t1.jpg\");\n        TestCallable t2 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t2.jpg\");\n        TestCallable t3 = new TestCallable\n                (\"https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5\", \"t3.jpg\");\n\n        //1.创建执行服务\n        ExecutorService serv = Executors.newFixedThreadPool(3); //线程池，并发数\n\n        //2.提交执行\n        Future<Boolean> r1 = serv.submit(t1);\n        Future<Boolean> r2 = serv.submit(t2);\n        Future<Boolean> r3 = serv.submit(t3);\n        //3.获取结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //4.关闭服务\n        serv.shutdownNow();\n    }\n}\n\n```\n\n## 静态代理--个人结婚与婚庆公司的例子\n\n```java\npackage com.thread.demo01;\n// 静态代理模式：\n// 真实对象和代理对象都要实现同一个接口\n// 代理对象要代理真实角色\n\n// 好处 ：\n// 1. 代理对象可以做很多真实对象做不了的事情\n// 2. 真实对象专注做自己的事情\n\npublic class StaticProxy {\n\n    public static void main(String[] args) {\n\n        You you = new You(); // 真实对象\n        new Thread(() -> System.out.println(\"i love you\")).start(); // lambda表达式\n\n//        //传统调用方式\n//        You you = new You();\n//        you.HappyMarry();\n\n        new WeddingCompany(new You()).HappyMarry();\n        //代理调用\n//        WeddingCompany weddingCompany = new WeddingCompany(new You());\n//        weddingCompany.HappyMarry();\n\n    }\n}\n\ninterface Marry {\n    void HappyMarry();\n}\n\n\n//真实角色，你去结婚\nclass You implements Marry {\n    @Override\n    public void HappyMarry() {\n        System.out.println(\"结婚，超开心(^_^)\"); //no-qinjiang\n    }\n}\n\n//代理角色，帮助你结婚, 起到帮助作用\nclass WeddingCompany implements Marry {\n    //代理谁 --> 真实目标角色\n    private Marry target;\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n    @Override\n    public void HappyMarry() {\n        before();\n        this.target.HappyMarry();\n        after();\n    }\n\n    private void before() {\n        System.out.println(\"布置婚礼现场\");\n    }\n\n    private void after() {\n        System.out.println(\"还债结尾款\");\n    }\n}\n```\n\n## Lambda 表达式\n\n为什么要使用 lambda 表达式\n\n1. 避免匿名内部类定义过多\n\n2. 可以让代码看起来更简洁\n\n3. 去掉无意义代码，留下核心逻辑\n\n   注：只有一行代码的情况下才能简化成一行；前提是接口为函数式接口\n\n理解函数式接口（Functional Interface）是学习 java8 lambda 表达式的关键所在\n\n函数式接口的定义：\n\n任何接口，如果只包含一个抽象方法，那么他就是一个函数式接口。\n\neg:\n\n```java\npublic interface Runable {\n    public abstract void run();\n}\n```\n\n对于函数式接口，我们可以通过 Lambda 表达式来创建该接口的对象。\n\n简化至 lambda 的步骤如下：\n\n```java\n//外部类，接口\npublic class TestLove {\n    public static void main(String[] args) {\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n\nclass Love implements ILove {\n    @Override\n    public void love(String a) {\n        System.out.println(\"I love --\" + a);\n    }\n}\n```\n\n```java\n//静态内部类\n\npublic class TestLove {\n    static class Love implements ILove {\n        @Override\n        public void love(String a) {\n            System.out.println(\"I love --\" + a);\n        }\n    }\n    public static void main(String[] args) {\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n\n\n```\n\n```java\npublic class TestLove {\n\n    public static void main(String[] args) {\n        class Love implements ILove {\n            @Override\n            public void love(String a) {\n                System.out.println(\"I love --\" + a);\n            }\n        }\n\n        ILove iLove = new Love();\n        iLove.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//匿名内部类\n\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove iLove = new ILove() {\n            @Override\n            public void love(String a) {\n                System.out.println(\"I love --\" + a);\n            }\n        };\n        iLove.love(\"zzz\");\n    }\n}\ninterface ILove { void love(String a);}\n```\n\n```java\n//lambda表达式\nublic class TestLove {\n    public static void main(String[] args) {\n\n        ILove love = (String a)-> {\n            System.out.println(\"I love --\" + a);\n        };\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化，去掉参数类型\n\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = (a)-> {\n            System.out.println(\"I love --\" + a);\n        };\n\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化括号\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = a-> {\n            System.out.println(\"I love --\" + a);\n        };\n\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n```java\n//简化花括号，因为代码只有一行，有多行不可简化花括号\npublic class TestLove {\n\n    public static void main(String[] args) {\n\n        ILove love = a-> System.out.println(\"I love --\" + a);\n        love.love(\"zzz\");\n\n    }\n}\n\ninterface ILove { void love(String a);}\n```\n\n总结：\n\n1. lambda 表达式代码只有一行的情况下才能简化为一行，有多行时必须用花括号包裹；\n2. 前提示接口为函数式接口（只包含一个方法）；\n3. 多个参数也可以去掉参数类型，留就都留，去就都去，必须加上括号；\n\n## 线程状态\n\n![image-20210411183018803](img/article/JAVA-线程-20210418/image-20210411183018803.png)\n\n**线程的方法**\n\n![image-20210411183039107](img/article/JAVA-线程-20210418/image-20210411183039107.png)\n\n### 停止线程\n\n1. 不推荐使用 JDK 提供的`stop(); destroy();`方法；\n2. 推荐线程自己停止；\n3. 建议使用一个标志位进行终止变量；\n\n```java\n/**\n * 测试stop\n * 1. 建议线程正常停止--->利用次数；不建议死循环\n * 2. 建议使用标志位--->设置一个标志位\n * 3. 不要使用stop或者destory等过时或JDK不建议使用的方法\n */\npublic class TestStop implements Runnable {\n    //1. 设置一个标志位\n    private boolean flag = true;\n\n    @Override\n    public void run() {\n        int i = 0;\n        while (flag) {\n            System.out.println(\"run thread ----\" + i++);\n        }\n    }\n\n    //设置一个公开的方法停止线程，转换标志位\n    public void stop() {\n        this.flag = false;\n    }\n\n    public static void main(String[] args) {\n        TestStop testStop = new TestStop();\n        new Thread(testStop).start();\n\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"main\" + i);\n            if (i==900) {\n                //调用stop方法切换标志为\n                testStop.stop();\n                System.out.println(\"该线程停止了\");\n                break;\n            }\n        }\n    }\n}\n```\n\n### 线程休眠\n\n1. sleep(时间) 指定当前线程阻塞的毫秒数；\n2. sleep 存在异常 InterruptException；\n3. sleep 时间达到后线程进入就绪状态；\n4. sleep 可以模拟网络延时，倒计时等；\n5. 每一个对象都有一个锁，sleep 不会释放锁；\n\n```java\n//模拟倒计时 10s\npublic class TestSleep2 {\n    public static void main(String[] args) throws InterruptedException {\n        tenDown();\n    }\n\n    public static void tenDown() throws InterruptedException {\n        int num = 10;\n        while (true) {\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if (num <= 0) {\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n//获取当前系统时间\npublic class TestSleep2 {\n    public static void main(String[] args) throws InterruptedException {\n        Date startTime = new Date(System.currentTimeMillis());\n        while (true) {\n            Thread.sleep(1000);\n            System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime));\n            startTime = new Date(System.currentTimeMillis());\n        }\n\n    }\n}\n```\n\n### 线程礼让\n\n1. 礼让线程，让当前正在执行的线程暂停，但不阻塞；\n2. 将线程从运行状态转为就绪状态；\n3. **让 cpu 重新调度，礼让不一定成功！看 CPU 心情；**\n\n```java\n/**\n * 测试礼让程序\n * 礼让不一定成功，看CPU心情\n */\npublic class TestYield implements Runnable {\n    public static void main(String[] args) {\n        TestYield testYield =  new TestYield();\n\n        new Thread(testYield, \"a\").start();\n        new Thread(testYield, \"b\").start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"线程开始执行\");\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + \"线程停止执行\");\n    }\n}\n\n//每次结果 都！不！一！样！ ？？？？？？？？？  -_-|||\n```\n\n### 合并线程\n\n1. join 合并线程，待此线程执行完成后再执行其他线程，其他线程阻塞；\n2. 可以想象成插队；\n3. join 前是交替执行；并不是不执行！！！\n\n```java\npublic class TestJoin implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0; i < 500; i++) {\n            System.out.println(\"★ VIP Thread ☆\" + i);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        TestJoin testJoin = new TestJoin();\n        Thread thread = new Thread(testJoin);\n        thread.start();\n\n        // 主线程\n        for (int i = 0; i < 500; i++) {\n            if(i == 200){\n                thread.join(); // 插队\n            }\n            System.out.println(\"main\" + i);\n        }\n    }\n}\n```\n\n### 线程状态观测\n\n**Thread.state**\n\n```java\n/**\n * 观察测试线程的状态\n */\npublic class TestState {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n                for (int i = 0; i < 5; i++) {\n            try {\n                Thread.sleep(1000);\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n        });\n\n        System.out.println(\"---------------\");\n\n        //观察状态\n        Thread.State state = thread.getState();\n        System.out.println(state); //NEW\n\n        //观察启动后\n        thread.start();\n        state = thread.getState();\n        System.out.println(state); //RUN\n\n        while (state != Thread.State.TERMINATED) { //只要线程不终止，就一直输出状态\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            state = thread.getState();  //更新线程状态\n            System.out.println(state);\n        }\n\n        thread.start();  //死亡的线程不能再启动，必须再new一个\n\n    }\n}\n```\n\n### 多线程优先级\n\n1. java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，调度器按照优先级决定应该调度哪个线程来执行；\n2. 线程的优先级用数字表示，范围从 1~10 ；\n   1. `Thread.MAX_PRIORITY = 10;`\n   2. `Thread.MIN_PRIORITY = 1;`\n   3. `Thread.NORM_PRIORITY = 5;`\n3. 使用以下方式改变或获取优先级 `getPriority().setPriority(int xxx);`\n\n优先级低只是意味着获得调度的概率低，并不是高优先级必然先调用 （性能倒置问题）；\n\n```java\npublic class TestPriority {\n    public static void main(String[] args) {\n        //主线程默认优先级\n        System.out.println(Thread.currentThread().getName() + \"---main---->\" + Thread.currentThread().getPriority());\n        MyPriority myPriority = new MyPriority();\n        Thread t1 = new Thread(myPriority);\n        Thread t2 = new Thread(myPriority);\n        Thread t3 = new Thread(myPriority);\n        Thread t4 = new Thread(myPriority);\n        Thread t5 = new Thread(myPriority);\n        Thread t6 = new Thread(myPriority);\n\n        t1.start();\n\n        t2.setPriority(1);\n        t2.start();\n\n        t3.setPriority(4);\n        t3.start();\n\n        t4.setPriority(Thread.MAX_PRIORITY);  //MAX_PRIORITY=10\n        t4.start();\n\n        t5.setPriority(Thread.MIN_PRIORITY); // min 为最小 1\n        t5.start();\n    }\n}\n\nclass MyPriority implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"---MyPriority---->\" + Thread.currentThread().getPriority());\n    }\n}\n```\n\n### 守护（daemon）线程\n\n1. 线程分为用户线程和守护线程；\n2. 虚拟机必须确保用户线程执行完毕；\n3. 虚拟机不用等待守护线程执行完毕；\n4. 如，后台记录操作日志，监控内存，垃圾回收等待；\n\n```java\n//测试守护线程\npublic class TestDaemon {\n    public static void main(String[] args) {\n        God god = new God();\n        Human human = new Human();\n\n        Thread thread = new Thread(god);\n        thread.setDaemon(true);  //默认是false表示用户线程，正常的线程都是用户线程\n\n        thread.start();  // 用户线程启动\n        new Thread(human).start();  //人类，用户线程启动\n\n    }\n\n}\n\n// 上帝\nclass God implements Runnable{\n\n    @Override\n    public void run() {\n        while(true){ // 按理来说不会结束 但作为守护线程在用户线程结束后 随之结束（可能会伴随虚拟机关闭的一点点延迟）\n            System.out.println(\"legends never die！\");\n        }\n    }\n}\n\n// 人类\nclass Human implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 365; i++) {\n            System.out.println(\"happy live！\");\n        }\n        System.out.println(\"Byebye, the worllllllllld!\");  //nope!!!!!!!!!!\n    }\n}\n```\n\n## 线程同步\n\n并发：同一个对象被多个线程同时操作；\n\n处理多线程问题时，多线程访问一个对象，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的**等待池**形成队列，等待前面线程使用完毕再让下一个线程使用\n\n### 三个不安全案例\n\n#### 不安全买票\n\n```java\n//不安全买票\n// 线程不安全，有负数\npublic class UnsafeBuyTicket {\n    public static void main(String[] args) {\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, \"牡丹\").start();\n        new Thread(station, \"井盖\").start();\n        new Thread(station, \"肥鯮 \").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() {\n        // 买票\n        while(true){\n            try {\n                buy();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void buy() throws InterruptedException {\n        // 判断是否有票\n        if(ticketNum <= 0){\n            flag = false;\n            return;\n        }\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + \"买到了\" + ticketNum--);\n    }\n}\n\n```\n\n#### 不安全取钱\n\n```java\n// 不安全取钱\n// 两个人去取钱\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        // 账户\n        Account account = new Account(100, \"存款金额\");\n        Drawing you = new Drawing(account, 50, \"你\");\n        Drawing gf = new Drawing(account, 100, \"对方\");\n        you.start();\n        gf.start();\n    }\n}\n\n// 账户\nclass Account{\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n// 银行 模拟取款\nclass Drawing extends Thread{\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name){\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    }\n\n    //取钱操作\n    @Override\n    public void run() {\n        // 判断有没有钱\n        if(account.money - drawingMoney < 0){\n            System.out.println(Thread.currentThread().getName() + \"钱不够，取不了咯！\");\n            return;\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + \"余额为：\" + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + \"手里的钱：\" + nowMoney);\n    }\n}\n\n```\n\n#### 不安全集合\n\n```java\npublic class UnSafeList {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(300);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n## 同步方法 - synchronized\n\n1. 由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 _synchronized_ 关键字，它包括两种用法：`synchronized` 方法和 `synchronized` 块；\n\n   同步方法 `public synchronized void method(int args){ }`；\n\n2. synchronized 方法控制对“对象”的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行；\n\n```java\n//买票\npublic class UnsafeBuyTicket {\n    public static void main(String[] args) {\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, \"牡丹\").start();\n        new Thread(station, \"井盖\").start();\n        new Thread(station, \"肥鯮 \").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() {\n        // 买票\n        while(true){\n            try {\n                buy();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n//synchronized\n    private synchronized void buy() throws InterruptedException {\n        // 判断是否有票\n        if(ticketNum <= 0){\n            flag = false;\n            return;\n        }\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + \"买到了\" + ticketNum--);\n    }\n}\n\n```\n\n**同步块**\n\n同步块：synchronized(Obj) {}\n\nObj 称为同步监视器\n\n1. Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器；\n2. 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this，就是这个对象本身，或者是 class【反射中讲解】\n\n同步监视器的执行过程：\n\n1. 第一个线程访问，锁定同步监视器，执行其中代码；\n2. 第二个线程访问，发现同步监视器被锁定，无法访问；\n3. 第一个线程访问完毕，解锁同步监视器；\n4. 第二个线程访问，发现同步监视器没有锁，然后锁定并反问；\n\n**synchronized () {}**\n\n```java\n// 两个人去取钱\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        // 账户\n        Account account = new Account(10000, \"存款金额\");\n        Drawing you = new Drawing(account, 50, \"你\");\n        Drawing gf = new Drawing(account, 100, \"对方\");\n        you.start();\n        gf.start();\n    }\n}\n\n// 账户\nclass Account{\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n// 银行 模拟取款\nclass Drawing extends Thread {\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name) {\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    }\n\n    //取钱操作\n    @Override\n    public void run() {\n         //锁的对象必须是变化的量\n        synchronized (account) {\n        // 判断有没有钱\n        if (account.money - drawingMoney < 0) {\n            System.out.println(Thread.currentThread().getName() + \"钱不够，取不了咯！\");\n            return;\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + \"余额为：\" + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + \"手里的钱：\" + nowMoney);\n    }\n}\n}\n\n```\n\n```java\npublic class UnSafeList {\n    public static void main(String[] args) throws InterruptedException {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                synchronized (list) {\n                    list.add(Thread.currentThread().getName());\n                }}).start();\n\n        }\n        try {\n            Thread.sleep(300);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n\n```\n\n## JUC 安全类型的集合-CopyOnWriteArrayList\n\n```java\npublic class TestJUC {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            new Thread( () ->{\n                list.add(Thread.currentThread().getName());\n            } ).start();\n\n            try {\n                Thread.sleep(30);\n            }catch (InterruptedException e){\n                e.printStackTrace();\n            }\n            System.out.println(list.size());\n        }\n\n    }\n}\n```\n\n## 死锁\n\n多个线程各自占用一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情况，某一个同步块同时拥有**两个以上对象的锁**时，就可能会发生”死锁“的问题。\n\n产生死锁的四个**必要**条件：\n\n1. 互斥：一个资源每次只能被一个进程使用\n2. 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3. 不剥夺：进程已获得的资源，在未用完之前，不能强行剥夺\n4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系\n\n上面四者只要想办法打破其中任意一个或者多个就可以避免死锁发生。\n\n```java\n// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(1, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n\n}\n\nclass Lipstick{\n}\nclass Mirror{\n}\n\nclass Makeup extends Thread{\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得镜子的锁\");\n                }\n            }\n\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得口红的锁\");\n                }\n            }\n\n\n\n        }\n    }\n}// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(0, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n}\nclass Lipstick{\n}\nclass Mirror{\n}\nclass Makeup extends Thread{\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n                synchronized (mirror){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得镜子的锁\");\n                }\n            }\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n                synchronized (lipstick){\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + \"获得口红的锁\");\n}}}}}\n```\n\n```java\n//代码块拿出来，不让互相抱死\npublic class DeadLock  {\n    public static void main(String[] args) {\n        Makeup moore = new Makeup(0, \"Moore\");\n        Makeup dove = new Makeup(1, \"Dove\");\n        moore.start();\n        dove.start();\n    }\n\n}\n\nclass Lipstick{\n}\nclass Mirror{\n}\n\nclass Makeup extends Thread{\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName){\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n    @Override\n    public void run() {\n        // 化妆\n        try {\n            Makeup();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException {\n        if(choice == 0){\n            synchronized (lipstick){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n                Thread.sleep(1000);\n            }\n            synchronized (mirror){\n                // 获得镜子的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n            }\n\n        }else{\n            synchronized (mirror){\n                // 获得口红的锁\n                System.out.println(this.girlName + \"获得镜子的锁\");\n                Thread.sleep(2000);\n\n            }\n\n            synchronized (lipstick){\n                // 获得镜子的锁\n                System.out.println(this.girlName + \"获得口红的锁\");\n            }\n\n        }\n    }\n}\n```\n\n## Lock 锁 - 可重入锁\n\n```java\n//不安全\npublic class TestLock {\n    public static void main(String[] args) {\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\nclass TestLock2 implements Runnable {\n    //票数\n    int ticketNum = 10;\n\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNum > 0) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n            } else {\n                break;\n            }\n        }\n    }\n}\n```\n\n```java\n//加锁.sleep不会释放锁对象，所以sleep请加到lock前面。\npublic class TestLock {\n    public static void main(String[] args) {\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, \"小明\").start();\n        new Thread(ticket, \"小二\").start();\n        new Thread(ticket, \"阿黄\").start();\n    }\n}\n\nclass TestLock2 implements Runnable {\n    //票数\n    int ticketNum = 10;\n\n    //定义Lock锁\n    private final ReentrantLock lock = new ReentrantLock();\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lock.lock();\n                if (ticketNum > 0) {\n                    System.out.println(Thread.currentThread().getName() + \"------拿到了第\" + ticketNum-- + \"张票------\");\n                }\n\n                else {\n                    break;\n                }\n            }finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n\n```java\nclass A{\n  private final ReentrantLock lock = new ReenTrantLock();\n  public void m(){\n    lock.lock();\n    try{\n      // 保证线程安全的代码\n    }\n    finally{\n\t\t\tlock.unlock();\n      // 如果同步代码有异常，要将unlock()写入finally语句块\n    }\n  }\n}\n```\n\n## synchronized 与 lock 的对比\n\n1. Lock 是显示锁，需要手动开启和关闭，synchronized 为隐式锁，出了作用域自动释放\n2. lock 只有代码块锁，synchronized 有代码块锁和方法锁\n3. 使用 lock 锁，jvm 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性\n4. 优先使用顺序\n   - Lock > 同步代码块（已经进入方法体，分配了相应资源）> 同步方法(在方法体之外)\n\n## 线程协作 - 生产者消费者问题\n\n线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n\n1. 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，有需要马上通知消费者消费\n2. 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n3. 在生产者消费者问题中，仅有 synchronized 是不够的\n   1. synchronized 可组织并发更新同一个共享资源，实现了同步\n   2. synchronized 不能用来实现不同线程之间的消息传递（通信）\n\nJava 提供了几个方法解决线程之间的通信问题\n\n| 方法名             | 作用                                                                  |\n| :----------------- | :-------------------------------------------------------------------- |\n| wait()             | 表示线程一直等待，直到其他线程通知，与 sleep（）不同，会释放锁        |\n| wait(long timeout) | 指定等待的毫秒数                                                      |\n| notify()           | 唤醒一个处于等待状态的线程                                            |\n| notifyAll()        | 唤醒同一个对象上所有调用 wait（）方法的线程，优先级别高的线程优先调度 |\n\n**注意：** 均是 Object 类的方法，都只能在同步方法或者同步代码快中使用，否则会抛出异常 `IllegalMonitorStateException`\n\n### 管程法\n\n1. 生产者：负责生产数据的模块（可能是方法、对象、线程、进程）\n\n2. 消费者：负责处理数据的模块（可能是方法、对象、线程、进程）\n\n3. 缓冲区：消费者不能直接使用生产者的数据，利用中间“缓冲区”\n\n   生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据\n\n```java\n// 测试 生产者消费者模型 --> 利用缓冲区解决：管程法\n// 有问题，会出现先消费后生产，要用队列实现\npublic class TestPC {\n    public static void main(String[] args) {\n        SynBuffer synBuffer = new SynBuffer();\n\n        new Producer(synBuffer).start();\n        new Consumer(synBuffer).start();\n    }\n}\n\n// 生产者\nclass Producer extends Thread{\n    SynBuffer buffer;\n    public Producer(SynBuffer buffer){\n        this.buffer = buffer;\n    }\n    // 生产\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"生产了\" + i +\"只鸡\");\n            try {\n                buffer.push(new Chicken(i));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 消费者\nclass Consumer extends Thread{\n    SynBuffer buffer;\n    public Consumer(SynBuffer buffer){\n        this.buffer = buffer;\n    }\n\n    // 消费\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            try {\n                System.out.println(\"消费了-->\" + buffer.pop().id +\"只鸡\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// 产品\nclass Chicken{\n    int id; // 产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n// 缓冲区\nclass SynBuffer{\n\n    //容器大小\n    Chicken[] chickens = new Chicken[10];\n    // 容器计数器\n    int count = 0;\n\n    // 生产者放入产品\n    public synchronized void push(Chicken chicken) throws InterruptedException {\n        // 如果容器满了，需要等待消费者消费\n        if(count == chickens.length){\n            // 通知消费者消费，生产等待\n            this.wait();\n        }\n        // 如果没有满，需要丢入产品\n        chickens[count] = chicken;\n        count ++;\n        // 可以通知消费者消费了\n        this.notifyAll();\n    }\n\n    // 消费者消费产品\n    public synchronized Chicken pop() throws InterruptedException {\n        // 判断能否消费\n        if(count == 0){\n            /// 等待生产者生产，消费者等待\n            this.wait();\n        }\n        // 如果可以消费\n        count --;\n        Chicken chicken = chickens[count];\n        // 吃完了，通知生产者生产\n        this.notifyAll();\n\n        return chicken;\n    }\n}\n```\n\n### 信号灯法\n\n```java\npublic class TestPC2 {\n    public static void main(String[] args) {\n        TV tv = new TV();\n        new Player(tv).start();\n        new Watcher(tv).start();\n    }\n}\n\n// 生产者 --> 演员\nclass Player extends Thread{\n    TV tv;\n    public Player(TV tv){\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            if (i % 2 == 0){\n                this.tv.play(\"节目一：新闻联播\");\n            }else{\n                this.tv.play(\"节目二：法治在线\");\n            }\n        }\n    }\n}\n// 消费者 --> 观众\nclass Watcher extends Thread{\n    TV tv;\n    public Watcher(TV tv){\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 20; i++) {\n            tv.watch();\n        }\n    }\n}\n\n// 产品 --> 节目\nclass TV{\n    // 演员表演，观众等待 T\n    // 观众观看，演员等待 F\n    String voice; // 表演的节目\n    boolean flag = true;\n    // 表演\n    public synchronized void play(String voice){\n\n        if (!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println(\"演员表演了:\" + voice);\n        // 通知观众观看\n        this.notifyAll(); // 通知唤醒\n        this.voice = voice;\n        this.flag = !this.flag;\n    }\n    // 观看\n    public synchronized void watch(){\n        if (flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"观看了：\" + voice);\n        // 通知演员表演\n        this.notifyAll();\n        this.flag = !this.flag;\n    }\n}\n\n```\n\n## 线程池\n\n背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n\n思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的交通工具。\n\n好处：\n\n    1. 提高响应速度（减少创建新线程的时间）\n\n2. 降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 3. 便于线程管理 1. corePoolSize：最大线程数； 2. maxmumPoolSize：最大线程数； 3. keepAliveTime：线程没有任务时最多保持多长时间后会终止；\n\n## 使用线程池\n\n1. jdk5.0 线程池相关 API ：ExecutorService 和 Executors；\n2. ExecutorService ：真正的线程池接口。常见子类 ThreadPoolExecutor；\n   1. void execute(Runnable command) : 执行任务/命令，没有返回值，一般用来执行 Runnable；\n   2. <T>Future<T> submit(Callable<T> task): 执行任务，有返回值，一般用来执行 Callable；\n   3. void shutdown(): 关闭连接池；\n3. Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池；\n\n```java\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool {\n    public static void main(String[] args) {\n        // 1. 创建服务，创建线程池\n        // newFixedThreadPool 参数为线程池大小\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        // 2. 关闭连接\n        service.shutdown();\n    }\n}\n\nclass   MyThread implements Runnable{\n\n    @Override\n    public void run() {\n            System.out.println(Thread.currentThread().getName());\n    }\n}\n```\n\n## 总结\n\n```java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class summary {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        new MyThread1().start();\n\n        new Thread(new MyThread2()).start();\n\n        FutureTask<Integer> futureTask = new FutureTask<Integer>(new MyThread3());\n        new Thread(futureTask).start();\n        Integer integer = futureTask.get();\n        System.out.println(integer);\n    }\n}\n\n// 1. 继承Thread类\nclass MyThread1 extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"My Thread1\");\n    }\n}\n// 2. 实现Runnable接口\nclass MyThread2 implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(\"My Thread2\");\n    }\n}\n// 3. 实现Callable接口\nclass MyThread3 implements Callable<Integer>{\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(\"My Thread3\");\n        return 100;\n    }\n}\n\n```\n","slug":"JAVA-线程-20210418","published":1,"updated":"2022-06-14T04:09:00.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1h001cy4w17itvevnj","content":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><span id=\"more\"></span>\n\n<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p>Thread、Runnable、Callable</p>\n<p><strong>继承 Thread 类</strong>和 <strong>实现 Runnable 接口</strong> 为重点，实现 Callable 接口仅作了解</p>\n<h2 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h2><ol>\n<li>自定义线程类继承 Thread 类</li>\n<li>重写 run()方法，编写线程执行体</li>\n<li>创建线程对象，调用 start()方法启动线程</li>\n</ol>\n<pre><code class=\"java\">// 创建线程的方式：继承Thread类 、重写run（）方法、 调用start开启线程\n\n// 总结：线程开启不一定立即执行，由cpu进行调度执行\n\npublic class TestThread01 extends Thread &#123;\n    @Override\n    public void run() &#123;\n        // run方法线程体\n        for (int i = 0; i &lt; 200; i++) &#123;\n            System.out.println(&quot;正在执行线程----&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // main主线程\n        // 创建一个线程对象\n        TestThread01 testThread01 = new TestThread01();\n        //调用start（）方法开启线程\n        testThread01.start();\n\n        for (int i = 0; i &lt; 2000; i++) &#123;\n            System.out.println(&quot;正在执行主方法******&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"实现多线程同步下载图片-commons-io\"><a href=\"#实现多线程同步下载图片-commons-io\" class=\"headerlink\" title=\"实现多线程同步下载图片(commons-io)\"></a>实现多线程同步下载图片(commons-io)</h3><pre><code class=\"java\">/**\n * 实现多线程同步下载图片\n */\npublic class TestThread2 extends Thread &#123;\n    private String url;\n    private String name;\n\n    public TestThread2(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n    @Override\n    public void run() &#123;\n        WebDownLoader webDownLoader = new WebDownLoader();\n        webDownLoader.downloader(url,name);\n        System.out.println(&quot;下载文件名为:&quot; + name);\n\n    &#125;\n    public static void main(String[] args) &#123;\n        TestThread2 t1 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestThread2 t2 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestThread2 t3 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n        t1.start();\n        t2.start();\n        t3.start();\n    &#125;\n&#125;\n\n//下载器\nclass WebDownLoader &#123;\n    //下载方法\n    public void downloader(String url, String name) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;io异常，downloader方法出现问题&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"实现-Runable-接口\"><a href=\"#实现-Runable-接口\" class=\"headerlink\" title=\"实现 Runable 接口\"></a>实现 Runable 接口</h2><ol>\n<li>定义 MyRunnable 类实现 Runnable 接口</li>\n<li>实现 run()方法，编写线程执行体</li>\n<li>创建线程对象，调用 start()方法启动线程</li>\n</ol>\n<pre><code class=\"java\">public class TestRunable01 implements Runnable &#123;\n    //run方法线程体\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 200; i++) &#123;\n            System.out.println(&quot;我在看代码--&quot; + i);\n        &#125;\n    &#125;\n\n    //执行下面代码\n    public static void main(String[] args) &#123;\n        //main线程，主线程\n        //创建一个Runable接口的实现对象\n        TestRunable01 testRunable01 = new TestRunable01();\n\n        //创建线程对象，通过线程对象来开启线程，这种方式叫做代理\n        new Thread(testRunable01).start();\n\n        for (int i = 0; i &lt; 20000; i++) &#123;\n            System.out.println(&quot;我在学习多线程--&quot;  + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Runable-实现多线程同步下载图片-commons-io\"><a href=\"#Runable-实现多线程同步下载图片-commons-io\" class=\"headerlink\" title=\"Runable-实现多线程同步下载图片(commons-io)\"></a>Runable-实现多线程同步下载图片(commons-io)</h3><pre><code class=\"java\">package com.thread.demo01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 实现多线程同步下载图片\n */\npublic class TestRunable02 extends Thread &#123;\n    private String url;\n    private String name;\n\n    public TestRunable02(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        WebDownLoader2 webDownLoader = new WebDownLoader2();\n        webDownLoader.downloader(url,name);\n        System.out.println(&quot;下载文件名为:&quot; + name);\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestThread2 t1 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestThread2 t2 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestThread2 t3 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    &#125;\n\n&#125;\n\n//下载器\nclass WebDownLoader2 &#123;\n    //下载方法\n    public void downloader(String url, String name) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;io异常，downloader方法出现问题&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Thread-与-Runable-比较\"><a href=\"#Thread-与-Runable-比较\" class=\"headerlink\" title=\"Thread 与 Runable 比较\"></a>Thread 与 Runable 比较</h2><table>\n<thead>\n<tr>\n<th align=\"center\">继承 Thread 类</th>\n<th align=\"center\">实现 Runnable 接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">子类继承 Thread 类具备多线程能力</td>\n<td align=\"center\">实现接口 Runnable 具有多线程能力</td>\n</tr>\n<tr>\n<td align=\"center\">启动线程：子类对象.start();</td>\n<td align=\"center\">启动线程：传入目标对象+Thread 对象.start();</td>\n</tr>\n<tr>\n<td align=\"center\">不建议使用：避免 OOP 单继承局限性</td>\n<td align=\"center\">推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</td>\n</tr>\n</tbody></table>\n<h2 id=\"买火车票的例子\"><a href=\"#买火车票的例子\" class=\"headerlink\" title=\"买火车票的例子\"></a>买火车票的例子</h2><p>存在并发问题，会出现多个不同用户抢到同一张票的问题；</p>\n<pre><code class=\"java\">package com.thread.demo01;\n\n/**\n * 多个县城同时操作一个对象\n * 买火车票的例子\n */\npublic class TestThread03 implements Runnable &#123;\n    //票数\n    private static int ticketNum = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNum&lt;=0)&#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestThread03 ticket = new TestThread03();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">小明------拿到了第10张票------\n阿黄------拿到了第9张票------\n小二------拿到了第8张票------\n小明------拿到了第7张票------\n小二------拿到了第7张票------\n阿黄------拿到了第7张票------\n阿黄------拿到了第6张票------\n小二------拿到了第6张票------\n小明------拿到了第5张票------\n小明------拿到了第3张票------\n小二------拿到了第4张票------\n阿黄------拿到了第4张票------\n阿黄------拿到了第2张票------\n小二------拿到了第2张票------\n小明------拿到了第2张票------\n阿黄------拿到了第0张票------\n小二------拿到了第-1张票------\n小明------拿到了第1张票------\n</code></pre>\n<h2 id=\"模拟龟兔赛跑\"><a href=\"#模拟龟兔赛跑\" class=\"headerlink\" title=\"模拟龟兔赛跑\"></a>模拟龟兔赛跑</h2><pre><code class=\"java\">/**\n * 模拟龟兔赛跑\n */\npublic class Race implements Runnable &#123;\n    private static String winner;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt;= 100; i++) &#123;\n\n            // 模拟兔子休息\n            if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i%10 == 0)&#123;\n                try &#123;\n                    Thread.sleep(1);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n            //判断比赛是否结束\n            boolean flag = gameOver(i);\n            //出现winner，跳出\n            if (flag) &#123;\n                break;\n            &#125;\n\n            System.out.println(Thread.currentThread().getName() + &quot;--&gt;跑了&quot; + i + &quot;米&quot;);\n        &#125;\n    &#125;\n\n    //判断是否完成比赛\n    public boolean gameOver(int steps) &#123;\n        if (winner != null) &#123;//已经存在\n            return true;\n        &#125;else &#123;\n            if (steps == 100) &#123;\n                winner = Thread.currentThread().getName();\n                System.out.println(&quot;winner is&quot; + winner);\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Race race = new Race();\n\n        new Thread(race, &quot;兔子&quot;).start();\n        new Thread(race, &quot;乌龟&quot;).start();\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"实现-Callable-接口（仅了解）-扩充\"><a href=\"#实现-Callable-接口（仅了解）-扩充\" class=\"headerlink\" title=\"实现 Callable 接口（仅了解） 扩充\"></a>实现 Callable 接口（仅了解） 扩充</h2><ol>\n<li>实现 Callable 接口，需要返回值类型</li>\n<li>重写 call 方法，需要抛出异常</li>\n<li>创建目标对象</li>\n<li>（1）创建执行服务 <code>ExecutorService ser=Executors.newFixedThreadPool(3);</code> //线程池，并发数</li>\n<li>（2）提交执行 <code>Future&lt;Boolean&gt; result = ser.submit(t1);</code></li>\n<li>（3）获取结果 <code>boolean r1 = result.get();</code></li>\n<li>（4）关闭服务 <code>ser.shutdownNow();</code></li>\n</ol>\n<p>示例代码如下：</p>\n<pre><code class=\"java\">import java.util.concurrent.*;\n\npublic class TestCallable implements Callable &#123;\n    private String url;\n    private String name;\n\n    public TestCallable(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n\n    @Override\n    public Object call() throws Exception &#123;\n        WebDownLoader wd = new WebDownLoader();\n        wd.downloader(url,name);\n        System.out.println(&quot;下载文件，名为---&quot; + name);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        TestCallable t1 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestCallable t2 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestCallable t3 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n\n        //1.创建执行服务\n        ExecutorService serv = Executors.newFixedThreadPool(3); //线程池，并发数\n\n        //2.提交执行\n        Future&lt;Boolean&gt; r1 = serv.submit(t1);\n        Future&lt;Boolean&gt; r2 = serv.submit(t2);\n        Future&lt;Boolean&gt; r3 = serv.submit(t3);\n        //3.获取结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //4.关闭服务\n        serv.shutdownNow();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"静态代理–个人结婚与婚庆公司的例子\"><a href=\"#静态代理–个人结婚与婚庆公司的例子\" class=\"headerlink\" title=\"静态代理–个人结婚与婚庆公司的例子\"></a>静态代理–个人结婚与婚庆公司的例子</h2><pre><code class=\"java\">package com.thread.demo01;\n// 静态代理模式：\n// 真实对象和代理对象都要实现同一个接口\n// 代理对象要代理真实角色\n\n// 好处 ：\n// 1. 代理对象可以做很多真实对象做不了的事情\n// 2. 真实对象专注做自己的事情\n\npublic class StaticProxy &#123;\n\n    public static void main(String[] args) &#123;\n\n        You you = new You(); // 真实对象\n        new Thread(() -&gt; System.out.println(&quot;i love you&quot;)).start(); // lambda表达式\n\n//        //传统调用方式\n//        You you = new You();\n//        you.HappyMarry();\n\n        new WeddingCompany(new You()).HappyMarry();\n        //代理调用\n//        WeddingCompany weddingCompany = new WeddingCompany(new You());\n//        weddingCompany.HappyMarry();\n\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void HappyMarry();\n&#125;\n\n\n//真实角色，你去结婚\nclass You implements Marry &#123;\n    @Override\n    public void HappyMarry() &#123;\n        System.out.println(&quot;结婚，超开心(^_^)&quot;); //no-qinjiang\n    &#125;\n&#125;\n\n//代理角色，帮助你结婚, 起到帮助作用\nclass WeddingCompany implements Marry &#123;\n    //代理谁 --&gt; 真实目标角色\n    private Marry target;\n    public WeddingCompany(Marry target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public void HappyMarry() &#123;\n        before();\n        this.target.HappyMarry();\n        after();\n    &#125;\n\n    private void before() &#123;\n        System.out.println(&quot;布置婚礼现场&quot;);\n    &#125;\n\n    private void after() &#123;\n        System.out.println(&quot;还债结尾款&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>为什么要使用 lambda 表达式</p>\n<ol>\n<li><p>避免匿名内部类定义过多</p>\n</li>\n<li><p>可以让代码看起来更简洁</p>\n</li>\n<li><p>去掉无意义代码，留下核心逻辑</p>\n<p>注：只有一行代码的情况下才能简化成一行；前提是接口为函数式接口</p>\n</li>\n</ol>\n<p>理解函数式接口（Functional Interface）是学习 java8 lambda 表达式的关键所在</p>\n<p>函数式接口的定义：</p>\n<p>任何接口，如果只包含一个抽象方法，那么他就是一个函数式接口。</p>\n<p>eg:</p>\n<pre><code class=\"java\">public interface Runable &#123;\n    public abstract void run();\n&#125;\n</code></pre>\n<p>对于函数式接口，我们可以通过 Lambda 表达式来创建该接口的对象。</p>\n<p>简化至 lambda 的步骤如下：</p>\n<pre><code class=\"java\">//外部类，接口\npublic class TestLove &#123;\n    public static void main(String[] args) &#123;\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n\nclass Love implements ILove &#123;\n    @Override\n    public void love(String a) &#123;\n        System.out.println(&quot;I love --&quot; + a);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//静态内部类\n\npublic class TestLove &#123;\n    static class Love implements ILove &#123;\n        @Override\n        public void love(String a) &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n\n</code></pre>\n<pre><code class=\"java\">public class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n        class Love implements ILove &#123;\n            @Override\n            public void love(String a) &#123;\n                System.out.println(&quot;I love --&quot; + a);\n            &#125;\n        &#125;\n\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//匿名内部类\n\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove iLove = new ILove() &#123;\n            @Override\n            public void love(String a) &#123;\n                System.out.println(&quot;I love --&quot; + a);\n            &#125;\n        &#125;;\n        iLove.love(&quot;zzz&quot;);\n    &#125;\n&#125;\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//lambda表达式\nublic class TestLove &#123;\n    public static void main(String[] args) &#123;\n\n        ILove love = (String a)-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化，去掉参数类型\n\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = (a)-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化括号\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = a-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化花括号，因为代码只有一行，有多行不可简化花括号\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = a-&gt; System.out.println(&quot;I love --&quot; + a);\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>lambda 表达式代码只有一行的情况下才能简化为一行，有多行时必须用花括号包裹；</li>\n<li>前提示接口为函数式接口（只包含一个方法）；</li>\n<li>多个参数也可以去掉参数类型，留就都留，去就都去，必须加上括号；</li>\n</ol>\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p><img src=\"img/article/JAVA-%E7%BA%BF%E7%A8%8B-20210418/image-20210411183018803.png\" alt=\"image-20210411183018803\"></p>\n<p><strong>线程的方法</strong></p>\n<p><img src=\"img/article/JAVA-%E7%BA%BF%E7%A8%8B-20210418/image-20210411183039107.png\" alt=\"image-20210411183039107\"></p>\n<h3 id=\"停止线程\"><a href=\"#停止线程\" class=\"headerlink\" title=\"停止线程\"></a>停止线程</h3><ol>\n<li>不推荐使用 JDK 提供的<code>stop(); destroy();</code>方法；</li>\n<li>推荐线程自己停止；</li>\n<li>建议使用一个标志位进行终止变量；</li>\n</ol>\n<pre><code class=\"java\">/**\n * 测试stop\n * 1. 建议线程正常停止---&gt;利用次数；不建议死循环\n * 2. 建议使用标志位---&gt;设置一个标志位\n * 3. 不要使用stop或者destory等过时或JDK不建议使用的方法\n */\npublic class TestStop implements Runnable &#123;\n    //1. 设置一个标志位\n    private boolean flag = true;\n\n    @Override\n    public void run() &#123;\n        int i = 0;\n        while (flag) &#123;\n            System.out.println(&quot;run thread ----&quot; + i++);\n        &#125;\n    &#125;\n\n    //设置一个公开的方法停止线程，转换标志位\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestStop testStop = new TestStop();\n        new Thread(testStop).start();\n\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            System.out.println(&quot;main&quot; + i);\n            if (i==900) &#123;\n                //调用stop方法切换标志为\n                testStop.stop();\n                System.out.println(&quot;该线程停止了&quot;);\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程休眠\"><a href=\"#线程休眠\" class=\"headerlink\" title=\"线程休眠\"></a>线程休眠</h3><ol>\n<li>sleep(时间) 指定当前线程阻塞的毫秒数；</li>\n<li>sleep 存在异常 InterruptException；</li>\n<li>sleep 时间达到后线程进入就绪状态；</li>\n<li>sleep 可以模拟网络延时，倒计时等；</li>\n<li>每一个对象都有一个锁，sleep 不会释放锁；</li>\n</ol>\n<pre><code class=\"java\">//模拟倒计时 10s\npublic class TestSleep2 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        tenDown();\n    &#125;\n\n    public static void tenDown() throws InterruptedException &#123;\n        int num = 10;\n        while (true) &#123;\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if (num &lt;= 0) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//获取当前系统时间\npublic class TestSleep2 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date startTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            Thread.sleep(1000);\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\n            startTime = new Date(System.currentTimeMillis());\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程礼让\"><a href=\"#线程礼让\" class=\"headerlink\" title=\"线程礼让\"></a>线程礼让</h3><ol>\n<li>礼让线程，让当前正在执行的线程暂停，但不阻塞；</li>\n<li>将线程从运行状态转为就绪状态；</li>\n<li><strong>让 cpu 重新调度，礼让不一定成功！看 CPU 心情；</strong></li>\n</ol>\n<pre><code class=\"java\">/**\n * 测试礼让程序\n * 礼让不一定成功，看CPU心情\n */\npublic class TestYield implements Runnable &#123;\n    public static void main(String[] args) &#123;\n        TestYield testYield =  new TestYield();\n\n        new Thread(testYield, &quot;a&quot;).start();\n        new Thread(testYield, &quot;b&quot;).start();\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n&#125;\n\n//每次结果 都！不！一！样！ ？？？？？？？？？  -_-|||\n</code></pre>\n<h3 id=\"合并线程\"><a href=\"#合并线程\" class=\"headerlink\" title=\"合并线程\"></a>合并线程</h3><ol>\n<li>join 合并线程，待此线程执行完成后再执行其他线程，其他线程阻塞；</li>\n<li>可以想象成插队；</li>\n<li>join 前是交替执行；并不是不执行！！！</li>\n</ol>\n<pre><code class=\"java\">public class TestJoin implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(&quot;★ VIP Thread ☆&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin = new TestJoin();\n        Thread thread = new Thread(testJoin);\n        thread.start();\n\n        // 主线程\n        for (int i = 0; i &lt; 500; i++) &#123;\n            if(i == 200)&#123;\n                thread.join(); // 插队\n            &#125;\n            System.out.println(&quot;main&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程状态观测\"><a href=\"#线程状态观测\" class=\"headerlink\" title=\"线程状态观测\"></a>线程状态观测</h3><p><strong>Thread.state</strong></p>\n<pre><code class=\"java\">/**\n * 观察测试线程的状态\n */\npublic class TestState &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new Thread(() -&gt; &#123;\n                for (int i = 0; i &lt; 5; i++) &#123;\n            try &#123;\n                Thread.sleep(1000);\n            &#125;catch (Exception e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        &#125;);\n\n        System.out.println(&quot;---------------&quot;);\n\n        //观察状态\n        Thread.State state = thread.getState();\n        System.out.println(state); //NEW\n\n        //观察启动后\n        thread.start();\n        state = thread.getState();\n        System.out.println(state); //RUN\n\n        while (state != Thread.State.TERMINATED) &#123; //只要线程不终止，就一直输出状态\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            state = thread.getState();  //更新线程状态\n            System.out.println(state);\n        &#125;\n\n        thread.start();  //死亡的线程不能再启动，必须再new一个\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"多线程优先级\"><a href=\"#多线程优先级\" class=\"headerlink\" title=\"多线程优先级\"></a>多线程优先级</h3><ol>\n<li>java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，调度器按照优先级决定应该调度哪个线程来执行；</li>\n<li>线程的优先级用数字表示，范围从 1~10 ；<ol>\n<li><code>Thread.MAX_PRIORITY = 10;</code></li>\n<li><code>Thread.MIN_PRIORITY = 1;</code></li>\n<li><code>Thread.NORM_PRIORITY = 5;</code></li>\n</ol>\n</li>\n<li>使用以下方式改变或获取优先级 <code>getPriority().setPriority(int xxx);</code></li>\n</ol>\n<p>优先级低只是意味着获得调度的概率低，并不是高优先级必然先调用 （性能倒置问题）；</p>\n<pre><code class=\"java\">public class TestPriority &#123;\n    public static void main(String[] args) &#123;\n        //主线程默认优先级\n        System.out.println(Thread.currentThread().getName() + &quot;---main----&gt;&quot; + Thread.currentThread().getPriority());\n        MyPriority myPriority = new MyPriority();\n        Thread t1 = new Thread(myPriority);\n        Thread t2 = new Thread(myPriority);\n        Thread t3 = new Thread(myPriority);\n        Thread t4 = new Thread(myPriority);\n        Thread t5 = new Thread(myPriority);\n        Thread t6 = new Thread(myPriority);\n\n        t1.start();\n\n        t2.setPriority(1);\n        t2.start();\n\n        t3.setPriority(4);\n        t3.start();\n\n        t4.setPriority(Thread.MAX_PRIORITY);  //MAX_PRIORITY=10\n        t4.start();\n\n        t5.setPriority(Thread.MIN_PRIORITY); // min 为最小 1\n        t5.start();\n    &#125;\n&#125;\n\nclass MyPriority implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;---MyPriority----&gt;&quot; + Thread.currentThread().getPriority());\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"守护（daemon）线程\"><a href=\"#守护（daemon）线程\" class=\"headerlink\" title=\"守护（daemon）线程\"></a>守护（daemon）线程</h3><ol>\n<li>线程分为用户线程和守护线程；</li>\n<li>虚拟机必须确保用户线程执行完毕；</li>\n<li>虚拟机不用等待守护线程执行完毕；</li>\n<li>如，后台记录操作日志，监控内存，垃圾回收等待；</li>\n</ol>\n<pre><code class=\"java\">//测试守护线程\npublic class TestDaemon &#123;\n    public static void main(String[] args) &#123;\n        God god = new God();\n        Human human = new Human();\n\n        Thread thread = new Thread(god);\n        thread.setDaemon(true);  //默认是false表示用户线程，正常的线程都是用户线程\n\n        thread.start();  // 用户线程启动\n        new Thread(human).start();  //人类，用户线程启动\n\n    &#125;\n\n&#125;\n\n// 上帝\nclass God implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        while(true)&#123; // 按理来说不会结束 但作为守护线程在用户线程结束后 随之结束（可能会伴随虚拟机关闭的一点点延迟）\n            System.out.println(&quot;legends never die！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n// 人类\nclass Human implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 365; i++) &#123;\n            System.out.println(&quot;happy live！&quot;);\n        &#125;\n        System.out.println(&quot;Byebye, the worllllllllld!&quot;);  //nope!!!!!!!!!!\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h2><p>并发：同一个对象被多个线程同时操作；</p>\n<p>处理多线程问题时，多线程访问一个对象，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的<strong>等待池</strong>形成队列，等待前面线程使用完毕再让下一个线程使用</p>\n<h3 id=\"三个不安全案例\"><a href=\"#三个不安全案例\" class=\"headerlink\" title=\"三个不安全案例\"></a>三个不安全案例</h3><h4 id=\"不安全买票\"><a href=\"#不安全买票\" class=\"headerlink\" title=\"不安全买票\"></a>不安全买票</h4><pre><code class=\"java\">//不安全买票\n// 线程不安全，有负数\npublic class UnsafeBuyTicket &#123;\n    public static void main(String[] args) &#123;\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, &quot;牡丹&quot;).start();\n        new Thread(station, &quot;井盖&quot;).start();\n        new Thread(station, &quot;肥鯮 &quot;).start();\n    &#125;\n&#125;\n\nclass BuyTicket implements Runnable&#123;\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() &#123;\n        // 买票\n        while(true)&#123;\n            try &#123;\n                buy();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n    private void buy() throws InterruptedException &#123;\n        // 判断是否有票\n        if(ticketNum &lt;= 0)&#123;\n            flag = false;\n            return;\n        &#125;\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + &quot;买到了&quot; + ticketNum--);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"不安全取钱\"><a href=\"#不安全取钱\" class=\"headerlink\" title=\"不安全取钱\"></a>不安全取钱</h4><pre><code class=\"java\">// 不安全取钱\n// 两个人去取钱\npublic class UnsafeBank &#123;\n    public static void main(String[] args) &#123;\n        // 账户\n        Account account = new Account(100, &quot;存款金额&quot;);\n        Drawing you = new Drawing(account, 50, &quot;你&quot;);\n        Drawing gf = new Drawing(account, 100, &quot;对方&quot;);\n        you.start();\n        gf.start();\n    &#125;\n&#125;\n\n// 账户\nclass Account&#123;\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) &#123;\n        this.money = money;\n        this.name = name;\n    &#125;\n&#125;\n// 银行 模拟取款\nclass Drawing extends Thread&#123;\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name)&#123;\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    &#125;\n\n    //取钱操作\n    @Override\n    public void run() &#123;\n        // 判断有没有钱\n        if(account.money - drawingMoney &lt; 0)&#123;\n            System.out.println(Thread.currentThread().getName() + &quot;钱不够，取不了咯！&quot;);\n            return;\n        &#125;\n\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + &quot;余额为：&quot; + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + &quot;手里的钱：&quot; + nowMoney);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"不安全集合\"><a href=\"#不安全集合\" class=\"headerlink\" title=\"不安全集合\"></a>不安全集合</h4><pre><code class=\"java\">public class UnSafeList &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            new Thread(() -&gt; &#123;\n                list.add(Thread.currentThread().getName());\n            &#125;).start();\n        &#125;\n        try &#123;\n            Thread.sleep(300);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(list.size());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"同步方法-synchronized\"><a href=\"#同步方法-synchronized\" class=\"headerlink\" title=\"同步方法 - synchronized\"></a>同步方法 - synchronized</h2><ol>\n<li><p>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 <em>synchronized</em> 关键字，它包括两种用法：<code>synchronized</code> 方法和 <code>synchronized</code> 块；</p>\n<p>同步方法 <code>public synchronized void method(int args)&#123; &#125;</code>；</p>\n</li>\n<li><p>synchronized 方法控制对“对象”的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行；</p>\n</li>\n</ol>\n<pre><code class=\"java\">//买票\npublic class UnsafeBuyTicket &#123;\n    public static void main(String[] args) &#123;\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, &quot;牡丹&quot;).start();\n        new Thread(station, &quot;井盖&quot;).start();\n        new Thread(station, &quot;肥鯮 &quot;).start();\n    &#125;\n&#125;\n\nclass BuyTicket implements Runnable&#123;\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() &#123;\n        // 买票\n        while(true)&#123;\n            try &#123;\n                buy();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n//synchronized\n    private synchronized void buy() throws InterruptedException &#123;\n        // 判断是否有票\n        if(ticketNum &lt;= 0)&#123;\n            flag = false;\n            return;\n        &#125;\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + &quot;买到了&quot; + ticketNum--);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>同步块</strong></p>\n<p>同步块：synchronized(Obj) {}</p>\n<p>Obj 称为同步监视器</p>\n<ol>\n<li>Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器；</li>\n<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this，就是这个对象本身，或者是 class【反射中讲解】</li>\n</ol>\n<p>同步监视器的执行过程：</p>\n<ol>\n<li>第一个线程访问，锁定同步监视器，执行其中代码；</li>\n<li>第二个线程访问，发现同步监视器被锁定，无法访问；</li>\n<li>第一个线程访问完毕，解锁同步监视器；</li>\n<li>第二个线程访问，发现同步监视器没有锁，然后锁定并反问；</li>\n</ol>\n<p><strong>synchronized () {}</strong></p>\n<pre><code class=\"java\">// 两个人去取钱\npublic class UnsafeBank &#123;\n    public static void main(String[] args) &#123;\n        // 账户\n        Account account = new Account(10000, &quot;存款金额&quot;);\n        Drawing you = new Drawing(account, 50, &quot;你&quot;);\n        Drawing gf = new Drawing(account, 100, &quot;对方&quot;);\n        you.start();\n        gf.start();\n    &#125;\n&#125;\n\n// 账户\nclass Account&#123;\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) &#123;\n        this.money = money;\n        this.name = name;\n    &#125;\n&#125;\n// 银行 模拟取款\nclass Drawing extends Thread &#123;\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name) &#123;\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    &#125;\n\n    //取钱操作\n    @Override\n    public void run() &#123;\n         //锁的对象必须是变化的量\n        synchronized (account) &#123;\n        // 判断有没有钱\n        if (account.money - drawingMoney &lt; 0) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;钱不够，取不了咯！&quot;);\n            return;\n        &#125;\n\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + &quot;余额为：&quot; + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + &quot;手里的钱：&quot; + nowMoney);\n    &#125;\n&#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class UnSafeList &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            new Thread(() -&gt; &#123;\n                synchronized (list) &#123;\n                    list.add(Thread.currentThread().getName());\n                &#125;&#125;).start();\n\n        &#125;\n        try &#123;\n            Thread.sleep(300);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(list.size());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"JUC-安全类型的集合-CopyOnWriteArrayList\"><a href=\"#JUC-安全类型的集合-CopyOnWriteArrayList\" class=\"headerlink\" title=\"JUC 安全类型的集合-CopyOnWriteArrayList\"></a>JUC 安全类型的集合-CopyOnWriteArrayList</h2><pre><code class=\"java\">public class TestJUC &#123;\n    public static void main(String[] args) &#123;\n        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            new Thread( () -&gt;&#123;\n                list.add(Thread.currentThread().getName());\n            &#125; ).start();\n\n            try &#123;\n                Thread.sleep(30);\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(list.size());\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>多个线程各自占用一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情况，某一个同步块同时拥有<strong>两个以上对象的锁</strong>时，就可能会发生”死锁“的问题。</p>\n<p>产生死锁的四个<strong>必要</strong>条件：</p>\n<ol>\n<li>互斥：一个资源每次只能被一个进程使用</li>\n<li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>\n<li>不剥夺：进程已获得的资源，在未用完之前，不能强行剥夺</li>\n<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系</li>\n</ol>\n<p>上面四者只要想办法打破其中任意一个或者多个就可以避免死锁发生。</p>\n<pre><code class=\"java\">// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(1, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n\n&#125;\n\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\n\nclass Makeup extends Thread&#123;\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n                synchronized (mirror)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                &#125;\n            &#125;\n\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n                synchronized (lipstick)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                &#125;\n            &#125;\n\n\n\n        &#125;\n    &#125;\n&#125;// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(0, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n&#125;\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\nclass Makeup extends Thread&#123;\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n                synchronized (mirror)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                &#125;\n            &#125;\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n                synchronized (lipstick)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n&#125;&#125;&#125;&#125;&#125;\n</code></pre>\n<pre><code class=\"java\">//代码块拿出来，不让互相抱死\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(1, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n\n&#125;\n\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\n\nclass Makeup extends Thread&#123;\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n            &#125;\n            synchronized (mirror)&#123;\n                // 获得镜子的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n            &#125;\n\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n\n            &#125;\n\n            synchronized (lipstick)&#123;\n                // 获得镜子的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Lock-锁-可重入锁\"><a href=\"#Lock-锁-可重入锁\" class=\"headerlink\" title=\"Lock 锁 - 可重入锁\"></a>Lock 锁 - 可重入锁</h2><pre><code class=\"java\">//不安全\npublic class TestLock &#123;\n    public static void main(String[] args) &#123;\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n\nclass TestLock2 implements Runnable &#123;\n    //票数\n    int ticketNum = 10;\n\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNum &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//加锁.sleep不会释放锁对象，所以sleep请加到lock前面。\npublic class TestLock &#123;\n    public static void main(String[] args) &#123;\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n\nclass TestLock2 implements Runnable &#123;\n    //票数\n    int ticketNum = 10;\n\n    //定义Lock锁\n    private final ReentrantLock lock = new ReentrantLock();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            try &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                lock.lock();\n                if (ticketNum &gt; 0) &#123;\n                    System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n                &#125;\n\n                else &#123;\n                    break;\n                &#125;\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">class A&#123;\n  private final ReentrantLock lock = new ReenTrantLock();\n  public void m()&#123;\n    lock.lock();\n    try&#123;\n      // 保证线程安全的代码\n    &#125;\n    finally&#123;\n            lock.unlock();\n      // 如果同步代码有异常，要将unlock()写入finally语句块\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"synchronized-与-lock-的对比\"><a href=\"#synchronized-与-lock-的对比\" class=\"headerlink\" title=\"synchronized 与 lock 的对比\"></a>synchronized 与 lock 的对比</h2><ol>\n<li>Lock 是显示锁，需要手动开启和关闭，synchronized 为隐式锁，出了作用域自动释放</li>\n<li>lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>\n<li>使用 lock 锁，jvm 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性</li>\n<li>优先使用顺序<ul>\n<li>Lock &gt; 同步代码块（已经进入方法体，分配了相应资源）&gt; 同步方法(在方法体之外)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程协作-生产者消费者问题\"><a href=\"#线程协作-生产者消费者问题\" class=\"headerlink\" title=\"线程协作 - 生产者消费者问题\"></a>线程协作 - 生产者消费者问题</h2><p>线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>\n<ol>\n<li>对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，有需要马上通知消费者消费</li>\n<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</li>\n<li>在生产者消费者问题中，仅有 synchronized 是不够的<ol>\n<li>synchronized 可组织并发更新同一个共享资源，实现了同步</li>\n<li>synchronized 不能用来实现不同线程之间的消息传递（通信）</li>\n</ol>\n</li>\n</ol>\n<p>Java 提供了几个方法解决线程之间的通信问题</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">wait()</td>\n<td align=\"left\">表示线程一直等待，直到其他线程通知，与 sleep（）不同，会释放锁</td>\n</tr>\n<tr>\n<td align=\"left\">wait(long timeout)</td>\n<td align=\"left\">指定等待的毫秒数</td>\n</tr>\n<tr>\n<td align=\"left\">notify()</td>\n<td align=\"left\">唤醒一个处于等待状态的线程</td>\n</tr>\n<tr>\n<td align=\"left\">notifyAll()</td>\n<td align=\"left\">唤醒同一个对象上所有调用 wait（）方法的线程，优先级别高的线程优先调度</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong> 均是 Object 类的方法，都只能在同步方法或者同步代码快中使用，否则会抛出异常 <code>IllegalMonitorStateException</code></p>\n<h3 id=\"管程法\"><a href=\"#管程法\" class=\"headerlink\" title=\"管程法\"></a>管程法</h3><ol>\n<li><p>生产者：负责生产数据的模块（可能是方法、对象、线程、进程）</p>\n</li>\n<li><p>消费者：负责处理数据的模块（可能是方法、对象、线程、进程）</p>\n</li>\n<li><p>缓冲区：消费者不能直接使用生产者的数据，利用中间“缓冲区”</p>\n<p>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p>\n</li>\n</ol>\n<pre><code class=\"java\">// 测试 生产者消费者模型 --&gt; 利用缓冲区解决：管程法\n// 有问题，会出现先消费后生产，要用队列实现\npublic class TestPC &#123;\n    public static void main(String[] args) &#123;\n        SynBuffer synBuffer = new SynBuffer();\n\n        new Producer(synBuffer).start();\n        new Consumer(synBuffer).start();\n    &#125;\n&#125;\n\n// 生产者\nclass Producer extends Thread&#123;\n    SynBuffer buffer;\n    public Producer(SynBuffer buffer)&#123;\n        this.buffer = buffer;\n    &#125;\n    // 生产\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;生产了&quot; + i +&quot;只鸡&quot;);\n            try &#123;\n                buffer.push(new Chicken(i));\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n// 消费者\nclass Consumer extends Thread&#123;\n    SynBuffer buffer;\n    public Consumer(SynBuffer buffer)&#123;\n        this.buffer = buffer;\n    &#125;\n\n    // 消费\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            try &#123;\n                System.out.println(&quot;消费了--&gt;&quot; + buffer.pop().id +&quot;只鸡&quot;);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n// 产品\nclass Chicken&#123;\n    int id; // 产品编号\n\n    public Chicken(int id) &#123;\n        this.id = id;\n    &#125;\n&#125;\n\n// 缓冲区\nclass SynBuffer&#123;\n\n    //容器大小\n    Chicken[] chickens = new Chicken[10];\n    // 容器计数器\n    int count = 0;\n\n    // 生产者放入产品\n    public synchronized void push(Chicken chicken) throws InterruptedException &#123;\n        // 如果容器满了，需要等待消费者消费\n        if(count == chickens.length)&#123;\n            // 通知消费者消费，生产等待\n            this.wait();\n        &#125;\n        // 如果没有满，需要丢入产品\n        chickens[count] = chicken;\n        count ++;\n        // 可以通知消费者消费了\n        this.notifyAll();\n    &#125;\n\n    // 消费者消费产品\n    public synchronized Chicken pop() throws InterruptedException &#123;\n        // 判断能否消费\n        if(count == 0)&#123;\n            /// 等待生产者生产，消费者等待\n            this.wait();\n        &#125;\n        // 如果可以消费\n        count --;\n        Chicken chicken = chickens[count];\n        // 吃完了，通知生产者生产\n        this.notifyAll();\n\n        return chicken;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"信号灯法\"><a href=\"#信号灯法\" class=\"headerlink\" title=\"信号灯法\"></a>信号灯法</h3><pre><code class=\"java\">public class TestPC2 &#123;\n    public static void main(String[] args) &#123;\n        TV tv = new TV();\n        new Player(tv).start();\n        new Watcher(tv).start();\n    &#125;\n&#125;\n\n// 生产者 --&gt; 演员\nclass Player extends Thread&#123;\n    TV tv;\n    public Player(TV tv)&#123;\n        this.tv = tv;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 20; i++) &#123;\n            if (i % 2 == 0)&#123;\n                this.tv.play(&quot;节目一：新闻联播&quot;);\n            &#125;else&#123;\n                this.tv.play(&quot;节目二：法治在线&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n// 消费者 --&gt; 观众\nclass Watcher extends Thread&#123;\n    TV tv;\n    public Watcher(TV tv)&#123;\n        this.tv = tv;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 20; i++) &#123;\n            tv.watch();\n        &#125;\n    &#125;\n&#125;\n\n// 产品 --&gt; 节目\nclass TV&#123;\n    // 演员表演，观众等待 T\n    // 观众观看，演员等待 F\n    String voice; // 表演的节目\n    boolean flag = true;\n    // 表演\n    public synchronized void play(String voice)&#123;\n\n        if (!flag)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        System.out.println(&quot;演员表演了:&quot; + voice);\n        // 通知观众观看\n        this.notifyAll(); // 通知唤醒\n        this.voice = voice;\n        this.flag = !this.flag;\n    &#125;\n    // 观看\n    public synchronized void watch()&#123;\n        if (flag)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        System.out.println(&quot;观看了：&quot; + voice);\n        // 通知演员表演\n        this.notifyAll();\n        this.flag = !this.flag;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p>\n<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的交通工具。</p>\n<p>好处：</p>\n<pre><code>1. 提高响应速度（减少创建新线程的时间）\n</code></pre>\n<ol start=\"2\">\n<li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 3. 便于线程管理 1. corePoolSize：最大线程数； 2. maxmumPoolSize：最大线程数； 3. keepAliveTime：线程没有任务时最多保持多长时间后会终止；</li>\n</ol>\n<h2 id=\"使用线程池\"><a href=\"#使用线程池\" class=\"headerlink\" title=\"使用线程池\"></a>使用线程池</h2><ol>\n<li>jdk5.0 线程池相关 API ：ExecutorService 和 Executors；</li>\n<li>ExecutorService ：真正的线程池接口。常见子类 ThreadPoolExecutor；<ol>\n<li>void execute(Runnable command) : 执行任务/命令，没有返回值，一般用来执行 Runnable；</li>\n<li><T>Future<T> submit(Callable<T> task): 执行任务，有返回值，一般用来执行 Callable；</li>\n<li>void shutdown(): 关闭连接池；</li>\n</ol>\n</li>\n<li>Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池；</li>\n</ol>\n<pre><code class=\"java\">import java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool &#123;\n    public static void main(String[] args) &#123;\n        // 1. 创建服务，创建线程池\n        // newFixedThreadPool 参数为线程池大小\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        // 2. 关闭连接\n        service.shutdown();\n    &#125;\n&#125;\n\nclass   MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n            System.out.println(Thread.currentThread().getName());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code class=\"java\">import java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class summary &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        new MyThread1().start();\n\n        new Thread(new MyThread2()).start();\n\n        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread3());\n        new Thread(futureTask).start();\n        Integer integer = futureTask.get();\n        System.out.println(integer);\n    &#125;\n&#125;\n\n// 1. 继承Thread类\nclass MyThread1 extends Thread&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;My Thread1&quot;);\n    &#125;\n&#125;\n// 2. 实现Runnable接口\nclass MyThread2 implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;My Thread2&quot;);\n    &#125;\n&#125;\n// 3. 实现Callable接口\nclass MyThread3 implements Callable&lt;Integer&gt;&#123;\n    @Override\n    public Integer call() throws Exception &#123;\n        System.out.println(&quot;My Thread3&quot;);\n        return 100;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1>","more":"<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p>Thread、Runnable、Callable</p>\n<p><strong>继承 Thread 类</strong>和 <strong>实现 Runnable 接口</strong> 为重点，实现 Callable 接口仅作了解</p>\n<h2 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h2><ol>\n<li>自定义线程类继承 Thread 类</li>\n<li>重写 run()方法，编写线程执行体</li>\n<li>创建线程对象，调用 start()方法启动线程</li>\n</ol>\n<pre><code class=\"java\">// 创建线程的方式：继承Thread类 、重写run（）方法、 调用start开启线程\n\n// 总结：线程开启不一定立即执行，由cpu进行调度执行\n\npublic class TestThread01 extends Thread &#123;\n    @Override\n    public void run() &#123;\n        // run方法线程体\n        for (int i = 0; i &lt; 200; i++) &#123;\n            System.out.println(&quot;正在执行线程----&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // main主线程\n        // 创建一个线程对象\n        TestThread01 testThread01 = new TestThread01();\n        //调用start（）方法开启线程\n        testThread01.start();\n\n        for (int i = 0; i &lt; 2000; i++) &#123;\n            System.out.println(&quot;正在执行主方法******&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"实现多线程同步下载图片-commons-io\"><a href=\"#实现多线程同步下载图片-commons-io\" class=\"headerlink\" title=\"实现多线程同步下载图片(commons-io)\"></a>实现多线程同步下载图片(commons-io)</h3><pre><code class=\"java\">/**\n * 实现多线程同步下载图片\n */\npublic class TestThread2 extends Thread &#123;\n    private String url;\n    private String name;\n\n    public TestThread2(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n    @Override\n    public void run() &#123;\n        WebDownLoader webDownLoader = new WebDownLoader();\n        webDownLoader.downloader(url,name);\n        System.out.println(&quot;下载文件名为:&quot; + name);\n\n    &#125;\n    public static void main(String[] args) &#123;\n        TestThread2 t1 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestThread2 t2 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestThread2 t3 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n        t1.start();\n        t2.start();\n        t3.start();\n    &#125;\n&#125;\n\n//下载器\nclass WebDownLoader &#123;\n    //下载方法\n    public void downloader(String url, String name) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;io异常，downloader方法出现问题&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"实现-Runable-接口\"><a href=\"#实现-Runable-接口\" class=\"headerlink\" title=\"实现 Runable 接口\"></a>实现 Runable 接口</h2><ol>\n<li>定义 MyRunnable 类实现 Runnable 接口</li>\n<li>实现 run()方法，编写线程执行体</li>\n<li>创建线程对象，调用 start()方法启动线程</li>\n</ol>\n<pre><code class=\"java\">public class TestRunable01 implements Runnable &#123;\n    //run方法线程体\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 200; i++) &#123;\n            System.out.println(&quot;我在看代码--&quot; + i);\n        &#125;\n    &#125;\n\n    //执行下面代码\n    public static void main(String[] args) &#123;\n        //main线程，主线程\n        //创建一个Runable接口的实现对象\n        TestRunable01 testRunable01 = new TestRunable01();\n\n        //创建线程对象，通过线程对象来开启线程，这种方式叫做代理\n        new Thread(testRunable01).start();\n\n        for (int i = 0; i &lt; 20000; i++) &#123;\n            System.out.println(&quot;我在学习多线程--&quot;  + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Runable-实现多线程同步下载图片-commons-io\"><a href=\"#Runable-实现多线程同步下载图片-commons-io\" class=\"headerlink\" title=\"Runable-实现多线程同步下载图片(commons-io)\"></a>Runable-实现多线程同步下载图片(commons-io)</h3><pre><code class=\"java\">package com.thread.demo01;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * 实现多线程同步下载图片\n */\npublic class TestRunable02 extends Thread &#123;\n    private String url;\n    private String name;\n\n    public TestRunable02(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        WebDownLoader2 webDownLoader = new WebDownLoader2();\n        webDownLoader.downloader(url,name);\n        System.out.println(&quot;下载文件名为:&quot; + name);\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestThread2 t1 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestThread2 t2 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestThread2 t3 = new TestThread2\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n    &#125;\n\n&#125;\n\n//下载器\nclass WebDownLoader2 &#123;\n    //下载方法\n    public void downloader(String url, String name) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;io异常，downloader方法出现问题&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Thread-与-Runable-比较\"><a href=\"#Thread-与-Runable-比较\" class=\"headerlink\" title=\"Thread 与 Runable 比较\"></a>Thread 与 Runable 比较</h2><table>\n<thead>\n<tr>\n<th align=\"center\">继承 Thread 类</th>\n<th align=\"center\">实现 Runnable 接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">子类继承 Thread 类具备多线程能力</td>\n<td align=\"center\">实现接口 Runnable 具有多线程能力</td>\n</tr>\n<tr>\n<td align=\"center\">启动线程：子类对象.start();</td>\n<td align=\"center\">启动线程：传入目标对象+Thread 对象.start();</td>\n</tr>\n<tr>\n<td align=\"center\">不建议使用：避免 OOP 单继承局限性</td>\n<td align=\"center\">推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</td>\n</tr>\n</tbody></table>\n<h2 id=\"买火车票的例子\"><a href=\"#买火车票的例子\" class=\"headerlink\" title=\"买火车票的例子\"></a>买火车票的例子</h2><p>存在并发问题，会出现多个不同用户抢到同一张票的问题；</p>\n<pre><code class=\"java\">package com.thread.demo01;\n\n/**\n * 多个县城同时操作一个对象\n * 买火车票的例子\n */\npublic class TestThread03 implements Runnable &#123;\n    //票数\n    private static int ticketNum = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNum&lt;=0)&#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestThread03 ticket = new TestThread03();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">小明------拿到了第10张票------\n阿黄------拿到了第9张票------\n小二------拿到了第8张票------\n小明------拿到了第7张票------\n小二------拿到了第7张票------\n阿黄------拿到了第7张票------\n阿黄------拿到了第6张票------\n小二------拿到了第6张票------\n小明------拿到了第5张票------\n小明------拿到了第3张票------\n小二------拿到了第4张票------\n阿黄------拿到了第4张票------\n阿黄------拿到了第2张票------\n小二------拿到了第2张票------\n小明------拿到了第2张票------\n阿黄------拿到了第0张票------\n小二------拿到了第-1张票------\n小明------拿到了第1张票------\n</code></pre>\n<h2 id=\"模拟龟兔赛跑\"><a href=\"#模拟龟兔赛跑\" class=\"headerlink\" title=\"模拟龟兔赛跑\"></a>模拟龟兔赛跑</h2><pre><code class=\"java\">/**\n * 模拟龟兔赛跑\n */\npublic class Race implements Runnable &#123;\n    private static String winner;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt;= 100; i++) &#123;\n\n            // 模拟兔子休息\n            if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i%10 == 0)&#123;\n                try &#123;\n                    Thread.sleep(1);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n            //判断比赛是否结束\n            boolean flag = gameOver(i);\n            //出现winner，跳出\n            if (flag) &#123;\n                break;\n            &#125;\n\n            System.out.println(Thread.currentThread().getName() + &quot;--&gt;跑了&quot; + i + &quot;米&quot;);\n        &#125;\n    &#125;\n\n    //判断是否完成比赛\n    public boolean gameOver(int steps) &#123;\n        if (winner != null) &#123;//已经存在\n            return true;\n        &#125;else &#123;\n            if (steps == 100) &#123;\n                winner = Thread.currentThread().getName();\n                System.out.println(&quot;winner is&quot; + winner);\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Race race = new Race();\n\n        new Thread(race, &quot;兔子&quot;).start();\n        new Thread(race, &quot;乌龟&quot;).start();\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"实现-Callable-接口（仅了解）-扩充\"><a href=\"#实现-Callable-接口（仅了解）-扩充\" class=\"headerlink\" title=\"实现 Callable 接口（仅了解） 扩充\"></a>实现 Callable 接口（仅了解） 扩充</h2><ol>\n<li>实现 Callable 接口，需要返回值类型</li>\n<li>重写 call 方法，需要抛出异常</li>\n<li>创建目标对象</li>\n<li>（1）创建执行服务 <code>ExecutorService ser=Executors.newFixedThreadPool(3);</code> //线程池，并发数</li>\n<li>（2）提交执行 <code>Future&lt;Boolean&gt; result = ser.submit(t1);</code></li>\n<li>（3）获取结果 <code>boolean r1 = result.get();</code></li>\n<li>（4）关闭服务 <code>ser.shutdownNow();</code></li>\n</ol>\n<p>示例代码如下：</p>\n<pre><code class=\"java\">import java.util.concurrent.*;\n\npublic class TestCallable implements Callable &#123;\n    private String url;\n    private String name;\n\n    public TestCallable(String url, String name) &#123;\n        this.url = url;\n        this.name = name;\n    &#125;\n\n    @Override\n    public Object call() throws Exception &#123;\n        WebDownLoader wd = new WebDownLoader();\n        wd.downloader(url,name);\n        System.out.println(&quot;下载文件，名为---&quot; + name);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        TestCallable t1 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t1.jpg&quot;);\n        TestCallable t2 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t2.jpg&quot;);\n        TestCallable t3 = new TestCallable\n                (&quot;https://pics2.baidu.com/feed/902397dda144ad348afc39466dd25efc30ad852d.jpeg?token=4f48564797f3e5ddda4bb40071f78be5&quot;, &quot;t3.jpg&quot;);\n\n        //1.创建执行服务\n        ExecutorService serv = Executors.newFixedThreadPool(3); //线程池，并发数\n\n        //2.提交执行\n        Future&lt;Boolean&gt; r1 = serv.submit(t1);\n        Future&lt;Boolean&gt; r2 = serv.submit(t2);\n        Future&lt;Boolean&gt; r3 = serv.submit(t3);\n        //3.获取结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n\n        System.out.println(rs1);\n        System.out.println(rs2);\n        System.out.println(rs3);\n\n        //4.关闭服务\n        serv.shutdownNow();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"静态代理–个人结婚与婚庆公司的例子\"><a href=\"#静态代理–个人结婚与婚庆公司的例子\" class=\"headerlink\" title=\"静态代理–个人结婚与婚庆公司的例子\"></a>静态代理–个人结婚与婚庆公司的例子</h2><pre><code class=\"java\">package com.thread.demo01;\n// 静态代理模式：\n// 真实对象和代理对象都要实现同一个接口\n// 代理对象要代理真实角色\n\n// 好处 ：\n// 1. 代理对象可以做很多真实对象做不了的事情\n// 2. 真实对象专注做自己的事情\n\npublic class StaticProxy &#123;\n\n    public static void main(String[] args) &#123;\n\n        You you = new You(); // 真实对象\n        new Thread(() -&gt; System.out.println(&quot;i love you&quot;)).start(); // lambda表达式\n\n//        //传统调用方式\n//        You you = new You();\n//        you.HappyMarry();\n\n        new WeddingCompany(new You()).HappyMarry();\n        //代理调用\n//        WeddingCompany weddingCompany = new WeddingCompany(new You());\n//        weddingCompany.HappyMarry();\n\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void HappyMarry();\n&#125;\n\n\n//真实角色，你去结婚\nclass You implements Marry &#123;\n    @Override\n    public void HappyMarry() &#123;\n        System.out.println(&quot;结婚，超开心(^_^)&quot;); //no-qinjiang\n    &#125;\n&#125;\n\n//代理角色，帮助你结婚, 起到帮助作用\nclass WeddingCompany implements Marry &#123;\n    //代理谁 --&gt; 真实目标角色\n    private Marry target;\n    public WeddingCompany(Marry target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public void HappyMarry() &#123;\n        before();\n        this.target.HappyMarry();\n        after();\n    &#125;\n\n    private void before() &#123;\n        System.out.println(&quot;布置婚礼现场&quot;);\n    &#125;\n\n    private void after() &#123;\n        System.out.println(&quot;还债结尾款&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>为什么要使用 lambda 表达式</p>\n<ol>\n<li><p>避免匿名内部类定义过多</p>\n</li>\n<li><p>可以让代码看起来更简洁</p>\n</li>\n<li><p>去掉无意义代码，留下核心逻辑</p>\n<p>注：只有一行代码的情况下才能简化成一行；前提是接口为函数式接口</p>\n</li>\n</ol>\n<p>理解函数式接口（Functional Interface）是学习 java8 lambda 表达式的关键所在</p>\n<p>函数式接口的定义：</p>\n<p>任何接口，如果只包含一个抽象方法，那么他就是一个函数式接口。</p>\n<p>eg:</p>\n<pre><code class=\"java\">public interface Runable &#123;\n    public abstract void run();\n&#125;\n</code></pre>\n<p>对于函数式接口，我们可以通过 Lambda 表达式来创建该接口的对象。</p>\n<p>简化至 lambda 的步骤如下：</p>\n<pre><code class=\"java\">//外部类，接口\npublic class TestLove &#123;\n    public static void main(String[] args) &#123;\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n\nclass Love implements ILove &#123;\n    @Override\n    public void love(String a) &#123;\n        System.out.println(&quot;I love --&quot; + a);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//静态内部类\n\npublic class TestLove &#123;\n    static class Love implements ILove &#123;\n        @Override\n        public void love(String a) &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n\n</code></pre>\n<pre><code class=\"java\">public class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n        class Love implements ILove &#123;\n            @Override\n            public void love(String a) &#123;\n                System.out.println(&quot;I love --&quot; + a);\n            &#125;\n        &#125;\n\n        ILove iLove = new Love();\n        iLove.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//匿名内部类\n\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove iLove = new ILove() &#123;\n            @Override\n            public void love(String a) &#123;\n                System.out.println(&quot;I love --&quot; + a);\n            &#125;\n        &#125;;\n        iLove.love(&quot;zzz&quot;);\n    &#125;\n&#125;\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//lambda表达式\nublic class TestLove &#123;\n    public static void main(String[] args) &#123;\n\n        ILove love = (String a)-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化，去掉参数类型\n\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = (a)-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化括号\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = a-&gt; &#123;\n            System.out.println(&quot;I love --&quot; + a);\n        &#125;;\n\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<pre><code class=\"java\">//简化花括号，因为代码只有一行，有多行不可简化花括号\npublic class TestLove &#123;\n\n    public static void main(String[] args) &#123;\n\n        ILove love = a-&gt; System.out.println(&quot;I love --&quot; + a);\n        love.love(&quot;zzz&quot;);\n\n    &#125;\n&#125;\n\ninterface ILove &#123; void love(String a);&#125;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>lambda 表达式代码只有一行的情况下才能简化为一行，有多行时必须用花括号包裹；</li>\n<li>前提示接口为函数式接口（只包含一个方法）；</li>\n<li>多个参数也可以去掉参数类型，留就都留，去就都去，必须加上括号；</li>\n</ol>\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p><img src=\"img/article/JAVA-%E7%BA%BF%E7%A8%8B-20210418/image-20210411183018803.png\" alt=\"image-20210411183018803\"></p>\n<p><strong>线程的方法</strong></p>\n<p><img src=\"img/article/JAVA-%E7%BA%BF%E7%A8%8B-20210418/image-20210411183039107.png\" alt=\"image-20210411183039107\"></p>\n<h3 id=\"停止线程\"><a href=\"#停止线程\" class=\"headerlink\" title=\"停止线程\"></a>停止线程</h3><ol>\n<li>不推荐使用 JDK 提供的<code>stop(); destroy();</code>方法；</li>\n<li>推荐线程自己停止；</li>\n<li>建议使用一个标志位进行终止变量；</li>\n</ol>\n<pre><code class=\"java\">/**\n * 测试stop\n * 1. 建议线程正常停止---&gt;利用次数；不建议死循环\n * 2. 建议使用标志位---&gt;设置一个标志位\n * 3. 不要使用stop或者destory等过时或JDK不建议使用的方法\n */\npublic class TestStop implements Runnable &#123;\n    //1. 设置一个标志位\n    private boolean flag = true;\n\n    @Override\n    public void run() &#123;\n        int i = 0;\n        while (flag) &#123;\n            System.out.println(&quot;run thread ----&quot; + i++);\n        &#125;\n    &#125;\n\n    //设置一个公开的方法停止线程，转换标志位\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TestStop testStop = new TestStop();\n        new Thread(testStop).start();\n\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            System.out.println(&quot;main&quot; + i);\n            if (i==900) &#123;\n                //调用stop方法切换标志为\n                testStop.stop();\n                System.out.println(&quot;该线程停止了&quot;);\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程休眠\"><a href=\"#线程休眠\" class=\"headerlink\" title=\"线程休眠\"></a>线程休眠</h3><ol>\n<li>sleep(时间) 指定当前线程阻塞的毫秒数；</li>\n<li>sleep 存在异常 InterruptException；</li>\n<li>sleep 时间达到后线程进入就绪状态；</li>\n<li>sleep 可以模拟网络延时，倒计时等；</li>\n<li>每一个对象都有一个锁，sleep 不会释放锁；</li>\n</ol>\n<pre><code class=\"java\">//模拟倒计时 10s\npublic class TestSleep2 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        tenDown();\n    &#125;\n\n    public static void tenDown() throws InterruptedException &#123;\n        int num = 10;\n        while (true) &#123;\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if (num &lt;= 0) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//获取当前系统时间\npublic class TestSleep2 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date startTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            Thread.sleep(1000);\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\n            startTime = new Date(System.currentTimeMillis());\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程礼让\"><a href=\"#线程礼让\" class=\"headerlink\" title=\"线程礼让\"></a>线程礼让</h3><ol>\n<li>礼让线程，让当前正在执行的线程暂停，但不阻塞；</li>\n<li>将线程从运行状态转为就绪状态；</li>\n<li><strong>让 cpu 重新调度，礼让不一定成功！看 CPU 心情；</strong></li>\n</ol>\n<pre><code class=\"java\">/**\n * 测试礼让程序\n * 礼让不一定成功，看CPU心情\n */\npublic class TestYield implements Runnable &#123;\n    public static void main(String[] args) &#123;\n        TestYield testYield =  new TestYield();\n\n        new Thread(testYield, &quot;a&quot;).start();\n        new Thread(testYield, &quot;b&quot;).start();\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n&#125;\n\n//每次结果 都！不！一！样！ ？？？？？？？？？  -_-|||\n</code></pre>\n<h3 id=\"合并线程\"><a href=\"#合并线程\" class=\"headerlink\" title=\"合并线程\"></a>合并线程</h3><ol>\n<li>join 合并线程，待此线程执行完成后再执行其他线程，其他线程阻塞；</li>\n<li>可以想象成插队；</li>\n<li>join 前是交替执行；并不是不执行！！！</li>\n</ol>\n<pre><code class=\"java\">public class TestJoin implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(&quot;★ VIP Thread ☆&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin = new TestJoin();\n        Thread thread = new Thread(testJoin);\n        thread.start();\n\n        // 主线程\n        for (int i = 0; i &lt; 500; i++) &#123;\n            if(i == 200)&#123;\n                thread.join(); // 插队\n            &#125;\n            System.out.println(&quot;main&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"线程状态观测\"><a href=\"#线程状态观测\" class=\"headerlink\" title=\"线程状态观测\"></a>线程状态观测</h3><p><strong>Thread.state</strong></p>\n<pre><code class=\"java\">/**\n * 观察测试线程的状态\n */\npublic class TestState &#123;\n    public static void main(String[] args) &#123;\n        Thread thread = new Thread(() -&gt; &#123;\n                for (int i = 0; i &lt; 5; i++) &#123;\n            try &#123;\n                Thread.sleep(1000);\n            &#125;catch (Exception e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        &#125;);\n\n        System.out.println(&quot;---------------&quot;);\n\n        //观察状态\n        Thread.State state = thread.getState();\n        System.out.println(state); //NEW\n\n        //观察启动后\n        thread.start();\n        state = thread.getState();\n        System.out.println(state); //RUN\n\n        while (state != Thread.State.TERMINATED) &#123; //只要线程不终止，就一直输出状态\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            state = thread.getState();  //更新线程状态\n            System.out.println(state);\n        &#125;\n\n        thread.start();  //死亡的线程不能再启动，必须再new一个\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"多线程优先级\"><a href=\"#多线程优先级\" class=\"headerlink\" title=\"多线程优先级\"></a>多线程优先级</h3><ol>\n<li>java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，调度器按照优先级决定应该调度哪个线程来执行；</li>\n<li>线程的优先级用数字表示，范围从 1~10 ；<ol>\n<li><code>Thread.MAX_PRIORITY = 10;</code></li>\n<li><code>Thread.MIN_PRIORITY = 1;</code></li>\n<li><code>Thread.NORM_PRIORITY = 5;</code></li>\n</ol>\n</li>\n<li>使用以下方式改变或获取优先级 <code>getPriority().setPriority(int xxx);</code></li>\n</ol>\n<p>优先级低只是意味着获得调度的概率低，并不是高优先级必然先调用 （性能倒置问题）；</p>\n<pre><code class=\"java\">public class TestPriority &#123;\n    public static void main(String[] args) &#123;\n        //主线程默认优先级\n        System.out.println(Thread.currentThread().getName() + &quot;---main----&gt;&quot; + Thread.currentThread().getPriority());\n        MyPriority myPriority = new MyPriority();\n        Thread t1 = new Thread(myPriority);\n        Thread t2 = new Thread(myPriority);\n        Thread t3 = new Thread(myPriority);\n        Thread t4 = new Thread(myPriority);\n        Thread t5 = new Thread(myPriority);\n        Thread t6 = new Thread(myPriority);\n\n        t1.start();\n\n        t2.setPriority(1);\n        t2.start();\n\n        t3.setPriority(4);\n        t3.start();\n\n        t4.setPriority(Thread.MAX_PRIORITY);  //MAX_PRIORITY=10\n        t4.start();\n\n        t5.setPriority(Thread.MIN_PRIORITY); // min 为最小 1\n        t5.start();\n    &#125;\n&#125;\n\nclass MyPriority implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;---MyPriority----&gt;&quot; + Thread.currentThread().getPriority());\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"守护（daemon）线程\"><a href=\"#守护（daemon）线程\" class=\"headerlink\" title=\"守护（daemon）线程\"></a>守护（daemon）线程</h3><ol>\n<li>线程分为用户线程和守护线程；</li>\n<li>虚拟机必须确保用户线程执行完毕；</li>\n<li>虚拟机不用等待守护线程执行完毕；</li>\n<li>如，后台记录操作日志，监控内存，垃圾回收等待；</li>\n</ol>\n<pre><code class=\"java\">//测试守护线程\npublic class TestDaemon &#123;\n    public static void main(String[] args) &#123;\n        God god = new God();\n        Human human = new Human();\n\n        Thread thread = new Thread(god);\n        thread.setDaemon(true);  //默认是false表示用户线程，正常的线程都是用户线程\n\n        thread.start();  // 用户线程启动\n        new Thread(human).start();  //人类，用户线程启动\n\n    &#125;\n\n&#125;\n\n// 上帝\nclass God implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        while(true)&#123; // 按理来说不会结束 但作为守护线程在用户线程结束后 随之结束（可能会伴随虚拟机关闭的一点点延迟）\n            System.out.println(&quot;legends never die！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n// 人类\nclass Human implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 365; i++) &#123;\n            System.out.println(&quot;happy live！&quot;);\n        &#125;\n        System.out.println(&quot;Byebye, the worllllllllld!&quot;);  //nope!!!!!!!!!!\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h2><p>并发：同一个对象被多个线程同时操作；</p>\n<p>处理多线程问题时，多线程访问一个对象，并且某些线程还想修改这个对象，这时候就需要线程同步。线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的<strong>等待池</strong>形成队列，等待前面线程使用完毕再让下一个线程使用</p>\n<h3 id=\"三个不安全案例\"><a href=\"#三个不安全案例\" class=\"headerlink\" title=\"三个不安全案例\"></a>三个不安全案例</h3><h4 id=\"不安全买票\"><a href=\"#不安全买票\" class=\"headerlink\" title=\"不安全买票\"></a>不安全买票</h4><pre><code class=\"java\">//不安全买票\n// 线程不安全，有负数\npublic class UnsafeBuyTicket &#123;\n    public static void main(String[] args) &#123;\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, &quot;牡丹&quot;).start();\n        new Thread(station, &quot;井盖&quot;).start();\n        new Thread(station, &quot;肥鯮 &quot;).start();\n    &#125;\n&#125;\n\nclass BuyTicket implements Runnable&#123;\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() &#123;\n        // 买票\n        while(true)&#123;\n            try &#123;\n                buy();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n    private void buy() throws InterruptedException &#123;\n        // 判断是否有票\n        if(ticketNum &lt;= 0)&#123;\n            flag = false;\n            return;\n        &#125;\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + &quot;买到了&quot; + ticketNum--);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"不安全取钱\"><a href=\"#不安全取钱\" class=\"headerlink\" title=\"不安全取钱\"></a>不安全取钱</h4><pre><code class=\"java\">// 不安全取钱\n// 两个人去取钱\npublic class UnsafeBank &#123;\n    public static void main(String[] args) &#123;\n        // 账户\n        Account account = new Account(100, &quot;存款金额&quot;);\n        Drawing you = new Drawing(account, 50, &quot;你&quot;);\n        Drawing gf = new Drawing(account, 100, &quot;对方&quot;);\n        you.start();\n        gf.start();\n    &#125;\n&#125;\n\n// 账户\nclass Account&#123;\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) &#123;\n        this.money = money;\n        this.name = name;\n    &#125;\n&#125;\n// 银行 模拟取款\nclass Drawing extends Thread&#123;\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name)&#123;\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    &#125;\n\n    //取钱操作\n    @Override\n    public void run() &#123;\n        // 判断有没有钱\n        if(account.money - drawingMoney &lt; 0)&#123;\n            System.out.println(Thread.currentThread().getName() + &quot;钱不够，取不了咯！&quot;);\n            return;\n        &#125;\n\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + &quot;余额为：&quot; + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + &quot;手里的钱：&quot; + nowMoney);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"不安全集合\"><a href=\"#不安全集合\" class=\"headerlink\" title=\"不安全集合\"></a>不安全集合</h4><pre><code class=\"java\">public class UnSafeList &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            new Thread(() -&gt; &#123;\n                list.add(Thread.currentThread().getName());\n            &#125;).start();\n        &#125;\n        try &#123;\n            Thread.sleep(300);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(list.size());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"同步方法-synchronized\"><a href=\"#同步方法-synchronized\" class=\"headerlink\" title=\"同步方法 - synchronized\"></a>同步方法 - synchronized</h2><ol>\n<li><p>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 <em>synchronized</em> 关键字，它包括两种用法：<code>synchronized</code> 方法和 <code>synchronized</code> 块；</p>\n<p>同步方法 <code>public synchronized void method(int args)&#123; &#125;</code>；</p>\n</li>\n<li><p>synchronized 方法控制对“对象”的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行；</p>\n</li>\n</ol>\n<pre><code class=\"java\">//买票\npublic class UnsafeBuyTicket &#123;\n    public static void main(String[] args) &#123;\n        BuyTicket station = new BuyTicket();\n\n        new Thread(station, &quot;牡丹&quot;).start();\n        new Thread(station, &quot;井盖&quot;).start();\n        new Thread(station, &quot;肥鯮 &quot;).start();\n    &#125;\n&#125;\n\nclass BuyTicket implements Runnable&#123;\n    // 票\n    private int ticketNum = 10;\n    boolean flag = true; // 外部停止方式\n    @Override\n    public void run() &#123;\n        // 买票\n        while(true)&#123;\n            try &#123;\n                buy();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n//synchronized\n    private synchronized void buy() throws InterruptedException &#123;\n        // 判断是否有票\n        if(ticketNum &lt;= 0)&#123;\n            flag = false;\n            return;\n        &#125;\n\n        //模拟延时\n        Thread.sleep(100);\n\n        // 买票\n        System.out.println(Thread.currentThread().getName() + &quot;买到了&quot; + ticketNum--);\n    &#125;\n&#125;\n</code></pre>\n<p><strong>同步块</strong></p>\n<p>同步块：synchronized(Obj) {}</p>\n<p>Obj 称为同步监视器</p>\n<ol>\n<li>Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器；</li>\n<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this，就是这个对象本身，或者是 class【反射中讲解】</li>\n</ol>\n<p>同步监视器的执行过程：</p>\n<ol>\n<li>第一个线程访问，锁定同步监视器，执行其中代码；</li>\n<li>第二个线程访问，发现同步监视器被锁定，无法访问；</li>\n<li>第一个线程访问完毕，解锁同步监视器；</li>\n<li>第二个线程访问，发现同步监视器没有锁，然后锁定并反问；</li>\n</ol>\n<p><strong>synchronized () {}</strong></p>\n<pre><code class=\"java\">// 两个人去取钱\npublic class UnsafeBank &#123;\n    public static void main(String[] args) &#123;\n        // 账户\n        Account account = new Account(10000, &quot;存款金额&quot;);\n        Drawing you = new Drawing(account, 50, &quot;你&quot;);\n        Drawing gf = new Drawing(account, 100, &quot;对方&quot;);\n        you.start();\n        gf.start();\n    &#125;\n&#125;\n\n// 账户\nclass Account&#123;\n    int money; // 余额\n    String name; // 卡名\n\n    public Account(int money, String name) &#123;\n        this.money = money;\n        this.name = name;\n    &#125;\n&#125;\n// 银行 模拟取款\nclass Drawing extends Thread &#123;\n    Account account; // 账户\n    int drawingMoney; // 取了多少钱\n    int nowMoney; // 还剩多少钱\n\n    public Drawing(Account account, int drawingMoney, String name) &#123;\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    &#125;\n\n    //取钱操作\n    @Override\n    public void run() &#123;\n         //锁的对象必须是变化的量\n        synchronized (account) &#123;\n        // 判断有没有钱\n        if (account.money - drawingMoney &lt; 0) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;钱不够，取不了咯！&quot;);\n            return;\n        &#125;\n\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 卡内余额 = 余额 - 你取的钱\n        account.money = account.money - drawingMoney;\n        // 你手里的钱\n        nowMoney = nowMoney + drawingMoney;\n\n        System.out.println(account.name + &quot;余额为：&quot; + account.money);\n        // 此时 Thread.currentThread().getName() = this.getName()\n        System.out.println(this.getName() + &quot;手里的钱：&quot; + nowMoney);\n    &#125;\n&#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class UnSafeList &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            new Thread(() -&gt; &#123;\n                synchronized (list) &#123;\n                    list.add(Thread.currentThread().getName());\n                &#125;&#125;).start();\n\n        &#125;\n        try &#123;\n            Thread.sleep(300);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(list.size());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"JUC-安全类型的集合-CopyOnWriteArrayList\"><a href=\"#JUC-安全类型的集合-CopyOnWriteArrayList\" class=\"headerlink\" title=\"JUC 安全类型的集合-CopyOnWriteArrayList\"></a>JUC 安全类型的集合-CopyOnWriteArrayList</h2><pre><code class=\"java\">public class TestJUC &#123;\n    public static void main(String[] args) &#123;\n        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            new Thread( () -&gt;&#123;\n                list.add(Thread.currentThread().getName());\n            &#125; ).start();\n\n            try &#123;\n                Thread.sleep(30);\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(list.size());\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>多个线程各自占用一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情况，某一个同步块同时拥有<strong>两个以上对象的锁</strong>时，就可能会发生”死锁“的问题。</p>\n<p>产生死锁的四个<strong>必要</strong>条件：</p>\n<ol>\n<li>互斥：一个资源每次只能被一个进程使用</li>\n<li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>\n<li>不剥夺：进程已获得的资源，在未用完之前，不能强行剥夺</li>\n<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系</li>\n</ol>\n<p>上面四者只要想办法打破其中任意一个或者多个就可以避免死锁发生。</p>\n<pre><code class=\"java\">// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(1, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n\n&#125;\n\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\n\nclass Makeup extends Thread&#123;\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n                synchronized (mirror)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                &#125;\n            &#125;\n\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n                synchronized (lipstick)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                &#125;\n            &#125;\n\n\n\n        &#125;\n    &#125;\n&#125;// 死锁：多个线程互相拥有对方需要的资源，形成僵持\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(0, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n&#125;\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\nclass Makeup extends Thread&#123;\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n                synchronized (mirror)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                &#125;\n            &#125;\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n                synchronized (lipstick)&#123;\n                    // 获得镜子的锁\n                    System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n&#125;&#125;&#125;&#125;&#125;\n</code></pre>\n<pre><code class=\"java\">//代码块拿出来，不让互相抱死\npublic class DeadLock  &#123;\n    public static void main(String[] args) &#123;\n        Makeup moore = new Makeup(0, &quot;Moore&quot;);\n        Makeup dove = new Makeup(1, &quot;Dove&quot;);\n        moore.start();\n        dove.start();\n    &#125;\n\n&#125;\n\nclass Lipstick&#123;\n&#125;\nclass Mirror&#123;\n&#125;\n\nclass Makeup extends Thread&#123;\n\n    // 需要的资源只有一份，用static来保证只有一份\n    static Lipstick lipstick = new Lipstick();\n    static Mirror mirror = new Mirror();\n\n    int choice; // 选择\n    String girlName; // 使用化妆品的人\n\n    Makeup(int choice, String girlName)&#123;\n        this.choice = choice;\n        this.girlName = girlName;\n    &#125;\n    @Override\n    public void run() &#123;\n        // 化妆\n        try &#123;\n            Makeup();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    // 化妆 互相持有对方的锁，就是需要拿到对方的资源\n    private void Makeup() throws InterruptedException &#123;\n        if(choice == 0)&#123;\n            synchronized (lipstick)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n                Thread.sleep(1000);\n            &#125;\n            synchronized (mirror)&#123;\n                // 获得镜子的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n            &#125;\n\n        &#125;else&#123;\n            synchronized (mirror)&#123;\n                // 获得口红的锁\n                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);\n                Thread.sleep(2000);\n\n            &#125;\n\n            synchronized (lipstick)&#123;\n                // 获得镜子的锁\n                System.out.println(this.girlName + &quot;获得口红的锁&quot;);\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"Lock-锁-可重入锁\"><a href=\"#Lock-锁-可重入锁\" class=\"headerlink\" title=\"Lock 锁 - 可重入锁\"></a>Lock 锁 - 可重入锁</h2><pre><code class=\"java\">//不安全\npublic class TestLock &#123;\n    public static void main(String[] args) &#123;\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n\nclass TestLock2 implements Runnable &#123;\n    //票数\n    int ticketNum = 10;\n\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNum &gt; 0) &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//加锁.sleep不会释放锁对象，所以sleep请加到lock前面。\npublic class TestLock &#123;\n    public static void main(String[] args) &#123;\n        TestLock2 ticket = new TestLock2();\n\n        new Thread(ticket, &quot;小明&quot;).start();\n        new Thread(ticket, &quot;小二&quot;).start();\n        new Thread(ticket, &quot;阿黄&quot;).start();\n    &#125;\n&#125;\n\nclass TestLock2 implements Runnable &#123;\n    //票数\n    int ticketNum = 10;\n\n    //定义Lock锁\n    private final ReentrantLock lock = new ReentrantLock();\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            try &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                lock.lock();\n                if (ticketNum &gt; 0) &#123;\n                    System.out.println(Thread.currentThread().getName() + &quot;------拿到了第&quot; + ticketNum-- + &quot;张票------&quot;);\n                &#125;\n\n                else &#123;\n                    break;\n                &#125;\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">class A&#123;\n  private final ReentrantLock lock = new ReenTrantLock();\n  public void m()&#123;\n    lock.lock();\n    try&#123;\n      // 保证线程安全的代码\n    &#125;\n    finally&#123;\n            lock.unlock();\n      // 如果同步代码有异常，要将unlock()写入finally语句块\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"synchronized-与-lock-的对比\"><a href=\"#synchronized-与-lock-的对比\" class=\"headerlink\" title=\"synchronized 与 lock 的对比\"></a>synchronized 与 lock 的对比</h2><ol>\n<li>Lock 是显示锁，需要手动开启和关闭，synchronized 为隐式锁，出了作用域自动释放</li>\n<li>lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>\n<li>使用 lock 锁，jvm 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性</li>\n<li>优先使用顺序<ul>\n<li>Lock &gt; 同步代码块（已经进入方法体，分配了相应资源）&gt; 同步方法(在方法体之外)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程协作-生产者消费者问题\"><a href=\"#线程协作-生产者消费者问题\" class=\"headerlink\" title=\"线程协作 - 生产者消费者问题\"></a>线程协作 - 生产者消费者问题</h2><p>线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>\n<ol>\n<li>对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，有需要马上通知消费者消费</li>\n<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</li>\n<li>在生产者消费者问题中，仅有 synchronized 是不够的<ol>\n<li>synchronized 可组织并发更新同一个共享资源，实现了同步</li>\n<li>synchronized 不能用来实现不同线程之间的消息传递（通信）</li>\n</ol>\n</li>\n</ol>\n<p>Java 提供了几个方法解决线程之间的通信问题</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">wait()</td>\n<td align=\"left\">表示线程一直等待，直到其他线程通知，与 sleep（）不同，会释放锁</td>\n</tr>\n<tr>\n<td align=\"left\">wait(long timeout)</td>\n<td align=\"left\">指定等待的毫秒数</td>\n</tr>\n<tr>\n<td align=\"left\">notify()</td>\n<td align=\"left\">唤醒一个处于等待状态的线程</td>\n</tr>\n<tr>\n<td align=\"left\">notifyAll()</td>\n<td align=\"left\">唤醒同一个对象上所有调用 wait（）方法的线程，优先级别高的线程优先调度</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong> 均是 Object 类的方法，都只能在同步方法或者同步代码快中使用，否则会抛出异常 <code>IllegalMonitorStateException</code></p>\n<h3 id=\"管程法\"><a href=\"#管程法\" class=\"headerlink\" title=\"管程法\"></a>管程法</h3><ol>\n<li><p>生产者：负责生产数据的模块（可能是方法、对象、线程、进程）</p>\n</li>\n<li><p>消费者：负责处理数据的模块（可能是方法、对象、线程、进程）</p>\n</li>\n<li><p>缓冲区：消费者不能直接使用生产者的数据，利用中间“缓冲区”</p>\n<p>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p>\n</li>\n</ol>\n<pre><code class=\"java\">// 测试 生产者消费者模型 --&gt; 利用缓冲区解决：管程法\n// 有问题，会出现先消费后生产，要用队列实现\npublic class TestPC &#123;\n    public static void main(String[] args) &#123;\n        SynBuffer synBuffer = new SynBuffer();\n\n        new Producer(synBuffer).start();\n        new Consumer(synBuffer).start();\n    &#125;\n&#125;\n\n// 生产者\nclass Producer extends Thread&#123;\n    SynBuffer buffer;\n    public Producer(SynBuffer buffer)&#123;\n        this.buffer = buffer;\n    &#125;\n    // 生产\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;生产了&quot; + i +&quot;只鸡&quot;);\n            try &#123;\n                buffer.push(new Chicken(i));\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n// 消费者\nclass Consumer extends Thread&#123;\n    SynBuffer buffer;\n    public Consumer(SynBuffer buffer)&#123;\n        this.buffer = buffer;\n    &#125;\n\n    // 消费\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            try &#123;\n                System.out.println(&quot;消费了--&gt;&quot; + buffer.pop().id +&quot;只鸡&quot;);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n// 产品\nclass Chicken&#123;\n    int id; // 产品编号\n\n    public Chicken(int id) &#123;\n        this.id = id;\n    &#125;\n&#125;\n\n// 缓冲区\nclass SynBuffer&#123;\n\n    //容器大小\n    Chicken[] chickens = new Chicken[10];\n    // 容器计数器\n    int count = 0;\n\n    // 生产者放入产品\n    public synchronized void push(Chicken chicken) throws InterruptedException &#123;\n        // 如果容器满了，需要等待消费者消费\n        if(count == chickens.length)&#123;\n            // 通知消费者消费，生产等待\n            this.wait();\n        &#125;\n        // 如果没有满，需要丢入产品\n        chickens[count] = chicken;\n        count ++;\n        // 可以通知消费者消费了\n        this.notifyAll();\n    &#125;\n\n    // 消费者消费产品\n    public synchronized Chicken pop() throws InterruptedException &#123;\n        // 判断能否消费\n        if(count == 0)&#123;\n            /// 等待生产者生产，消费者等待\n            this.wait();\n        &#125;\n        // 如果可以消费\n        count --;\n        Chicken chicken = chickens[count];\n        // 吃完了，通知生产者生产\n        this.notifyAll();\n\n        return chicken;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"信号灯法\"><a href=\"#信号灯法\" class=\"headerlink\" title=\"信号灯法\"></a>信号灯法</h3><pre><code class=\"java\">public class TestPC2 &#123;\n    public static void main(String[] args) &#123;\n        TV tv = new TV();\n        new Player(tv).start();\n        new Watcher(tv).start();\n    &#125;\n&#125;\n\n// 生产者 --&gt; 演员\nclass Player extends Thread&#123;\n    TV tv;\n    public Player(TV tv)&#123;\n        this.tv = tv;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 20; i++) &#123;\n            if (i % 2 == 0)&#123;\n                this.tv.play(&quot;节目一：新闻联播&quot;);\n            &#125;else&#123;\n                this.tv.play(&quot;节目二：法治在线&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n// 消费者 --&gt; 观众\nclass Watcher extends Thread&#123;\n    TV tv;\n    public Watcher(TV tv)&#123;\n        this.tv = tv;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 20; i++) &#123;\n            tv.watch();\n        &#125;\n    &#125;\n&#125;\n\n// 产品 --&gt; 节目\nclass TV&#123;\n    // 演员表演，观众等待 T\n    // 观众观看，演员等待 F\n    String voice; // 表演的节目\n    boolean flag = true;\n    // 表演\n    public synchronized void play(String voice)&#123;\n\n        if (!flag)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n        System.out.println(&quot;演员表演了:&quot; + voice);\n        // 通知观众观看\n        this.notifyAll(); // 通知唤醒\n        this.voice = voice;\n        this.flag = !this.flag;\n    &#125;\n    // 观看\n    public synchronized void watch()&#123;\n        if (flag)&#123;\n            try &#123;\n                this.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        System.out.println(&quot;观看了：&quot; + voice);\n        // 通知演员表演\n        this.notifyAll();\n        this.flag = !this.flag;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p>\n<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的交通工具。</p>\n<p>好处：</p>\n<pre><code>1. 提高响应速度（减少创建新线程的时间）\n</code></pre>\n<ol start=\"2\">\n<li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建） 3. 便于线程管理 1. corePoolSize：最大线程数； 2. maxmumPoolSize：最大线程数； 3. keepAliveTime：线程没有任务时最多保持多长时间后会终止；</li>\n</ol>\n<h2 id=\"使用线程池\"><a href=\"#使用线程池\" class=\"headerlink\" title=\"使用线程池\"></a>使用线程池</h2><ol>\n<li>jdk5.0 线程池相关 API ：ExecutorService 和 Executors；</li>\n<li>ExecutorService ：真正的线程池接口。常见子类 ThreadPoolExecutor；<ol>\n<li>void execute(Runnable command) : 执行任务/命令，没有返回值，一般用来执行 Runnable；</li>\n<li><T>Future<T> submit(Callable<T> task): 执行任务，有返回值，一般用来执行 Callable；</li>\n<li>void shutdown(): 关闭连接池；</li>\n</ol>\n</li>\n<li>Executors: 工具类、线程池的工厂类，用于创建并返回不同类型的线程池；</li>\n</ol>\n<pre><code class=\"java\">import java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool &#123;\n    public static void main(String[] args) &#123;\n        // 1. 创建服务，创建线程池\n        // newFixedThreadPool 参数为线程池大小\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        // 2. 关闭连接\n        service.shutdown();\n    &#125;\n&#125;\n\nclass   MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n            System.out.println(Thread.currentThread().getName());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code class=\"java\">import java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class summary &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        new MyThread1().start();\n\n        new Thread(new MyThread2()).start();\n\n        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread3());\n        new Thread(futureTask).start();\n        Integer integer = futureTask.get();\n        System.out.println(integer);\n    &#125;\n&#125;\n\n// 1. 继承Thread类\nclass MyThread1 extends Thread&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;My Thread1&quot;);\n    &#125;\n&#125;\n// 2. 实现Runnable接口\nclass MyThread2 implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;My Thread2&quot;);\n    &#125;\n&#125;\n// 3. 实现Callable接口\nclass MyThread3 implements Callable&lt;Integer&gt;&#123;\n    @Override\n    public Integer call() throws Exception &#123;\n        System.out.println(&quot;My Thread3&quot;);\n        return 100;\n    &#125;\n&#125;\n</code></pre>"},{"title":"JAVA-集合框架","date":"2021-04-09T17:38:17.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png"],"_content":"\n# 集合\n\n<!--more-->\n\n## 什么是集合\n\n#### 概念\n\n​ 对象的容器，实现了对对象常用的操作\n\n#### 和数组的区别\n\n1. 数组长度固定，集合长度不固定\n2. 数组可以存储基本类型和引用类型，集合只能存储引用类型\n\n#### 位置\n\n​ java.util.\\*;包\n\n## collection 体系\n\n![image-20210407105452970](img/article/JAVA-集合框架-20210418/image-20210407105452970.png)\n\n## Collection 父接口\n\n特点：代表一组任意类型的对象，无序、无下标、不能重复。\n\n创建集合 `Collection collection = new ArrayList();`\n\n### 常用方法\n\n1. collection.add(Object obj); 添加一个对象；\n2. adddAll(Collection c) ；//将一个集合中的所有对象添加到此集合中；\n3. void clear(); 清空此集合中的所有对象；\n4. contains(Object obj); //检查此集合中是否包含 o 对象；\n5. equals(Object obj); //比较此集合中是否包含 o 对象；\n6. isEmpty(); 判断此集合是否为空；\n7. remove(Object obj); //在此集合中移除 o 对象；\n8. int size(); //返回此集合中的元素个数；\n9. Object[] toArray(); //将此集合转换成数组 ；\n\n遍历元素（重点）\n\n1.  增强 for（因为无下标）\n\n    `or(Object object : collection){ }`\n\n2.  使用迭代器\n\n    ```java\n    //haNext(); 有没有下一个元素\n    //next(); 获取下一个元素\n    //remove(); 删除当前元素\n    Iterator it = collection.iterator();\n    while (it.hasNext()) {\n        String s = (String) it.next();\n        System.out.println(s);\n        // 可以使用it.remove(); 进行移除元素\n        // collection.remove(); 不能用collection其他方法 会报并发修改异常\n\n    ```\n\n3.  列表迭代器\n\n    ```java\n     List list = new ArrayList();\n            list.add(\"aaa\");\n            list.add(\"bbb\");\n            list.add(\"ccc\");\n            ListIterator li = list.listIterator();\n            while(li.hasNext()){\n                System.out.println(li.nextIndex() + \":\" + li.next()); //从前往后遍历\n            }\n\n            while(li.hasPrevious()){\n                System.out.println(li.previousIndex() + \":\" + li.previous()); //从后往前遍历\n            }\n    ```\n\n### List 子接口\n\n1. 特点：有序，有下标，元素可以重复；\n2. 方法：\n   1. list.add(int index, Object o) //在 index 位置插入对象 o\n   2. list.addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的 index 位置\n   3. list.get(int index) //返回集合中指定位置的元素\n   4. list.remove(Object o) list.remove(index) //删除集合中指定元素或指定位置的元素\n   5. list,isEmpty() //判断是否为空\n   6. list.subList(int fromIndex, int toIndex) //返回 fromindex 和 toindex 之间的集合元素，含头不含尾\n\n```java\npublic static void main(String[] args) {\n        List list = new ArrayList<>();\n\n        list.add(\"apple\");\n        list.add(\"xiaomi\");\n        list.add(\"huawei\");\n        System.out.println(\"元素个数:\"+ list.size());\n        System.out.println(list.toString());\n\n//        list.remove(\"xiaomi\");\n//        System.out.println(\"元素个数:\"+ list.size());\n//        list.remove(0);\n//        System.out.println(\"元素个数:\"+ list.size());\n\n        System.out.println(\"----------------for遍历-------------------\");\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n        System.out.println(\"----------------增强for-------------------\");\n        for (Object o : list) {\n            System.out.println(o);\n        }\n        System.out.println(\"----------------使用迭代器进行遍历-------------------\");\n        Iterator it1 = list.iterator();\n        while (it1.hasNext()){\n            System.out.println(it1.next());\n        }\n        System.out.println(\"----------------使用列表迭代器进行正序遍历-------------------\");\n        ListIterator it2 = list.listIterator();\n        while (it2.hasNext()){\n            System.out.println(it2.next());\n        }\n\n        //从后向前\n        System.out.println(\"----------------使用列表迭代器进行逆序遍历-------------------\");\n        while (it2.hasPrevious()){\n            System.out.println(it2.previous());\n        }\n\n        System.out.println(\"-----------------------------------------------------------\");\n        //判断是否存在\n        System.out.println(list.contains(\"xiaomi\"));\n        //判断是否为空\n        System.out.println(list.isEmpty());\n    System.out.println(\"-----------------------------------------------------------\");\n        //指定位置输出,含头不含尾\n        System.out.println(list.subList(1,2));\n\n    }\n```\n\n### List 实现类\n\n1. ArrayLsit [重点]：\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.2 版本，运行效率快，线程不安全。\n\n2. Vector:\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.0 版本，运行效率慢，线程安全。\n\n3. LinkedList：\n\n   1. 链表结构实现，增删快，查询慢。\n\n### ArrayList 的使用\n\n创建集合 `ArrayList arrayList = new ArrayList<>();`\n\n1. 添加元素 `arrayList.add();`\n\n2. 删除元素 `arrayList.remove(new Student(\"name\", 10));`\n\n   这里重写了 equals(this == obj) 方法\n\n```java\n @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if(obj instanceof Student){\n            Student s = (Student)obj;\n            //4 比较属性\n            return this.name.equals(s.getName()) && this.age == s.getAge();\n        }\n        return false;\n    }\n```\n\n3. 遍历元素【重点】\n\n   1. 迭代器\n\n   ```java\n   Iterator it = arrayList.iterator();\n   while(it.hasNext()){\n     Student s = (Student)it.next(); //强转\n   }\n   ```\n\n   2. 列表迭代器\n\n   ```java\n   ListIterator li = arrayList.listIterator();\n   while(li.hasNext()){\n     Student s = (Student)li.next(); //从前往后遍历\n   }\n\n   while(li.hasPrevious()){\n     Student s = (Student)li.previous();//从后往前遍历\n   }\n   ```\n\n4. ArrayList 源码分析\n\n   1. `private static final int DEFAULT_CAPACITY = 10;` //默认容量 10；\n\n      注意：如果没有向集合中添加任何元素时，容量 0，添加一个后，容量为 10；\n\n      每次扩容是原来的 1.5 倍；\n\n   2. `private static final Object[] EMPTY_ELEMENTDATA = {};` 存放元素的数组；\n\n   3. `private int size;` 实际元素个数，一定小于容量；\n\n### Vector 类\n\n1. 创建集合 `Vector vector = new Vector<>();`\n2. 增加、删除、判断同上与 list 相同\n3. 遍历中枚举器遍历\n\n```java\nEnumeration en = vector.elements();\nwhile(en.hasMoreElements()){\n  String o = (String)en.nextElement();\n  sout(o);\n}\n```\n\n### LinkedList\n\n1. ArrayLsit [重点]：\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.2 版本，运行效率快，线程不安全。\n\n2. Vector:\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.0 版本，运行效率慢，线程安全。\n\n3. LinkedList：\n\n   1. 链表结构实现，增删快，查询慢。\n\n4. ```java\n   LinkedList linkedList = new LinkedList();\n   ```\n\n5. 主要方法与 ArrayList()相同；遍历方法，for, Iterator;\n\n## 泛型\n\n1. 本质是参数化类型，把类型作为参数传递\n2. 常见形式有泛型类、泛型接口、泛型方法\n3. 语法<T> <T, V> T 成为类型占位符，表示一种引用类型，可以写多个逗号隔开\n4. 好处\n   1. 提高代码重用性\n   2. 防止类型转换异常，提高代码安全性\n\n### 泛型类\n\n```java\n/**\n * 泛型类\n * T是类型占位符，表示一种引用类型，如果编写多个使用逗号隔开\n */\npublic class MyGeneric<T> {\n    T t;\n    public void show(T t) {\n        System .out.println(t);\n    }\n    public T getT() {\n        return t;\n    }\n}\n\n```\n\n```java\n\t\tMyGeneric<String> myGeneric = new MyGeneric<String>();\n        myGeneric.t = \"hello\";\n        myGeneric.show(\"大家好，加油\");\n        String str = myGeneric.getT();\n        System.out.println(str);\n\n        MyGeneric<Integer> myGeneric2 = new MyGeneric<>();\n        myGeneric2.t = 100;\n        myGeneric2.show(200);\n        Integer integer = myGeneric2.getT();\n        System.out.println(integer);\n```\n\n### 泛型接口\n\n```java\n/**\n * 泛型接口\n * 语法, 接口名<T>\n * 注意，不能泛型静态常量\n */\npublic interface MyInterface<T> {\n    String name = \"张三\";\n\n    T server(T t);\n}\n```\n\n```java\npublic class MyInterfaceImpl implements MyInterface<String> {\n\n    @Override\n    public String server(String t) {\n        System.out.println(t);\n        return t;\n    }\n}\n\n```\n\n```java\npublic class MyInterfanceImpl2<T> implements MyInterface<T> {\n\n    @Override\n    public T server(T t) {\n        System.out.println(t);\n        return t;\n    }\n}\n```\n\n```java\n\t\t//myinterface\n        MyInterfaceImpl impl = new MyInterfaceImpl();\n        impl.server(\"xxxxxxxxxx\");\n\n        //myinterfaceimpl2\n        MyInterfanceImpl2<Integer> impl2 = new MyInterfanceImpl2<>();\n        impl2.server(1000);\n        MyInterfanceImpl2<String> impl3 = new MyInterfanceImpl2<>();\n        impl3.server(\"ccccccccccc\");\n```\n\n### 泛型方法\n\n```java\n/**\n * 泛型方法\n * 语法： <T> 返回值类型\n */\n\npublic class MyGenericMethod {\n    public <T> T show(T t) {\n        System.out.println(\"泛型方法\" + t);\n        return t;\n    }\n}\n```\n\n```java\n        //泛型方法\n        MyGenericMethod myGenericMethod = new MyGenericMethod();\n        myGenericMethod.show(\"bbbb\");\n        myGenericMethod.show(200);\n        myGenericMethod.show(1.23);\n```\n\n### 泛型集合\n\n概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致\n\n特点：\n\n1. 编译时即可检查，而非运行时抛出异常\n2. 访问时，不必类型转换（拆箱）\n3. 不同泛型之间应用不能相互赋值，泛型不存在多态\n\n```java\n\t\tArrayList<String> arrayList = new ArrayList<String>();\n        arrayList.add(\"xxx\");\n        arrayList.add(\"yyy\");\n\n        for (String s : arrayList) {\n            System.out.println(s.toString());\n        }\n\n        ArrayList<Student> arrayList2 = new ArrayList<>();\n        Student s1 = new Student(\"刘德华\", 20);\n        Student s2 = new Student(\"郭富城\", 21);\n        Student s3 = new Student(\"梁朝伟\", 22);\n        arrayList2.add(s1);\n        arrayList2.add(s2);\n        arrayList2.add(s3);\n\n        Iterator iterator = arrayList2.listIterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n```\n\n## Set 集合\n\n1. 特点：无序，无下标、元素不可重复；\n2. 方法：全部继承自 Collection 中的方法；\n3. 增、删、遍历、判断与 collection 相同；\n\n```java\n\t\tSet<String> set = new HashSet<>();\n        //1. 添加数据\n        set.add(\"小米\");\n        set.add(\"华为\");\n        set.add(\"苹果\");\n        System.out.println(\"数据个数:\" + set.size());\n        System.out.println(set.toString());\n        //2 删除数据\n\t\t//set.remove(\"小米\");\n        System.out.println(\"----------------增强for--------------\");\n        for (String s : set) {\n            System.out.println(s);\n        }\n        System.out.println(\"----------------迭代器--------------\");\n        Iterator<String> iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n```\n\n### Set 实现类\n\n#### HashSet[重点]：\n\n1. 无序，基于 HashCode 实现元素不重复；\n2. 当存入元素的哈希码相同时，会调用 equals 进行确认，如结果为 true，则拒绝后者存入；\n\n存储结构：哈希表（数组+链表+红黑树）\n\n存储过程（重复依据）\n\n1. 根据 hashCode 计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步\n\n2. 再执行 equals 方法，如果 equals 为 true，则认为是重复，否则形成链表\n\n   基于 HashCode 计算元素存放位置\n\n   1. 利用 31 这个质数，减少散列冲突\n\n      31 提高执行效率 `31 * i = (i << 5) - i` 转为移位操作\n\n   2. 当存入元素的哈希码相同时，会调用 equals 进行确认，如果结果为 true，则拒绝后者存入\n\n```java\n public static void main(String[] args) {\n        HashSet<String> hashSet = new HashSet<>();\n\n        hashSet.add(\"刘德华\");\n        hashSet.add(\"郭富城\");\n        hashSet.add(\"梁朝伟\");\n\n        System.out.println(\"元素个数：\" + hashSet.size());\n        System.out.println(hashSet.toString());\n        //删除元素\n//        hashSet.remove(\"刘德华\");\n        //增强for\n        System.out.println(\"---------------增强for-----------------\");\n        for (String s : hashSet) {\n            System.out.println(s);\n        }\n\n        System.out.println(\"---------------迭代器-----------------\");\n        Iterator it= hashSet.iterator();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n```\n\n```java\n//重写equals + hashCode\n     @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &&\n                name.equals(person.name);\n    }\n\n   @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    }\n```\n\n#### TreeSet:\n\n1. 基于排列顺序实现元素不重复；\n\n2. 实现了 sortedset 接口，对集合元素自动排序；\n\n3. 元素对象的类型必须实现，Comparable 接口，指定排序规则；\n\n4. 通过 CompareTo 方法确定是否为重复元素；\n\n5. 存储结构：红黑树\n\n6. 创建集合 `TreeSet<String> treeSet = new TreeSet<>()`\n\n   添加元素 `treeSet.add();`\n\n   删除元素 `treeSet.remove();`\n\n   遍历 1. 增强 for 2. 迭代器\n\n   判断 `treeSet.contains();`\n\n7. 补充： TreeSet 集合的使用\n\n   1. Comparator 实现定制比较（比较器）\n   2. Comparable 可比较的\n\n   ```java\n   TreeSet<Person> persons = new TreeSet<>(new Comparator<Person>() {\n               @Override\n               public int compare(Person o1, Person o2) {\n                   int n1 = o1.getAge() - o2.getAge();\n                   int n2 = o1.getName().compareTo(o2.getName());\n                   return n1 == 0 ? n2 : n1;\n               }\n           });\n   ```\n\n8. TreeSet 案例:\n\n   - 要求使用 TreeSet 集合实现字符串按照长度进行排序；\n   - 实现方法：重写 Comparator 的 compare 方法\n\n```java\n /**\n     * 要求使用TreeSet 集合实现字符串按照长度进行排序；\n     * helloWord  zhang  lisi  wangwu  beijing  xian  nanjing\n     * @authoe sx\n     */\n    public static void main(String[] args) {\n        TreeSet treeSet = new TreeSet<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                int n1 = o1.length()-o2.length();\n                int n2 = o1.compareTo(o2);\n                return n1==0?n2:n1;\n            }\n        });\n        //添加数据\n        treeSet.add(\"helloWord\");\n        treeSet.add(\"zhang\");\n        treeSet.add(\"lisi\");\n        treeSet.add(\"wangwu\");\n        treeSet.add(\"beijing\");\n        treeSet.add(\"xian\");\n        treeSet.add(\"nanjing\");\n        System.out.println(treeSet.toString());\n\n    }\n\n[lisi, xian, zhang, wangwu, beijing, nanjing, helloWord]\n```\n\n## Map\n\n1. 特点：存储一对数据（Key, Value），无序、无下标，键不可以重复，值可重复；\n2. 方法：\n   1. V put(K key, V value) 将对象存到集合中，关联键值 ;\n   2. Object get(Object key) 根据键获得对应的值 ;\n   3. Set<K> 返回所有的 Key;\n   4. Collection<V> values() 返回包含所有值的 Collection 集合;\n   5. Set<Map.Entry<K, V>> 键值匹配的 Set 集合;\n\n### Map 接口的使用：\n\n两种遍历方法：\n\n1. keySet()把 map 中的 key 存在 set 集合中；entrySet()把（key，value）封装成一个 entry 类型（映射对）；\n2. entrySet()效率高于 keySet()方法；因为 entrySet 一次性把 key，value 取出。\n\n```java\npublic static void main(String[] args) {\n        //创建Map集合\n        Map<String, String> map = new HashMap<>();\n\n        map.put(\"cn\", \"中国\");\n        map.put(\"uk\", \"英国\");\n        map.put(\"fc\", \"法国\");\n        map.put(\"gm\", \"德国\");\n\n        System.out.println(\"元素个数：\" + map.size());\n        System.out.println(map.toString());\n\n        //删除\n//        map.remove(\"fc\");\n//        System.out.println(map.toString());\n\n        //遍历\n        //使用keySet()方法\n        System.out.println(\"----------keySet---------------\");\n        Set<String> keySet = map.keySet();\n        for (String key : keySet) {\n            System.out.println(key + \":\" + map.get(key));\n        }\n        System.out.println(\"----------entrySet---------------\");\n//        使用entrySet方法\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            System.out.println(entry.getKey() + \":\" + entry.getValue());\n        }\n    }\n```\n\n### HashMap[重点]\n\nJDK1.2 版本，线程不安全，运行效率快，允许用 null 作为 key 或是 value。\n\n存储结构：哈希表（数组+链表+红黑树）\n\n使用 key 可使 hashcode 和 equals 作为重复\n\n增、删、遍历、判断与上述一致\n\nHashMap 常用方法：alt + insert 重写 equals 和 hashcode 去掉重复项；\n\n```java\npublic static void main(String[] args) {\n        //创建集合\n        HashMap<Student, String> students = new HashMap<>();\n        //添加元素\n        Student s1 = new Student(\"孙悟空\", 100);\n        Student s2 = new Student(\"猪八戒\", 101);\n        Student s3 = new Student(\"沙和尚\", 102);\n        students.put(s1, \"花果山\");\n        students.put(s2, \"黑风洞\");\n        students.put(s3, \"流沙河\");\n        students.put(s3, \"流沙河\");\n        students.put(new Student(\"沙和尚\", 102), \"流沙河\");\n        System.out.println(students.size());\n        System.out.println(students.toString());\n\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(\"删除之后：\" + students.size());\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //遍历\n        for (Student key : students.keySet()) {\n            System.out.println(key.toString() + \":\" + students.get(key));\n        }\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //使用entrySet()\n        for (Map.Entry<Student, String> studentStringEntry : students.entrySet()) {\n            System.out.println(studentStringEntry.getKey() + \":\" + studentStringEntry.getValue());\n        }\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(\"流沙河\"));\n    }\n```\n\n### HashMap 源码分析：\n\n1. `static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;` //默认初始容量大小\n\n   1 左移 4 位 = 2^4 = 16，底层移位计算最快；\n\n2. `static final int MAXIMUM_CAPACITY = 1 << 30;` //最大容量大小；\n\n3. `DEFAULT_LOAD_FACTOR` //默认加载因子；\n\n4. `static final int TREEIFY_THRESHOLD = 8;`\n\n   `static final int MIN_TREEIFY_CAPACITY = 64;` //链表长度大于 8，数组长度大于 64 时存储结构改为红黑树；\n\n5. `static final int UNTREEIFY_THRESHOLD = 6;` //链表长度小于 6，变回链表结构\n\n**源码分析总结**：\n\n1. HashMap 刚创建时，table 是 null，节省空间，当添加第一个元素时，table 容量调整为 16\n2. 当元素个数大于阈值 75%（16\\*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数\n3. jdk1.8 当每个链表长度 >8 ，并且数组元素个数 ≥64 时，会调整成红黑树，目的是提高效率\n4. jdk1.8 当链表长度 <6 时 调整成链表\n5. jdk1.8 以前，链表是头插入，之后为尾插入\n\n### Hashtable\n\n​ JDK1.0 版本，线程安全，运行效率慢，不允许 NULL 作为 key 或是 value。\n\n​ 基本不用。\n\n### Properties\n\n​ Hashtable 的子类，需要 key 和 value 都是 String。在流中使用较多，通常用于配置文件的读取。在流的学习中进行使用。\n\n```java\npublic static void main(String[] args) {\n        //创建集合\n        Properties properties = new Properties();\n        //添加数据\n        properties.setProperty(\"username\", \"zhangsan\");\n        properties.setProperty(\"age\", \"20\");\n        System.out.println(properties);\n\n        //遍历\n        //keyset\n        for (Object o : properties.keySet()) {\n            System.out.println(o);\n        }\n\n        //entrySet\n        for (Map.Entry<Object, Object> objectObjectEntry : properties.entrySet()) {\n            System.out.println(objectObjectEntry);\n        }\n\n        //stringPropertyName\n        for (String stringPropertyName : properties.stringPropertyNames()) {\n            System.out.println(stringPropertyName + \":\" + properties.getProperty(stringPropertyName));\n        }\n    }\n```\n\n#### 和流有关的方法\n\n```java\n//和流有关的方法\n        PrintWriter pw = new PrintWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties\");\n        properties.list(pw);\n        pw.close();\n```\n\n#### store 方法\n\n```java\nFileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties\");\n        properties.store(fos, \"注释\");\n        fos.close();\n\n结果：\n#\\u6CE8\\u91CA    properties文件不允许中文\n#Sat Apr 10 01:08:21 CST 2021\nage=20\nusername=zhangsan\n\n```\n\n#### load 方法\n\n```java\n//        load方法\n        Properties properties2 = new Properties();\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\\\\\print.properties\");\n        properties2.load(fis);\n        fis.close();\n        System.out.println(properties2.toString());\n```\n\n### TreeMap\n\n​ 实现了 SortedMap 接口（是 map 的子接口），可以对 key 自动排序\n\n```java\npublic static void main(String[] args) {\n        TreeMap<Student, String> students = new TreeMap<>();\n        Student s1 = new Student(\"孙悟空\", 103);\n        Student s2 = new Student(\"猪八戒\", 101);\n        Student s3 = new Student(\"沙和尚\", 102);\n        students.put(s1, \"花果山\");\n        students.put(s2, \"黑风洞\");\n        students.put(s3, \"流沙河\");\n        students.put(s3, \"流沙河\");\n        students.put(new Student(\"沙和尚\", 102), \"流沙河\");\n        System.out.println(students.size());\n        System.out.println(students.toString());\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(\"删除之后：\" + students.size());\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //遍历\n        for (Student key : students.keySet()) {\n            System.out.println(key.toString() + \":\" + students.get(key));\n        }\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //使用entrySet()\n        for (Map.Entry<Student, String> studentStringEntry : students.entrySet()) {\n            System.out.println(studentStringEntry.getKey() + \":\" + studentStringEntry.getValue());\n        }\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(\"流沙河\"));\n\n    }\n```\n\n定制比较器：重写 compare 方法:\n\n可以自定义规则\n\n```java\nTreeMap<Student, String> students = new TreeMap(new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            }\n        });\n```\n\n## Collection 工具类\n\n​ 概念：集合工具类，定义了除了存取以外的集合常用方法；\n\n​ 1. 排序 `Collections.sort()`\n\n​ 2. 直接二分查找`int i = Collections.binarySearch(list, x);` 成功返回索引；\n\n​ 其他方法 ：\n\n复制`Collections.copy(dest, list);`\n\n​ 反转`Collections.reverse(list);`\n\n​ 打乱`ollections.shuffle(list);`\n\n```java\npublic static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(20);\n        list.add(3);\n        list.add(14);\n        list.add(50);\n        list.add(36);\n        //排序\n        System.out.println(\"排序之前---\" + list.toString());\n        Collections.sort(list);\n        System.out.println(\"排序之后---\" + list.toString());\n\n        int i = Collections.binarySearch(list, 3);\n        System.out.println(\"第\" + i + \"位\");\n\n        List<Integer> dest = new ArrayList<>();\n        //开辟空间，否则dest为空，无法直接copy放入\n        for (int j = 0; j < list.size(); j++) {\n            dest.add(0);\n        }\n        Collections.copy(dest, list);\n        System.out.println(dest.toString());\n\n        //翻转\n        Collections.reverse(list);\n        System.out.println(list);\n\n        //打乱\n        Collections.shuffle(list);\n        System.out.println(list);\n    }\n```\n\n​ 补充：\n\n```java\n// list转成数组\nInteger[] arr = list.toArray(new Integer[10]);\nsout(arr.length);\nsout(Array.toString(arr));\n\n// 数组转成集合\n// 此时为受限集合，不能 添加和删除！\nString[] name = {\"张三\",\"李四\",\"王五\"};\nList<String> list2 = Arrays.asList(names);\n\n// 把基本类型数组转为集合时，需要修改为包装类\nInteger[] nums = {100, 200, 300, 400, 500};\nList<Integer> list3 = Arrays.asList(nums);\n```\n","source":"_posts/JAVA-集合框架-20210418.md","raw":"---\ntitle: JAVA-集合框架\ndate: 2021-04-10 01:38:17\ntags:\n  - java基础\n  - 狂神说\ncategories:\n  - java\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/JAVA.png\n---\n\n# 集合\n\n<!--more-->\n\n## 什么是集合\n\n#### 概念\n\n​ 对象的容器，实现了对对象常用的操作\n\n#### 和数组的区别\n\n1. 数组长度固定，集合长度不固定\n2. 数组可以存储基本类型和引用类型，集合只能存储引用类型\n\n#### 位置\n\n​ java.util.\\*;包\n\n## collection 体系\n\n![image-20210407105452970](img/article/JAVA-集合框架-20210418/image-20210407105452970.png)\n\n## Collection 父接口\n\n特点：代表一组任意类型的对象，无序、无下标、不能重复。\n\n创建集合 `Collection collection = new ArrayList();`\n\n### 常用方法\n\n1. collection.add(Object obj); 添加一个对象；\n2. adddAll(Collection c) ；//将一个集合中的所有对象添加到此集合中；\n3. void clear(); 清空此集合中的所有对象；\n4. contains(Object obj); //检查此集合中是否包含 o 对象；\n5. equals(Object obj); //比较此集合中是否包含 o 对象；\n6. isEmpty(); 判断此集合是否为空；\n7. remove(Object obj); //在此集合中移除 o 对象；\n8. int size(); //返回此集合中的元素个数；\n9. Object[] toArray(); //将此集合转换成数组 ；\n\n遍历元素（重点）\n\n1.  增强 for（因为无下标）\n\n    `or(Object object : collection){ }`\n\n2.  使用迭代器\n\n    ```java\n    //haNext(); 有没有下一个元素\n    //next(); 获取下一个元素\n    //remove(); 删除当前元素\n    Iterator it = collection.iterator();\n    while (it.hasNext()) {\n        String s = (String) it.next();\n        System.out.println(s);\n        // 可以使用it.remove(); 进行移除元素\n        // collection.remove(); 不能用collection其他方法 会报并发修改异常\n\n    ```\n\n3.  列表迭代器\n\n    ```java\n     List list = new ArrayList();\n            list.add(\"aaa\");\n            list.add(\"bbb\");\n            list.add(\"ccc\");\n            ListIterator li = list.listIterator();\n            while(li.hasNext()){\n                System.out.println(li.nextIndex() + \":\" + li.next()); //从前往后遍历\n            }\n\n            while(li.hasPrevious()){\n                System.out.println(li.previousIndex() + \":\" + li.previous()); //从后往前遍历\n            }\n    ```\n\n### List 子接口\n\n1. 特点：有序，有下标，元素可以重复；\n2. 方法：\n   1. list.add(int index, Object o) //在 index 位置插入对象 o\n   2. list.addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的 index 位置\n   3. list.get(int index) //返回集合中指定位置的元素\n   4. list.remove(Object o) list.remove(index) //删除集合中指定元素或指定位置的元素\n   5. list,isEmpty() //判断是否为空\n   6. list.subList(int fromIndex, int toIndex) //返回 fromindex 和 toindex 之间的集合元素，含头不含尾\n\n```java\npublic static void main(String[] args) {\n        List list = new ArrayList<>();\n\n        list.add(\"apple\");\n        list.add(\"xiaomi\");\n        list.add(\"huawei\");\n        System.out.println(\"元素个数:\"+ list.size());\n        System.out.println(list.toString());\n\n//        list.remove(\"xiaomi\");\n//        System.out.println(\"元素个数:\"+ list.size());\n//        list.remove(0);\n//        System.out.println(\"元素个数:\"+ list.size());\n\n        System.out.println(\"----------------for遍历-------------------\");\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n        System.out.println(\"----------------增强for-------------------\");\n        for (Object o : list) {\n            System.out.println(o);\n        }\n        System.out.println(\"----------------使用迭代器进行遍历-------------------\");\n        Iterator it1 = list.iterator();\n        while (it1.hasNext()){\n            System.out.println(it1.next());\n        }\n        System.out.println(\"----------------使用列表迭代器进行正序遍历-------------------\");\n        ListIterator it2 = list.listIterator();\n        while (it2.hasNext()){\n            System.out.println(it2.next());\n        }\n\n        //从后向前\n        System.out.println(\"----------------使用列表迭代器进行逆序遍历-------------------\");\n        while (it2.hasPrevious()){\n            System.out.println(it2.previous());\n        }\n\n        System.out.println(\"-----------------------------------------------------------\");\n        //判断是否存在\n        System.out.println(list.contains(\"xiaomi\"));\n        //判断是否为空\n        System.out.println(list.isEmpty());\n    System.out.println(\"-----------------------------------------------------------\");\n        //指定位置输出,含头不含尾\n        System.out.println(list.subList(1,2));\n\n    }\n```\n\n### List 实现类\n\n1. ArrayLsit [重点]：\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.2 版本，运行效率快，线程不安全。\n\n2. Vector:\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.0 版本，运行效率慢，线程安全。\n\n3. LinkedList：\n\n   1. 链表结构实现，增删快，查询慢。\n\n### ArrayList 的使用\n\n创建集合 `ArrayList arrayList = new ArrayList<>();`\n\n1. 添加元素 `arrayList.add();`\n\n2. 删除元素 `arrayList.remove(new Student(\"name\", 10));`\n\n   这里重写了 equals(this == obj) 方法\n\n```java\n @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if(obj instanceof Student){\n            Student s = (Student)obj;\n            //4 比较属性\n            return this.name.equals(s.getName()) && this.age == s.getAge();\n        }\n        return false;\n    }\n```\n\n3. 遍历元素【重点】\n\n   1. 迭代器\n\n   ```java\n   Iterator it = arrayList.iterator();\n   while(it.hasNext()){\n     Student s = (Student)it.next(); //强转\n   }\n   ```\n\n   2. 列表迭代器\n\n   ```java\n   ListIterator li = arrayList.listIterator();\n   while(li.hasNext()){\n     Student s = (Student)li.next(); //从前往后遍历\n   }\n\n   while(li.hasPrevious()){\n     Student s = (Student)li.previous();//从后往前遍历\n   }\n   ```\n\n4. ArrayList 源码分析\n\n   1. `private static final int DEFAULT_CAPACITY = 10;` //默认容量 10；\n\n      注意：如果没有向集合中添加任何元素时，容量 0，添加一个后，容量为 10；\n\n      每次扩容是原来的 1.5 倍；\n\n   2. `private static final Object[] EMPTY_ELEMENTDATA = {};` 存放元素的数组；\n\n   3. `private int size;` 实际元素个数，一定小于容量；\n\n### Vector 类\n\n1. 创建集合 `Vector vector = new Vector<>();`\n2. 增加、删除、判断同上与 list 相同\n3. 遍历中枚举器遍历\n\n```java\nEnumeration en = vector.elements();\nwhile(en.hasMoreElements()){\n  String o = (String)en.nextElement();\n  sout(o);\n}\n```\n\n### LinkedList\n\n1. ArrayLsit [重点]：\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.2 版本，运行效率快，线程不安全。\n\n2. Vector:\n\n   1. 数组结构实现，查询快，增删慢；\n   2. JDK1.0 版本，运行效率慢，线程安全。\n\n3. LinkedList：\n\n   1. 链表结构实现，增删快，查询慢。\n\n4. ```java\n   LinkedList linkedList = new LinkedList();\n   ```\n\n5. 主要方法与 ArrayList()相同；遍历方法，for, Iterator;\n\n## 泛型\n\n1. 本质是参数化类型，把类型作为参数传递\n2. 常见形式有泛型类、泛型接口、泛型方法\n3. 语法<T> <T, V> T 成为类型占位符，表示一种引用类型，可以写多个逗号隔开\n4. 好处\n   1. 提高代码重用性\n   2. 防止类型转换异常，提高代码安全性\n\n### 泛型类\n\n```java\n/**\n * 泛型类\n * T是类型占位符，表示一种引用类型，如果编写多个使用逗号隔开\n */\npublic class MyGeneric<T> {\n    T t;\n    public void show(T t) {\n        System .out.println(t);\n    }\n    public T getT() {\n        return t;\n    }\n}\n\n```\n\n```java\n\t\tMyGeneric<String> myGeneric = new MyGeneric<String>();\n        myGeneric.t = \"hello\";\n        myGeneric.show(\"大家好，加油\");\n        String str = myGeneric.getT();\n        System.out.println(str);\n\n        MyGeneric<Integer> myGeneric2 = new MyGeneric<>();\n        myGeneric2.t = 100;\n        myGeneric2.show(200);\n        Integer integer = myGeneric2.getT();\n        System.out.println(integer);\n```\n\n### 泛型接口\n\n```java\n/**\n * 泛型接口\n * 语法, 接口名<T>\n * 注意，不能泛型静态常量\n */\npublic interface MyInterface<T> {\n    String name = \"张三\";\n\n    T server(T t);\n}\n```\n\n```java\npublic class MyInterfaceImpl implements MyInterface<String> {\n\n    @Override\n    public String server(String t) {\n        System.out.println(t);\n        return t;\n    }\n}\n\n```\n\n```java\npublic class MyInterfanceImpl2<T> implements MyInterface<T> {\n\n    @Override\n    public T server(T t) {\n        System.out.println(t);\n        return t;\n    }\n}\n```\n\n```java\n\t\t//myinterface\n        MyInterfaceImpl impl = new MyInterfaceImpl();\n        impl.server(\"xxxxxxxxxx\");\n\n        //myinterfaceimpl2\n        MyInterfanceImpl2<Integer> impl2 = new MyInterfanceImpl2<>();\n        impl2.server(1000);\n        MyInterfanceImpl2<String> impl3 = new MyInterfanceImpl2<>();\n        impl3.server(\"ccccccccccc\");\n```\n\n### 泛型方法\n\n```java\n/**\n * 泛型方法\n * 语法： <T> 返回值类型\n */\n\npublic class MyGenericMethod {\n    public <T> T show(T t) {\n        System.out.println(\"泛型方法\" + t);\n        return t;\n    }\n}\n```\n\n```java\n        //泛型方法\n        MyGenericMethod myGenericMethod = new MyGenericMethod();\n        myGenericMethod.show(\"bbbb\");\n        myGenericMethod.show(200);\n        myGenericMethod.show(1.23);\n```\n\n### 泛型集合\n\n概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致\n\n特点：\n\n1. 编译时即可检查，而非运行时抛出异常\n2. 访问时，不必类型转换（拆箱）\n3. 不同泛型之间应用不能相互赋值，泛型不存在多态\n\n```java\n\t\tArrayList<String> arrayList = new ArrayList<String>();\n        arrayList.add(\"xxx\");\n        arrayList.add(\"yyy\");\n\n        for (String s : arrayList) {\n            System.out.println(s.toString());\n        }\n\n        ArrayList<Student> arrayList2 = new ArrayList<>();\n        Student s1 = new Student(\"刘德华\", 20);\n        Student s2 = new Student(\"郭富城\", 21);\n        Student s3 = new Student(\"梁朝伟\", 22);\n        arrayList2.add(s1);\n        arrayList2.add(s2);\n        arrayList2.add(s3);\n\n        Iterator iterator = arrayList2.listIterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n```\n\n## Set 集合\n\n1. 特点：无序，无下标、元素不可重复；\n2. 方法：全部继承自 Collection 中的方法；\n3. 增、删、遍历、判断与 collection 相同；\n\n```java\n\t\tSet<String> set = new HashSet<>();\n        //1. 添加数据\n        set.add(\"小米\");\n        set.add(\"华为\");\n        set.add(\"苹果\");\n        System.out.println(\"数据个数:\" + set.size());\n        System.out.println(set.toString());\n        //2 删除数据\n\t\t//set.remove(\"小米\");\n        System.out.println(\"----------------增强for--------------\");\n        for (String s : set) {\n            System.out.println(s);\n        }\n        System.out.println(\"----------------迭代器--------------\");\n        Iterator<String> iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n```\n\n### Set 实现类\n\n#### HashSet[重点]：\n\n1. 无序，基于 HashCode 实现元素不重复；\n2. 当存入元素的哈希码相同时，会调用 equals 进行确认，如结果为 true，则拒绝后者存入；\n\n存储结构：哈希表（数组+链表+红黑树）\n\n存储过程（重复依据）\n\n1. 根据 hashCode 计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步\n\n2. 再执行 equals 方法，如果 equals 为 true，则认为是重复，否则形成链表\n\n   基于 HashCode 计算元素存放位置\n\n   1. 利用 31 这个质数，减少散列冲突\n\n      31 提高执行效率 `31 * i = (i << 5) - i` 转为移位操作\n\n   2. 当存入元素的哈希码相同时，会调用 equals 进行确认，如果结果为 true，则拒绝后者存入\n\n```java\n public static void main(String[] args) {\n        HashSet<String> hashSet = new HashSet<>();\n\n        hashSet.add(\"刘德华\");\n        hashSet.add(\"郭富城\");\n        hashSet.add(\"梁朝伟\");\n\n        System.out.println(\"元素个数：\" + hashSet.size());\n        System.out.println(hashSet.toString());\n        //删除元素\n//        hashSet.remove(\"刘德华\");\n        //增强for\n        System.out.println(\"---------------增强for-----------------\");\n        for (String s : hashSet) {\n            System.out.println(s);\n        }\n\n        System.out.println(\"---------------迭代器-----------------\");\n        Iterator it= hashSet.iterator();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n```\n\n```java\n//重写equals + hashCode\n     @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &&\n                name.equals(person.name);\n    }\n\n   @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    }\n```\n\n#### TreeSet:\n\n1. 基于排列顺序实现元素不重复；\n\n2. 实现了 sortedset 接口，对集合元素自动排序；\n\n3. 元素对象的类型必须实现，Comparable 接口，指定排序规则；\n\n4. 通过 CompareTo 方法确定是否为重复元素；\n\n5. 存储结构：红黑树\n\n6. 创建集合 `TreeSet<String> treeSet = new TreeSet<>()`\n\n   添加元素 `treeSet.add();`\n\n   删除元素 `treeSet.remove();`\n\n   遍历 1. 增强 for 2. 迭代器\n\n   判断 `treeSet.contains();`\n\n7. 补充： TreeSet 集合的使用\n\n   1. Comparator 实现定制比较（比较器）\n   2. Comparable 可比较的\n\n   ```java\n   TreeSet<Person> persons = new TreeSet<>(new Comparator<Person>() {\n               @Override\n               public int compare(Person o1, Person o2) {\n                   int n1 = o1.getAge() - o2.getAge();\n                   int n2 = o1.getName().compareTo(o2.getName());\n                   return n1 == 0 ? n2 : n1;\n               }\n           });\n   ```\n\n8. TreeSet 案例:\n\n   - 要求使用 TreeSet 集合实现字符串按照长度进行排序；\n   - 实现方法：重写 Comparator 的 compare 方法\n\n```java\n /**\n     * 要求使用TreeSet 集合实现字符串按照长度进行排序；\n     * helloWord  zhang  lisi  wangwu  beijing  xian  nanjing\n     * @authoe sx\n     */\n    public static void main(String[] args) {\n        TreeSet treeSet = new TreeSet<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                int n1 = o1.length()-o2.length();\n                int n2 = o1.compareTo(o2);\n                return n1==0?n2:n1;\n            }\n        });\n        //添加数据\n        treeSet.add(\"helloWord\");\n        treeSet.add(\"zhang\");\n        treeSet.add(\"lisi\");\n        treeSet.add(\"wangwu\");\n        treeSet.add(\"beijing\");\n        treeSet.add(\"xian\");\n        treeSet.add(\"nanjing\");\n        System.out.println(treeSet.toString());\n\n    }\n\n[lisi, xian, zhang, wangwu, beijing, nanjing, helloWord]\n```\n\n## Map\n\n1. 特点：存储一对数据（Key, Value），无序、无下标，键不可以重复，值可重复；\n2. 方法：\n   1. V put(K key, V value) 将对象存到集合中，关联键值 ;\n   2. Object get(Object key) 根据键获得对应的值 ;\n   3. Set<K> 返回所有的 Key;\n   4. Collection<V> values() 返回包含所有值的 Collection 集合;\n   5. Set<Map.Entry<K, V>> 键值匹配的 Set 集合;\n\n### Map 接口的使用：\n\n两种遍历方法：\n\n1. keySet()把 map 中的 key 存在 set 集合中；entrySet()把（key，value）封装成一个 entry 类型（映射对）；\n2. entrySet()效率高于 keySet()方法；因为 entrySet 一次性把 key，value 取出。\n\n```java\npublic static void main(String[] args) {\n        //创建Map集合\n        Map<String, String> map = new HashMap<>();\n\n        map.put(\"cn\", \"中国\");\n        map.put(\"uk\", \"英国\");\n        map.put(\"fc\", \"法国\");\n        map.put(\"gm\", \"德国\");\n\n        System.out.println(\"元素个数：\" + map.size());\n        System.out.println(map.toString());\n\n        //删除\n//        map.remove(\"fc\");\n//        System.out.println(map.toString());\n\n        //遍历\n        //使用keySet()方法\n        System.out.println(\"----------keySet---------------\");\n        Set<String> keySet = map.keySet();\n        for (String key : keySet) {\n            System.out.println(key + \":\" + map.get(key));\n        }\n        System.out.println(\"----------entrySet---------------\");\n//        使用entrySet方法\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        for (Map.Entry<String, String> entry : entries) {\n            System.out.println(entry.getKey() + \":\" + entry.getValue());\n        }\n    }\n```\n\n### HashMap[重点]\n\nJDK1.2 版本，线程不安全，运行效率快，允许用 null 作为 key 或是 value。\n\n存储结构：哈希表（数组+链表+红黑树）\n\n使用 key 可使 hashcode 和 equals 作为重复\n\n增、删、遍历、判断与上述一致\n\nHashMap 常用方法：alt + insert 重写 equals 和 hashcode 去掉重复项；\n\n```java\npublic static void main(String[] args) {\n        //创建集合\n        HashMap<Student, String> students = new HashMap<>();\n        //添加元素\n        Student s1 = new Student(\"孙悟空\", 100);\n        Student s2 = new Student(\"猪八戒\", 101);\n        Student s3 = new Student(\"沙和尚\", 102);\n        students.put(s1, \"花果山\");\n        students.put(s2, \"黑风洞\");\n        students.put(s3, \"流沙河\");\n        students.put(s3, \"流沙河\");\n        students.put(new Student(\"沙和尚\", 102), \"流沙河\");\n        System.out.println(students.size());\n        System.out.println(students.toString());\n\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(\"删除之后：\" + students.size());\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //遍历\n        for (Student key : students.keySet()) {\n            System.out.println(key.toString() + \":\" + students.get(key));\n        }\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //使用entrySet()\n        for (Map.Entry<Student, String> studentStringEntry : students.entrySet()) {\n            System.out.println(studentStringEntry.getKey() + \":\" + studentStringEntry.getValue());\n        }\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(\"流沙河\"));\n    }\n```\n\n### HashMap 源码分析：\n\n1. `static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;` //默认初始容量大小\n\n   1 左移 4 位 = 2^4 = 16，底层移位计算最快；\n\n2. `static final int MAXIMUM_CAPACITY = 1 << 30;` //最大容量大小；\n\n3. `DEFAULT_LOAD_FACTOR` //默认加载因子；\n\n4. `static final int TREEIFY_THRESHOLD = 8;`\n\n   `static final int MIN_TREEIFY_CAPACITY = 64;` //链表长度大于 8，数组长度大于 64 时存储结构改为红黑树；\n\n5. `static final int UNTREEIFY_THRESHOLD = 6;` //链表长度小于 6，变回链表结构\n\n**源码分析总结**：\n\n1. HashMap 刚创建时，table 是 null，节省空间，当添加第一个元素时，table 容量调整为 16\n2. 当元素个数大于阈值 75%（16\\*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数\n3. jdk1.8 当每个链表长度 >8 ，并且数组元素个数 ≥64 时，会调整成红黑树，目的是提高效率\n4. jdk1.8 当链表长度 <6 时 调整成链表\n5. jdk1.8 以前，链表是头插入，之后为尾插入\n\n### Hashtable\n\n​ JDK1.0 版本，线程安全，运行效率慢，不允许 NULL 作为 key 或是 value。\n\n​ 基本不用。\n\n### Properties\n\n​ Hashtable 的子类，需要 key 和 value 都是 String。在流中使用较多，通常用于配置文件的读取。在流的学习中进行使用。\n\n```java\npublic static void main(String[] args) {\n        //创建集合\n        Properties properties = new Properties();\n        //添加数据\n        properties.setProperty(\"username\", \"zhangsan\");\n        properties.setProperty(\"age\", \"20\");\n        System.out.println(properties);\n\n        //遍历\n        //keyset\n        for (Object o : properties.keySet()) {\n            System.out.println(o);\n        }\n\n        //entrySet\n        for (Map.Entry<Object, Object> objectObjectEntry : properties.entrySet()) {\n            System.out.println(objectObjectEntry);\n        }\n\n        //stringPropertyName\n        for (String stringPropertyName : properties.stringPropertyNames()) {\n            System.out.println(stringPropertyName + \":\" + properties.getProperty(stringPropertyName));\n        }\n    }\n```\n\n#### 和流有关的方法\n\n```java\n//和流有关的方法\n        PrintWriter pw = new PrintWriter(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties\");\n        properties.list(pw);\n        pw.close();\n```\n\n#### store 方法\n\n```java\nFileOutputStream fos = new FileOutputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties\");\n        properties.store(fos, \"注释\");\n        fos.close();\n\n结果：\n#\\u6CE8\\u91CA    properties文件不允许中文\n#Sat Apr 10 01:08:21 CST 2021\nage=20\nusername=zhangsan\n\n```\n\n#### load 方法\n\n```java\n//        load方法\n        Properties properties2 = new Properties();\n        FileInputStream fis = new FileInputStream(\"D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\\\\\print.properties\");\n        properties2.load(fis);\n        fis.close();\n        System.out.println(properties2.toString());\n```\n\n### TreeMap\n\n​ 实现了 SortedMap 接口（是 map 的子接口），可以对 key 自动排序\n\n```java\npublic static void main(String[] args) {\n        TreeMap<Student, String> students = new TreeMap<>();\n        Student s1 = new Student(\"孙悟空\", 103);\n        Student s2 = new Student(\"猪八戒\", 101);\n        Student s3 = new Student(\"沙和尚\", 102);\n        students.put(s1, \"花果山\");\n        students.put(s2, \"黑风洞\");\n        students.put(s3, \"流沙河\");\n        students.put(s3, \"流沙河\");\n        students.put(new Student(\"沙和尚\", 102), \"流沙河\");\n        System.out.println(students.size());\n        System.out.println(students.toString());\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(\"删除之后：\" + students.size());\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //遍历\n        for (Student key : students.keySet()) {\n            System.out.println(key.toString() + \":\" + students.get(key));\n        }\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //使用entrySet()\n        for (Map.Entry<Student, String> studentStringEntry : students.entrySet()) {\n            System.out.println(studentStringEntry.getKey() + \":\" + studentStringEntry.getValue());\n        }\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(\"流沙河\"));\n\n    }\n```\n\n定制比较器：重写 compare 方法:\n\n可以自定义规则\n\n```java\nTreeMap<Student, String> students = new TreeMap(new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            }\n        });\n```\n\n## Collection 工具类\n\n​ 概念：集合工具类，定义了除了存取以外的集合常用方法；\n\n​ 1. 排序 `Collections.sort()`\n\n​ 2. 直接二分查找`int i = Collections.binarySearch(list, x);` 成功返回索引；\n\n​ 其他方法 ：\n\n复制`Collections.copy(dest, list);`\n\n​ 反转`Collections.reverse(list);`\n\n​ 打乱`ollections.shuffle(list);`\n\n```java\npublic static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(20);\n        list.add(3);\n        list.add(14);\n        list.add(50);\n        list.add(36);\n        //排序\n        System.out.println(\"排序之前---\" + list.toString());\n        Collections.sort(list);\n        System.out.println(\"排序之后---\" + list.toString());\n\n        int i = Collections.binarySearch(list, 3);\n        System.out.println(\"第\" + i + \"位\");\n\n        List<Integer> dest = new ArrayList<>();\n        //开辟空间，否则dest为空，无法直接copy放入\n        for (int j = 0; j < list.size(); j++) {\n            dest.add(0);\n        }\n        Collections.copy(dest, list);\n        System.out.println(dest.toString());\n\n        //翻转\n        Collections.reverse(list);\n        System.out.println(list);\n\n        //打乱\n        Collections.shuffle(list);\n        System.out.println(list);\n    }\n```\n\n​ 补充：\n\n```java\n// list转成数组\nInteger[] arr = list.toArray(new Integer[10]);\nsout(arr.length);\nsout(Array.toString(arr));\n\n// 数组转成集合\n// 此时为受限集合，不能 添加和删除！\nString[] name = {\"张三\",\"李四\",\"王五\"};\nList<String> list2 = Arrays.asList(names);\n\n// 把基本类型数组转为集合时，需要修改为包装类\nInteger[] nums = {100, 200, 300, 400, 500};\nList<Integer> list3 = Arrays.asList(nums);\n```\n","slug":"JAVA-集合框架-20210418","published":1,"updated":"2022-06-14T04:09:00.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1i001dy4w19mzkei3j","content":"<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><span id=\"more\"></span>\n\n<h2 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h2><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>​ 对象的容器，实现了对对象常用的操作</p>\n<h4 id=\"和数组的区别\"><a href=\"#和数组的区别\" class=\"headerlink\" title=\"和数组的区别\"></a>和数组的区别</h4><ol>\n<li>数组长度固定，集合长度不固定</li>\n<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>\n</ol>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>​ java.util.*;包</p>\n<h2 id=\"collection-体系\"><a href=\"#collection-体系\" class=\"headerlink\" title=\"collection 体系\"></a>collection 体系</h2><p><img src=\"img/article/JAVA-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-20210418/image-20210407105452970.png\" alt=\"image-20210407105452970\"></p>\n<h2 id=\"Collection-父接口\"><a href=\"#Collection-父接口\" class=\"headerlink\" title=\"Collection 父接口\"></a>Collection 父接口</h2><p>特点：代表一组任意类型的对象，无序、无下标、不能重复。</p>\n<p>创建集合 <code>Collection collection = new ArrayList();</code></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ol>\n<li>collection.add(Object obj); 添加一个对象；</li>\n<li>adddAll(Collection c) ；//将一个集合中的所有对象添加到此集合中；</li>\n<li>void clear(); 清空此集合中的所有对象；</li>\n<li>contains(Object obj); //检查此集合中是否包含 o 对象；</li>\n<li>equals(Object obj); //比较此集合中是否包含 o 对象；</li>\n<li>isEmpty(); 判断此集合是否为空；</li>\n<li>remove(Object obj); //在此集合中移除 o 对象；</li>\n<li>int size(); //返回此集合中的元素个数；</li>\n<li>Object[] toArray(); //将此集合转换成数组 ；</li>\n</ol>\n<p>遍历元素（重点）</p>\n<ol>\n<li><p>增强 for（因为无下标）</p>\n<p> <code>or(Object object : collection)&#123; &#125;</code></p>\n</li>\n<li><p>使用迭代器</p>\n<pre><code class=\"java\">//haNext(); 有没有下一个元素\n//next(); 获取下一个元素\n//remove(); 删除当前元素\nIterator it = collection.iterator();\nwhile (it.hasNext()) &#123;\n    String s = (String) it.next();\n    System.out.println(s);\n    // 可以使用it.remove(); 进行移除元素\n    // collection.remove(); 不能用collection其他方法 会报并发修改异常\n</code></pre>\n</li>\n<li><p>列表迭代器</p>\n<pre><code class=\"java\"> List list = new ArrayList();\n        list.add(&quot;aaa&quot;);\n        list.add(&quot;bbb&quot;);\n        list.add(&quot;ccc&quot;);\n        ListIterator li = list.listIterator();\n        while(li.hasNext())&#123;\n            System.out.println(li.nextIndex() + &quot;:&quot; + li.next()); //从前往后遍历\n        &#125;\n\n        while(li.hasPrevious())&#123;\n            System.out.println(li.previousIndex() + &quot;:&quot; + li.previous()); //从后往前遍历\n        &#125;\n</code></pre>\n</li>\n</ol>\n<h3 id=\"List-子接口\"><a href=\"#List-子接口\" class=\"headerlink\" title=\"List 子接口\"></a>List 子接口</h3><ol>\n<li>特点：有序，有下标，元素可以重复；</li>\n<li>方法：<ol>\n<li>list.add(int index, Object o) //在 index 位置插入对象 o</li>\n<li>list.addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的 index 位置</li>\n<li>list.get(int index) //返回集合中指定位置的元素</li>\n<li>list.remove(Object o) list.remove(index) //删除集合中指定元素或指定位置的元素</li>\n<li>list,isEmpty() //判断是否为空</li>\n<li>list.subList(int fromIndex, int toIndex) //返回 fromindex 和 toindex 之间的集合元素，含头不含尾</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        List list = new ArrayList&lt;&gt;();\n\n        list.add(&quot;apple&quot;);\n        list.add(&quot;xiaomi&quot;);\n        list.add(&quot;huawei&quot;);\n        System.out.println(&quot;元素个数:&quot;+ list.size());\n        System.out.println(list.toString());\n\n//        list.remove(&quot;xiaomi&quot;);\n//        System.out.println(&quot;元素个数:&quot;+ list.size());\n//        list.remove(0);\n//        System.out.println(&quot;元素个数:&quot;+ list.size());\n\n        System.out.println(&quot;----------------for遍历-------------------&quot;);\n        for (int i = 0; i &lt; list.size(); i++) &#123;\n            System.out.println(list.get(i));\n        &#125;\n        System.out.println(&quot;----------------增强for-------------------&quot;);\n        for (Object o : list) &#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(&quot;----------------使用迭代器进行遍历-------------------&quot;);\n        Iterator it1 = list.iterator();\n        while (it1.hasNext())&#123;\n            System.out.println(it1.next());\n        &#125;\n        System.out.println(&quot;----------------使用列表迭代器进行正序遍历-------------------&quot;);\n        ListIterator it2 = list.listIterator();\n        while (it2.hasNext())&#123;\n            System.out.println(it2.next());\n        &#125;\n\n        //从后向前\n        System.out.println(&quot;----------------使用列表迭代器进行逆序遍历-------------------&quot;);\n        while (it2.hasPrevious())&#123;\n            System.out.println(it2.previous());\n        &#125;\n\n        System.out.println(&quot;-----------------------------------------------------------&quot;);\n        //判断是否存在\n        System.out.println(list.contains(&quot;xiaomi&quot;));\n        //判断是否为空\n        System.out.println(list.isEmpty());\n    System.out.println(&quot;-----------------------------------------------------------&quot;);\n        //指定位置输出,含头不含尾\n        System.out.println(list.subList(1,2));\n\n    &#125;\n</code></pre>\n<h3 id=\"List-实现类\"><a href=\"#List-实现类\" class=\"headerlink\" title=\"List 实现类\"></a>List 实现类</h3><ol>\n<li><p>ArrayLsit [重点]：</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.2 版本，运行效率快，线程不安全。</li>\n</ol>\n</li>\n<li><p>Vector:</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.0 版本，运行效率慢，线程安全。</li>\n</ol>\n</li>\n<li><p>LinkedList：</p>\n<ol>\n<li>链表结构实现，增删快，查询慢。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"ArrayList-的使用\"><a href=\"#ArrayList-的使用\" class=\"headerlink\" title=\"ArrayList 的使用\"></a>ArrayList 的使用</h3><p>创建集合 <code>ArrayList arrayList = new ArrayList&lt;&gt;();</code></p>\n<ol>\n<li><p>添加元素 <code>arrayList.add();</code></p>\n</li>\n<li><p>删除元素 <code>arrayList.remove(new Student(&quot;name&quot;, 10));</code></p>\n<p>这里重写了 equals(this == obj) 方法</p>\n</li>\n</ol>\n<pre><code class=\"java\"> @Override\n    public boolean equals(Object obj) &#123;\n        if (this == obj) &#123;\n            return true;\n        &#125;\n        if (obj == null) &#123;\n            return false;\n        &#125;\n        if(obj instanceof Student)&#123;\n            Student s = (Student)obj;\n            //4 比较属性\n            return this.name.equals(s.getName()) &amp;&amp; this.age == s.getAge();\n        &#125;\n        return false;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li><p>遍历元素【重点】</p>\n<ol>\n<li>迭代器</li>\n</ol>\n<pre><code class=\"java\">Iterator it = arrayList.iterator();\nwhile(it.hasNext())&#123;\n  Student s = (Student)it.next(); //强转\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>列表迭代器</li>\n</ol>\n<pre><code class=\"java\">ListIterator li = arrayList.listIterator();\nwhile(li.hasNext())&#123;\n  Student s = (Student)li.next(); //从前往后遍历\n&#125;\n\nwhile(li.hasPrevious())&#123;\n  Student s = (Student)li.previous();//从后往前遍历\n&#125;\n</code></pre>\n</li>\n<li><p>ArrayList 源码分析</p>\n<ol>\n<li><p><code>private static final int DEFAULT_CAPACITY = 10;</code> //默认容量 10；</p>\n<p>注意：如果没有向集合中添加任何元素时，容量 0，添加一个后，容量为 10；</p>\n<p>每次扩容是原来的 1.5 倍；</p>\n</li>\n<li><p><code>private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</code> 存放元素的数组；</p>\n</li>\n<li><p><code>private int size;</code> 实际元素个数，一定小于容量；</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Vector-类\"><a href=\"#Vector-类\" class=\"headerlink\" title=\"Vector 类\"></a>Vector 类</h3><ol>\n<li>创建集合 <code>Vector vector = new Vector&lt;&gt;();</code></li>\n<li>增加、删除、判断同上与 list 相同</li>\n<li>遍历中枚举器遍历</li>\n</ol>\n<pre><code class=\"java\">Enumeration en = vector.elements();\nwhile(en.hasMoreElements())&#123;\n  String o = (String)en.nextElement();\n  sout(o);\n&#125;\n</code></pre>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><ol>\n<li><p>ArrayLsit [重点]：</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.2 版本，运行效率快，线程不安全。</li>\n</ol>\n</li>\n<li><p>Vector:</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.0 版本，运行效率慢，线程安全。</li>\n</ol>\n</li>\n<li><p>LinkedList：</p>\n<ol>\n<li>链表结构实现，增删快，查询慢。</li>\n</ol>\n</li>\n<li><pre><code class=\"java\">LinkedList linkedList = new LinkedList();\n</code></pre>\n</li>\n<li><p>主要方法与 ArrayList()相同；遍历方法，for, Iterator;</p>\n</li>\n</ol>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ol>\n<li>本质是参数化类型，把类型作为参数传递</li>\n<li>常见形式有泛型类、泛型接口、泛型方法</li>\n<li>语法<T> &lt;T, V&gt; T 成为类型占位符，表示一种引用类型，可以写多个逗号隔开</li>\n<li>好处<ol>\n<li>提高代码重用性</li>\n<li>防止类型转换异常，提高代码安全性</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h3><pre><code class=\"java\">/**\n * 泛型类\n * T是类型占位符，表示一种引用类型，如果编写多个使用逗号隔开\n */\npublic class MyGeneric&lt;T&gt; &#123;\n    T t;\n    public void show(T t) &#123;\n        System .out.println(t);\n    &#125;\n    public T getT() &#123;\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        MyGeneric&lt;String&gt; myGeneric = new MyGeneric&lt;String&gt;();\n        myGeneric.t = &quot;hello&quot;;\n        myGeneric.show(&quot;大家好，加油&quot;);\n        String str = myGeneric.getT();\n        System.out.println(str);\n\n        MyGeneric&lt;Integer&gt; myGeneric2 = new MyGeneric&lt;&gt;();\n        myGeneric2.t = 100;\n        myGeneric2.show(200);\n        Integer integer = myGeneric2.getT();\n        System.out.println(integer);\n</code></pre>\n<h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h3><pre><code class=\"java\">/**\n * 泛型接口\n * 语法, 接口名&lt;T&gt;\n * 注意，不能泛型静态常量\n */\npublic interface MyInterface&lt;T&gt; &#123;\n    String name = &quot;张三&quot;;\n\n    T server(T t);\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class MyInterfaceImpl implements MyInterface&lt;String&gt; &#123;\n\n    @Override\n    public String server(String t) &#123;\n        System.out.println(t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class MyInterfanceImpl2&lt;T&gt; implements MyInterface&lt;T&gt; &#123;\n\n    @Override\n    public T server(T t) &#123;\n        System.out.println(t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        //myinterface\n        MyInterfaceImpl impl = new MyInterfaceImpl();\n        impl.server(&quot;xxxxxxxxxx&quot;);\n\n        //myinterfaceimpl2\n        MyInterfanceImpl2&lt;Integer&gt; impl2 = new MyInterfanceImpl2&lt;&gt;();\n        impl2.server(1000);\n        MyInterfanceImpl2&lt;String&gt; impl3 = new MyInterfanceImpl2&lt;&gt;();\n        impl3.server(&quot;ccccccccccc&quot;);\n</code></pre>\n<h3 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h3><pre><code class=\"java\">/**\n * 泛型方法\n * 语法： &lt;T&gt; 返回值类型\n */\n\npublic class MyGenericMethod &#123;\n    public &lt;T&gt; T show(T t) &#123;\n        System.out.println(&quot;泛型方法&quot; + t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        //泛型方法\n        MyGenericMethod myGenericMethod = new MyGenericMethod();\n        myGenericMethod.show(&quot;bbbb&quot;);\n        myGenericMethod.show(200);\n        myGenericMethod.show(1.23);\n</code></pre>\n<h3 id=\"泛型集合\"><a href=\"#泛型集合\" class=\"headerlink\" title=\"泛型集合\"></a>泛型集合</h3><p>概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致</p>\n<p>特点：</p>\n<ol>\n<li>编译时即可检查，而非运行时抛出异常</li>\n<li>访问时，不必类型转换（拆箱）</li>\n<li>不同泛型之间应用不能相互赋值，泛型不存在多态</li>\n</ol>\n<pre><code class=\"java\">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();\n        arrayList.add(&quot;xxx&quot;);\n        arrayList.add(&quot;yyy&quot;);\n\n        for (String s : arrayList) &#123;\n            System.out.println(s.toString());\n        &#125;\n\n        ArrayList&lt;Student&gt; arrayList2 = new ArrayList&lt;&gt;();\n        Student s1 = new Student(&quot;刘德华&quot;, 20);\n        Student s2 = new Student(&quot;郭富城&quot;, 21);\n        Student s3 = new Student(&quot;梁朝伟&quot;, 22);\n        arrayList2.add(s1);\n        arrayList2.add(s2);\n        arrayList2.add(s3);\n\n        Iterator iterator = arrayList2.listIterator();\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n</code></pre>\n<h2 id=\"Set-集合\"><a href=\"#Set-集合\" class=\"headerlink\" title=\"Set 集合\"></a>Set 集合</h2><ol>\n<li>特点：无序，无下标、元素不可重复；</li>\n<li>方法：全部继承自 Collection 中的方法；</li>\n<li>增、删、遍历、判断与 collection 相同；</li>\n</ol>\n<pre><code class=\"java\">        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n        //1. 添加数据\n        set.add(&quot;小米&quot;);\n        set.add(&quot;华为&quot;);\n        set.add(&quot;苹果&quot;);\n        System.out.println(&quot;数据个数:&quot; + set.size());\n        System.out.println(set.toString());\n        //2 删除数据\n        //set.remove(&quot;小米&quot;);\n        System.out.println(&quot;----------------增强for--------------&quot;);\n        for (String s : set) &#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(&quot;----------------迭代器--------------&quot;);\n        Iterator&lt;String&gt; iterator = set.iterator();\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n</code></pre>\n<h3 id=\"Set-实现类\"><a href=\"#Set-实现类\" class=\"headerlink\" title=\"Set 实现类\"></a>Set 实现类</h3><h4 id=\"HashSet-重点-：\"><a href=\"#HashSet-重点-：\" class=\"headerlink\" title=\"HashSet[重点]：\"></a>HashSet[重点]：</h4><ol>\n<li>无序，基于 HashCode 实现元素不重复；</li>\n<li>当存入元素的哈希码相同时，会调用 equals 进行确认，如结果为 true，则拒绝后者存入；</li>\n</ol>\n<p>存储结构：哈希表（数组+链表+红黑树）</p>\n<p>存储过程（重复依据）</p>\n<ol>\n<li><p>根据 hashCode 计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步</p>\n</li>\n<li><p>再执行 equals 方法，如果 equals 为 true，则认为是重复，否则形成链表</p>\n<p>基于 HashCode 计算元素存放位置</p>\n<ol>\n<li><p>利用 31 这个质数，减少散列冲突</p>\n<p>31 提高执行效率 <code>31 * i = (i &lt;&lt; 5) - i</code> 转为移位操作</p>\n</li>\n<li><p>当存入元素的哈希码相同时，会调用 equals 进行确认，如果结果为 true，则拒绝后者存入</p>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\"> public static void main(String[] args) &#123;\n        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();\n\n        hashSet.add(&quot;刘德华&quot;);\n        hashSet.add(&quot;郭富城&quot;);\n        hashSet.add(&quot;梁朝伟&quot;);\n\n        System.out.println(&quot;元素个数：&quot; + hashSet.size());\n        System.out.println(hashSet.toString());\n        //删除元素\n//        hashSet.remove(&quot;刘德华&quot;);\n        //增强for\n        System.out.println(&quot;---------------增强for-----------------&quot;);\n        for (String s : hashSet) &#123;\n            System.out.println(s);\n        &#125;\n\n        System.out.println(&quot;---------------迭代器-----------------&quot;);\n        Iterator it= hashSet.iterator();\n        while (it.hasNext()) &#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//重写equals + hashCode\n     @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n                name.equals(person.name);\n    &#125;\n\n   @Override\n    public int hashCode() &#123;\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    &#125;\n</code></pre>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet:\"></a>TreeSet:</h4><ol>\n<li><p>基于排列顺序实现元素不重复；</p>\n</li>\n<li><p>实现了 sortedset 接口，对集合元素自动排序；</p>\n</li>\n<li><p>元素对象的类型必须实现，Comparable 接口，指定排序规则；</p>\n</li>\n<li><p>通过 CompareTo 方法确定是否为重复元素；</p>\n</li>\n<li><p>存储结构：红黑树</p>\n</li>\n<li><p>创建集合 <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;()</code></p>\n<p>添加元素 <code>treeSet.add();</code></p>\n<p>删除元素 <code>treeSet.remove();</code></p>\n<p>遍历 1. 增强 for 2. 迭代器</p>\n<p>判断 <code>treeSet.contains();</code></p>\n</li>\n<li><p>补充： TreeSet 集合的使用</p>\n<ol>\n<li>Comparator 实现定制比较（比较器）</li>\n<li>Comparable 可比较的</li>\n</ol>\n<pre><code class=\"java\">TreeSet&lt;Person&gt; persons = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() &#123;\n            @Override\n            public int compare(Person o1, Person o2) &#123;\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            &#125;\n        &#125;);\n</code></pre>\n</li>\n<li><p>TreeSet 案例:</p>\n<ul>\n<li>要求使用 TreeSet 集合实现字符串按照长度进行排序；</li>\n<li>实现方法：重写 Comparator 的 compare 方法</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"java\"> /**\n     * 要求使用TreeSet 集合实现字符串按照长度进行排序；\n     * helloWord  zhang  lisi  wangwu  beijing  xian  nanjing\n     * @authoe sx\n     */\n    public static void main(String[] args) &#123;\n        TreeSet treeSet = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;\n            @Override\n            public int compare(String o1, String o2) &#123;\n                int n1 = o1.length()-o2.length();\n                int n2 = o1.compareTo(o2);\n                return n1==0?n2:n1;\n            &#125;\n        &#125;);\n        //添加数据\n        treeSet.add(&quot;helloWord&quot;);\n        treeSet.add(&quot;zhang&quot;);\n        treeSet.add(&quot;lisi&quot;);\n        treeSet.add(&quot;wangwu&quot;);\n        treeSet.add(&quot;beijing&quot;);\n        treeSet.add(&quot;xian&quot;);\n        treeSet.add(&quot;nanjing&quot;);\n        System.out.println(treeSet.toString());\n\n    &#125;\n\n[lisi, xian, zhang, wangwu, beijing, nanjing, helloWord]\n</code></pre>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><ol>\n<li>特点：存储一对数据（Key, Value），无序、无下标，键不可以重复，值可重复；</li>\n<li>方法：<ol>\n<li>V put(K key, V value) 将对象存到集合中，关联键值 ;</li>\n<li>Object get(Object key) 根据键获得对应的值 ;</li>\n<li>Set<K> 返回所有的 Key;</li>\n<li>Collection<V> values() 返回包含所有值的 Collection 集合;</li>\n<li>Set&lt;Map.Entry&lt;K, V&gt;&gt; 键值匹配的 Set 集合;</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Map-接口的使用：\"><a href=\"#Map-接口的使用：\" class=\"headerlink\" title=\"Map 接口的使用：\"></a>Map 接口的使用：</h3><p>两种遍历方法：</p>\n<ol>\n<li>keySet()把 map 中的 key 存在 set 集合中；entrySet()把（key，value）封装成一个 entry 类型（映射对）；</li>\n<li>entrySet()效率高于 keySet()方法；因为 entrySet 一次性把 key，value 取出。</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建Map集合\n        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\n\n        map.put(&quot;cn&quot;, &quot;中国&quot;);\n        map.put(&quot;uk&quot;, &quot;英国&quot;);\n        map.put(&quot;fc&quot;, &quot;法国&quot;);\n        map.put(&quot;gm&quot;, &quot;德国&quot;);\n\n        System.out.println(&quot;元素个数：&quot; + map.size());\n        System.out.println(map.toString());\n\n        //删除\n//        map.remove(&quot;fc&quot;);\n//        System.out.println(map.toString());\n\n        //遍历\n        //使用keySet()方法\n        System.out.println(&quot;----------keySet---------------&quot;);\n        Set&lt;String&gt; keySet = map.keySet();\n        for (String key : keySet) &#123;\n            System.out.println(key + &quot;:&quot; + map.get(key));\n        &#125;\n        System.out.println(&quot;----------entrySet---------------&quot;);\n//        使用entrySet方法\n        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;\n            System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"HashMap-重点\"><a href=\"#HashMap-重点\" class=\"headerlink\" title=\"HashMap[重点]\"></a>HashMap[重点]</h3><p>JDK1.2 版本，线程不安全，运行效率快，允许用 null 作为 key 或是 value。</p>\n<p>存储结构：哈希表（数组+链表+红黑树）</p>\n<p>使用 key 可使 hashcode 和 equals 作为重复</p>\n<p>增、删、遍历、判断与上述一致</p>\n<p>HashMap 常用方法：alt + insert 重写 equals 和 hashcode 去掉重复项；</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建集合\n        HashMap&lt;Student, String&gt; students = new HashMap&lt;&gt;();\n        //添加元素\n        Student s1 = new Student(&quot;孙悟空&quot;, 100);\n        Student s2 = new Student(&quot;猪八戒&quot;, 101);\n        Student s3 = new Student(&quot;沙和尚&quot;, 102);\n        students.put(s1, &quot;花果山&quot;);\n        students.put(s2, &quot;黑风洞&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(new Student(&quot;沙和尚&quot;, 102), &quot;流沙河&quot;);\n        System.out.println(students.size());\n        System.out.println(students.toString());\n\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(&quot;删除之后：&quot; + students.size());\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //遍历\n        for (Student key : students.keySet()) &#123;\n            System.out.println(key.toString() + &quot;:&quot; + students.get(key));\n        &#125;\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //使用entrySet()\n        for (Map.Entry&lt;Student, String&gt; studentStringEntry : students.entrySet()) &#123;\n            System.out.println(studentStringEntry.getKey() + &quot;:&quot; + studentStringEntry.getValue());\n        &#125;\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(&quot;流沙河&quot;));\n    &#125;\n</code></pre>\n<h3 id=\"HashMap-源码分析：\"><a href=\"#HashMap-源码分析：\" class=\"headerlink\" title=\"HashMap 源码分析：\"></a>HashMap 源码分析：</h3><ol>\n<li><p><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code> //默认初始容量大小</p>\n<p>1 左移 4 位 = 2^4 = 16，底层移位计算最快；</p>\n</li>\n<li><p><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code> //最大容量大小；</p>\n</li>\n<li><p><code>DEFAULT_LOAD_FACTOR</code> //默认加载因子；</p>\n</li>\n<li><p><code>static final int TREEIFY_THRESHOLD = 8;</code></p>\n<p><code>static final int MIN_TREEIFY_CAPACITY = 64;</code> //链表长度大于 8，数组长度大于 64 时存储结构改为红黑树；</p>\n</li>\n<li><p><code>static final int UNTREEIFY_THRESHOLD = 6;</code> //链表长度小于 6，变回链表结构</p>\n</li>\n</ol>\n<p><strong>源码分析总结</strong>：</p>\n<ol>\n<li>HashMap 刚创建时，table 是 null，节省空间，当添加第一个元素时，table 容量调整为 16</li>\n<li>当元素个数大于阈值 75%（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li>\n<li>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64 时，会调整成红黑树，目的是提高效率</li>\n<li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li>\n<li>jdk1.8 以前，链表是头插入，之后为尾插入</li>\n</ol>\n<h3 id=\"Hashtable\"><a href=\"#Hashtable\" class=\"headerlink\" title=\"Hashtable\"></a>Hashtable</h3><p>​ JDK1.0 版本，线程安全，运行效率慢，不允许 NULL 作为 key 或是 value。</p>\n<p>​ 基本不用。</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><p>​ Hashtable 的子类，需要 key 和 value 都是 String。在流中使用较多，通常用于配置文件的读取。在流的学习中进行使用。</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建集合\n        Properties properties = new Properties();\n        //添加数据\n        properties.setProperty(&quot;username&quot;, &quot;zhangsan&quot;);\n        properties.setProperty(&quot;age&quot;, &quot;20&quot;);\n        System.out.println(properties);\n\n        //遍历\n        //keyset\n        for (Object o : properties.keySet()) &#123;\n            System.out.println(o);\n        &#125;\n\n        //entrySet\n        for (Map.Entry&lt;Object, Object&gt; objectObjectEntry : properties.entrySet()) &#123;\n            System.out.println(objectObjectEntry);\n        &#125;\n\n        //stringPropertyName\n        for (String stringPropertyName : properties.stringPropertyNames()) &#123;\n            System.out.println(stringPropertyName + &quot;:&quot; + properties.getProperty(stringPropertyName));\n        &#125;\n    &#125;\n</code></pre>\n<h4 id=\"和流有关的方法\"><a href=\"#和流有关的方法\" class=\"headerlink\" title=\"和流有关的方法\"></a>和流有关的方法</h4><pre><code class=\"java\">//和流有关的方法\n        PrintWriter pw = new PrintWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties&quot;);\n        properties.list(pw);\n        pw.close();\n</code></pre>\n<h4 id=\"store-方法\"><a href=\"#store-方法\" class=\"headerlink\" title=\"store 方法\"></a>store 方法</h4><pre><code class=\"java\">FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties&quot;);\n        properties.store(fos, &quot;注释&quot;);\n        fos.close();\n\n结果：\n#\\u6CE8\\u91CA    properties文件不允许中文\n#Sat Apr 10 01:08:21 CST 2021\nage=20\nusername=zhangsan\n</code></pre>\n<h4 id=\"load-方法\"><a href=\"#load-方法\" class=\"headerlink\" title=\"load 方法\"></a>load 方法</h4><pre><code class=\"java\">//        load方法\n        Properties properties2 = new Properties();\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\\\\\print.properties&quot;);\n        properties2.load(fis);\n        fis.close();\n        System.out.println(properties2.toString());\n</code></pre>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><p>​ 实现了 SortedMap 接口（是 map 的子接口），可以对 key 自动排序</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        TreeMap&lt;Student, String&gt; students = new TreeMap&lt;&gt;();\n        Student s1 = new Student(&quot;孙悟空&quot;, 103);\n        Student s2 = new Student(&quot;猪八戒&quot;, 101);\n        Student s3 = new Student(&quot;沙和尚&quot;, 102);\n        students.put(s1, &quot;花果山&quot;);\n        students.put(s2, &quot;黑风洞&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(new Student(&quot;沙和尚&quot;, 102), &quot;流沙河&quot;);\n        System.out.println(students.size());\n        System.out.println(students.toString());\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(&quot;删除之后：&quot; + students.size());\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //遍历\n        for (Student key : students.keySet()) &#123;\n            System.out.println(key.toString() + &quot;:&quot; + students.get(key));\n        &#125;\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //使用entrySet()\n        for (Map.Entry&lt;Student, String&gt; studentStringEntry : students.entrySet()) &#123;\n            System.out.println(studentStringEntry.getKey() + &quot;:&quot; + studentStringEntry.getValue());\n        &#125;\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(&quot;流沙河&quot;));\n\n    &#125;\n</code></pre>\n<p>定制比较器：重写 compare 方法:</p>\n<p>可以自定义规则</p>\n<pre><code class=\"java\">TreeMap&lt;Student, String&gt; students = new TreeMap(new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            &#125;\n        &#125;);\n</code></pre>\n<h2 id=\"Collection-工具类\"><a href=\"#Collection-工具类\" class=\"headerlink\" title=\"Collection 工具类\"></a>Collection 工具类</h2><p>​ 概念：集合工具类，定义了除了存取以外的集合常用方法；</p>\n<p>​ 1. 排序 <code>Collections.sort()</code></p>\n<p>​ 2. 直接二分查找<code>int i = Collections.binarySearch(list, x);</code> 成功返回索引；</p>\n<p>​ 其他方法 ：</p>\n<p>复制<code>Collections.copy(dest, list);</code></p>\n<p>​ 反转<code>Collections.reverse(list);</code></p>\n<p>​ 打乱<code>ollections.shuffle(list);</code></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        list.add(20);\n        list.add(3);\n        list.add(14);\n        list.add(50);\n        list.add(36);\n        //排序\n        System.out.println(&quot;排序之前---&quot; + list.toString());\n        Collections.sort(list);\n        System.out.println(&quot;排序之后---&quot; + list.toString());\n\n        int i = Collections.binarySearch(list, 3);\n        System.out.println(&quot;第&quot; + i + &quot;位&quot;);\n\n        List&lt;Integer&gt; dest = new ArrayList&lt;&gt;();\n        //开辟空间，否则dest为空，无法直接copy放入\n        for (int j = 0; j &lt; list.size(); j++) &#123;\n            dest.add(0);\n        &#125;\n        Collections.copy(dest, list);\n        System.out.println(dest.toString());\n\n        //翻转\n        Collections.reverse(list);\n        System.out.println(list);\n\n        //打乱\n        Collections.shuffle(list);\n        System.out.println(list);\n    &#125;\n</code></pre>\n<p>​ 补充：</p>\n<pre><code class=\"java\">// list转成数组\nInteger[] arr = list.toArray(new Integer[10]);\nsout(arr.length);\nsout(Array.toString(arr));\n\n// 数组转成集合\n// 此时为受限集合，不能 添加和删除！\nString[] name = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;\nList&lt;String&gt; list2 = Arrays.asList(names);\n\n// 把基本类型数组转为集合时，需要修改为包装类\nInteger[] nums = &#123;100, 200, 300, 400, 500&#125;;\nList&lt;Integer&gt; list3 = Arrays.asList(nums);\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1>","more":"<h2 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h2><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>​ 对象的容器，实现了对对象常用的操作</p>\n<h4 id=\"和数组的区别\"><a href=\"#和数组的区别\" class=\"headerlink\" title=\"和数组的区别\"></a>和数组的区别</h4><ol>\n<li>数组长度固定，集合长度不固定</li>\n<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>\n</ol>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>​ java.util.*;包</p>\n<h2 id=\"collection-体系\"><a href=\"#collection-体系\" class=\"headerlink\" title=\"collection 体系\"></a>collection 体系</h2><p><img src=\"img/article/JAVA-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-20210418/image-20210407105452970.png\" alt=\"image-20210407105452970\"></p>\n<h2 id=\"Collection-父接口\"><a href=\"#Collection-父接口\" class=\"headerlink\" title=\"Collection 父接口\"></a>Collection 父接口</h2><p>特点：代表一组任意类型的对象，无序、无下标、不能重复。</p>\n<p>创建集合 <code>Collection collection = new ArrayList();</code></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ol>\n<li>collection.add(Object obj); 添加一个对象；</li>\n<li>adddAll(Collection c) ；//将一个集合中的所有对象添加到此集合中；</li>\n<li>void clear(); 清空此集合中的所有对象；</li>\n<li>contains(Object obj); //检查此集合中是否包含 o 对象；</li>\n<li>equals(Object obj); //比较此集合中是否包含 o 对象；</li>\n<li>isEmpty(); 判断此集合是否为空；</li>\n<li>remove(Object obj); //在此集合中移除 o 对象；</li>\n<li>int size(); //返回此集合中的元素个数；</li>\n<li>Object[] toArray(); //将此集合转换成数组 ；</li>\n</ol>\n<p>遍历元素（重点）</p>\n<ol>\n<li><p>增强 for（因为无下标）</p>\n<p> <code>or(Object object : collection)&#123; &#125;</code></p>\n</li>\n<li><p>使用迭代器</p>\n<pre><code class=\"java\">//haNext(); 有没有下一个元素\n//next(); 获取下一个元素\n//remove(); 删除当前元素\nIterator it = collection.iterator();\nwhile (it.hasNext()) &#123;\n    String s = (String) it.next();\n    System.out.println(s);\n    // 可以使用it.remove(); 进行移除元素\n    // collection.remove(); 不能用collection其他方法 会报并发修改异常\n</code></pre>\n</li>\n<li><p>列表迭代器</p>\n<pre><code class=\"java\"> List list = new ArrayList();\n        list.add(&quot;aaa&quot;);\n        list.add(&quot;bbb&quot;);\n        list.add(&quot;ccc&quot;);\n        ListIterator li = list.listIterator();\n        while(li.hasNext())&#123;\n            System.out.println(li.nextIndex() + &quot;:&quot; + li.next()); //从前往后遍历\n        &#125;\n\n        while(li.hasPrevious())&#123;\n            System.out.println(li.previousIndex() + &quot;:&quot; + li.previous()); //从后往前遍历\n        &#125;\n</code></pre>\n</li>\n</ol>\n<h3 id=\"List-子接口\"><a href=\"#List-子接口\" class=\"headerlink\" title=\"List 子接口\"></a>List 子接口</h3><ol>\n<li>特点：有序，有下标，元素可以重复；</li>\n<li>方法：<ol>\n<li>list.add(int index, Object o) //在 index 位置插入对象 o</li>\n<li>list.addAll(int index, Collection c) //将一个集合中的元素添加到此集合中的 index 位置</li>\n<li>list.get(int index) //返回集合中指定位置的元素</li>\n<li>list.remove(Object o) list.remove(index) //删除集合中指定元素或指定位置的元素</li>\n<li>list,isEmpty() //判断是否为空</li>\n<li>list.subList(int fromIndex, int toIndex) //返回 fromindex 和 toindex 之间的集合元素，含头不含尾</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        List list = new ArrayList&lt;&gt;();\n\n        list.add(&quot;apple&quot;);\n        list.add(&quot;xiaomi&quot;);\n        list.add(&quot;huawei&quot;);\n        System.out.println(&quot;元素个数:&quot;+ list.size());\n        System.out.println(list.toString());\n\n//        list.remove(&quot;xiaomi&quot;);\n//        System.out.println(&quot;元素个数:&quot;+ list.size());\n//        list.remove(0);\n//        System.out.println(&quot;元素个数:&quot;+ list.size());\n\n        System.out.println(&quot;----------------for遍历-------------------&quot;);\n        for (int i = 0; i &lt; list.size(); i++) &#123;\n            System.out.println(list.get(i));\n        &#125;\n        System.out.println(&quot;----------------增强for-------------------&quot;);\n        for (Object o : list) &#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(&quot;----------------使用迭代器进行遍历-------------------&quot;);\n        Iterator it1 = list.iterator();\n        while (it1.hasNext())&#123;\n            System.out.println(it1.next());\n        &#125;\n        System.out.println(&quot;----------------使用列表迭代器进行正序遍历-------------------&quot;);\n        ListIterator it2 = list.listIterator();\n        while (it2.hasNext())&#123;\n            System.out.println(it2.next());\n        &#125;\n\n        //从后向前\n        System.out.println(&quot;----------------使用列表迭代器进行逆序遍历-------------------&quot;);\n        while (it2.hasPrevious())&#123;\n            System.out.println(it2.previous());\n        &#125;\n\n        System.out.println(&quot;-----------------------------------------------------------&quot;);\n        //判断是否存在\n        System.out.println(list.contains(&quot;xiaomi&quot;));\n        //判断是否为空\n        System.out.println(list.isEmpty());\n    System.out.println(&quot;-----------------------------------------------------------&quot;);\n        //指定位置输出,含头不含尾\n        System.out.println(list.subList(1,2));\n\n    &#125;\n</code></pre>\n<h3 id=\"List-实现类\"><a href=\"#List-实现类\" class=\"headerlink\" title=\"List 实现类\"></a>List 实现类</h3><ol>\n<li><p>ArrayLsit [重点]：</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.2 版本，运行效率快，线程不安全。</li>\n</ol>\n</li>\n<li><p>Vector:</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.0 版本，运行效率慢，线程安全。</li>\n</ol>\n</li>\n<li><p>LinkedList：</p>\n<ol>\n<li>链表结构实现，增删快，查询慢。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"ArrayList-的使用\"><a href=\"#ArrayList-的使用\" class=\"headerlink\" title=\"ArrayList 的使用\"></a>ArrayList 的使用</h3><p>创建集合 <code>ArrayList arrayList = new ArrayList&lt;&gt;();</code></p>\n<ol>\n<li><p>添加元素 <code>arrayList.add();</code></p>\n</li>\n<li><p>删除元素 <code>arrayList.remove(new Student(&quot;name&quot;, 10));</code></p>\n<p>这里重写了 equals(this == obj) 方法</p>\n</li>\n</ol>\n<pre><code class=\"java\"> @Override\n    public boolean equals(Object obj) &#123;\n        if (this == obj) &#123;\n            return true;\n        &#125;\n        if (obj == null) &#123;\n            return false;\n        &#125;\n        if(obj instanceof Student)&#123;\n            Student s = (Student)obj;\n            //4 比较属性\n            return this.name.equals(s.getName()) &amp;&amp; this.age == s.getAge();\n        &#125;\n        return false;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li><p>遍历元素【重点】</p>\n<ol>\n<li>迭代器</li>\n</ol>\n<pre><code class=\"java\">Iterator it = arrayList.iterator();\nwhile(it.hasNext())&#123;\n  Student s = (Student)it.next(); //强转\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>列表迭代器</li>\n</ol>\n<pre><code class=\"java\">ListIterator li = arrayList.listIterator();\nwhile(li.hasNext())&#123;\n  Student s = (Student)li.next(); //从前往后遍历\n&#125;\n\nwhile(li.hasPrevious())&#123;\n  Student s = (Student)li.previous();//从后往前遍历\n&#125;\n</code></pre>\n</li>\n<li><p>ArrayList 源码分析</p>\n<ol>\n<li><p><code>private static final int DEFAULT_CAPACITY = 10;</code> //默认容量 10；</p>\n<p>注意：如果没有向集合中添加任何元素时，容量 0，添加一个后，容量为 10；</p>\n<p>每次扩容是原来的 1.5 倍；</p>\n</li>\n<li><p><code>private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</code> 存放元素的数组；</p>\n</li>\n<li><p><code>private int size;</code> 实际元素个数，一定小于容量；</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Vector-类\"><a href=\"#Vector-类\" class=\"headerlink\" title=\"Vector 类\"></a>Vector 类</h3><ol>\n<li>创建集合 <code>Vector vector = new Vector&lt;&gt;();</code></li>\n<li>增加、删除、判断同上与 list 相同</li>\n<li>遍历中枚举器遍历</li>\n</ol>\n<pre><code class=\"java\">Enumeration en = vector.elements();\nwhile(en.hasMoreElements())&#123;\n  String o = (String)en.nextElement();\n  sout(o);\n&#125;\n</code></pre>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><ol>\n<li><p>ArrayLsit [重点]：</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.2 版本，运行效率快，线程不安全。</li>\n</ol>\n</li>\n<li><p>Vector:</p>\n<ol>\n<li>数组结构实现，查询快，增删慢；</li>\n<li>JDK1.0 版本，运行效率慢，线程安全。</li>\n</ol>\n</li>\n<li><p>LinkedList：</p>\n<ol>\n<li>链表结构实现，增删快，查询慢。</li>\n</ol>\n</li>\n<li><pre><code class=\"java\">LinkedList linkedList = new LinkedList();\n</code></pre>\n</li>\n<li><p>主要方法与 ArrayList()相同；遍历方法，for, Iterator;</p>\n</li>\n</ol>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ol>\n<li>本质是参数化类型，把类型作为参数传递</li>\n<li>常见形式有泛型类、泛型接口、泛型方法</li>\n<li>语法<T> &lt;T, V&gt; T 成为类型占位符，表示一种引用类型，可以写多个逗号隔开</li>\n<li>好处<ol>\n<li>提高代码重用性</li>\n<li>防止类型转换异常，提高代码安全性</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h3><pre><code class=\"java\">/**\n * 泛型类\n * T是类型占位符，表示一种引用类型，如果编写多个使用逗号隔开\n */\npublic class MyGeneric&lt;T&gt; &#123;\n    T t;\n    public void show(T t) &#123;\n        System .out.println(t);\n    &#125;\n    public T getT() &#123;\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        MyGeneric&lt;String&gt; myGeneric = new MyGeneric&lt;String&gt;();\n        myGeneric.t = &quot;hello&quot;;\n        myGeneric.show(&quot;大家好，加油&quot;);\n        String str = myGeneric.getT();\n        System.out.println(str);\n\n        MyGeneric&lt;Integer&gt; myGeneric2 = new MyGeneric&lt;&gt;();\n        myGeneric2.t = 100;\n        myGeneric2.show(200);\n        Integer integer = myGeneric2.getT();\n        System.out.println(integer);\n</code></pre>\n<h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h3><pre><code class=\"java\">/**\n * 泛型接口\n * 语法, 接口名&lt;T&gt;\n * 注意，不能泛型静态常量\n */\npublic interface MyInterface&lt;T&gt; &#123;\n    String name = &quot;张三&quot;;\n\n    T server(T t);\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class MyInterfaceImpl implements MyInterface&lt;String&gt; &#123;\n\n    @Override\n    public String server(String t) &#123;\n        System.out.println(t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class MyInterfanceImpl2&lt;T&gt; implements MyInterface&lt;T&gt; &#123;\n\n    @Override\n    public T server(T t) &#123;\n        System.out.println(t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        //myinterface\n        MyInterfaceImpl impl = new MyInterfaceImpl();\n        impl.server(&quot;xxxxxxxxxx&quot;);\n\n        //myinterfaceimpl2\n        MyInterfanceImpl2&lt;Integer&gt; impl2 = new MyInterfanceImpl2&lt;&gt;();\n        impl2.server(1000);\n        MyInterfanceImpl2&lt;String&gt; impl3 = new MyInterfanceImpl2&lt;&gt;();\n        impl3.server(&quot;ccccccccccc&quot;);\n</code></pre>\n<h3 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h3><pre><code class=\"java\">/**\n * 泛型方法\n * 语法： &lt;T&gt; 返回值类型\n */\n\npublic class MyGenericMethod &#123;\n    public &lt;T&gt; T show(T t) &#123;\n        System.out.println(&quot;泛型方法&quot; + t);\n        return t;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">        //泛型方法\n        MyGenericMethod myGenericMethod = new MyGenericMethod();\n        myGenericMethod.show(&quot;bbbb&quot;);\n        myGenericMethod.show(200);\n        myGenericMethod.show(1.23);\n</code></pre>\n<h3 id=\"泛型集合\"><a href=\"#泛型集合\" class=\"headerlink\" title=\"泛型集合\"></a>泛型集合</h3><p>概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致</p>\n<p>特点：</p>\n<ol>\n<li>编译时即可检查，而非运行时抛出异常</li>\n<li>访问时，不必类型转换（拆箱）</li>\n<li>不同泛型之间应用不能相互赋值，泛型不存在多态</li>\n</ol>\n<pre><code class=\"java\">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();\n        arrayList.add(&quot;xxx&quot;);\n        arrayList.add(&quot;yyy&quot;);\n\n        for (String s : arrayList) &#123;\n            System.out.println(s.toString());\n        &#125;\n\n        ArrayList&lt;Student&gt; arrayList2 = new ArrayList&lt;&gt;();\n        Student s1 = new Student(&quot;刘德华&quot;, 20);\n        Student s2 = new Student(&quot;郭富城&quot;, 21);\n        Student s3 = new Student(&quot;梁朝伟&quot;, 22);\n        arrayList2.add(s1);\n        arrayList2.add(s2);\n        arrayList2.add(s3);\n\n        Iterator iterator = arrayList2.listIterator();\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n</code></pre>\n<h2 id=\"Set-集合\"><a href=\"#Set-集合\" class=\"headerlink\" title=\"Set 集合\"></a>Set 集合</h2><ol>\n<li>特点：无序，无下标、元素不可重复；</li>\n<li>方法：全部继承自 Collection 中的方法；</li>\n<li>增、删、遍历、判断与 collection 相同；</li>\n</ol>\n<pre><code class=\"java\">        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n        //1. 添加数据\n        set.add(&quot;小米&quot;);\n        set.add(&quot;华为&quot;);\n        set.add(&quot;苹果&quot;);\n        System.out.println(&quot;数据个数:&quot; + set.size());\n        System.out.println(set.toString());\n        //2 删除数据\n        //set.remove(&quot;小米&quot;);\n        System.out.println(&quot;----------------增强for--------------&quot;);\n        for (String s : set) &#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(&quot;----------------迭代器--------------&quot;);\n        Iterator&lt;String&gt; iterator = set.iterator();\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n</code></pre>\n<h3 id=\"Set-实现类\"><a href=\"#Set-实现类\" class=\"headerlink\" title=\"Set 实现类\"></a>Set 实现类</h3><h4 id=\"HashSet-重点-：\"><a href=\"#HashSet-重点-：\" class=\"headerlink\" title=\"HashSet[重点]：\"></a>HashSet[重点]：</h4><ol>\n<li>无序，基于 HashCode 实现元素不重复；</li>\n<li>当存入元素的哈希码相同时，会调用 equals 进行确认，如结果为 true，则拒绝后者存入；</li>\n</ol>\n<p>存储结构：哈希表（数组+链表+红黑树）</p>\n<p>存储过程（重复依据）</p>\n<ol>\n<li><p>根据 hashCode 计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步</p>\n</li>\n<li><p>再执行 equals 方法，如果 equals 为 true，则认为是重复，否则形成链表</p>\n<p>基于 HashCode 计算元素存放位置</p>\n<ol>\n<li><p>利用 31 这个质数，减少散列冲突</p>\n<p>31 提高执行效率 <code>31 * i = (i &lt;&lt; 5) - i</code> 转为移位操作</p>\n</li>\n<li><p>当存入元素的哈希码相同时，会调用 equals 进行确认，如果结果为 true，则拒绝后者存入</p>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"java\"> public static void main(String[] args) &#123;\n        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();\n\n        hashSet.add(&quot;刘德华&quot;);\n        hashSet.add(&quot;郭富城&quot;);\n        hashSet.add(&quot;梁朝伟&quot;);\n\n        System.out.println(&quot;元素个数：&quot; + hashSet.size());\n        System.out.println(hashSet.toString());\n        //删除元素\n//        hashSet.remove(&quot;刘德华&quot;);\n        //增强for\n        System.out.println(&quot;---------------增强for-----------------&quot;);\n        for (String s : hashSet) &#123;\n            System.out.println(s);\n        &#125;\n\n        System.out.println(&quot;---------------迭代器-----------------&quot;);\n        Iterator it= hashSet.iterator();\n        while (it.hasNext()) &#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n</code></pre>\n<pre><code class=\"java\">//重写equals + hashCode\n     @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age &amp;&amp;\n                name.equals(person.name);\n    &#125;\n\n   @Override\n    public int hashCode() &#123;\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    &#125;\n</code></pre>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet:\"></a>TreeSet:</h4><ol>\n<li><p>基于排列顺序实现元素不重复；</p>\n</li>\n<li><p>实现了 sortedset 接口，对集合元素自动排序；</p>\n</li>\n<li><p>元素对象的类型必须实现，Comparable 接口，指定排序规则；</p>\n</li>\n<li><p>通过 CompareTo 方法确定是否为重复元素；</p>\n</li>\n<li><p>存储结构：红黑树</p>\n</li>\n<li><p>创建集合 <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;()</code></p>\n<p>添加元素 <code>treeSet.add();</code></p>\n<p>删除元素 <code>treeSet.remove();</code></p>\n<p>遍历 1. 增强 for 2. 迭代器</p>\n<p>判断 <code>treeSet.contains();</code></p>\n</li>\n<li><p>补充： TreeSet 集合的使用</p>\n<ol>\n<li>Comparator 实现定制比较（比较器）</li>\n<li>Comparable 可比较的</li>\n</ol>\n<pre><code class=\"java\">TreeSet&lt;Person&gt; persons = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() &#123;\n            @Override\n            public int compare(Person o1, Person o2) &#123;\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            &#125;\n        &#125;);\n</code></pre>\n</li>\n<li><p>TreeSet 案例:</p>\n<ul>\n<li>要求使用 TreeSet 集合实现字符串按照长度进行排序；</li>\n<li>实现方法：重写 Comparator 的 compare 方法</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"java\"> /**\n     * 要求使用TreeSet 集合实现字符串按照长度进行排序；\n     * helloWord  zhang  lisi  wangwu  beijing  xian  nanjing\n     * @authoe sx\n     */\n    public static void main(String[] args) &#123;\n        TreeSet treeSet = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;\n            @Override\n            public int compare(String o1, String o2) &#123;\n                int n1 = o1.length()-o2.length();\n                int n2 = o1.compareTo(o2);\n                return n1==0?n2:n1;\n            &#125;\n        &#125;);\n        //添加数据\n        treeSet.add(&quot;helloWord&quot;);\n        treeSet.add(&quot;zhang&quot;);\n        treeSet.add(&quot;lisi&quot;);\n        treeSet.add(&quot;wangwu&quot;);\n        treeSet.add(&quot;beijing&quot;);\n        treeSet.add(&quot;xian&quot;);\n        treeSet.add(&quot;nanjing&quot;);\n        System.out.println(treeSet.toString());\n\n    &#125;\n\n[lisi, xian, zhang, wangwu, beijing, nanjing, helloWord]\n</code></pre>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><ol>\n<li>特点：存储一对数据（Key, Value），无序、无下标，键不可以重复，值可重复；</li>\n<li>方法：<ol>\n<li>V put(K key, V value) 将对象存到集合中，关联键值 ;</li>\n<li>Object get(Object key) 根据键获得对应的值 ;</li>\n<li>Set<K> 返回所有的 Key;</li>\n<li>Collection<V> values() 返回包含所有值的 Collection 集合;</li>\n<li>Set&lt;Map.Entry&lt;K, V&gt;&gt; 键值匹配的 Set 集合;</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Map-接口的使用：\"><a href=\"#Map-接口的使用：\" class=\"headerlink\" title=\"Map 接口的使用：\"></a>Map 接口的使用：</h3><p>两种遍历方法：</p>\n<ol>\n<li>keySet()把 map 中的 key 存在 set 集合中；entrySet()把（key，value）封装成一个 entry 类型（映射对）；</li>\n<li>entrySet()效率高于 keySet()方法；因为 entrySet 一次性把 key，value 取出。</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建Map集合\n        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\n\n        map.put(&quot;cn&quot;, &quot;中国&quot;);\n        map.put(&quot;uk&quot;, &quot;英国&quot;);\n        map.put(&quot;fc&quot;, &quot;法国&quot;);\n        map.put(&quot;gm&quot;, &quot;德国&quot;);\n\n        System.out.println(&quot;元素个数：&quot; + map.size());\n        System.out.println(map.toString());\n\n        //删除\n//        map.remove(&quot;fc&quot;);\n//        System.out.println(map.toString());\n\n        //遍历\n        //使用keySet()方法\n        System.out.println(&quot;----------keySet---------------&quot;);\n        Set&lt;String&gt; keySet = map.keySet();\n        for (String key : keySet) &#123;\n            System.out.println(key + &quot;:&quot; + map.get(key));\n        &#125;\n        System.out.println(&quot;----------entrySet---------------&quot;);\n//        使用entrySet方法\n        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();\n        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;\n            System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"HashMap-重点\"><a href=\"#HashMap-重点\" class=\"headerlink\" title=\"HashMap[重点]\"></a>HashMap[重点]</h3><p>JDK1.2 版本，线程不安全，运行效率快，允许用 null 作为 key 或是 value。</p>\n<p>存储结构：哈希表（数组+链表+红黑树）</p>\n<p>使用 key 可使 hashcode 和 equals 作为重复</p>\n<p>增、删、遍历、判断与上述一致</p>\n<p>HashMap 常用方法：alt + insert 重写 equals 和 hashcode 去掉重复项；</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建集合\n        HashMap&lt;Student, String&gt; students = new HashMap&lt;&gt;();\n        //添加元素\n        Student s1 = new Student(&quot;孙悟空&quot;, 100);\n        Student s2 = new Student(&quot;猪八戒&quot;, 101);\n        Student s3 = new Student(&quot;沙和尚&quot;, 102);\n        students.put(s1, &quot;花果山&quot;);\n        students.put(s2, &quot;黑风洞&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(new Student(&quot;沙和尚&quot;, 102), &quot;流沙河&quot;);\n        System.out.println(students.size());\n        System.out.println(students.toString());\n\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(&quot;删除之后：&quot; + students.size());\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //遍历\n        for (Student key : students.keySet()) &#123;\n            System.out.println(key.toString() + &quot;:&quot; + students.get(key));\n        &#125;\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //使用entrySet()\n        for (Map.Entry&lt;Student, String&gt; studentStringEntry : students.entrySet()) &#123;\n            System.out.println(studentStringEntry.getKey() + &quot;:&quot; + studentStringEntry.getValue());\n        &#125;\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(&quot;流沙河&quot;));\n    &#125;\n</code></pre>\n<h3 id=\"HashMap-源码分析：\"><a href=\"#HashMap-源码分析：\" class=\"headerlink\" title=\"HashMap 源码分析：\"></a>HashMap 源码分析：</h3><ol>\n<li><p><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code> //默认初始容量大小</p>\n<p>1 左移 4 位 = 2^4 = 16，底层移位计算最快；</p>\n</li>\n<li><p><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code> //最大容量大小；</p>\n</li>\n<li><p><code>DEFAULT_LOAD_FACTOR</code> //默认加载因子；</p>\n</li>\n<li><p><code>static final int TREEIFY_THRESHOLD = 8;</code></p>\n<p><code>static final int MIN_TREEIFY_CAPACITY = 64;</code> //链表长度大于 8，数组长度大于 64 时存储结构改为红黑树；</p>\n</li>\n<li><p><code>static final int UNTREEIFY_THRESHOLD = 6;</code> //链表长度小于 6，变回链表结构</p>\n</li>\n</ol>\n<p><strong>源码分析总结</strong>：</p>\n<ol>\n<li>HashMap 刚创建时，table 是 null，节省空间，当添加第一个元素时，table 容量调整为 16</li>\n<li>当元素个数大于阈值 75%（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li>\n<li>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64 时，会调整成红黑树，目的是提高效率</li>\n<li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li>\n<li>jdk1.8 以前，链表是头插入，之后为尾插入</li>\n</ol>\n<h3 id=\"Hashtable\"><a href=\"#Hashtable\" class=\"headerlink\" title=\"Hashtable\"></a>Hashtable</h3><p>​ JDK1.0 版本，线程安全，运行效率慢，不允许 NULL 作为 key 或是 value。</p>\n<p>​ 基本不用。</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><p>​ Hashtable 的子类，需要 key 和 value 都是 String。在流中使用较多，通常用于配置文件的读取。在流的学习中进行使用。</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        //创建集合\n        Properties properties = new Properties();\n        //添加数据\n        properties.setProperty(&quot;username&quot;, &quot;zhangsan&quot;);\n        properties.setProperty(&quot;age&quot;, &quot;20&quot;);\n        System.out.println(properties);\n\n        //遍历\n        //keyset\n        for (Object o : properties.keySet()) &#123;\n            System.out.println(o);\n        &#125;\n\n        //entrySet\n        for (Map.Entry&lt;Object, Object&gt; objectObjectEntry : properties.entrySet()) &#123;\n            System.out.println(objectObjectEntry);\n        &#125;\n\n        //stringPropertyName\n        for (String stringPropertyName : properties.stringPropertyNames()) &#123;\n            System.out.println(stringPropertyName + &quot;:&quot; + properties.getProperty(stringPropertyName));\n        &#125;\n    &#125;\n</code></pre>\n<h4 id=\"和流有关的方法\"><a href=\"#和流有关的方法\" class=\"headerlink\" title=\"和流有关的方法\"></a>和流有关的方法</h4><pre><code class=\"java\">//和流有关的方法\n        PrintWriter pw = new PrintWriter(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties&quot;);\n        properties.list(pw);\n        pw.close();\n</code></pre>\n<h4 id=\"store-方法\"><a href=\"#store-方法\" class=\"headerlink\" title=\"store 方法\"></a>store 方法</h4><pre><code class=\"java\">FileOutputStream fos = new FileOutputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\print.properties&quot;);\n        properties.store(fos, &quot;注释&quot;);\n        fos.close();\n\n结果：\n#\\u6CE8\\u91CA    properties文件不允许中文\n#Sat Apr 10 01:08:21 CST 2021\nage=20\nusername=zhangsan\n</code></pre>\n<h4 id=\"load-方法\"><a href=\"#load-方法\" class=\"headerlink\" title=\"load 方法\"></a>load 方法</h4><pre><code class=\"java\">//        load方法\n        Properties properties2 = new Properties();\n        FileInputStream fis = new FileInputStream(&quot;D:\\\\workspace\\\\IDEA-workspace\\\\kuangshen_java\\\\集合框架\\\\src\\\\com\\\\shan\\\\collection\\\\properties\\\\\\\\print.properties&quot;);\n        properties2.load(fis);\n        fis.close();\n        System.out.println(properties2.toString());\n</code></pre>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><p>​ 实现了 SortedMap 接口（是 map 的子接口），可以对 key 自动排序</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        TreeMap&lt;Student, String&gt; students = new TreeMap&lt;&gt;();\n        Student s1 = new Student(&quot;孙悟空&quot;, 103);\n        Student s2 = new Student(&quot;猪八戒&quot;, 101);\n        Student s3 = new Student(&quot;沙和尚&quot;, 102);\n        students.put(s1, &quot;花果山&quot;);\n        students.put(s2, &quot;黑风洞&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(s3, &quot;流沙河&quot;);\n        students.put(new Student(&quot;沙和尚&quot;, 102), &quot;流沙河&quot;);\n        System.out.println(students.size());\n        System.out.println(students.toString());\n        //删除元素\n//        students.remove(s1);\n//        System.out.println(&quot;删除之后：&quot; + students.size());\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //遍历\n        for (Student key : students.keySet()) &#123;\n            System.out.println(key.toString() + &quot;:&quot; + students.get(key));\n        &#125;\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //使用entrySet()\n        for (Map.Entry&lt;Student, String&gt; studentStringEntry : students.entrySet()) &#123;\n            System.out.println(studentStringEntry.getKey() + &quot;:&quot; + studentStringEntry.getValue());\n        &#125;\n\n        System.out.println(&quot;+++++++++++++++++++++++++++++++++++++++&quot;);\n        //判断\n        System.out.println(students.containsKey(s1));\n        System.out.println(students.containsValue(&quot;流沙河&quot;));\n\n    &#125;\n</code></pre>\n<p>定制比较器：重写 compare 方法:</p>\n<p>可以自定义规则</p>\n<pre><code class=\"java\">TreeMap&lt;Student, String&gt; students = new TreeMap(new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                int n1 = o1.getAge() - o2.getAge();\n                int n2 = o1.getName().compareTo(o2.getName());\n                return n1 == 0 ? n2 : n1;\n            &#125;\n        &#125;);\n</code></pre>\n<h2 id=\"Collection-工具类\"><a href=\"#Collection-工具类\" class=\"headerlink\" title=\"Collection 工具类\"></a>Collection 工具类</h2><p>​ 概念：集合工具类，定义了除了存取以外的集合常用方法；</p>\n<p>​ 1. 排序 <code>Collections.sort()</code></p>\n<p>​ 2. 直接二分查找<code>int i = Collections.binarySearch(list, x);</code> 成功返回索引；</p>\n<p>​ 其他方法 ：</p>\n<p>复制<code>Collections.copy(dest, list);</code></p>\n<p>​ 反转<code>Collections.reverse(list);</code></p>\n<p>​ 打乱<code>ollections.shuffle(list);</code></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        list.add(20);\n        list.add(3);\n        list.add(14);\n        list.add(50);\n        list.add(36);\n        //排序\n        System.out.println(&quot;排序之前---&quot; + list.toString());\n        Collections.sort(list);\n        System.out.println(&quot;排序之后---&quot; + list.toString());\n\n        int i = Collections.binarySearch(list, 3);\n        System.out.println(&quot;第&quot; + i + &quot;位&quot;);\n\n        List&lt;Integer&gt; dest = new ArrayList&lt;&gt;();\n        //开辟空间，否则dest为空，无法直接copy放入\n        for (int j = 0; j &lt; list.size(); j++) &#123;\n            dest.add(0);\n        &#125;\n        Collections.copy(dest, list);\n        System.out.println(dest.toString());\n\n        //翻转\n        Collections.reverse(list);\n        System.out.println(list);\n\n        //打乱\n        Collections.shuffle(list);\n        System.out.println(list);\n    &#125;\n</code></pre>\n<p>​ 补充：</p>\n<pre><code class=\"java\">// list转成数组\nInteger[] arr = list.toArray(new Integer[10]);\nsout(arr.length);\nsout(Array.toString(arr));\n\n// 数组转成集合\n// 此时为受限集合，不能 添加和删除！\nString[] name = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;;\nList&lt;String&gt; list2 = Arrays.asList(names);\n\n// 把基本类型数组转为集合时，需要修改为包装类\nInteger[] nums = &#123;100, 200, 300, 400, 500&#125;;\nList&lt;Integer&gt; list3 = Arrays.asList(nums);\n</code></pre>"},{"title":"Leetcode-002-两数相加","date":"2021-04-19T17:17:44.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png","_content":"\n\n\n# 两数相加-我是废物T-T\n\n<!--more-->\n\n# 链表结构\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。\n每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 \n\n上面是链表的定义，那么我们用通俗点的语言来说就是：\n一些节点，除了最后一个节点以外的每一个节点都存储着下一个节点的地址，依据这种方法依次连接， 构成一个链式结构。\n\n在Java中我们需要自己定义一个链表的类来生成对象，这个类需要由一个存储数据的数据域也需要有存储下一个节点地址的域，因此，我们至少定义两个属性。\n\n\n\n# 解决方法（抄的）\n\n```java\n\npublic class AddTwoNumbers_002 {\n    public static void main(String[] args) {\n        // 数字为倒序\n        /*\n        最终测试用例，直接给我干碎\n        [9]\n        [1,9,9,9,9,9,9,9,9,9]\n        连续进位的问题没有解决导致的错误\n         */\n\n        int[] l1 = new int[]{9};\n        int[] l2 = new int[]{1, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n\n        ListNode ln1 = new ListNode(0);\n        ListNode ln2 = new ListNode(0);\n        ListNode temp1 = ln1;\n        ListNode temp2 = ln2;\n\n        for (int i : l1) {\n            temp1.next = new ListNode(i);\n            temp1 = temp1.next;\n        }\n        for (int i : l2) {\n            temp2.next = new ListNode(i);\n            temp2 = temp2.next;\n        }\n\n        System.out.println(\"================================================\");\n\n        ListNode res = addtwoNumbers(ln1.next, ln2.next);\n        System.out.println(res.toString());\n    }\n\n    public static ListNode addtwoNumbers(ListNode l1, ListNode l2) {\n        ListNode res = new ListNode(0);\n        ListNode restemp = res;\n        int sum = 0;\n        int value1 = 0;\n        int value2 = 0;\n        //进位记录值\n        int carrybit = 0;\n\n        // l1 l2 有值，存在进位，则继续\n        while (l1!=null || l2!=null || carrybit!=0) {\n            value1 = l1 != null ? l1.val : 0;\n            value2 = l2 != null ? l2.val : 0;\n\n            //进位，当1+2>=10时，进位=1;当1，2都为0时，进位值=1，最后执行的这一次sum计算，使sum进到了更高位\n            sum = value1 + value2 + carrybit;\n            carrybit = sum/10;\n\n            //每次都将数字直接插入到ListNode中\n            restemp.next = new ListNode(sum%10);\n            restemp = restemp.next;\n\n            if (l1 != null) { l1 = l1.next; }\n            if (l2 != null) { l2 = l2.next; }\n        }\n        return res.next;\n    }\n}\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {\n    }\n    ListNode(int val) {\n        this.val = val;\n    }\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n    @Override\n    public String toString() {\n        return \"\"+val + next;\n    }\n}\n```\n\n\n\n本质上就是加法的实现。","source":"_posts/Leetcode-002-两数相加-20210420.md","raw":"---\ntitle: Leetcode-002-两数相加\ndate: 2021-04-20 01:17:44\ntags:\n- Leetcode\ncategories:\n- Leetcode\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png\n---\n\n\n\n# 两数相加-我是废物T-T\n\n<!--more-->\n\n# 链表结构\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。\n每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 \n\n上面是链表的定义，那么我们用通俗点的语言来说就是：\n一些节点，除了最后一个节点以外的每一个节点都存储着下一个节点的地址，依据这种方法依次连接， 构成一个链式结构。\n\n在Java中我们需要自己定义一个链表的类来生成对象，这个类需要由一个存储数据的数据域也需要有存储下一个节点地址的域，因此，我们至少定义两个属性。\n\n\n\n# 解决方法（抄的）\n\n```java\n\npublic class AddTwoNumbers_002 {\n    public static void main(String[] args) {\n        // 数字为倒序\n        /*\n        最终测试用例，直接给我干碎\n        [9]\n        [1,9,9,9,9,9,9,9,9,9]\n        连续进位的问题没有解决导致的错误\n         */\n\n        int[] l1 = new int[]{9};\n        int[] l2 = new int[]{1, 9, 9, 9, 9, 9, 9, 9, 9, 9};\n\n        ListNode ln1 = new ListNode(0);\n        ListNode ln2 = new ListNode(0);\n        ListNode temp1 = ln1;\n        ListNode temp2 = ln2;\n\n        for (int i : l1) {\n            temp1.next = new ListNode(i);\n            temp1 = temp1.next;\n        }\n        for (int i : l2) {\n            temp2.next = new ListNode(i);\n            temp2 = temp2.next;\n        }\n\n        System.out.println(\"================================================\");\n\n        ListNode res = addtwoNumbers(ln1.next, ln2.next);\n        System.out.println(res.toString());\n    }\n\n    public static ListNode addtwoNumbers(ListNode l1, ListNode l2) {\n        ListNode res = new ListNode(0);\n        ListNode restemp = res;\n        int sum = 0;\n        int value1 = 0;\n        int value2 = 0;\n        //进位记录值\n        int carrybit = 0;\n\n        // l1 l2 有值，存在进位，则继续\n        while (l1!=null || l2!=null || carrybit!=0) {\n            value1 = l1 != null ? l1.val : 0;\n            value2 = l2 != null ? l2.val : 0;\n\n            //进位，当1+2>=10时，进位=1;当1，2都为0时，进位值=1，最后执行的这一次sum计算，使sum进到了更高位\n            sum = value1 + value2 + carrybit;\n            carrybit = sum/10;\n\n            //每次都将数字直接插入到ListNode中\n            restemp.next = new ListNode(sum%10);\n            restemp = restemp.next;\n\n            if (l1 != null) { l1 = l1.next; }\n            if (l2 != null) { l2 = l2.next; }\n        }\n        return res.next;\n    }\n}\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {\n    }\n    ListNode(int val) {\n        this.val = val;\n    }\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n    @Override\n    public String toString() {\n        return \"\"+val + next;\n    }\n}\n```\n\n\n\n本质上就是加法的实现。","slug":"Leetcode-002-两数相加-20210420","published":1,"updated":"2022-04-07T17:25:27.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1l001iy4w1d6wh0m0q","content":"<h1 id=\"两数相加-我是废物T-T\"><a href=\"#两数相加-我是废物T-T\" class=\"headerlink\" title=\"两数相加-我是废物T-T\"></a>两数相加-我是废物T-T</h1><span id=\"more\"></span>\n\n<h1 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。<br>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 </p>\n<p>上面是链表的定义，那么我们用通俗点的语言来说就是：<br>一些节点，除了最后一个节点以外的每一个节点都存储着下一个节点的地址，依据这种方法依次连接， 构成一个链式结构。</p>\n<p>在Java中我们需要自己定义一个链表的类来生成对象，这个类需要由一个存储数据的数据域也需要有存储下一个节点地址的域，因此，我们至少定义两个属性。</p>\n<h1 id=\"解决方法（抄的）\"><a href=\"#解决方法（抄的）\" class=\"headerlink\" title=\"解决方法（抄的）\"></a>解决方法（抄的）</h1><pre><code class=\"java\">\npublic class AddTwoNumbers_002 &#123;\n    public static void main(String[] args) &#123;\n        // 数字为倒序\n        /*\n        最终测试用例，直接给我干碎\n        [9]\n        [1,9,9,9,9,9,9,9,9,9]\n        连续进位的问题没有解决导致的错误\n         */\n\n        int[] l1 = new int[]&#123;9&#125;;\n        int[] l2 = new int[]&#123;1, 9, 9, 9, 9, 9, 9, 9, 9, 9&#125;;\n\n        ListNode ln1 = new ListNode(0);\n        ListNode ln2 = new ListNode(0);\n        ListNode temp1 = ln1;\n        ListNode temp2 = ln2;\n\n        for (int i : l1) &#123;\n            temp1.next = new ListNode(i);\n            temp1 = temp1.next;\n        &#125;\n        for (int i : l2) &#123;\n            temp2.next = new ListNode(i);\n            temp2 = temp2.next;\n        &#125;\n\n        System.out.println(&quot;================================================&quot;);\n\n        ListNode res = addtwoNumbers(ln1.next, ln2.next);\n        System.out.println(res.toString());\n    &#125;\n\n    public static ListNode addtwoNumbers(ListNode l1, ListNode l2) &#123;\n        ListNode res = new ListNode(0);\n        ListNode restemp = res;\n        int sum = 0;\n        int value1 = 0;\n        int value2 = 0;\n        //进位记录值\n        int carrybit = 0;\n\n        // l1 l2 有值，存在进位，则继续\n        while (l1!=null || l2!=null || carrybit!=0) &#123;\n            value1 = l1 != null ? l1.val : 0;\n            value2 = l2 != null ? l2.val : 0;\n\n            //进位，当1+2&gt;=10时，进位=1;当1，2都为0时，进位值=1，最后执行的这一次sum计算，使sum进到了更高位\n            sum = value1 + value2 + carrybit;\n            carrybit = sum/10;\n\n            //每次都将数字直接插入到ListNode中\n            restemp.next = new ListNode(sum%10);\n            restemp = restemp.next;\n\n            if (l1 != null) &#123; l1 = l1.next; &#125;\n            if (l2 != null) &#123; l2 = l2.next; &#125;\n        &#125;\n        return res.next;\n    &#125;\n&#125;\nclass ListNode &#123;\n    int val;\n    ListNode next;\n    ListNode() &#123;\n    &#125;\n    ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n    ListNode(int val, ListNode next) &#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;&quot;+val + next;\n    &#125;\n&#125;\n</code></pre>\n<p>本质上就是加法的实现。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"两数相加-我是废物T-T\"><a href=\"#两数相加-我是废物T-T\" class=\"headerlink\" title=\"两数相加-我是废物T-T\"></a>两数相加-我是废物T-T</h1>","more":"<h1 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。<br>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 </p>\n<p>上面是链表的定义，那么我们用通俗点的语言来说就是：<br>一些节点，除了最后一个节点以外的每一个节点都存储着下一个节点的地址，依据这种方法依次连接， 构成一个链式结构。</p>\n<p>在Java中我们需要自己定义一个链表的类来生成对象，这个类需要由一个存储数据的数据域也需要有存储下一个节点地址的域，因此，我们至少定义两个属性。</p>\n<h1 id=\"解决方法（抄的）\"><a href=\"#解决方法（抄的）\" class=\"headerlink\" title=\"解决方法（抄的）\"></a>解决方法（抄的）</h1><pre><code class=\"java\">\npublic class AddTwoNumbers_002 &#123;\n    public static void main(String[] args) &#123;\n        // 数字为倒序\n        /*\n        最终测试用例，直接给我干碎\n        [9]\n        [1,9,9,9,9,9,9,9,9,9]\n        连续进位的问题没有解决导致的错误\n         */\n\n        int[] l1 = new int[]&#123;9&#125;;\n        int[] l2 = new int[]&#123;1, 9, 9, 9, 9, 9, 9, 9, 9, 9&#125;;\n\n        ListNode ln1 = new ListNode(0);\n        ListNode ln2 = new ListNode(0);\n        ListNode temp1 = ln1;\n        ListNode temp2 = ln2;\n\n        for (int i : l1) &#123;\n            temp1.next = new ListNode(i);\n            temp1 = temp1.next;\n        &#125;\n        for (int i : l2) &#123;\n            temp2.next = new ListNode(i);\n            temp2 = temp2.next;\n        &#125;\n\n        System.out.println(&quot;================================================&quot;);\n\n        ListNode res = addtwoNumbers(ln1.next, ln2.next);\n        System.out.println(res.toString());\n    &#125;\n\n    public static ListNode addtwoNumbers(ListNode l1, ListNode l2) &#123;\n        ListNode res = new ListNode(0);\n        ListNode restemp = res;\n        int sum = 0;\n        int value1 = 0;\n        int value2 = 0;\n        //进位记录值\n        int carrybit = 0;\n\n        // l1 l2 有值，存在进位，则继续\n        while (l1!=null || l2!=null || carrybit!=0) &#123;\n            value1 = l1 != null ? l1.val : 0;\n            value2 = l2 != null ? l2.val : 0;\n\n            //进位，当1+2&gt;=10时，进位=1;当1，2都为0时，进位值=1，最后执行的这一次sum计算，使sum进到了更高位\n            sum = value1 + value2 + carrybit;\n            carrybit = sum/10;\n\n            //每次都将数字直接插入到ListNode中\n            restemp.next = new ListNode(sum%10);\n            restemp = restemp.next;\n\n            if (l1 != null) &#123; l1 = l1.next; &#125;\n            if (l2 != null) &#123; l2 = l2.next; &#125;\n        &#125;\n        return res.next;\n    &#125;\n&#125;\nclass ListNode &#123;\n    int val;\n    ListNode next;\n    ListNode() &#123;\n    &#125;\n    ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n    ListNode(int val, ListNode next) &#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;&quot;+val + next;\n    &#125;\n&#125;\n</code></pre>\n<p>本质上就是加法的实现。</p>"},{"title":"Leetcode-001-两数之和","date":"2021-04-18T14:36:34.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png","_content":"\n\n\n# Leetcode-001-两数之和\n\n<!--more-->\n\n目前两种方法\n\n暴力枚举：\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n       int[] res = new int[2];\n        int a;\n        int b = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            a = nums[i];\n            for (int j = i+1; j < nums.length; j++) {\n                b = a + nums[j];\n                if (b == target) {\n                    res[0] = i;\n                    res[1] = j;\n                    return res;\n                }\n            }\n        }\n\n        return res;\n}\n}\n```\n\n\n\nHashMap法：\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        //将nums用例放入hashmap\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            hashMap.put(nums[i],i);\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            // 直接找另一个数是否存在，第二个条件防止用例中出现重复数字的时候找到自己，导致结果出错\n            if (hashMap.containsKey(target-nums[i]) && hashMap.get(target-nums[i])!=i){\n                res[0] = i;\n                res[1] = hashMap.get(target-nums[i]);\n                break;\n            }\n        }\n        return res;\n}\n}\n```\n\n\n\n问题：`hashmap.contains` 方法是否扫全部内容？","source":"_posts/Leetcode-001-两数之和-20210418.md","raw":"---\ntitle: Leetcode-001-两数之和\ndate: 2021-04-18 22:36:34\ntags:\n- Leetcode\ncategories:\n- Leetcode\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png\n---\n\n\n\n# Leetcode-001-两数之和\n\n<!--more-->\n\n目前两种方法\n\n暴力枚举：\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n       int[] res = new int[2];\n        int a;\n        int b = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            a = nums[i];\n            for (int j = i+1; j < nums.length; j++) {\n                b = a + nums[j];\n                if (b == target) {\n                    res[0] = i;\n                    res[1] = j;\n                    return res;\n                }\n            }\n        }\n\n        return res;\n}\n}\n```\n\n\n\nHashMap法：\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        //将nums用例放入hashmap\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            hashMap.put(nums[i],i);\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            // 直接找另一个数是否存在，第二个条件防止用例中出现重复数字的时候找到自己，导致结果出错\n            if (hashMap.containsKey(target-nums[i]) && hashMap.get(target-nums[i])!=i){\n                res[0] = i;\n                res[1] = hashMap.get(target-nums[i]);\n                break;\n            }\n        }\n        return res;\n}\n}\n```\n\n\n\n问题：`hashmap.contains` 方法是否扫全部内容？","slug":"Leetcode-001-两数之和-20210418","published":1,"updated":"2022-04-07T17:25:27.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1m001ly4w11rgk32gm","content":"<h1 id=\"Leetcode-001-两数之和\"><a href=\"#Leetcode-001-两数之和\" class=\"headerlink\" title=\"Leetcode-001-两数之和\"></a>Leetcode-001-两数之和</h1><span id=\"more\"></span>\n\n<p>目前两种方法</p>\n<p>暴力枚举：</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n       int[] res = new int[2];\n        int a;\n        int b = 0;\n\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            a = nums[i];\n            for (int j = i+1; j &lt; nums.length; j++) &#123;\n                b = a + nums[j];\n                if (b == target) &#123;\n                    res[0] = i;\n                    res[1] = j;\n                    return res;\n                &#125;\n            &#125;\n        &#125;\n\n        return res;\n&#125;\n&#125;\n</code></pre>\n<p>HashMap法：</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n        int[] res = new int[2];\n        //将nums用例放入hashmap\n        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            hashMap.put(nums[i],i);\n        &#125;\n\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            // 直接找另一个数是否存在，第二个条件防止用例中出现重复数字的时候找到自己，导致结果出错\n            if (hashMap.containsKey(target-nums[i]) &amp;&amp; hashMap.get(target-nums[i])!=i)&#123;\n                res[0] = i;\n                res[1] = hashMap.get(target-nums[i]);\n                break;\n            &#125;\n        &#125;\n        return res;\n&#125;\n&#125;\n</code></pre>\n<p>问题：<code>hashmap.contains</code> 方法是否扫全部内容？</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Leetcode-001-两数之和\"><a href=\"#Leetcode-001-两数之和\" class=\"headerlink\" title=\"Leetcode-001-两数之和\"></a>Leetcode-001-两数之和</h1>","more":"<p>目前两种方法</p>\n<p>暴力枚举：</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n       int[] res = new int[2];\n        int a;\n        int b = 0;\n\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            a = nums[i];\n            for (int j = i+1; j &lt; nums.length; j++) &#123;\n                b = a + nums[j];\n                if (b == target) &#123;\n                    res[0] = i;\n                    res[1] = j;\n                    return res;\n                &#125;\n            &#125;\n        &#125;\n\n        return res;\n&#125;\n&#125;\n</code></pre>\n<p>HashMap法：</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n        int[] res = new int[2];\n        //将nums用例放入hashmap\n        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            hashMap.put(nums[i],i);\n        &#125;\n\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            // 直接找另一个数是否存在，第二个条件防止用例中出现重复数字的时候找到自己，导致结果出错\n            if (hashMap.containsKey(target-nums[i]) &amp;&amp; hashMap.get(target-nums[i])!=i)&#123;\n                res[0] = i;\n                res[1] = hashMap.get(target-nums[i]);\n                break;\n            &#125;\n        &#125;\n        return res;\n&#125;\n&#125;\n</code></pre>\n<p>问题：<code>hashmap.contains</code> 方法是否扫全部内容？</p>"},{"title":"Leetcode-004-寻找两个正序数组的中位数","date":"2021-04-26T12:18:05.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png","_content":"\n\n\n# 寻找两个正序数组的中位数\n\n<!--more-->\n\n最朴实的方法，数组合并用sort排序，然后找出中位数：\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class FindMedianSortedArrays {\n    public static void main(String[] args) {\n        int[] arr1 = new int[]{};\n        int[] arr2 = new int[]{};\n\n        float res = findMedianSortedArrays(arr1,arr2);\n        System.out.println(\"中位数为\"+res);\n    }\n\n    public static float findMedianSortedArrays(int[] nums1, int[] nums2) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        for (int i : nums1) {\n            arr.add(i);\n        }\n        for (int i : nums2) {\n            arr.add(i);\n        }\n        Collections.sort(arr);\n\n        float res = 0;\n        int length = arr.size();\n        int mid;\n        if (length==0){\n            return 0;\n        }else if (length%2==1){\n            mid = arr.size()/2;\n            res = arr.get(mid);\n        }else {\n            mid = arr.size()/2;\n            res = arr.get(mid) + arr.get(mid-1);\n            res = res/2;\n        }\n        return res;\n    }\n}\n\n```\n\n\n\n## 但是\n\n要求时间复杂度为 `O(log (m+n))` \n\n所以需要使用------归并排序法\n\n\n\n","source":"_posts/Leetcode-004-寻找两个正序数组的中位数-20210426.md","raw":"---\ntitle: Leetcode-004-寻找两个正序数组的中位数\ndate: 2021-04-26 20:18:05\ntags:\n- Leetcode\ncategories:\n- Leetcode\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png\n---\n\n\n\n# 寻找两个正序数组的中位数\n\n<!--more-->\n\n最朴实的方法，数组合并用sort排序，然后找出中位数：\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class FindMedianSortedArrays {\n    public static void main(String[] args) {\n        int[] arr1 = new int[]{};\n        int[] arr2 = new int[]{};\n\n        float res = findMedianSortedArrays(arr1,arr2);\n        System.out.println(\"中位数为\"+res);\n    }\n\n    public static float findMedianSortedArrays(int[] nums1, int[] nums2) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        for (int i : nums1) {\n            arr.add(i);\n        }\n        for (int i : nums2) {\n            arr.add(i);\n        }\n        Collections.sort(arr);\n\n        float res = 0;\n        int length = arr.size();\n        int mid;\n        if (length==0){\n            return 0;\n        }else if (length%2==1){\n            mid = arr.size()/2;\n            res = arr.get(mid);\n        }else {\n            mid = arr.size()/2;\n            res = arr.get(mid) + arr.get(mid-1);\n            res = res/2;\n        }\n        return res;\n    }\n}\n\n```\n\n\n\n## 但是\n\n要求时间复杂度为 `O(log (m+n))` \n\n所以需要使用------归并排序法\n\n\n\n","slug":"Leetcode-004-寻找两个正序数组的中位数-20210426","published":1,"updated":"2022-04-07T17:25:27.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1p001py4w18tis8h5d","content":"<h1 id=\"寻找两个正序数组的中位数\"><a href=\"#寻找两个正序数组的中位数\" class=\"headerlink\" title=\"寻找两个正序数组的中位数\"></a>寻找两个正序数组的中位数</h1><span id=\"more\"></span>\n\n<p>最朴实的方法，数组合并用sort排序，然后找出中位数：</p>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class FindMedianSortedArrays &#123;\n    public static void main(String[] args) &#123;\n        int[] arr1 = new int[]&#123;&#125;;\n        int[] arr2 = new int[]&#123;&#125;;\n\n        float res = findMedianSortedArrays(arr1,arr2);\n        System.out.println(&quot;中位数为&quot;+res);\n    &#125;\n\n    public static float findMedianSortedArrays(int[] nums1, int[] nums2) &#123;\n        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        for (int i : nums1) &#123;\n            arr.add(i);\n        &#125;\n        for (int i : nums2) &#123;\n            arr.add(i);\n        &#125;\n        Collections.sort(arr);\n\n        float res = 0;\n        int length = arr.size();\n        int mid;\n        if (length==0)&#123;\n            return 0;\n        &#125;else if (length%2==1)&#123;\n            mid = arr.size()/2;\n            res = arr.get(mid);\n        &#125;else &#123;\n            mid = arr.size()/2;\n            res = arr.get(mid) + arr.get(mid-1);\n            res = res/2;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"但是\"><a href=\"#但是\" class=\"headerlink\" title=\"但是\"></a>但是</h2><p>要求时间复杂度为 <code>O(log (m+n))</code> </p>\n<p>所以需要使用——归并排序法</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"寻找两个正序数组的中位数\"><a href=\"#寻找两个正序数组的中位数\" class=\"headerlink\" title=\"寻找两个正序数组的中位数\"></a>寻找两个正序数组的中位数</h1>","more":"<p>最朴实的方法，数组合并用sort排序，然后找出中位数：</p>\n<pre><code class=\"java\">import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class FindMedianSortedArrays &#123;\n    public static void main(String[] args) &#123;\n        int[] arr1 = new int[]&#123;&#125;;\n        int[] arr2 = new int[]&#123;&#125;;\n\n        float res = findMedianSortedArrays(arr1,arr2);\n        System.out.println(&quot;中位数为&quot;+res);\n    &#125;\n\n    public static float findMedianSortedArrays(int[] nums1, int[] nums2) &#123;\n        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        for (int i : nums1) &#123;\n            arr.add(i);\n        &#125;\n        for (int i : nums2) &#123;\n            arr.add(i);\n        &#125;\n        Collections.sort(arr);\n\n        float res = 0;\n        int length = arr.size();\n        int mid;\n        if (length==0)&#123;\n            return 0;\n        &#125;else if (length%2==1)&#123;\n            mid = arr.size()/2;\n            res = arr.get(mid);\n        &#125;else &#123;\n            mid = arr.size()/2;\n            res = arr.get(mid) + arr.get(mid-1);\n            res = res/2;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"但是\"><a href=\"#但是\" class=\"headerlink\" title=\"但是\"></a>但是</h2><p>要求时间复杂度为 <code>O(log (m+n))</code> </p>\n<p>所以需要使用——归并排序法</p>"},{"title":"Leetcode-003-无重复字符的最长子串","date":"2021-04-21T08:51:03.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png","_content":"\n\n\n# 无重复字符的最长子串\n\n<!--more-->\n\n## 滑动窗口法\n\n```java\nimport java.util.ArrayList;\n\npublic class LengthOfLongestSubstring_003 {\n    public static void main(String[] args) {\n        String str = new String(\"twwwwwwwwwwwwwt\");\n\n        int len = lengthOfLongestSubstring(str);\n        System.out.println(len);\n    }\n\n    public static int lengthOfLongestSubstring(String s) {\n        int len = 0;\n        int left = 0;\n        String[] strs = s.split(\"\");\n        //存放字符串\n        StringBuilder sb = new StringBuilder();\n        //字符长度为0，结果为0\n        if(s.equals(\"\")) return  0;\n        for (int i = 0; i < strs.length; i++) {\n            //有重复字符出现，左侧范围加一\n            left = Math.max(left++, sb.lastIndexOf(strs[i])+1);\n            //添加下一个字符\n            sb.append(strs[i]);\n            len = Math.max(len, i-left+1);\n        }\n        return len;\n    }\n}\n\n```\n\n\n\n效率过差，耗内存也耗时间，猜测是 lastIndexOf 和 String 扩容机制导致的：\n\n- lastindexof每次遍历全部内容；\n- String 扩容是创建了新的对象，占用了更多的空间；\n- 可以用hashmap，或者参考题解，用 int[] 数组 计录 ASC II 码的方式代替String的对比方法；\n\n","source":"_posts/Leetcode—003-无重复字符的最长子串-20210421.md","raw":"---\ntitle: Leetcode-003-无重复字符的最长子串\ndate: 2021-04-21 16:51:03\ntags:\n- Leetcode\ncategories:\n- Leetcode\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/leetcode.png\n---\n\n\n\n# 无重复字符的最长子串\n\n<!--more-->\n\n## 滑动窗口法\n\n```java\nimport java.util.ArrayList;\n\npublic class LengthOfLongestSubstring_003 {\n    public static void main(String[] args) {\n        String str = new String(\"twwwwwwwwwwwwwt\");\n\n        int len = lengthOfLongestSubstring(str);\n        System.out.println(len);\n    }\n\n    public static int lengthOfLongestSubstring(String s) {\n        int len = 0;\n        int left = 0;\n        String[] strs = s.split(\"\");\n        //存放字符串\n        StringBuilder sb = new StringBuilder();\n        //字符长度为0，结果为0\n        if(s.equals(\"\")) return  0;\n        for (int i = 0; i < strs.length; i++) {\n            //有重复字符出现，左侧范围加一\n            left = Math.max(left++, sb.lastIndexOf(strs[i])+1);\n            //添加下一个字符\n            sb.append(strs[i]);\n            len = Math.max(len, i-left+1);\n        }\n        return len;\n    }\n}\n\n```\n\n\n\n效率过差，耗内存也耗时间，猜测是 lastIndexOf 和 String 扩容机制导致的：\n\n- lastindexof每次遍历全部内容；\n- String 扩容是创建了新的对象，占用了更多的空间；\n- 可以用hashmap，或者参考题解，用 int[] 数组 计录 ASC II 码的方式代替String的对比方法；\n\n","slug":"Leetcode—003-无重复字符的最长子串-20210421","published":1,"updated":"2022-04-07T17:25:27.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x1q001sy4w1dta39zwh","content":"<h1 id=\"无重复字符的最长子串\"><a href=\"#无重复字符的最长子串\" class=\"headerlink\" title=\"无重复字符的最长子串\"></a>无重复字符的最长子串</h1><span id=\"more\"></span>\n\n<h2 id=\"滑动窗口法\"><a href=\"#滑动窗口法\" class=\"headerlink\" title=\"滑动窗口法\"></a>滑动窗口法</h2><pre><code class=\"java\">import java.util.ArrayList;\n\npublic class LengthOfLongestSubstring_003 &#123;\n    public static void main(String[] args) &#123;\n        String str = new String(&quot;twwwwwwwwwwwwwt&quot;);\n\n        int len = lengthOfLongestSubstring(str);\n        System.out.println(len);\n    &#125;\n\n    public static int lengthOfLongestSubstring(String s) &#123;\n        int len = 0;\n        int left = 0;\n        String[] strs = s.split(&quot;&quot;);\n        //存放字符串\n        StringBuilder sb = new StringBuilder();\n        //字符长度为0，结果为0\n        if(s.equals(&quot;&quot;)) return  0;\n        for (int i = 0; i &lt; strs.length; i++) &#123;\n            //有重复字符出现，左侧范围加一\n            left = Math.max(left++, sb.lastIndexOf(strs[i])+1);\n            //添加下一个字符\n            sb.append(strs[i]);\n            len = Math.max(len, i-left+1);\n        &#125;\n        return len;\n    &#125;\n&#125;\n</code></pre>\n<p>效率过差，耗内存也耗时间，猜测是 lastIndexOf 和 String 扩容机制导致的：</p>\n<ul>\n<li>lastindexof每次遍历全部内容；</li>\n<li>String 扩容是创建了新的对象，占用了更多的空间；</li>\n<li>可以用hashmap，或者参考题解，用 int[] 数组 计录 ASC II 码的方式代替String的对比方法；</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"无重复字符的最长子串\"><a href=\"#无重复字符的最长子串\" class=\"headerlink\" title=\"无重复字符的最长子串\"></a>无重复字符的最长子串</h1>","more":"<h2 id=\"滑动窗口法\"><a href=\"#滑动窗口法\" class=\"headerlink\" title=\"滑动窗口法\"></a>滑动窗口法</h2><pre><code class=\"java\">import java.util.ArrayList;\n\npublic class LengthOfLongestSubstring_003 &#123;\n    public static void main(String[] args) &#123;\n        String str = new String(&quot;twwwwwwwwwwwwwt&quot;);\n\n        int len = lengthOfLongestSubstring(str);\n        System.out.println(len);\n    &#125;\n\n    public static int lengthOfLongestSubstring(String s) &#123;\n        int len = 0;\n        int left = 0;\n        String[] strs = s.split(&quot;&quot;);\n        //存放字符串\n        StringBuilder sb = new StringBuilder();\n        //字符长度为0，结果为0\n        if(s.equals(&quot;&quot;)) return  0;\n        for (int i = 0; i &lt; strs.length; i++) &#123;\n            //有重复字符出现，左侧范围加一\n            left = Math.max(left++, sb.lastIndexOf(strs[i])+1);\n            //添加下一个字符\n            sb.append(strs[i]);\n            len = Math.max(len, i-left+1);\n        &#125;\n        return len;\n    &#125;\n&#125;\n</code></pre>\n<p>效率过差，耗内存也耗时间，猜测是 lastIndexOf 和 String 扩容机制导致的：</p>\n<ul>\n<li>lastindexof每次遍历全部内容；</li>\n<li>String 扩容是创建了新的对象，占用了更多的空间；</li>\n<li>可以用hashmap，或者参考题解，用 int[] 数组 计录 ASC II 码的方式代替String的对比方法；</li>\n</ul>"},{"title":"Mysql数据库","date":"2021-04-27T14:28:17.000Z","cover":["https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/mysql.png"],"_content":"\n# MySQL 数据库\n\n<!--more-->\n\n## 数据库引擎的类型\n\n|              | MYISAM | INNODB          |\n| ------------ | ------ | --------------- |\n| 事务支持     | 不支持 | 支持            |\n| 数据行锁定   | 不支持 | 支持            |\n| 外键约束     | 不支持 | 支持            |\n| 全文索引     | 支持   | 不支持          |\n| 表空间的大小 | 较小   | 较大，约为 2 倍 |\n\n常规使用操作：\n\n- MYISAM 节约空间，速度较快\n- INNODB 安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在 data 目录下，一个文件夹对应一个数据库，本质还是文件的存储！\n\nMySQL 引擎在物理文件上的区别：\n\n- InnoDB 在数据库表中只有一个 `*.fm` 文件，以及上级目录下的 `ibdata1` 文件；\n- MYISAM 对应文件\n  - \\*.frm 表结构的定义文件\n  - \\*.MYD 数据文件（data）\n  - \\*.MYI 索引文件（index）\n\n## 三大范式\n\n前[关系数据库](https://baike.baidu.com/item/关系数据库/1237340)有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、[第四范式](https://baike.baidu.com/item/第四范式/3193985)(4NF）和[第五范式](https://baike.baidu.com/item/第五范式/5025271)（5NF，又称完美范式）。\n\n而通常我们用的最多的就是第一范式（1NF）、第二范式（2NF）、第三范式（3NF），也就是本文要讲的“三大范式”。\n\n**第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**\n\n举例说明：\n\n![1NF-1](img/article/Mysql数据库-20210427/1NF-1.png)\n\n在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：\n\n![1NF-2](img/article/Mysql数据库-20210427/1NF-2.png)\n\n可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；\n\n**第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）**\n\n**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**\n\n举例说明：\n\n![2NF-1](img/article/Mysql数据库-20210427/2NF-1.png)\n\n在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，\n\n但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，\n\n这样就不满足第二范式的要求，调整如下，需分成两个表：\n\n![2NF-2](img/article/Mysql数据库-20210427/2NF-2.png)![2NF-3](img/article/Mysql数据库-20210427/2NF-3.png)\n\n**第三范式（3NF）：在 2NF 基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（在 2NF 基础上消除传递依赖）**\n\n**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**\n\n举例说明：\n\n![3NF-1](img/article/Mysql数据库-20210427/3NF-1.png)\n\n上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，\n\n而不是主键“学号”，所以需做如下调整：\n\n![3NF-2](img/article/Mysql数据库-20210427/3NF-2.png)![3NF-3](img/article/Mysql数据库-20210427/3NF-3.png)\n\n这样以来，就满足了第三范式的要求。\n\nps:如果把上表中的班主任姓名改成班主任教工号可能更确切，更符合实际情况，不过只要能理解就行。\n\n(原文地址：https://www.cnblogs.com/wsg25/p/9615100.html)\n\n## JDBC\n\n程序通过数据库驱动 JDBC 和数据库打交道；\n\nSUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个（JAVA 操作数据库的）规范，俗称 JDBC;\n\n对于开发人员来说，只要掌握 jdbc 就扣的操作即可；\n\n```java\n//第一个jdbc程序\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //1.加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");  //固定写法，加载驱动\n\n        //2.用户信息url\n        String url = \"jdbc:mysql://localhost:3306/test01?useUnicode=true&characterEncoding=utf8&useSSL=false\";\n        String name = \"root\";\n        String password = \"123456\";\n\n        //3.连接成功, 数据库对象 Connection  代表数据库\n        Connection connection = DriverManager.getConnection(url, name, password);\n\n        //4.执行SQL的对象 Statement 执行SQL的对象\n        Statement statement = connection.createStatement();\n\n        //5.执行SQL的对象 去执行 SQL ，可能存在结果， 查看返回对象\n        String sql = \"SELECT * FROM user\";\n\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        while (resultSet.next()) {\n            System.out.println(\"id=\" + resultSet.getObject(\"id\"));\n            System.out.println(\"username=\" + resultSet.getObject(\"username\"));\n            System.out.println(\"address=\" + resultSet.getObject(\"address\"));\n            System.out.println(\"=====================================\");\n        }\n\n        //6.释放连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n    }\n```\n\n### `Statement`对象\n\n1. jdbc 中的 Statement 对象用于向数据库发送 SQL 语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可；\n2. Statement 对象的 executeUpdate 方法用于向数据库发送增、删、改的 SQL 语句，executeUpdate 执行完后，将会返回一个证书（即 SQL 语句影响的行数）;\n3. Statement.executeQuery 方法用于向数据库发送查询语句，executeQuery 方法返回代表查询结果的 ResultSet 对象。\n\n### 工具类 JdbcUtils\n\n```java\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JdbcUtils {\n    private static String driver = null;\n    private static String url = null;\n    private static String username = null;\n    private static String password = null;\n    static {\n        try {\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n            Properties properties = new Properties();\n            properties.load(in);\n\n            driver = properties.getProperty(\"driver\");\n            url = properties.getProperty(\"url\");\n            username = properties.getProperty(\"username\");\n            password = properties.getProperty(\"password\");\n\n            //驱动只用加载一次\n            Class.forName(driver);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    //获取连接\n    public static Connection getConnection() throws SQLException {\n        return DriverManager.getConnection(url, username, password);\n    }\n\n    //释放连接\n    public static void release(Connection conn, Statement  st, ResultSet rs) {\n        if (rs!=null) {\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (st!=null) {\n            try {\n                st.close();\n            }catch (SQLException e){\n                e.printStackTrace();\n            }\n        }\n        if (conn!=null) {\n            try {\n                conn.close();\n            }catch (SQLException e){\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n```\n\n### 增删改都是`st.executeUpdate(sql)`\n\n### 查询`st.executeQuery(sql);`\n\n```java\n\t\t\trs = st.executeQuery(sql);\n            while (rs.next()){\n                System.out.println(rs.getObject(\"id\"));\n                System.out.println(rs.getObject(\"username\"));\n                System.out.println(rs.getObject(\"address\"));\n            }\n```\n\n### SQL 注入\n\nsql 存在漏洞，会被攻击导致数据泄露，SQL 会被拼接 or\n\n```java\npublic static void main(String[] args) {\n        login(\" 'or '1=1\", \" 'or '1=1\");\n    }\n\n    public static void login(String username, String password) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n\n        try {\n            conn = JdbcUtils.getConnection(); //获取数据库连接\n            st = conn.createStatement();\n            String sql = \"select username,address from user where username='\" + username + \"' and address='\"+password+\"'\";\n\n            rs = st.executeQuery(sql);\n            while (rs.next()){\n                System.out.println(rs.getObject(\"username\"));\n                System.out.println(rs.getObject(\"address\"));\n                System.out.println(\"=====================================\");\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.release(conn, st, rs);\n        }\n    }\n```\n\n### `preparedStatement` 对象\n\n`preparedStatement`防止注入的本质是它将传递进来的参数当做字符，假设其中存在转义字符，比如(`)会被直接转义；\n\n```java\npublic static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement pst = null;\n\n        try {\n            conn = JdbcUtils.getConnection();\n            String sql = \"INSERT INTO user(id,username,address) VALUES(?,?,?)\";\n            pst = conn.prepareStatement(sql);  //预编译SQL，重写SQL,然后不执行\n\n            pst.setInt(1, 22);\n            pst.setString(2, \"wangwu\");\n            pst.setString(3, \"成华大道\");\n\n            pst.executeUpdate();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.release(conn, pst, null);\n        }\n    }\n```\n\n## Idea 连接 mysql 数据库\n\n![20210427182334](img/article/Mysql数据库-20210427/20210427182334.png)\n\n![](img/article/Mysql数据库-20210427/20210427182427.png)\n\n- 连接错误，修改 `Advanced` 配置中的 `ServerTimeZone` 为 `UTC`；\n- 连接成功后可以在 `Schemas `中勾选要用到的数据库；\n\n![](img/article/Mysql数据库-20210427/20210427183235.png)\n\n## 数据库表事务\n\n### 原子性（Atomicity）\n\n原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n### 一致性（Consistency）\n\n一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n\n拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。\n\n### 隔离性（Isolation）\n\n隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。\n\n即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。\n\n### 持久性（Durability）\n\n持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。\n\n以上介绍完事务的四大特性(简称 ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：\n\n### 脏读\n\n脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。\n\n当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下\n\n```sql\n    update account set money=money+100 where name=’B’;  (此时A通知B)\n\n    update account set money=money - 100 where name=’A’;\n```\n\n当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。\n\n### 不可重复读\n\n不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。\n\n例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。\n\n不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。\n\n在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……\n\n### 虚读(幻读)\n\n幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。\n\n幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。\n\n现在来看看 MySQL 数据库为我们提供的四种隔离级别：\n\n- Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n- Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n- Read committed (读已提交)：可避免脏读的发生。\n- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\n\n以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于 Java 多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在 MySQL 数据库中默认的隔离级别为 Repeatable read (可重复读)。\n\n在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。\n\n在 MySQL 数据库中查看当前事务的隔离级别：\n\n```sql\n    select @@tx_isolation;\n```\n\n在 MySQL 数据库中设置事务的隔离 级别：\n\n```sql\n    set  [glogal | session]  transaction isolation level 隔离级别名称;\n\n    set tx_isolation=’隔离级别名称;’\n```\n\n### java 代码实现事务\n\n1. 开启事务`onn.setAutoCommit(false);`\n2. 一组业务执行完毕，提交事务`conn.commit();`\n3. 可以在 catch 语句中显示的定义回滚语句，但默认的，失败就是会回滚的；\n\n```java\npublic static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n\n        try {\n            conn = JdbcUtils.getConnection();\n            //关闭数据库自动提交，自动会开启事务\n            conn.setAutoCommit(false);  //开启事务\n\n            String sql1 = \"UPDATE ACCOUNT SET money=money-100 where name='A'\";\n            st = conn.prepareStatement(sql1);\n            st.executeUpdate();\n\n            int x = 1/0; //模拟出错，失败自动回滚\n\n            String sql2 = \"UPDATE ACCOUNT SET money=money+100 where name='B'\";\n            st = conn.prepareStatement(sql2);\n            st.executeUpdate();\n\n            //事务完毕，提交事务\n            conn.commit();\n            System.out.println(\"transaction finished\");\n        } catch (SQLException e) {\n            try {\n                conn.rollback(); //回滚\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.release(conn,st,rs);\n        }\n    }\n```\n\n## 数据库连接池\n\n数据库连接 - 执行完毕 - 释放\n\n连接 - 释放十分浪费系统资源\n\n**池化技术：准备一些预先的资源，过来就连接预先准备好的**\n\n最小连接数（常用连接数）：10\n\n最大连接数：100 业务最高承载上限，超出最大连接数的等待\n\n等待超时: 100ms\n\n编写连接池，实现一个接口，DataSource\n\n开源数据源实现：\n\n- DBCP\n- C3P0\n- druid 德鲁伊 阿里巴巴\n\n使用这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码；区别是性能上的区别；\n\n## DBCP\n\n需要用到的 jar 包\n\ncommons-dbcp-1.4 commons-pool-1.6\n\n## C3P0\n\n需要用到的 jar 包\n\nc3p0-0.9.5.5 mchange-commons-java-0.2.19\n\n无论使用什么数据源，本质是一样的，DataSource 接口不会变，方法就不会变。\n\ndruid 结合 springboot 使用。\n","source":"_posts/Mysql数据库-20210427.md","raw":"---\ntitle: Mysql数据库\ndate: 2021-04-27 22:28:17\ntags:\n  - mysql\n  - 狂神说\ncategories:\n  - DB\ncover:\n  - https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/mysql.png\n---\n\n# MySQL 数据库\n\n<!--more-->\n\n## 数据库引擎的类型\n\n|              | MYISAM | INNODB          |\n| ------------ | ------ | --------------- |\n| 事务支持     | 不支持 | 支持            |\n| 数据行锁定   | 不支持 | 支持            |\n| 外键约束     | 不支持 | 支持            |\n| 全文索引     | 支持   | 不支持          |\n| 表空间的大小 | 较小   | 较大，约为 2 倍 |\n\n常规使用操作：\n\n- MYISAM 节约空间，速度较快\n- INNODB 安全性高，事务的处理，多表多用户操作\n\n所有的数据库文件都存在 data 目录下，一个文件夹对应一个数据库，本质还是文件的存储！\n\nMySQL 引擎在物理文件上的区别：\n\n- InnoDB 在数据库表中只有一个 `*.fm` 文件，以及上级目录下的 `ibdata1` 文件；\n- MYISAM 对应文件\n  - \\*.frm 表结构的定义文件\n  - \\*.MYD 数据文件（data）\n  - \\*.MYI 索引文件（index）\n\n## 三大范式\n\n前[关系数据库](https://baike.baidu.com/item/关系数据库/1237340)有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、[第四范式](https://baike.baidu.com/item/第四范式/3193985)(4NF）和[第五范式](https://baike.baidu.com/item/第五范式/5025271)（5NF，又称完美范式）。\n\n而通常我们用的最多的就是第一范式（1NF）、第二范式（2NF）、第三范式（3NF），也就是本文要讲的“三大范式”。\n\n**第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**\n\n举例说明：\n\n![1NF-1](img/article/Mysql数据库-20210427/1NF-1.png)\n\n在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：\n\n![1NF-2](img/article/Mysql数据库-20210427/1NF-2.png)\n\n可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；\n\n**第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）**\n\n**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**\n\n举例说明：\n\n![2NF-1](img/article/Mysql数据库-20210427/2NF-1.png)\n\n在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，\n\n但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，\n\n这样就不满足第二范式的要求，调整如下，需分成两个表：\n\n![2NF-2](img/article/Mysql数据库-20210427/2NF-2.png)![2NF-3](img/article/Mysql数据库-20210427/2NF-3.png)\n\n**第三范式（3NF）：在 2NF 基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（在 2NF 基础上消除传递依赖）**\n\n**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**\n\n举例说明：\n\n![3NF-1](img/article/Mysql数据库-20210427/3NF-1.png)\n\n上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，\n\n而不是主键“学号”，所以需做如下调整：\n\n![3NF-2](img/article/Mysql数据库-20210427/3NF-2.png)![3NF-3](img/article/Mysql数据库-20210427/3NF-3.png)\n\n这样以来，就满足了第三范式的要求。\n\nps:如果把上表中的班主任姓名改成班主任教工号可能更确切，更符合实际情况，不过只要能理解就行。\n\n(原文地址：https://www.cnblogs.com/wsg25/p/9615100.html)\n\n## JDBC\n\n程序通过数据库驱动 JDBC 和数据库打交道；\n\nSUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个（JAVA 操作数据库的）规范，俗称 JDBC;\n\n对于开发人员来说，只要掌握 jdbc 就扣的操作即可；\n\n```java\n//第一个jdbc程序\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //1.加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");  //固定写法，加载驱动\n\n        //2.用户信息url\n        String url = \"jdbc:mysql://localhost:3306/test01?useUnicode=true&characterEncoding=utf8&useSSL=false\";\n        String name = \"root\";\n        String password = \"123456\";\n\n        //3.连接成功, 数据库对象 Connection  代表数据库\n        Connection connection = DriverManager.getConnection(url, name, password);\n\n        //4.执行SQL的对象 Statement 执行SQL的对象\n        Statement statement = connection.createStatement();\n\n        //5.执行SQL的对象 去执行 SQL ，可能存在结果， 查看返回对象\n        String sql = \"SELECT * FROM user\";\n\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        while (resultSet.next()) {\n            System.out.println(\"id=\" + resultSet.getObject(\"id\"));\n            System.out.println(\"username=\" + resultSet.getObject(\"username\"));\n            System.out.println(\"address=\" + resultSet.getObject(\"address\"));\n            System.out.println(\"=====================================\");\n        }\n\n        //6.释放连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n    }\n```\n\n### `Statement`对象\n\n1. jdbc 中的 Statement 对象用于向数据库发送 SQL 语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可；\n2. Statement 对象的 executeUpdate 方法用于向数据库发送增、删、改的 SQL 语句，executeUpdate 执行完后，将会返回一个证书（即 SQL 语句影响的行数）;\n3. Statement.executeQuery 方法用于向数据库发送查询语句，executeQuery 方法返回代表查询结果的 ResultSet 对象。\n\n### 工具类 JdbcUtils\n\n```java\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JdbcUtils {\n    private static String driver = null;\n    private static String url = null;\n    private static String username = null;\n    private static String password = null;\n    static {\n        try {\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n            Properties properties = new Properties();\n            properties.load(in);\n\n            driver = properties.getProperty(\"driver\");\n            url = properties.getProperty(\"url\");\n            username = properties.getProperty(\"username\");\n            password = properties.getProperty(\"password\");\n\n            //驱动只用加载一次\n            Class.forName(driver);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    //获取连接\n    public static Connection getConnection() throws SQLException {\n        return DriverManager.getConnection(url, username, password);\n    }\n\n    //释放连接\n    public static void release(Connection conn, Statement  st, ResultSet rs) {\n        if (rs!=null) {\n            try {\n                rs.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        if (st!=null) {\n            try {\n                st.close();\n            }catch (SQLException e){\n                e.printStackTrace();\n            }\n        }\n        if (conn!=null) {\n            try {\n                conn.close();\n            }catch (SQLException e){\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n```\n\n### 增删改都是`st.executeUpdate(sql)`\n\n### 查询`st.executeQuery(sql);`\n\n```java\n\t\t\trs = st.executeQuery(sql);\n            while (rs.next()){\n                System.out.println(rs.getObject(\"id\"));\n                System.out.println(rs.getObject(\"username\"));\n                System.out.println(rs.getObject(\"address\"));\n            }\n```\n\n### SQL 注入\n\nsql 存在漏洞，会被攻击导致数据泄露，SQL 会被拼接 or\n\n```java\npublic static void main(String[] args) {\n        login(\" 'or '1=1\", \" 'or '1=1\");\n    }\n\n    public static void login(String username, String password) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n\n        try {\n            conn = JdbcUtils.getConnection(); //获取数据库连接\n            st = conn.createStatement();\n            String sql = \"select username,address from user where username='\" + username + \"' and address='\"+password+\"'\";\n\n            rs = st.executeQuery(sql);\n            while (rs.next()){\n                System.out.println(rs.getObject(\"username\"));\n                System.out.println(rs.getObject(\"address\"));\n                System.out.println(\"=====================================\");\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.release(conn, st, rs);\n        }\n    }\n```\n\n### `preparedStatement` 对象\n\n`preparedStatement`防止注入的本质是它将传递进来的参数当做字符，假设其中存在转义字符，比如(`)会被直接转义；\n\n```java\npublic static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement pst = null;\n\n        try {\n            conn = JdbcUtils.getConnection();\n            String sql = \"INSERT INTO user(id,username,address) VALUES(?,?,?)\";\n            pst = conn.prepareStatement(sql);  //预编译SQL，重写SQL,然后不执行\n\n            pst.setInt(1, 22);\n            pst.setString(2, \"wangwu\");\n            pst.setString(3, \"成华大道\");\n\n            pst.executeUpdate();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.release(conn, pst, null);\n        }\n    }\n```\n\n## Idea 连接 mysql 数据库\n\n![20210427182334](img/article/Mysql数据库-20210427/20210427182334.png)\n\n![](img/article/Mysql数据库-20210427/20210427182427.png)\n\n- 连接错误，修改 `Advanced` 配置中的 `ServerTimeZone` 为 `UTC`；\n- 连接成功后可以在 `Schemas `中勾选要用到的数据库；\n\n![](img/article/Mysql数据库-20210427/20210427183235.png)\n\n## 数据库表事务\n\n### 原子性（Atomicity）\n\n原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n### 一致性（Consistency）\n\n一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n\n拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。\n\n### 隔离性（Isolation）\n\n隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。\n\n即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。\n\n### 持久性（Durability）\n\n持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。\n\n以上介绍完事务的四大特性(简称 ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：\n\n### 脏读\n\n脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。\n\n当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下\n\n```sql\n    update account set money=money+100 where name=’B’;  (此时A通知B)\n\n    update account set money=money - 100 where name=’A’;\n```\n\n当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。\n\n### 不可重复读\n\n不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。\n\n例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。\n\n不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。\n\n在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……\n\n### 虚读(幻读)\n\n幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。\n\n幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。\n\n现在来看看 MySQL 数据库为我们提供的四种隔离级别：\n\n- Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n- Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n- Read committed (读已提交)：可避免脏读的发生。\n- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\n\n以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于 Java 多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在 MySQL 数据库中默认的隔离级别为 Repeatable read (可重复读)。\n\n在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。\n\n在 MySQL 数据库中查看当前事务的隔离级别：\n\n```sql\n    select @@tx_isolation;\n```\n\n在 MySQL 数据库中设置事务的隔离 级别：\n\n```sql\n    set  [glogal | session]  transaction isolation level 隔离级别名称;\n\n    set tx_isolation=’隔离级别名称;’\n```\n\n### java 代码实现事务\n\n1. 开启事务`onn.setAutoCommit(false);`\n2. 一组业务执行完毕，提交事务`conn.commit();`\n3. 可以在 catch 语句中显示的定义回滚语句，但默认的，失败就是会回滚的；\n\n```java\npublic static void main(String[] args) {\n        Connection conn = null;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n\n        try {\n            conn = JdbcUtils.getConnection();\n            //关闭数据库自动提交，自动会开启事务\n            conn.setAutoCommit(false);  //开启事务\n\n            String sql1 = \"UPDATE ACCOUNT SET money=money-100 where name='A'\";\n            st = conn.prepareStatement(sql1);\n            st.executeUpdate();\n\n            int x = 1/0; //模拟出错，失败自动回滚\n\n            String sql2 = \"UPDATE ACCOUNT SET money=money+100 where name='B'\";\n            st = conn.prepareStatement(sql2);\n            st.executeUpdate();\n\n            //事务完毕，提交事务\n            conn.commit();\n            System.out.println(\"transaction finished\");\n        } catch (SQLException e) {\n            try {\n                conn.rollback(); //回滚\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.release(conn,st,rs);\n        }\n    }\n```\n\n## 数据库连接池\n\n数据库连接 - 执行完毕 - 释放\n\n连接 - 释放十分浪费系统资源\n\n**池化技术：准备一些预先的资源，过来就连接预先准备好的**\n\n最小连接数（常用连接数）：10\n\n最大连接数：100 业务最高承载上限，超出最大连接数的等待\n\n等待超时: 100ms\n\n编写连接池，实现一个接口，DataSource\n\n开源数据源实现：\n\n- DBCP\n- C3P0\n- druid 德鲁伊 阿里巴巴\n\n使用这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码；区别是性能上的区别；\n\n## DBCP\n\n需要用到的 jar 包\n\ncommons-dbcp-1.4 commons-pool-1.6\n\n## C3P0\n\n需要用到的 jar 包\n\nc3p0-0.9.5.5 mchange-commons-java-0.2.19\n\n无论使用什么数据源，本质是一样的，DataSource 接口不会变，方法就不会变。\n\ndruid 结合 springboot 使用。\n","slug":"Mysql数据库-20210427","published":1,"updated":"2022-06-14T04:09:00.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x28003qy4w1hsypeptb","content":"<h1 id=\"MySQL-数据库\"><a href=\"#MySQL-数据库\" class=\"headerlink\" title=\"MySQL 数据库\"></a>MySQL 数据库</h1><span id=\"more\"></span>\n\n<h2 id=\"数据库引擎的类型\"><a href=\"#数据库引擎的类型\" class=\"headerlink\" title=\"数据库引擎的类型\"></a>数据库引擎的类型</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>MYISAM</th>\n<th>INNODB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事务支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>数据行锁定</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>外键约束</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>表空间的大小</td>\n<td>较小</td>\n<td>较大，约为 2 倍</td>\n</tr>\n</tbody></table>\n<p>常规使用操作：</p>\n<ul>\n<li>MYISAM 节约空间，速度较快</li>\n<li>INNODB 安全性高，事务的处理，多表多用户操作</li>\n</ul>\n<p>所有的数据库文件都存在 data 目录下，一个文件夹对应一个数据库，本质还是文件的存储！</p>\n<p>MySQL 引擎在物理文件上的区别：</p>\n<ul>\n<li>InnoDB 在数据库表中只有一个 <code>*.fm</code> 文件，以及上级目录下的 <code>ibdata1</code> 文件；</li>\n<li>MYISAM 对应文件<ul>\n<li>*.frm 表结构的定义文件</li>\n<li>*.MYD 数据文件（data）</li>\n<li>*.MYI 索引文件（index）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三大范式\"><a href=\"#三大范式\" class=\"headerlink\" title=\"三大范式\"></a>三大范式</h2><p>前<a href=\"https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340\">关系数据库</a>有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985\">第四范式</a>(4NF）和<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271\">第五范式</a>（5NF，又称完美范式）。</p>\n<p>而通常我们用的最多的就是第一范式（1NF）、第二范式（2NF）、第三范式（3NF），也就是本文要讲的“三大范式”。</p>\n<p><strong>第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/1NF-1.png\" alt=\"1NF-1\"></p>\n<p>在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/1NF-2.png\" alt=\"1NF-2\"></p>\n<p>可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；</p>\n<p><strong>第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）</strong></p>\n<p><strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-1.png\" alt=\"2NF-1\"></p>\n<p>在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，</p>\n<p>但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，</p>\n<p>这样就不满足第二范式的要求，调整如下，需分成两个表：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-2.png\" alt=\"2NF-2\"><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-3.png\" alt=\"2NF-3\"></p>\n<p><strong>第三范式（3NF）：在 2NF 基础上，任何非主<a href=\"https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7\">属性</a>不依赖于其它非主属性（在 2NF 基础上消除传递依赖）</strong></p>\n<p><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-1.png\" alt=\"3NF-1\"></p>\n<p>上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，</p>\n<p>而不是主键“学号”，所以需做如下调整：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-2.png\" alt=\"3NF-2\"><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-3.png\" alt=\"3NF-3\"></p>\n<p>这样以来，就满足了第三范式的要求。</p>\n<p>ps:如果把上表中的班主任姓名改成班主任教工号可能更确切，更符合实际情况，不过只要能理解就行。</p>\n<p>(原文地址：<a href=\"https://www.cnblogs.com/wsg25/p/9615100.html\">https://www.cnblogs.com/wsg25/p/9615100.html</a>)</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>程序通过数据库驱动 JDBC 和数据库打交道；</p>\n<p>SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个（JAVA 操作数据库的）规范，俗称 JDBC;</p>\n<p>对于开发人员来说，只要掌握 jdbc 就扣的操作即可；</p>\n<pre><code class=\"java\">//第一个jdbc程序\npublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1.加载驱动\n        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  //固定写法，加载驱动\n\n        //2.用户信息url\n        String url = &quot;jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;;\n        String name = &quot;root&quot;;\n        String password = &quot;123456&quot;;\n\n        //3.连接成功, 数据库对象 Connection  代表数据库\n        Connection connection = DriverManager.getConnection(url, name, password);\n\n        //4.执行SQL的对象 Statement 执行SQL的对象\n        Statement statement = connection.createStatement();\n\n        //5.执行SQL的对象 去执行 SQL ，可能存在结果， 查看返回对象\n        String sql = &quot;SELECT * FROM user&quot;;\n\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        while (resultSet.next()) &#123;\n            System.out.println(&quot;id=&quot; + resultSet.getObject(&quot;id&quot;));\n            System.out.println(&quot;username=&quot; + resultSet.getObject(&quot;username&quot;));\n            System.out.println(&quot;address=&quot; + resultSet.getObject(&quot;address&quot;));\n            System.out.println(&quot;=====================================&quot;);\n        &#125;\n\n        //6.释放连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n    &#125;\n</code></pre>\n<h3 id=\"Statement对象\"><a href=\"#Statement对象\" class=\"headerlink\" title=\"Statement对象\"></a><code>Statement</code>对象</h3><ol>\n<li>jdbc 中的 Statement 对象用于向数据库发送 SQL 语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可；</li>\n<li>Statement 对象的 executeUpdate 方法用于向数据库发送增、删、改的 SQL 语句，executeUpdate 执行完后，将会返回一个证书（即 SQL 语句影响的行数）;</li>\n<li>Statement.executeQuery 方法用于向数据库发送查询语句，executeQuery 方法返回代表查询结果的 ResultSet 对象。</li>\n</ol>\n<h3 id=\"工具类-JdbcUtils\"><a href=\"#工具类-JdbcUtils\" class=\"headerlink\" title=\"工具类 JdbcUtils\"></a>工具类 JdbcUtils</h3><pre><code class=\"java\">import java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JdbcUtils &#123;\n    private static String driver = null;\n    private static String url = null;\n    private static String username = null;\n    private static String password = null;\n    static &#123;\n        try &#123;\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);\n            Properties properties = new Properties();\n            properties.load(in);\n\n            driver = properties.getProperty(&quot;driver&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            username = properties.getProperty(&quot;username&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n\n            //驱动只用加载一次\n            Class.forName(driver);\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    //获取连接\n    public static Connection getConnection() throws SQLException &#123;\n        return DriverManager.getConnection(url, username, password);\n    &#125;\n\n    //释放连接\n    public static void release(Connection conn, Statement  st, ResultSet rs) &#123;\n        if (rs!=null) &#123;\n            try &#123;\n                rs.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (st!=null) &#123;\n            try &#123;\n                st.close();\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!=null) &#123;\n            try &#123;\n                conn.close();\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"增删改都是st-executeUpdate-sql\"><a href=\"#增删改都是st-executeUpdate-sql\" class=\"headerlink\" title=\"增删改都是st.executeUpdate(sql)\"></a>增删改都是<code>st.executeUpdate(sql)</code></h3><h3 id=\"查询st-executeQuery-sql\"><a href=\"#查询st-executeQuery-sql\" class=\"headerlink\" title=\"查询st.executeQuery(sql);\"></a>查询<code>st.executeQuery(sql);</code></h3><pre><code class=\"java\">            rs = st.executeQuery(sql);\n            while (rs.next())&#123;\n                System.out.println(rs.getObject(&quot;id&quot;));\n                System.out.println(rs.getObject(&quot;username&quot;));\n                System.out.println(rs.getObject(&quot;address&quot;));\n            &#125;\n</code></pre>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><p>sql 存在漏洞，会被攻击导致数据泄露，SQL 会被拼接 or</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        login(&quot; &#39;or &#39;1=1&quot;, &quot; &#39;or &#39;1=1&quot;);\n    &#125;\n\n    public static void login(String username, String password) &#123;\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection(); //获取数据库连接\n            st = conn.createStatement();\n            String sql = &quot;select username,address from user where username=&#39;&quot; + username + &quot;&#39; and address=&#39;&quot;+password+&quot;&#39;&quot;;\n\n            rs = st.executeQuery(sql);\n            while (rs.next())&#123;\n                System.out.println(rs.getObject(&quot;username&quot;));\n                System.out.println(rs.getObject(&quot;address&quot;));\n                System.out.println(&quot;=====================================&quot;);\n            &#125;\n\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            JdbcUtils.release(conn, st, rs);\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"preparedStatement-对象\"><a href=\"#preparedStatement-对象\" class=\"headerlink\" title=\"preparedStatement 对象\"></a><code>preparedStatement</code> 对象</h3><p><code>preparedStatement</code>防止注入的本质是它将传递进来的参数当做字符，假设其中存在转义字符，比如(`)会被直接转义；</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Connection conn = null;\n        PreparedStatement pst = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection();\n            String sql = &quot;INSERT INTO user(id,username,address) VALUES(?,?,?)&quot;;\n            pst = conn.prepareStatement(sql);  //预编译SQL，重写SQL,然后不执行\n\n            pst.setInt(1, 22);\n            pst.setString(2, &quot;wangwu&quot;);\n            pst.setString(3, &quot;成华大道&quot;);\n\n            pst.executeUpdate();\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            JdbcUtils.release(conn, pst, null);\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"Idea-连接-mysql-数据库\"><a href=\"#Idea-连接-mysql-数据库\" class=\"headerlink\" title=\"Idea 连接 mysql 数据库\"></a>Idea 连接 mysql 数据库</h2><p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427182334.png\" alt=\"20210427182334\"></p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427182427.png\"></p>\n<ul>\n<li>连接错误，修改 <code>Advanced</code> 配置中的 <code>ServerTimeZone</code> 为 <code>UTC</code>；</li>\n<li>连接成功后可以在 <code>Schemas </code>中勾选要用到的数据库；</li>\n</ul>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427183235.png\"></p>\n<h2 id=\"数据库表事务\"><a href=\"#数据库表事务\" class=\"headerlink\" title=\"数据库表事务\"></a>数据库表事务</h2><h3 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<h3 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>\n<p>拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。</p>\n<h3 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>\n<p>即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>\n<p>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n<h3 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<p>例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>\n<p>以上介绍完事务的四大特性(简称 ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>\n<h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>\n<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下</p>\n<pre><code class=\"sql\">    update account set money=money+100 where name=’B’;  (此时A通知B)\n\n    update account set money=money - 100 where name=’A’;\n</code></pre>\n<p>当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。</p>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>\n<p>例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。</p>\n<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>\n<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……</p>\n<h3 id=\"虚读-幻读\"><a href=\"#虚读-幻读\" class=\"headerlink\" title=\"虚读(幻读)\"></a>虚读(幻读)</h3><p>幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>\n<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>\n<p>现在来看看 MySQL 数据库为我们提供的四种隔离级别：</p>\n<ul>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>\n<li>Read committed (读已提交)：可避免脏读的发生。</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>\n</ul>\n<p>以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于 Java 多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在 MySQL 数据库中默认的隔离级别为 Repeatable read (可重复读)。</p>\n<p>在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。</p>\n<p>在 MySQL 数据库中查看当前事务的隔离级别：</p>\n<pre><code class=\"sql\">    select @@tx_isolation;\n</code></pre>\n<p>在 MySQL 数据库中设置事务的隔离 级别：</p>\n<pre><code class=\"sql\">    set  [glogal | session]  transaction isolation level 隔离级别名称;\n\n    set tx_isolation=’隔离级别名称;’\n</code></pre>\n<h3 id=\"java-代码实现事务\"><a href=\"#java-代码实现事务\" class=\"headerlink\" title=\"java 代码实现事务\"></a>java 代码实现事务</h3><ol>\n<li>开启事务<code>onn.setAutoCommit(false);</code></li>\n<li>一组业务执行完毕，提交事务<code>conn.commit();</code></li>\n<li>可以在 catch 语句中显示的定义回滚语句，但默认的，失败就是会回滚的；</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Connection conn = null;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection();\n            //关闭数据库自动提交，自动会开启事务\n            conn.setAutoCommit(false);  //开启事务\n\n            String sql1 = &quot;UPDATE ACCOUNT SET money=money-100 where name=&#39;A&#39;&quot;;\n            st = conn.prepareStatement(sql1);\n            st.executeUpdate();\n\n            int x = 1/0; //模拟出错，失败自动回滚\n\n            String sql2 = &quot;UPDATE ACCOUNT SET money=money+100 where name=&#39;B&#39;&quot;;\n            st = conn.prepareStatement(sql2);\n            st.executeUpdate();\n\n            //事务完毕，提交事务\n            conn.commit();\n            System.out.println(&quot;transaction finished&quot;);\n        &#125; catch (SQLException e) &#123;\n            try &#123;\n                conn.rollback(); //回滚\n            &#125; catch (SQLException ex) &#123;\n                ex.printStackTrace();\n            &#125;\n            e.printStackTrace();\n        &#125;finally &#123;\n            JdbcUtils.release(conn,st,rs);\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"数据库连接池\"><a href=\"#数据库连接池\" class=\"headerlink\" title=\"数据库连接池\"></a>数据库连接池</h2><p>数据库连接 - 执行完毕 - 释放</p>\n<p>连接 - 释放十分浪费系统资源</p>\n<p><strong>池化技术：准备一些预先的资源，过来就连接预先准备好的</strong></p>\n<p>最小连接数（常用连接数）：10</p>\n<p>最大连接数：100 业务最高承载上限，超出最大连接数的等待</p>\n<p>等待超时: 100ms</p>\n<p>编写连接池，实现一个接口，DataSource</p>\n<p>开源数据源实现：</p>\n<ul>\n<li>DBCP</li>\n<li>C3P0</li>\n<li>druid 德鲁伊 阿里巴巴</li>\n</ul>\n<p>使用这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码；区别是性能上的区别；</p>\n<h2 id=\"DBCP\"><a href=\"#DBCP\" class=\"headerlink\" title=\"DBCP\"></a>DBCP</h2><p>需要用到的 jar 包</p>\n<p>commons-dbcp-1.4 commons-pool-1.6</p>\n<h2 id=\"C3P0\"><a href=\"#C3P0\" class=\"headerlink\" title=\"C3P0\"></a>C3P0</h2><p>需要用到的 jar 包</p>\n<p>c3p0-0.9.5.5 mchange-commons-java-0.2.19</p>\n<p>无论使用什么数据源，本质是一样的，DataSource 接口不会变，方法就不会变。</p>\n<p>druid 结合 springboot 使用。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"MySQL-数据库\"><a href=\"#MySQL-数据库\" class=\"headerlink\" title=\"MySQL 数据库\"></a>MySQL 数据库</h1>","more":"<h2 id=\"数据库引擎的类型\"><a href=\"#数据库引擎的类型\" class=\"headerlink\" title=\"数据库引擎的类型\"></a>数据库引擎的类型</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>MYISAM</th>\n<th>INNODB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事务支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>数据行锁定</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>外键约束</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>表空间的大小</td>\n<td>较小</td>\n<td>较大，约为 2 倍</td>\n</tr>\n</tbody></table>\n<p>常规使用操作：</p>\n<ul>\n<li>MYISAM 节约空间，速度较快</li>\n<li>INNODB 安全性高，事务的处理，多表多用户操作</li>\n</ul>\n<p>所有的数据库文件都存在 data 目录下，一个文件夹对应一个数据库，本质还是文件的存储！</p>\n<p>MySQL 引擎在物理文件上的区别：</p>\n<ul>\n<li>InnoDB 在数据库表中只有一个 <code>*.fm</code> 文件，以及上级目录下的 <code>ibdata1</code> 文件；</li>\n<li>MYISAM 对应文件<ul>\n<li>*.frm 表结构的定义文件</li>\n<li>*.MYD 数据文件（data）</li>\n<li>*.MYI 索引文件（index）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三大范式\"><a href=\"#三大范式\" class=\"headerlink\" title=\"三大范式\"></a>三大范式</h2><p>前<a href=\"https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/1237340\">关系数据库</a>有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F/3193985\">第四范式</a>(4NF）和<a href=\"https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F/5025271\">第五范式</a>（5NF，又称完美范式）。</p>\n<p>而通常我们用的最多的就是第一范式（1NF）、第二范式（2NF）、第三范式（3NF），也就是本文要讲的“三大范式”。</p>\n<p><strong>第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/1NF-1.png\" alt=\"1NF-1\"></p>\n<p>在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/1NF-2.png\" alt=\"1NF-2\"></p>\n<p>可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；</p>\n<p><strong>第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）</strong></p>\n<p><strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-1.png\" alt=\"2NF-1\"></p>\n<p>在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，</p>\n<p>但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，</p>\n<p>这样就不满足第二范式的要求，调整如下，需分成两个表：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-2.png\" alt=\"2NF-2\"><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/2NF-3.png\" alt=\"2NF-3\"></p>\n<p><strong>第三范式（3NF）：在 2NF 基础上，任何非主<a href=\"https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7\">属性</a>不依赖于其它非主属性（在 2NF 基础上消除传递依赖）</strong></p>\n<p><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong></p>\n<p>举例说明：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-1.png\" alt=\"3NF-1\"></p>\n<p>上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，</p>\n<p>而不是主键“学号”，所以需做如下调整：</p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-2.png\" alt=\"3NF-2\"><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/3NF-3.png\" alt=\"3NF-3\"></p>\n<p>这样以来，就满足了第三范式的要求。</p>\n<p>ps:如果把上表中的班主任姓名改成班主任教工号可能更确切，更符合实际情况，不过只要能理解就行。</p>\n<p>(原文地址：<a href=\"https://www.cnblogs.com/wsg25/p/9615100.html\">https://www.cnblogs.com/wsg25/p/9615100.html</a>)</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>程序通过数据库驱动 JDBC 和数据库打交道；</p>\n<p>SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个（JAVA 操作数据库的）规范，俗称 JDBC;</p>\n<p>对于开发人员来说，只要掌握 jdbc 就扣的操作即可；</p>\n<pre><code class=\"java\">//第一个jdbc程序\npublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1.加载驱动\n        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  //固定写法，加载驱动\n\n        //2.用户信息url\n        String url = &quot;jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;;\n        String name = &quot;root&quot;;\n        String password = &quot;123456&quot;;\n\n        //3.连接成功, 数据库对象 Connection  代表数据库\n        Connection connection = DriverManager.getConnection(url, name, password);\n\n        //4.执行SQL的对象 Statement 执行SQL的对象\n        Statement statement = connection.createStatement();\n\n        //5.执行SQL的对象 去执行 SQL ，可能存在结果， 查看返回对象\n        String sql = &quot;SELECT * FROM user&quot;;\n\n        ResultSet resultSet = statement.executeQuery(sql);\n\n        while (resultSet.next()) &#123;\n            System.out.println(&quot;id=&quot; + resultSet.getObject(&quot;id&quot;));\n            System.out.println(&quot;username=&quot; + resultSet.getObject(&quot;username&quot;));\n            System.out.println(&quot;address=&quot; + resultSet.getObject(&quot;address&quot;));\n            System.out.println(&quot;=====================================&quot;);\n        &#125;\n\n        //6.释放连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n\n    &#125;\n</code></pre>\n<h3 id=\"Statement对象\"><a href=\"#Statement对象\" class=\"headerlink\" title=\"Statement对象\"></a><code>Statement</code>对象</h3><ol>\n<li>jdbc 中的 Statement 对象用于向数据库发送 SQL 语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可；</li>\n<li>Statement 对象的 executeUpdate 方法用于向数据库发送增、删、改的 SQL 语句，executeUpdate 执行完后，将会返回一个证书（即 SQL 语句影响的行数）;</li>\n<li>Statement.executeQuery 方法用于向数据库发送查询语句，executeQuery 方法返回代表查询结果的 ResultSet 对象。</li>\n</ol>\n<h3 id=\"工具类-JdbcUtils\"><a href=\"#工具类-JdbcUtils\" class=\"headerlink\" title=\"工具类 JdbcUtils\"></a>工具类 JdbcUtils</h3><pre><code class=\"java\">import java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JdbcUtils &#123;\n    private static String driver = null;\n    private static String url = null;\n    private static String username = null;\n    private static String password = null;\n    static &#123;\n        try &#123;\n            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);\n            Properties properties = new Properties();\n            properties.load(in);\n\n            driver = properties.getProperty(&quot;driver&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            username = properties.getProperty(&quot;username&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n\n            //驱动只用加载一次\n            Class.forName(driver);\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    //获取连接\n    public static Connection getConnection() throws SQLException &#123;\n        return DriverManager.getConnection(url, username, password);\n    &#125;\n\n    //释放连接\n    public static void release(Connection conn, Statement  st, ResultSet rs) &#123;\n        if (rs!=null) &#123;\n            try &#123;\n                rs.close();\n            &#125; catch (SQLException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (st!=null) &#123;\n            try &#123;\n                st.close();\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (conn!=null) &#123;\n            try &#123;\n                conn.close();\n            &#125;catch (SQLException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"增删改都是st-executeUpdate-sql\"><a href=\"#增删改都是st-executeUpdate-sql\" class=\"headerlink\" title=\"增删改都是st.executeUpdate(sql)\"></a>增删改都是<code>st.executeUpdate(sql)</code></h3><h3 id=\"查询st-executeQuery-sql\"><a href=\"#查询st-executeQuery-sql\" class=\"headerlink\" title=\"查询st.executeQuery(sql);\"></a>查询<code>st.executeQuery(sql);</code></h3><pre><code class=\"java\">            rs = st.executeQuery(sql);\n            while (rs.next())&#123;\n                System.out.println(rs.getObject(&quot;id&quot;));\n                System.out.println(rs.getObject(&quot;username&quot;));\n                System.out.println(rs.getObject(&quot;address&quot;));\n            &#125;\n</code></pre>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><p>sql 存在漏洞，会被攻击导致数据泄露，SQL 会被拼接 or</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        login(&quot; &#39;or &#39;1=1&quot;, &quot; &#39;or &#39;1=1&quot;);\n    &#125;\n\n    public static void login(String username, String password) &#123;\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection(); //获取数据库连接\n            st = conn.createStatement();\n            String sql = &quot;select username,address from user where username=&#39;&quot; + username + &quot;&#39; and address=&#39;&quot;+password+&quot;&#39;&quot;;\n\n            rs = st.executeQuery(sql);\n            while (rs.next())&#123;\n                System.out.println(rs.getObject(&quot;username&quot;));\n                System.out.println(rs.getObject(&quot;address&quot;));\n                System.out.println(&quot;=====================================&quot;);\n            &#125;\n\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            JdbcUtils.release(conn, st, rs);\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"preparedStatement-对象\"><a href=\"#preparedStatement-对象\" class=\"headerlink\" title=\"preparedStatement 对象\"></a><code>preparedStatement</code> 对象</h3><p><code>preparedStatement</code>防止注入的本质是它将传递进来的参数当做字符，假设其中存在转义字符，比如(`)会被直接转义；</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Connection conn = null;\n        PreparedStatement pst = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection();\n            String sql = &quot;INSERT INTO user(id,username,address) VALUES(?,?,?)&quot;;\n            pst = conn.prepareStatement(sql);  //预编译SQL，重写SQL,然后不执行\n\n            pst.setInt(1, 22);\n            pst.setString(2, &quot;wangwu&quot;);\n            pst.setString(3, &quot;成华大道&quot;);\n\n            pst.executeUpdate();\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            JdbcUtils.release(conn, pst, null);\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"Idea-连接-mysql-数据库\"><a href=\"#Idea-连接-mysql-数据库\" class=\"headerlink\" title=\"Idea 连接 mysql 数据库\"></a>Idea 连接 mysql 数据库</h2><p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427182334.png\" alt=\"20210427182334\"></p>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427182427.png\"></p>\n<ul>\n<li>连接错误，修改 <code>Advanced</code> 配置中的 <code>ServerTimeZone</code> 为 <code>UTC</code>；</li>\n<li>连接成功后可以在 <code>Schemas </code>中勾选要用到的数据库；</li>\n</ul>\n<p><img src=\"img/article/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-20210427/20210427183235.png\"></p>\n<h2 id=\"数据库表事务\"><a href=\"#数据库表事务\" class=\"headerlink\" title=\"数据库表事务\"></a>数据库表事务</h2><h3 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<h3 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>\n<p>拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。</p>\n<h3 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>\n<p>即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>\n<p>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n<h3 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<p>例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>\n<p>以上介绍完事务的四大特性(简称 ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>\n<h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>\n<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 100 元，对应 SQL 命令如下</p>\n<pre><code class=\"sql\">    update account set money=money+100 where name=’B’;  (此时A通知B)\n\n    update account set money=money - 100 where name=’A’;\n</code></pre>\n<p>当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。</p>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>\n<p>例如事务 T1 在读取某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。</p>\n<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>\n<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……</p>\n<h3 id=\"虚读-幻读\"><a href=\"#虚读-幻读\" class=\"headerlink\" title=\"虚读(幻读)\"></a>虚读(幻读)</h3><p>幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>\n<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>\n<p>现在来看看 MySQL 数据库为我们提供的四种隔离级别：</p>\n<ul>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>\n<li>Read committed (读已提交)：可避免脏读的发生。</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>\n</ul>\n<p>以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于 Java 多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在 MySQL 数据库中默认的隔离级别为 Repeatable read (可重复读)。</p>\n<p>在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。</p>\n<p>在 MySQL 数据库中查看当前事务的隔离级别：</p>\n<pre><code class=\"sql\">    select @@tx_isolation;\n</code></pre>\n<p>在 MySQL 数据库中设置事务的隔离 级别：</p>\n<pre><code class=\"sql\">    set  [glogal | session]  transaction isolation level 隔离级别名称;\n\n    set tx_isolation=’隔离级别名称;’\n</code></pre>\n<h3 id=\"java-代码实现事务\"><a href=\"#java-代码实现事务\" class=\"headerlink\" title=\"java 代码实现事务\"></a>java 代码实现事务</h3><ol>\n<li>开启事务<code>onn.setAutoCommit(false);</code></li>\n<li>一组业务执行完毕，提交事务<code>conn.commit();</code></li>\n<li>可以在 catch 语句中显示的定义回滚语句，但默认的，失败就是会回滚的；</li>\n</ol>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n        Connection conn = null;\n        PreparedStatement st = null;\n        ResultSet rs = null;\n\n        try &#123;\n            conn = JdbcUtils.getConnection();\n            //关闭数据库自动提交，自动会开启事务\n            conn.setAutoCommit(false);  //开启事务\n\n            String sql1 = &quot;UPDATE ACCOUNT SET money=money-100 where name=&#39;A&#39;&quot;;\n            st = conn.prepareStatement(sql1);\n            st.executeUpdate();\n\n            int x = 1/0; //模拟出错，失败自动回滚\n\n            String sql2 = &quot;UPDATE ACCOUNT SET money=money+100 where name=&#39;B&#39;&quot;;\n            st = conn.prepareStatement(sql2);\n            st.executeUpdate();\n\n            //事务完毕，提交事务\n            conn.commit();\n            System.out.println(&quot;transaction finished&quot;);\n        &#125; catch (SQLException e) &#123;\n            try &#123;\n                conn.rollback(); //回滚\n            &#125; catch (SQLException ex) &#123;\n                ex.printStackTrace();\n            &#125;\n            e.printStackTrace();\n        &#125;finally &#123;\n            JdbcUtils.release(conn,st,rs);\n        &#125;\n    &#125;\n</code></pre>\n<h2 id=\"数据库连接池\"><a href=\"#数据库连接池\" class=\"headerlink\" title=\"数据库连接池\"></a>数据库连接池</h2><p>数据库连接 - 执行完毕 - 释放</p>\n<p>连接 - 释放十分浪费系统资源</p>\n<p><strong>池化技术：准备一些预先的资源，过来就连接预先准备好的</strong></p>\n<p>最小连接数（常用连接数）：10</p>\n<p>最大连接数：100 业务最高承载上限，超出最大连接数的等待</p>\n<p>等待超时: 100ms</p>\n<p>编写连接池，实现一个接口，DataSource</p>\n<p>开源数据源实现：</p>\n<ul>\n<li>DBCP</li>\n<li>C3P0</li>\n<li>druid 德鲁伊 阿里巴巴</li>\n</ul>\n<p>使用这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码；区别是性能上的区别；</p>\n<h2 id=\"DBCP\"><a href=\"#DBCP\" class=\"headerlink\" title=\"DBCP\"></a>DBCP</h2><p>需要用到的 jar 包</p>\n<p>commons-dbcp-1.4 commons-pool-1.6</p>\n<h2 id=\"C3P0\"><a href=\"#C3P0\" class=\"headerlink\" title=\"C3P0\"></a>C3P0</h2><p>需要用到的 jar 包</p>\n<p>c3p0-0.9.5.5 mchange-commons-java-0.2.19</p>\n<p>无论使用什么数据源，本质是一样的，DataSource 接口不会变，方法就不会变。</p>\n<p>druid 结合 springboot 使用。</p>"},{"title":"Hello World","date":"2021-03-31T18:52:54.000Z","_content":"\nHello World~\n\n<!-- more -->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2021-04-01 02:52:54\n---\n\nHello World~\n\n<!-- more -->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2024-08-13T14:37:02.575Z","_id":"clana7x28003ry4w1ax8601e1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Hello World~</p>\n<span id=\"more\"></span>\n\n<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Hello World~</p>","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"PostGis数据类型","date":"2021-08-08T08:38:55.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/postgre.jpeg","_content":"\n\n\n整理自官方文档\n\n<!--more-->\n\n\n\n# PostGIS空间数据库，数据类型\n\n## 几何类型：\n\n### point(点)：\n\n点是几何类型的基本二维构建块。point使用以下任一语法指定类型的值：\n\n```\n（x，y）   x，y\n```\n\n其中*x*和*y*是相应的坐标，作为浮点数。\n\n使用第一种语法输出点。\n\n\n\n### line(线):\n\n线由线性方程`*A*`x + `*B*`y + `*C*`= 0表示，其中`*A*`和`*B*`不都为零。类型的值 `line`以下列形式输入和输出：\n\n```\n{ A，B，C}\n```\n\n或者，可以使用以下任何形式进行输入：\n\n```\n[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n```\n\n其中（x1，y1）和（x2，y2）是线上的两个不同点。\n\n \n\n### lseg(线段):\n\n线段由成对的点表示，这些点是段的端点。`lseg`类型的值使用下列语法中的任何一种来指定：\n\n```\n[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n```\n\n其中（x1，y1）和（x2，y2）是线段的端点。\n\n使用第一种语法输出线段。\n\n\n\n### box (矩形):\n\n矩形是由矩形的对角线的点对来表示的。box 使用下列语法中的任何一种来指定类型的值：\n\n( ( x1 , y1 ) , ( x2 , y2 ) )\n  ( x1 , y1 ) , ( x2 , y2 )\n    x1 , y1   ,   x2 , y2\n\n其中（x1，y1）和（x2，y2）是矩形的任意两个相对的角。\n\n使用第二种语法输出矩形。\n\n可以在输入时提供任意两个相对的角，但是值将根据需要重新排序，以便按顺序存储右上角和左下角。\n\n所以建议在输入时提供右上角和左下角。\n\n\n\n### path(路径)：\n\n路径由连接点列表表示。路径可以是**开放**的（其中列表中的第一和最后一个点被认为是未连接的），或者是**闭合**的（其中第一和最后一个点被认为是连接的）。\n\n`path`使用以下任何语法指定类型的值：\n\n```\n[ ( x1 , y1 ) , ... , ( xn , yn ) ]( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n```\n\n其中点是包括路径的线段的端点。方括号（`[]`）表示开放路径，而圆括号（`()`）表示闭合路径。当省略最外面的括号时，如在第三到第五语法中，假设闭合路径。\n\n其中点是包括路径的线段的端点。方括号（[]）表示开放路径，而小括号（（））表示闭合路径。当最外括号被省略时，如在第三到第五语法中，表示默认为一条闭合路径。\n\n根据需要，建议使用第一或第二语法输出路径。\n\n \n\n### polygon(多边形)：\n\n多边形由点列表（多边形的顶点）表示。多边形与闭合路径非常相似，但存储方式不同，并且具有自己的一组支持程序。\n\n`polygon`使用以下任何一种语法指定类型的值：\n\n```\n( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n```\n\n其中点是包括多边形边界的线段的端点。\n\n建议使用第一种语法输出多边形。\n\n \n\n### circle(圆)：\n\n圆由中心点和半径表示。`circle`使用以下任何一种语法指定类型的值：\n\n```\n< ( x , y ) , r >( ( x , y ) , r )  ( x , y ) , r    x , y   , r\n```\n\n其中（x，y）是中心点，r是圆的半径。\n\n建议使用第一种语法输出圆。\n\n\n\n##  数字类型 ：\n\n### numeric:\n\n numeric [ (p , s ) ]等同于decimal [ (p , s ) ]\t可选精度的准确数字，p代表整数位加小数位的总位数（不算小数点），s代表小数位的位数。 \n\n\n\n### float4 / float8: \n\n 对于`float8`值，此值最多使用 17 个有效十进制数字，对于`float4`值，最多使用9个数字。 \n\n 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用[extra_float_digits](http://www.postgres.cn/docs/12/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)参数选择四舍五入的十进制输出。 将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于`float4`）或15（对于`float8`）个有效的十进制数字。 设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。\n\n\n\n### int2 / int4 / int8:\n\nint2 = smallint；\n\n int4 = integer ；\n\nint8 = bigint；\n\n**`int2`**    2字节小范围整数-32768 to +32767；\n\n**`int4`**    4字节整数的典型选择-2147483648 to +2147483647；\n\n**`int8`**  8字节  大范围整数  -9223372036854775808 to +9223372036854775807\n\n\n\n###  serial2  /   serial4  / serial8：\n\n自增整数\n\n\n\n## 字符型：\n\n### char:\n\n 定长字符串 , postgre 内 char类型数据不够填满长度时，会以空格的形式自动补长，取数据的时候，char类型的要用trim()去掉多余的空格，最大255个字符。\n\n\n\n### varchar:\n\n变长字符串，输入长度不够，变为输入字符长度，最大65535个字节 。\n\n\n\n### text:\n\n无限变长\n\n\n\n## 布尔类型：\n\n### bool:\n\n布尔值， f/ t\n\n输入true或1默认保存为't'\n\n输入false或0默认保存为'f'\n\n可为空(NULL)\n\n\n\n## 二进制数据类型：\n\n### bytea:\n\n bytea类型是PostgreSQL特有的存储二进制数据的字段类型，与SQL标准中的BLOB和BINARY LARGE OBJECT类型相同。\n\n## 位串类型：\n\n### bit:\n\nBIT 是一种可以存储值 0 或 1 的整数类型。\n\n缺省情况下，BIT 数据类型不允许 NULL。\n\n一个 BIT 值需要 1 个存储字节。\n\n在将字符串转换为 BIT 时，前导空格和尾随空格会被删除。如果前导字符是 +，则其将被忽略。如果前导字符是 -，则后面的位会被解释为负数。前导的 0 字符将跳过，其余字符将转换为整数值。如果值不为 0 或 1，则返回错误。\n\n\n\n### varbit:\n\n `varbit(n)` 数据是最长*`n`*的变长类型，更长的串会被拒绝 。\n\n\n\n## 日期类型：\n\n### date:\n\n 日历日期（年，月，日） \n\n\n\n### interval:\n\ninterval [ fields ] [ (p) ]\t16字节\t时间间隔\t-178000000年\t178000000年\n\n| 例子                                               | 描述                                         |\n| -------------------------------------------------- | -------------------------------------------- |\n| 1-2                                                | SQL标准格式：1年2个月                        |\n| 3 4:05:06                                          | SQL标准格式：3日4小时5分钟6秒                |\n| 1 year 2 months 3 days 4 hours 5 minutes 6 seconds | 传统Postgres格式：1年2个月3日4小时5分钟6秒钟 |\n| P1Y2M3DT4H5M6S                                     | “带标志符的”ISO 8601 格式：含义同上          |\n| P0001-02-03T04:05:06                               | ISO 8601 的“替代格式”：含义同上              |\n\n\n\n### time：\n\ntime [ (*p*) ] without time zone\n\n一天中的时间\n\n\n\n### timetz:\n\ntime [ (*p*) ] with time zone\n\n一天里的时间，包括时区\n\n\n\n### timestamp:\n\ntimestamp [ (*p*) ] without time zone\n\n日期和时间\n\n\n\n### timestamptz:\n\ntimestamp [ (*p*) ] with time zone\n\n日期和时间，包括时区\n\n\n\n## JSON 类型:\n\n### json  /  jsonb:\n\njson 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支 持索引，这也是一个令人瞩目的优势。\n\n**JSON 基本类型和相应的PostgreSQL类型**\n\n| JSON 基本类型 | PostgreSQL类型 | 注释                                                         |\n| ------------- | -------------- | ------------------------------------------------------------ |\n| `string`      | `text`         | 不允许`\\u0000`，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样 |\n| `number`      | `numeric`      | 不允许`NaN` 和 `infinity`值                                  |\n| `boolean`     | `boolean`      | 只接受小写`true`和`false`拼写                                |\n| `null`        | (无)           | SQL `NULL`是一个不同的概念                                   |\n\n\n\n##  **复合类型** :\n\n### （Type）:\n\n PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。\n   \\1. 声明复合类型:\n   下面是两个简单的声明示例：\n\n```sql\n  **CREATE TYPE** complex **AS** (\n     r double,\n     i double\n   ); \n   **CREATE TYPE** inventory_item **AS** (\n     name      text,\n     supplier_id  integer,\n     price      numeric\n   );\n```\n\n   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：\n\n   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：\n\n```sql\n CREATE TABLE on_hand (\n     item   **inventory_item**,\n     count  integer\n   );\n```\n\n   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。\n\n   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。\n\n   \\2. 复合类型值输入：\n   我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：\n   '(\"fuzzy dice\",42,1.99)'\n   如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，\n   '(\"fuzzy dice\",42,)'\n   如果只是需要一个空字串，而非NULL，写一对双引号，如：\n   '(\"\",42,)'\n   在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：\n   **ROW**('fuzzy dice', 42, 1.99)\n   **ROW**('', 42, NULL)\n   注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：\n   ('fuzzy dice', 42, 1.99)\n   ('', 42, NULL)\n\n   \\3. 访问复合类型：\n   访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：\n  SELECT (item).name FROM on_hand WHERE (item).price > 9.99;\n   如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：\n\n```sql\n   SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;\n```\n\n   \\4. 修改复合类型：\n   见如下几个示例：\n   *--直接插入复合类型的数据，这里是通过ROW表达式来完成的。*\n\n```sql\n  INSERT INTO on_hand(item) VALUES(ROW(\"fuzzy dice\",42,1.99));\n```\n\n   *--在更新操作中，也是可以通过ROW表达式来完成。*\n\n   *--在更新操作中，也是可以通过ROW表达式来完成。*\n\n```sql\nUPDATE on_hand SET item = ROW(\"fuzzy dice\",42,1.99) WHERE count = 0;\n```\n\n  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*\n   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*\n\n  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*\n   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*\n\n```sql\n  UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;\n```\n\n   *--可以在插入中，直接插入复合类型中字段。*\n\n   *--可以在插入中，直接插入复合类型中字段。*\n\n```sql\n INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2); \n```\n\n\n\n## 域：\n\n### domain：\n\npg中的CREATE DOMAIN表示创建一个新的域，这一功能在oracle中是不支持的。域本质上是一种带有可选约束(在允许的值集合上的 限制)的数据类型。 定义一个域的用户将成为它的拥有者。\n如果给定一个模式名(例如CREATE DOMAIN myschema.mydomain …)，那么域将被创建在 该指定的模式中。 否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间 必 须保持唯一。\n要创建一个域，你必须在其底层类型上拥有USAGE特权。\n\n**语法：**\n\n```sql\nCommand:     CREATE DOMAIN\nDescription: define a new domain\nSyntax:\nCREATE DOMAIN name [ AS ] data_type\n    [ COLLATE collation ]\n    [ DEFAULT expression ]\n    [ constraint [ ... ] ]\n\nwhere constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL | NULL | CHECK (expression) }\n123456789101112\n```\n\n**例子：**\n–创建domain\n创建一个domain表示用来存放小于0的整数\n\n```sql\nbill=# create domain d1 as int check(value < 0);\nCREATE DOMAIN\n12\n```\n\n–使用domain建表\n\n```sql\nbill=# create table t_domain(id d1);\nCREATE TABLE\n12\n```\n\n–插入数据测试\n插入大于0的数便会报错\n\n```sql\nbill=# insert into t_domain values(1);\nERROR:  value for domain d1 violates check constraint \"d1_check\"\nbill=# insert into t_domain values(-1);\nINSERT 0 1\n```\n\n\n\n##  网络地址类型\n\n### cidr / inet:\n\n IPv4 或 IPv6 网络地址 。\n\n `inet`和`cidr`类型之间的本质区别是`inet`接受右边有非零位的网络掩码， 而`cidr`不接受。例如，`192.168.0.1/24`对`inet`是有效的，但对`cidr`是无效的。 \n\n### macaddr：\n\n`macaddr`类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：\n\n'08:00:2b:01:02:03'\n'08-00-2b-01-02-03'\n'08002b:010203'\n'08002b-010203'\n'0800.2b01.0203'\n'0800-2b01-0203'\n'08002b010203'\n\n\n\n### macaddr8：\n\n `macaddr8`类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。 \n\n\n\n## 货币类型：\n\n### money:\n\n| 名字    | 存储尺寸 | 描述   | 范围                                         |\n| ------- | -------- | ------ | -------------------------------------------- |\n| `money` | 8 bytes  | 货币额 | -92233720368547758.08到+92233720368547758.07 |\n\n\n\n## 文本搜索类型：\n\n### tsquery:\n\n一个`tsquery`值存储要用于搜索的词位，并且使用布尔操作符`&`（AND）、`|`（OR）和`!`（NOT）来组合它们，还有短语搜索操作符`<->`（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体`<*`N`*>`，其中*`N`*是一个整数常量，它指定要搜索的两个词位之间的距离。`<->`等效于`<1>`。\n\n圆括号可以被用来强制对操作符分组。如果没有圆括号，`!`（NOT）的优先级最高，其次是`<->`（FOLLOWED BY），然后是`&`（AND），最后是`|`（OR）。\n\n### tsvector:\n\n 一个`tsvector`值是一个排序的可区分词位的列表，*词位*是被*正规化*合并了同一个词的不同变种的词 \n\n\n\n## UUID类型：\n\n数据类型`uuid`存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。\n\n一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：\n\n```\na0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n```\n\nPostgreSQL也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：\n\n```\nA0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\na0eebc999c0b4ef8bb6d6bb9bd380a11\na0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}\n```\n\n输出总是采用标准形式。\n\n\n\n### XML类型:\n\n `xml`数据类型可以被用来存储XML数据。它比直接在一个`text`域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作 \n\n\n\n## 事务快照：\n\n### txid_snapshot\n没看到~","source":"_posts/PostGis数据类型-20210808.md","raw":"---\ntitle: PostGis数据类型\ndate: 2021-08-08 16:38:55\ntags:\n- GIS\n- 数据库\ncategories:\n- DB\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/postgre.jpeg\n---\n\n\n\n整理自官方文档\n\n<!--more-->\n\n\n\n# PostGIS空间数据库，数据类型\n\n## 几何类型：\n\n### point(点)：\n\n点是几何类型的基本二维构建块。point使用以下任一语法指定类型的值：\n\n```\n（x，y）   x，y\n```\n\n其中*x*和*y*是相应的坐标，作为浮点数。\n\n使用第一种语法输出点。\n\n\n\n### line(线):\n\n线由线性方程`*A*`x + `*B*`y + `*C*`= 0表示，其中`*A*`和`*B*`不都为零。类型的值 `line`以下列形式输入和输出：\n\n```\n{ A，B，C}\n```\n\n或者，可以使用以下任何形式进行输入：\n\n```\n[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n```\n\n其中（x1，y1）和（x2，y2）是线上的两个不同点。\n\n \n\n### lseg(线段):\n\n线段由成对的点表示，这些点是段的端点。`lseg`类型的值使用下列语法中的任何一种来指定：\n\n```\n[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n```\n\n其中（x1，y1）和（x2，y2）是线段的端点。\n\n使用第一种语法输出线段。\n\n\n\n### box (矩形):\n\n矩形是由矩形的对角线的点对来表示的。box 使用下列语法中的任何一种来指定类型的值：\n\n( ( x1 , y1 ) , ( x2 , y2 ) )\n  ( x1 , y1 ) , ( x2 , y2 )\n    x1 , y1   ,   x2 , y2\n\n其中（x1，y1）和（x2，y2）是矩形的任意两个相对的角。\n\n使用第二种语法输出矩形。\n\n可以在输入时提供任意两个相对的角，但是值将根据需要重新排序，以便按顺序存储右上角和左下角。\n\n所以建议在输入时提供右上角和左下角。\n\n\n\n### path(路径)：\n\n路径由连接点列表表示。路径可以是**开放**的（其中列表中的第一和最后一个点被认为是未连接的），或者是**闭合**的（其中第一和最后一个点被认为是连接的）。\n\n`path`使用以下任何语法指定类型的值：\n\n```\n[ ( x1 , y1 ) , ... , ( xn , yn ) ]( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n```\n\n其中点是包括路径的线段的端点。方括号（`[]`）表示开放路径，而圆括号（`()`）表示闭合路径。当省略最外面的括号时，如在第三到第五语法中，假设闭合路径。\n\n其中点是包括路径的线段的端点。方括号（[]）表示开放路径，而小括号（（））表示闭合路径。当最外括号被省略时，如在第三到第五语法中，表示默认为一条闭合路径。\n\n根据需要，建议使用第一或第二语法输出路径。\n\n \n\n### polygon(多边形)：\n\n多边形由点列表（多边形的顶点）表示。多边形与闭合路径非常相似，但存储方式不同，并且具有自己的一组支持程序。\n\n`polygon`使用以下任何一种语法指定类型的值：\n\n```\n( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n```\n\n其中点是包括多边形边界的线段的端点。\n\n建议使用第一种语法输出多边形。\n\n \n\n### circle(圆)：\n\n圆由中心点和半径表示。`circle`使用以下任何一种语法指定类型的值：\n\n```\n< ( x , y ) , r >( ( x , y ) , r )  ( x , y ) , r    x , y   , r\n```\n\n其中（x，y）是中心点，r是圆的半径。\n\n建议使用第一种语法输出圆。\n\n\n\n##  数字类型 ：\n\n### numeric:\n\n numeric [ (p , s ) ]等同于decimal [ (p , s ) ]\t可选精度的准确数字，p代表整数位加小数位的总位数（不算小数点），s代表小数位的位数。 \n\n\n\n### float4 / float8: \n\n 对于`float8`值，此值最多使用 17 个有效十进制数字，对于`float4`值，最多使用9个数字。 \n\n 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用[extra_float_digits](http://www.postgres.cn/docs/12/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)参数选择四舍五入的十进制输出。 将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于`float4`）或15（对于`float8`）个有效的十进制数字。 设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。\n\n\n\n### int2 / int4 / int8:\n\nint2 = smallint；\n\n int4 = integer ；\n\nint8 = bigint；\n\n**`int2`**    2字节小范围整数-32768 to +32767；\n\n**`int4`**    4字节整数的典型选择-2147483648 to +2147483647；\n\n**`int8`**  8字节  大范围整数  -9223372036854775808 to +9223372036854775807\n\n\n\n###  serial2  /   serial4  / serial8：\n\n自增整数\n\n\n\n## 字符型：\n\n### char:\n\n 定长字符串 , postgre 内 char类型数据不够填满长度时，会以空格的形式自动补长，取数据的时候，char类型的要用trim()去掉多余的空格，最大255个字符。\n\n\n\n### varchar:\n\n变长字符串，输入长度不够，变为输入字符长度，最大65535个字节 。\n\n\n\n### text:\n\n无限变长\n\n\n\n## 布尔类型：\n\n### bool:\n\n布尔值， f/ t\n\n输入true或1默认保存为't'\n\n输入false或0默认保存为'f'\n\n可为空(NULL)\n\n\n\n## 二进制数据类型：\n\n### bytea:\n\n bytea类型是PostgreSQL特有的存储二进制数据的字段类型，与SQL标准中的BLOB和BINARY LARGE OBJECT类型相同。\n\n## 位串类型：\n\n### bit:\n\nBIT 是一种可以存储值 0 或 1 的整数类型。\n\n缺省情况下，BIT 数据类型不允许 NULL。\n\n一个 BIT 值需要 1 个存储字节。\n\n在将字符串转换为 BIT 时，前导空格和尾随空格会被删除。如果前导字符是 +，则其将被忽略。如果前导字符是 -，则后面的位会被解释为负数。前导的 0 字符将跳过，其余字符将转换为整数值。如果值不为 0 或 1，则返回错误。\n\n\n\n### varbit:\n\n `varbit(n)` 数据是最长*`n`*的变长类型，更长的串会被拒绝 。\n\n\n\n## 日期类型：\n\n### date:\n\n 日历日期（年，月，日） \n\n\n\n### interval:\n\ninterval [ fields ] [ (p) ]\t16字节\t时间间隔\t-178000000年\t178000000年\n\n| 例子                                               | 描述                                         |\n| -------------------------------------------------- | -------------------------------------------- |\n| 1-2                                                | SQL标准格式：1年2个月                        |\n| 3 4:05:06                                          | SQL标准格式：3日4小时5分钟6秒                |\n| 1 year 2 months 3 days 4 hours 5 minutes 6 seconds | 传统Postgres格式：1年2个月3日4小时5分钟6秒钟 |\n| P1Y2M3DT4H5M6S                                     | “带标志符的”ISO 8601 格式：含义同上          |\n| P0001-02-03T04:05:06                               | ISO 8601 的“替代格式”：含义同上              |\n\n\n\n### time：\n\ntime [ (*p*) ] without time zone\n\n一天中的时间\n\n\n\n### timetz:\n\ntime [ (*p*) ] with time zone\n\n一天里的时间，包括时区\n\n\n\n### timestamp:\n\ntimestamp [ (*p*) ] without time zone\n\n日期和时间\n\n\n\n### timestamptz:\n\ntimestamp [ (*p*) ] with time zone\n\n日期和时间，包括时区\n\n\n\n## JSON 类型:\n\n### json  /  jsonb:\n\njson 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支 持索引，这也是一个令人瞩目的优势。\n\n**JSON 基本类型和相应的PostgreSQL类型**\n\n| JSON 基本类型 | PostgreSQL类型 | 注释                                                         |\n| ------------- | -------------- | ------------------------------------------------------------ |\n| `string`      | `text`         | 不允许`\\u0000`，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样 |\n| `number`      | `numeric`      | 不允许`NaN` 和 `infinity`值                                  |\n| `boolean`     | `boolean`      | 只接受小写`true`和`false`拼写                                |\n| `null`        | (无)           | SQL `NULL`是一个不同的概念                                   |\n\n\n\n##  **复合类型** :\n\n### （Type）:\n\n PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。\n   \\1. 声明复合类型:\n   下面是两个简单的声明示例：\n\n```sql\n  **CREATE TYPE** complex **AS** (\n     r double,\n     i double\n   ); \n   **CREATE TYPE** inventory_item **AS** (\n     name      text,\n     supplier_id  integer,\n     price      numeric\n   );\n```\n\n   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：\n\n   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：\n\n```sql\n CREATE TABLE on_hand (\n     item   **inventory_item**,\n     count  integer\n   );\n```\n\n   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。\n\n   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。\n\n   \\2. 复合类型值输入：\n   我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：\n   '(\"fuzzy dice\",42,1.99)'\n   如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，\n   '(\"fuzzy dice\",42,)'\n   如果只是需要一个空字串，而非NULL，写一对双引号，如：\n   '(\"\",42,)'\n   在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：\n   **ROW**('fuzzy dice', 42, 1.99)\n   **ROW**('', 42, NULL)\n   注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：\n   ('fuzzy dice', 42, 1.99)\n   ('', 42, NULL)\n\n   \\3. 访问复合类型：\n   访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：\n  SELECT (item).name FROM on_hand WHERE (item).price > 9.99;\n   如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：\n\n```sql\n   SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;\n```\n\n   \\4. 修改复合类型：\n   见如下几个示例：\n   *--直接插入复合类型的数据，这里是通过ROW表达式来完成的。*\n\n```sql\n  INSERT INTO on_hand(item) VALUES(ROW(\"fuzzy dice\",42,1.99));\n```\n\n   *--在更新操作中，也是可以通过ROW表达式来完成。*\n\n   *--在更新操作中，也是可以通过ROW表达式来完成。*\n\n```sql\nUPDATE on_hand SET item = ROW(\"fuzzy dice\",42,1.99) WHERE count = 0;\n```\n\n  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*\n   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*\n\n  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*\n   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*\n\n```sql\n  UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;\n```\n\n   *--可以在插入中，直接插入复合类型中字段。*\n\n   *--可以在插入中，直接插入复合类型中字段。*\n\n```sql\n INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2); \n```\n\n\n\n## 域：\n\n### domain：\n\npg中的CREATE DOMAIN表示创建一个新的域，这一功能在oracle中是不支持的。域本质上是一种带有可选约束(在允许的值集合上的 限制)的数据类型。 定义一个域的用户将成为它的拥有者。\n如果给定一个模式名(例如CREATE DOMAIN myschema.mydomain …)，那么域将被创建在 该指定的模式中。 否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间 必 须保持唯一。\n要创建一个域，你必须在其底层类型上拥有USAGE特权。\n\n**语法：**\n\n```sql\nCommand:     CREATE DOMAIN\nDescription: define a new domain\nSyntax:\nCREATE DOMAIN name [ AS ] data_type\n    [ COLLATE collation ]\n    [ DEFAULT expression ]\n    [ constraint [ ... ] ]\n\nwhere constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL | NULL | CHECK (expression) }\n123456789101112\n```\n\n**例子：**\n–创建domain\n创建一个domain表示用来存放小于0的整数\n\n```sql\nbill=# create domain d1 as int check(value < 0);\nCREATE DOMAIN\n12\n```\n\n–使用domain建表\n\n```sql\nbill=# create table t_domain(id d1);\nCREATE TABLE\n12\n```\n\n–插入数据测试\n插入大于0的数便会报错\n\n```sql\nbill=# insert into t_domain values(1);\nERROR:  value for domain d1 violates check constraint \"d1_check\"\nbill=# insert into t_domain values(-1);\nINSERT 0 1\n```\n\n\n\n##  网络地址类型\n\n### cidr / inet:\n\n IPv4 或 IPv6 网络地址 。\n\n `inet`和`cidr`类型之间的本质区别是`inet`接受右边有非零位的网络掩码， 而`cidr`不接受。例如，`192.168.0.1/24`对`inet`是有效的，但对`cidr`是无效的。 \n\n### macaddr：\n\n`macaddr`类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：\n\n'08:00:2b:01:02:03'\n'08-00-2b-01-02-03'\n'08002b:010203'\n'08002b-010203'\n'0800.2b01.0203'\n'0800-2b01-0203'\n'08002b010203'\n\n\n\n### macaddr8：\n\n `macaddr8`类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。 \n\n\n\n## 货币类型：\n\n### money:\n\n| 名字    | 存储尺寸 | 描述   | 范围                                         |\n| ------- | -------- | ------ | -------------------------------------------- |\n| `money` | 8 bytes  | 货币额 | -92233720368547758.08到+92233720368547758.07 |\n\n\n\n## 文本搜索类型：\n\n### tsquery:\n\n一个`tsquery`值存储要用于搜索的词位，并且使用布尔操作符`&`（AND）、`|`（OR）和`!`（NOT）来组合它们，还有短语搜索操作符`<->`（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体`<*`N`*>`，其中*`N`*是一个整数常量，它指定要搜索的两个词位之间的距离。`<->`等效于`<1>`。\n\n圆括号可以被用来强制对操作符分组。如果没有圆括号，`!`（NOT）的优先级最高，其次是`<->`（FOLLOWED BY），然后是`&`（AND），最后是`|`（OR）。\n\n### tsvector:\n\n 一个`tsvector`值是一个排序的可区分词位的列表，*词位*是被*正规化*合并了同一个词的不同变种的词 \n\n\n\n## UUID类型：\n\n数据类型`uuid`存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。\n\n一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：\n\n```\na0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n```\n\nPostgreSQL也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：\n\n```\nA0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\na0eebc999c0b4ef8bb6d6bb9bd380a11\na0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}\n```\n\n输出总是采用标准形式。\n\n\n\n### XML类型:\n\n `xml`数据类型可以被用来存储XML数据。它比直接在一个`text`域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作 \n\n\n\n## 事务快照：\n\n### txid_snapshot\n没看到~","slug":"PostGis数据类型-20210808","published":1,"updated":"2022-04-07T17:25:27.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x2a003uy4w12aq6a87k","content":"<p>整理自官方文档</p>\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"PostGIS空间数据库，数据类型\"><a href=\"#PostGIS空间数据库，数据类型\" class=\"headerlink\" title=\"PostGIS空间数据库，数据类型\"></a>PostGIS空间数据库，数据类型</h1><h2 id=\"几何类型：\"><a href=\"#几何类型：\" class=\"headerlink\" title=\"几何类型：\"></a>几何类型：</h2><h3 id=\"point-点-：\"><a href=\"#point-点-：\" class=\"headerlink\" title=\"point(点)：\"></a>point(点)：</h3><p>点是几何类型的基本二维构建块。point使用以下任一语法指定类型的值：</p>\n<pre><code>（x，y）   x，y\n</code></pre>\n<p>其中<em>x</em>和<em>y</em>是相应的坐标，作为浮点数。</p>\n<p>使用第一种语法输出点。</p>\n<h3 id=\"line-线\"><a href=\"#line-线\" class=\"headerlink\" title=\"line(线):\"></a>line(线):</h3><p>线由线性方程<code>*A*</code>x + <code>*B*</code>y + <code>*C*</code>= 0表示，其中<code>*A*</code>和<code>*B*</code>不都为零。类型的值 <code>line</code>以下列形式输入和输出：</p>\n<pre><code>&#123; A，B，C&#125;\n</code></pre>\n<p>或者，可以使用以下任何形式进行输入：</p>\n<pre><code>[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n</code></pre>\n<p>其中（x1，y1）和（x2，y2）是线上的两个不同点。</p>\n<h3 id=\"lseg-线段\"><a href=\"#lseg-线段\" class=\"headerlink\" title=\"lseg(线段):\"></a>lseg(线段):</h3><p>线段由成对的点表示，这些点是段的端点。<code>lseg</code>类型的值使用下列语法中的任何一种来指定：</p>\n<pre><code>[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n</code></pre>\n<p>其中（x1，y1）和（x2，y2）是线段的端点。</p>\n<p>使用第一种语法输出线段。</p>\n<h3 id=\"box-矩形\"><a href=\"#box-矩形\" class=\"headerlink\" title=\"box (矩形):\"></a>box (矩形):</h3><p>矩形是由矩形的对角线的点对来表示的。box 使用下列语法中的任何一种来指定类型的值：</p>\n<p>( ( x1 , y1 ) , ( x2 , y2 ) )<br>  ( x1 , y1 ) , ( x2 , y2 )<br>    x1 , y1   ,   x2 , y2</p>\n<p>其中（x1，y1）和（x2，y2）是矩形的任意两个相对的角。</p>\n<p>使用第二种语法输出矩形。</p>\n<p>可以在输入时提供任意两个相对的角，但是值将根据需要重新排序，以便按顺序存储右上角和左下角。</p>\n<p>所以建议在输入时提供右上角和左下角。</p>\n<h3 id=\"path-路径-：\"><a href=\"#path-路径-：\" class=\"headerlink\" title=\"path(路径)：\"></a>path(路径)：</h3><p>路径由连接点列表表示。路径可以是<strong>开放</strong>的（其中列表中的第一和最后一个点被认为是未连接的），或者是<strong>闭合</strong>的（其中第一和最后一个点被认为是连接的）。</p>\n<p><code>path</code>使用以下任何语法指定类型的值：</p>\n<pre><code>[ ( x1 , y1 ) , ... , ( xn , yn ) ]( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n</code></pre>\n<p>其中点是包括路径的线段的端点。方括号（<code>[]</code>）表示开放路径，而圆括号（<code>()</code>）表示闭合路径。当省略最外面的括号时，如在第三到第五语法中，假设闭合路径。</p>\n<p>其中点是包括路径的线段的端点。方括号（[]）表示开放路径，而小括号（（））表示闭合路径。当最外括号被省略时，如在第三到第五语法中，表示默认为一条闭合路径。</p>\n<p>根据需要，建议使用第一或第二语法输出路径。</p>\n<h3 id=\"polygon-多边形-：\"><a href=\"#polygon-多边形-：\" class=\"headerlink\" title=\"polygon(多边形)：\"></a>polygon(多边形)：</h3><p>多边形由点列表（多边形的顶点）表示。多边形与闭合路径非常相似，但存储方式不同，并且具有自己的一组支持程序。</p>\n<p><code>polygon</code>使用以下任何一种语法指定类型的值：</p>\n<pre><code>( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n</code></pre>\n<p>其中点是包括多边形边界的线段的端点。</p>\n<p>建议使用第一种语法输出多边形。</p>\n<h3 id=\"circle-圆-：\"><a href=\"#circle-圆-：\" class=\"headerlink\" title=\"circle(圆)：\"></a>circle(圆)：</h3><p>圆由中心点和半径表示。<code>circle</code>使用以下任何一种语法指定类型的值：</p>\n<pre><code>&lt; ( x , y ) , r &gt;( ( x , y ) , r )  ( x , y ) , r    x , y   , r\n</code></pre>\n<p>其中（x，y）是中心点，r是圆的半径。</p>\n<p>建议使用第一种语法输出圆。</p>\n<h2 id=\"数字类型-：\"><a href=\"#数字类型-：\" class=\"headerlink\" title=\"数字类型 ：\"></a>数字类型 ：</h2><h3 id=\"numeric\"><a href=\"#numeric\" class=\"headerlink\" title=\"numeric:\"></a>numeric:</h3><p> numeric [ (p , s ) ]等同于decimal [ (p , s ) ]    可选精度的准确数字，p代表整数位加小数位的总位数（不算小数点），s代表小数位的位数。 </p>\n<h3 id=\"float4-float8\"><a href=\"#float4-float8\" class=\"headerlink\" title=\"float4 / float8:\"></a>float4 / float8:</h3><p> 对于<code>float8</code>值，此值最多使用 17 个有效十进制数字，对于<code>float4</code>值，最多使用9个数字。 </p>\n<p> 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用<a href=\"http://www.postgres.cn/docs/12/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS\">extra_float_digits</a>参数选择四舍五入的十进制输出。 将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于<code>float4</code>）或15（对于<code>float8</code>）个有效的十进制数字。 设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。</p>\n<h3 id=\"int2-int4-int8\"><a href=\"#int2-int4-int8\" class=\"headerlink\" title=\"int2 / int4 / int8:\"></a>int2 / int4 / int8:</h3><p>int2 = smallint；</p>\n<p> int4 = integer ；</p>\n<p>int8 = bigint；</p>\n<p><strong><code>int2</code></strong>    2字节小范围整数-32768 to +32767；</p>\n<p><strong><code>int4</code></strong>    4字节整数的典型选择-2147483648 to +2147483647；</p>\n<p><strong><code>int8</code></strong>  8字节  大范围整数  -9223372036854775808 to +9223372036854775807</p>\n<h3 id=\"serial2-serial4-serial8：\"><a href=\"#serial2-serial4-serial8：\" class=\"headerlink\" title=\"serial2  /   serial4  / serial8：\"></a>serial2  /   serial4  / serial8：</h3><p>自增整数</p>\n<h2 id=\"字符型：\"><a href=\"#字符型：\" class=\"headerlink\" title=\"字符型：\"></a>字符型：</h2><h3 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char:\"></a>char:</h3><p> 定长字符串 , postgre 内 char类型数据不够填满长度时，会以空格的形式自动补长，取数据的时候，char类型的要用trim()去掉多余的空格，最大255个字符。</p>\n<h3 id=\"varchar\"><a href=\"#varchar\" class=\"headerlink\" title=\"varchar:\"></a>varchar:</h3><p>变长字符串，输入长度不够，变为输入字符长度，最大65535个字节 。</p>\n<h3 id=\"text\"><a href=\"#text\" class=\"headerlink\" title=\"text:\"></a>text:</h3><p>无限变长</p>\n<h2 id=\"布尔类型：\"><a href=\"#布尔类型：\" class=\"headerlink\" title=\"布尔类型：\"></a>布尔类型：</h2><h3 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool:\"></a>bool:</h3><p>布尔值， f/ t</p>\n<p>输入true或1默认保存为’t’</p>\n<p>输入false或0默认保存为’f’</p>\n<p>可为空(NULL)</p>\n<h2 id=\"二进制数据类型：\"><a href=\"#二进制数据类型：\" class=\"headerlink\" title=\"二进制数据类型：\"></a>二进制数据类型：</h2><h3 id=\"bytea\"><a href=\"#bytea\" class=\"headerlink\" title=\"bytea:\"></a>bytea:</h3><p> bytea类型是PostgreSQL特有的存储二进制数据的字段类型，与SQL标准中的BLOB和BINARY LARGE OBJECT类型相同。</p>\n<h2 id=\"位串类型：\"><a href=\"#位串类型：\" class=\"headerlink\" title=\"位串类型：\"></a>位串类型：</h2><h3 id=\"bit\"><a href=\"#bit\" class=\"headerlink\" title=\"bit:\"></a>bit:</h3><p>BIT 是一种可以存储值 0 或 1 的整数类型。</p>\n<p>缺省情况下，BIT 数据类型不允许 NULL。</p>\n<p>一个 BIT 值需要 1 个存储字节。</p>\n<p>在将字符串转换为 BIT 时，前导空格和尾随空格会被删除。如果前导字符是 +，则其将被忽略。如果前导字符是 -，则后面的位会被解释为负数。前导的 0 字符将跳过，其余字符将转换为整数值。如果值不为 0 或 1，则返回错误。</p>\n<h3 id=\"varbit\"><a href=\"#varbit\" class=\"headerlink\" title=\"varbit:\"></a>varbit:</h3><p> <code>varbit(n)</code> 数据是最长*<code>n</code>*的变长类型，更长的串会被拒绝 。</p>\n<h2 id=\"日期类型：\"><a href=\"#日期类型：\" class=\"headerlink\" title=\"日期类型：\"></a>日期类型：</h2><h3 id=\"date\"><a href=\"#date\" class=\"headerlink\" title=\"date:\"></a>date:</h3><p> 日历日期（年，月，日） </p>\n<h3 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval:\"></a>interval:</h3><p>interval [ fields ] [ (p) ]    16字节    时间间隔    -178000000年    178000000年</p>\n<table>\n<thead>\n<tr>\n<th>例子</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1-2</td>\n<td>SQL标准格式：1年2个月</td>\n</tr>\n<tr>\n<td>3 4:05:06</td>\n<td>SQL标准格式：3日4小时5分钟6秒</td>\n</tr>\n<tr>\n<td>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td>\n<td>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</td>\n</tr>\n<tr>\n<td>P1Y2M3DT4H5M6S</td>\n<td>“带标志符的”ISO 8601 格式：含义同上</td>\n</tr>\n<tr>\n<td>P0001-02-03T04:05:06</td>\n<td>ISO 8601 的“替代格式”：含义同上</td>\n</tr>\n</tbody></table>\n<h3 id=\"time：\"><a href=\"#time：\" class=\"headerlink\" title=\"time：\"></a>time：</h3><p>time [ (<em>p</em>) ] without time zone</p>\n<p>一天中的时间</p>\n<h3 id=\"timetz\"><a href=\"#timetz\" class=\"headerlink\" title=\"timetz:\"></a>timetz:</h3><p>time [ (<em>p</em>) ] with time zone</p>\n<p>一天里的时间，包括时区</p>\n<h3 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp:\"></a>timestamp:</h3><p>timestamp [ (<em>p</em>) ] without time zone</p>\n<p>日期和时间</p>\n<h3 id=\"timestamptz\"><a href=\"#timestamptz\" class=\"headerlink\" title=\"timestamptz:\"></a>timestamptz:</h3><p>timestamp [ (<em>p</em>) ] with time zone</p>\n<p>日期和时间，包括时区</p>\n<h2 id=\"JSON-类型\"><a href=\"#JSON-类型\" class=\"headerlink\" title=\"JSON 类型:\"></a>JSON 类型:</h2><h3 id=\"json-jsonb\"><a href=\"#json-jsonb\" class=\"headerlink\" title=\"json  /  jsonb:\"></a>json  /  jsonb:</h3><p>json 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支 持索引，这也是一个令人瞩目的优势。</p>\n<p><strong>JSON 基本类型和相应的PostgreSQL类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>JSON 基本类型</th>\n<th>PostgreSQL类型</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string</code></td>\n<td><code>text</code></td>\n<td>不允许<code>\\u0000</code>，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样</td>\n</tr>\n<tr>\n<td><code>number</code></td>\n<td><code>numeric</code></td>\n<td>不允许<code>NaN</code> 和 <code>infinity</code>值</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td><code>boolean</code></td>\n<td>只接受小写<code>true</code>和<code>false</code>拼写</td>\n</tr>\n<tr>\n<td><code>null</code></td>\n<td>(无)</td>\n<td>SQL <code>NULL</code>是一个不同的概念</td>\n</tr>\n</tbody></table>\n<h2 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型 :\"></a><strong>复合类型</strong> :</h2><h3 id=\"（Type）\"><a href=\"#（Type）\" class=\"headerlink\" title=\"（Type）:\"></a>（Type）:</h3><p> PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。<br>   \\1. 声明复合类型:<br>   下面是两个简单的声明示例：</p>\n<pre><code class=\"sql\">  **CREATE TYPE** complex **AS** (\n     r double,\n     i double\n   ); \n   **CREATE TYPE** inventory_item **AS** (\n     name      text,\n     supplier_id  integer,\n     price      numeric\n   );\n</code></pre>\n<p>   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：</p>\n<p>   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：</p>\n<pre><code class=\"sql\"> CREATE TABLE on_hand (\n     item   **inventory_item**,\n     count  integer\n   );\n</code></pre>\n<p>   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。</p>\n<p>   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。</p>\n<p>   \\2. 复合类型值输入：<br>   我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：<br>   ‘(“fuzzy dice”,42,1.99)’<br>   如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，<br>   ‘(“fuzzy dice”,42,)’<br>   如果只是需要一个空字串，而非NULL，写一对双引号，如：<br>   ‘(“”,42,)’<br>   在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：<br>   <strong>ROW</strong>(‘fuzzy dice’, 42, 1.99)<br>   <strong>ROW</strong>(‘’, 42, NULL)<br>   注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：<br>   (‘fuzzy dice’, 42, 1.99)<br>   (‘’, 42, NULL)</p>\n<p>   \\3. 访问复合类型：<br>   访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：<br>  SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;<br>   如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：</p>\n<pre><code class=\"sql\">   SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;\n</code></pre>\n<p>   \\4. 修改复合类型：<br>   见如下几个示例：<br>   <em>–直接插入复合类型的数据，这里是通过ROW表达式来完成的。</em></p>\n<pre><code class=\"sql\">  INSERT INTO on_hand(item) VALUES(ROW(&quot;fuzzy dice&quot;,42,1.99));\n</code></pre>\n<p>   <em>–在更新操作中，也是可以通过ROW表达式来完成。</em></p>\n<p>   <em>–在更新操作中，也是可以通过ROW表达式来完成。</em></p>\n<pre><code class=\"sql\">UPDATE on_hand SET item = ROW(&quot;fuzzy dice&quot;,42,1.99) WHERE count = 0;\n</code></pre>\n<p>  <em>–在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，</em><br>   <em>–但是在等号右边的表达式里引用同一个字段时却需要圆括号。</em></p>\n<p>  <em>–在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，</em><br>   <em>–但是在等号右边的表达式里引用同一个字段时却需要圆括号。</em></p>\n<pre><code class=\"sql\">  UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;\n</code></pre>\n<p>   <em>–可以在插入中，直接插入复合类型中字段。</em></p>\n<p>   <em>–可以在插入中，直接插入复合类型中字段。</em></p>\n<pre><code class=\"sql\"> INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2); \n</code></pre>\n<h2 id=\"域：\"><a href=\"#域：\" class=\"headerlink\" title=\"域：\"></a>域：</h2><h3 id=\"domain：\"><a href=\"#domain：\" class=\"headerlink\" title=\"domain：\"></a>domain：</h3><p>pg中的CREATE DOMAIN表示创建一个新的域，这一功能在oracle中是不支持的。域本质上是一种带有可选约束(在允许的值集合上的 限制)的数据类型。 定义一个域的用户将成为它的拥有者。<br>如果给定一个模式名(例如CREATE DOMAIN myschema.mydomain …)，那么域将被创建在 该指定的模式中。 否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间 必 须保持唯一。<br>要创建一个域，你必须在其底层类型上拥有USAGE特权。</p>\n<p><strong>语法：</strong></p>\n<pre><code class=\"sql\">Command:     CREATE DOMAIN\nDescription: define a new domain\nSyntax:\nCREATE DOMAIN name [ AS ] data_type\n    [ COLLATE collation ]\n    [ DEFAULT expression ]\n    [ constraint [ ... ] ]\n\nwhere constraint is:\n\n[ CONSTRAINT constraint_name ]\n&#123; NOT NULL | NULL | CHECK (expression) &#125;\n123456789101112\n</code></pre>\n<p><strong>例子：</strong><br>–创建domain<br>创建一个domain表示用来存放小于0的整数</p>\n<pre><code class=\"sql\">bill=# create domain d1 as int check(value &lt; 0);\nCREATE DOMAIN\n12\n</code></pre>\n<p>–使用domain建表</p>\n<pre><code class=\"sql\">bill=# create table t_domain(id d1);\nCREATE TABLE\n12\n</code></pre>\n<p>–插入数据测试<br>插入大于0的数便会报错</p>\n<pre><code class=\"sql\">bill=# insert into t_domain values(1);\nERROR:  value for domain d1 violates check constraint &quot;d1_check&quot;\nbill=# insert into t_domain values(-1);\nINSERT 0 1\n</code></pre>\n<h2 id=\"网络地址类型\"><a href=\"#网络地址类型\" class=\"headerlink\" title=\"网络地址类型\"></a>网络地址类型</h2><h3 id=\"cidr-inet\"><a href=\"#cidr-inet\" class=\"headerlink\" title=\"cidr / inet:\"></a>cidr / inet:</h3><p> IPv4 或 IPv6 网络地址 。</p>\n<p> <code>inet</code>和<code>cidr</code>类型之间的本质区别是<code>inet</code>接受右边有非零位的网络掩码， 而<code>cidr</code>不接受。例如，<code>192.168.0.1/24</code>对<code>inet</code>是有效的，但对<code>cidr</code>是无效的。 </p>\n<h3 id=\"macaddr：\"><a href=\"#macaddr：\" class=\"headerlink\" title=\"macaddr：\"></a>macaddr：</h3><p><code>macaddr</code>类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：</p>\n<p>‘08:00:2b:01:02:03’<br>‘08-00-2b-01-02-03’<br>‘08002b:010203’<br>‘08002b-010203’<br>‘0800.2b01.0203’<br>‘0800-2b01-0203’<br>‘08002b010203’</p>\n<h3 id=\"macaddr8：\"><a href=\"#macaddr8：\" class=\"headerlink\" title=\"macaddr8：\"></a>macaddr8：</h3><p> <code>macaddr8</code>类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。 </p>\n<h2 id=\"货币类型：\"><a href=\"#货币类型：\" class=\"headerlink\" title=\"货币类型：\"></a>货币类型：</h2><h3 id=\"money\"><a href=\"#money\" class=\"headerlink\" title=\"money:\"></a>money:</h3><table>\n<thead>\n<tr>\n<th>名字</th>\n<th>存储尺寸</th>\n<th>描述</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>money</code></td>\n<td>8 bytes</td>\n<td>货币额</td>\n<td>-92233720368547758.08到+92233720368547758.07</td>\n</tr>\n</tbody></table>\n<h2 id=\"文本搜索类型：\"><a href=\"#文本搜索类型：\" class=\"headerlink\" title=\"文本搜索类型：\"></a>文本搜索类型：</h2><h3 id=\"tsquery\"><a href=\"#tsquery\" class=\"headerlink\" title=\"tsquery:\"></a>tsquery:</h3><p>一个<code>tsquery</code>值存储要用于搜索的词位，并且使用布尔操作符<code>&amp;</code>（AND）、<code>|</code>（OR）和<code>!</code>（NOT）来组合它们，还有短语搜索操作符<code>&lt;-&gt;</code>（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体<code>&lt;*</code>N<code>*&gt;</code>，其中*<code>N</code>*是一个整数常量，它指定要搜索的两个词位之间的距离。<code>&lt;-&gt;</code>等效于<code>&lt;1&gt;</code>。</p>\n<p>圆括号可以被用来强制对操作符分组。如果没有圆括号，<code>!</code>（NOT）的优先级最高，其次是<code>&lt;-&gt;</code>（FOLLOWED BY），然后是<code>&amp;</code>（AND），最后是<code>|</code>（OR）。</p>\n<h3 id=\"tsvector\"><a href=\"#tsvector\" class=\"headerlink\" title=\"tsvector:\"></a>tsvector:</h3><p> 一个<code>tsvector</code>值是一个排序的可区分词位的列表，<em>词位</em>是被<em>正规化</em>合并了同一个词的不同变种的词 </p>\n<h2 id=\"UUID类型：\"><a href=\"#UUID类型：\" class=\"headerlink\" title=\"UUID类型：\"></a>UUID类型：</h2><p>数据类型<code>uuid</code>存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。</p>\n<p>一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：</p>\n<pre><code>a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n</code></pre>\n<p>PostgreSQL也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：</p>\n<pre><code>A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n&#123;a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11&#125;\na0eebc999c0b4ef8bb6d6bb9bd380a11\na0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n&#123;a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11&#125;\n</code></pre>\n<p>输出总是采用标准形式。</p>\n<h3 id=\"XML类型\"><a href=\"#XML类型\" class=\"headerlink\" title=\"XML类型:\"></a>XML类型:</h3><p> <code>xml</code>数据类型可以被用来存储XML数据。它比直接在一个<code>text</code>域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作 </p>\n<h2 id=\"事务快照：\"><a href=\"#事务快照：\" class=\"headerlink\" title=\"事务快照：\"></a>事务快照：</h2><h3 id=\"txid-snapshot\"><a href=\"#txid-snapshot\" class=\"headerlink\" title=\"txid_snapshot\"></a>txid_snapshot</h3><p>没看到~</p>\n","site":{"data":{}},"excerpt":"<p>整理自官方文档</p>","more":"<h1 id=\"PostGIS空间数据库，数据类型\"><a href=\"#PostGIS空间数据库，数据类型\" class=\"headerlink\" title=\"PostGIS空间数据库，数据类型\"></a>PostGIS空间数据库，数据类型</h1><h2 id=\"几何类型：\"><a href=\"#几何类型：\" class=\"headerlink\" title=\"几何类型：\"></a>几何类型：</h2><h3 id=\"point-点-：\"><a href=\"#point-点-：\" class=\"headerlink\" title=\"point(点)：\"></a>point(点)：</h3><p>点是几何类型的基本二维构建块。point使用以下任一语法指定类型的值：</p>\n<pre><code>（x，y）   x，y\n</code></pre>\n<p>其中<em>x</em>和<em>y</em>是相应的坐标，作为浮点数。</p>\n<p>使用第一种语法输出点。</p>\n<h3 id=\"line-线\"><a href=\"#line-线\" class=\"headerlink\" title=\"line(线):\"></a>line(线):</h3><p>线由线性方程<code>*A*</code>x + <code>*B*</code>y + <code>*C*</code>= 0表示，其中<code>*A*</code>和<code>*B*</code>不都为零。类型的值 <code>line</code>以下列形式输入和输出：</p>\n<pre><code>&#123; A，B，C&#125;\n</code></pre>\n<p>或者，可以使用以下任何形式进行输入：</p>\n<pre><code>[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n</code></pre>\n<p>其中（x1，y1）和（x2，y2）是线上的两个不同点。</p>\n<h3 id=\"lseg-线段\"><a href=\"#lseg-线段\" class=\"headerlink\" title=\"lseg(线段):\"></a>lseg(线段):</h3><p>线段由成对的点表示，这些点是段的端点。<code>lseg</code>类型的值使用下列语法中的任何一种来指定：</p>\n<pre><code>[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2\n</code></pre>\n<p>其中（x1，y1）和（x2，y2）是线段的端点。</p>\n<p>使用第一种语法输出线段。</p>\n<h3 id=\"box-矩形\"><a href=\"#box-矩形\" class=\"headerlink\" title=\"box (矩形):\"></a>box (矩形):</h3><p>矩形是由矩形的对角线的点对来表示的。box 使用下列语法中的任何一种来指定类型的值：</p>\n<p>( ( x1 , y1 ) , ( x2 , y2 ) )<br>  ( x1 , y1 ) , ( x2 , y2 )<br>    x1 , y1   ,   x2 , y2</p>\n<p>其中（x1，y1）和（x2，y2）是矩形的任意两个相对的角。</p>\n<p>使用第二种语法输出矩形。</p>\n<p>可以在输入时提供任意两个相对的角，但是值将根据需要重新排序，以便按顺序存储右上角和左下角。</p>\n<p>所以建议在输入时提供右上角和左下角。</p>\n<h3 id=\"path-路径-：\"><a href=\"#path-路径-：\" class=\"headerlink\" title=\"path(路径)：\"></a>path(路径)：</h3><p>路径由连接点列表表示。路径可以是<strong>开放</strong>的（其中列表中的第一和最后一个点被认为是未连接的），或者是<strong>闭合</strong>的（其中第一和最后一个点被认为是连接的）。</p>\n<p><code>path</code>使用以下任何语法指定类型的值：</p>\n<pre><code>[ ( x1 , y1 ) , ... , ( xn , yn ) ]( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n</code></pre>\n<p>其中点是包括路径的线段的端点。方括号（<code>[]</code>）表示开放路径，而圆括号（<code>()</code>）表示闭合路径。当省略最外面的括号时，如在第三到第五语法中，假设闭合路径。</p>\n<p>其中点是包括路径的线段的端点。方括号（[]）表示开放路径，而小括号（（））表示闭合路径。当最外括号被省略时，如在第三到第五语法中，表示默认为一条闭合路径。</p>\n<p>根据需要，建议使用第一或第二语法输出路径。</p>\n<h3 id=\"polygon-多边形-：\"><a href=\"#polygon-多边形-：\" class=\"headerlink\" title=\"polygon(多边形)：\"></a>polygon(多边形)：</h3><p>多边形由点列表（多边形的顶点）表示。多边形与闭合路径非常相似，但存储方式不同，并且具有自己的一组支持程序。</p>\n<p><code>polygon</code>使用以下任何一种语法指定类型的值：</p>\n<pre><code>( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn\n</code></pre>\n<p>其中点是包括多边形边界的线段的端点。</p>\n<p>建议使用第一种语法输出多边形。</p>\n<h3 id=\"circle-圆-：\"><a href=\"#circle-圆-：\" class=\"headerlink\" title=\"circle(圆)：\"></a>circle(圆)：</h3><p>圆由中心点和半径表示。<code>circle</code>使用以下任何一种语法指定类型的值：</p>\n<pre><code>&lt; ( x , y ) , r &gt;( ( x , y ) , r )  ( x , y ) , r    x , y   , r\n</code></pre>\n<p>其中（x，y）是中心点，r是圆的半径。</p>\n<p>建议使用第一种语法输出圆。</p>\n<h2 id=\"数字类型-：\"><a href=\"#数字类型-：\" class=\"headerlink\" title=\"数字类型 ：\"></a>数字类型 ：</h2><h3 id=\"numeric\"><a href=\"#numeric\" class=\"headerlink\" title=\"numeric:\"></a>numeric:</h3><p> numeric [ (p , s ) ]等同于decimal [ (p , s ) ]    可选精度的准确数字，p代表整数位加小数位的总位数（不算小数点），s代表小数位的位数。 </p>\n<h3 id=\"float4-float8\"><a href=\"#float4-float8\" class=\"headerlink\" title=\"float4 / float8:\"></a>float4 / float8:</h3><p> 对于<code>float8</code>值，此值最多使用 17 个有效十进制数字，对于<code>float4</code>值，最多使用9个数字。 </p>\n<p> 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用<a href=\"http://www.postgres.cn/docs/12/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS\">extra_float_digits</a>参数选择四舍五入的十进制输出。 将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于<code>float4</code>）或15（对于<code>float8</code>）个有效的十进制数字。 设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。</p>\n<h3 id=\"int2-int4-int8\"><a href=\"#int2-int4-int8\" class=\"headerlink\" title=\"int2 / int4 / int8:\"></a>int2 / int4 / int8:</h3><p>int2 = smallint；</p>\n<p> int4 = integer ；</p>\n<p>int8 = bigint；</p>\n<p><strong><code>int2</code></strong>    2字节小范围整数-32768 to +32767；</p>\n<p><strong><code>int4</code></strong>    4字节整数的典型选择-2147483648 to +2147483647；</p>\n<p><strong><code>int8</code></strong>  8字节  大范围整数  -9223372036854775808 to +9223372036854775807</p>\n<h3 id=\"serial2-serial4-serial8：\"><a href=\"#serial2-serial4-serial8：\" class=\"headerlink\" title=\"serial2  /   serial4  / serial8：\"></a>serial2  /   serial4  / serial8：</h3><p>自增整数</p>\n<h2 id=\"字符型：\"><a href=\"#字符型：\" class=\"headerlink\" title=\"字符型：\"></a>字符型：</h2><h3 id=\"char\"><a href=\"#char\" class=\"headerlink\" title=\"char:\"></a>char:</h3><p> 定长字符串 , postgre 内 char类型数据不够填满长度时，会以空格的形式自动补长，取数据的时候，char类型的要用trim()去掉多余的空格，最大255个字符。</p>\n<h3 id=\"varchar\"><a href=\"#varchar\" class=\"headerlink\" title=\"varchar:\"></a>varchar:</h3><p>变长字符串，输入长度不够，变为输入字符长度，最大65535个字节 。</p>\n<h3 id=\"text\"><a href=\"#text\" class=\"headerlink\" title=\"text:\"></a>text:</h3><p>无限变长</p>\n<h2 id=\"布尔类型：\"><a href=\"#布尔类型：\" class=\"headerlink\" title=\"布尔类型：\"></a>布尔类型：</h2><h3 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool:\"></a>bool:</h3><p>布尔值， f/ t</p>\n<p>输入true或1默认保存为’t’</p>\n<p>输入false或0默认保存为’f’</p>\n<p>可为空(NULL)</p>\n<h2 id=\"二进制数据类型：\"><a href=\"#二进制数据类型：\" class=\"headerlink\" title=\"二进制数据类型：\"></a>二进制数据类型：</h2><h3 id=\"bytea\"><a href=\"#bytea\" class=\"headerlink\" title=\"bytea:\"></a>bytea:</h3><p> bytea类型是PostgreSQL特有的存储二进制数据的字段类型，与SQL标准中的BLOB和BINARY LARGE OBJECT类型相同。</p>\n<h2 id=\"位串类型：\"><a href=\"#位串类型：\" class=\"headerlink\" title=\"位串类型：\"></a>位串类型：</h2><h3 id=\"bit\"><a href=\"#bit\" class=\"headerlink\" title=\"bit:\"></a>bit:</h3><p>BIT 是一种可以存储值 0 或 1 的整数类型。</p>\n<p>缺省情况下，BIT 数据类型不允许 NULL。</p>\n<p>一个 BIT 值需要 1 个存储字节。</p>\n<p>在将字符串转换为 BIT 时，前导空格和尾随空格会被删除。如果前导字符是 +，则其将被忽略。如果前导字符是 -，则后面的位会被解释为负数。前导的 0 字符将跳过，其余字符将转换为整数值。如果值不为 0 或 1，则返回错误。</p>\n<h3 id=\"varbit\"><a href=\"#varbit\" class=\"headerlink\" title=\"varbit:\"></a>varbit:</h3><p> <code>varbit(n)</code> 数据是最长*<code>n</code>*的变长类型，更长的串会被拒绝 。</p>\n<h2 id=\"日期类型：\"><a href=\"#日期类型：\" class=\"headerlink\" title=\"日期类型：\"></a>日期类型：</h2><h3 id=\"date\"><a href=\"#date\" class=\"headerlink\" title=\"date:\"></a>date:</h3><p> 日历日期（年，月，日） </p>\n<h3 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval:\"></a>interval:</h3><p>interval [ fields ] [ (p) ]    16字节    时间间隔    -178000000年    178000000年</p>\n<table>\n<thead>\n<tr>\n<th>例子</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1-2</td>\n<td>SQL标准格式：1年2个月</td>\n</tr>\n<tr>\n<td>3 4:05:06</td>\n<td>SQL标准格式：3日4小时5分钟6秒</td>\n</tr>\n<tr>\n<td>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td>\n<td>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</td>\n</tr>\n<tr>\n<td>P1Y2M3DT4H5M6S</td>\n<td>“带标志符的”ISO 8601 格式：含义同上</td>\n</tr>\n<tr>\n<td>P0001-02-03T04:05:06</td>\n<td>ISO 8601 的“替代格式”：含义同上</td>\n</tr>\n</tbody></table>\n<h3 id=\"time：\"><a href=\"#time：\" class=\"headerlink\" title=\"time：\"></a>time：</h3><p>time [ (<em>p</em>) ] without time zone</p>\n<p>一天中的时间</p>\n<h3 id=\"timetz\"><a href=\"#timetz\" class=\"headerlink\" title=\"timetz:\"></a>timetz:</h3><p>time [ (<em>p</em>) ] with time zone</p>\n<p>一天里的时间，包括时区</p>\n<h3 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp:\"></a>timestamp:</h3><p>timestamp [ (<em>p</em>) ] without time zone</p>\n<p>日期和时间</p>\n<h3 id=\"timestamptz\"><a href=\"#timestamptz\" class=\"headerlink\" title=\"timestamptz:\"></a>timestamptz:</h3><p>timestamp [ (<em>p</em>) ] with time zone</p>\n<p>日期和时间，包括时区</p>\n<h2 id=\"JSON-类型\"><a href=\"#JSON-类型\" class=\"headerlink\" title=\"JSON 类型:\"></a>JSON 类型:</h2><h3 id=\"json-jsonb\"><a href=\"#json-jsonb\" class=\"headerlink\" title=\"json  /  jsonb:\"></a>json  /  jsonb:</h3><p>json 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支 持索引，这也是一个令人瞩目的优势。</p>\n<p><strong>JSON 基本类型和相应的PostgreSQL类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>JSON 基本类型</th>\n<th>PostgreSQL类型</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string</code></td>\n<td><code>text</code></td>\n<td>不允许<code>\\u0000</code>，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样</td>\n</tr>\n<tr>\n<td><code>number</code></td>\n<td><code>numeric</code></td>\n<td>不允许<code>NaN</code> 和 <code>infinity</code>值</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td><code>boolean</code></td>\n<td>只接受小写<code>true</code>和<code>false</code>拼写</td>\n</tr>\n<tr>\n<td><code>null</code></td>\n<td>(无)</td>\n<td>SQL <code>NULL</code>是一个不同的概念</td>\n</tr>\n</tbody></table>\n<h2 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型 :\"></a><strong>复合类型</strong> :</h2><h3 id=\"（Type）\"><a href=\"#（Type）\" class=\"headerlink\" title=\"（Type）:\"></a>（Type）:</h3><p> PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。<br>   \\1. 声明复合类型:<br>   下面是两个简单的声明示例：</p>\n<pre><code class=\"sql\">  **CREATE TYPE** complex **AS** (\n     r double,\n     i double\n   ); \n   **CREATE TYPE** inventory_item **AS** (\n     name      text,\n     supplier_id  integer,\n     price      numeric\n   );\n</code></pre>\n<p>   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：</p>\n<p>   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：</p>\n<pre><code class=\"sql\"> CREATE TABLE on_hand (\n     item   **inventory_item**,\n     count  integer\n   );\n</code></pre>\n<p>   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。</p>\n<p>   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。</p>\n<p>   \\2. 复合类型值输入：<br>   我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：<br>   ‘(“fuzzy dice”,42,1.99)’<br>   如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，<br>   ‘(“fuzzy dice”,42,)’<br>   如果只是需要一个空字串，而非NULL，写一对双引号，如：<br>   ‘(“”,42,)’<br>   在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：<br>   <strong>ROW</strong>(‘fuzzy dice’, 42, 1.99)<br>   <strong>ROW</strong>(‘’, 42, NULL)<br>   注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：<br>   (‘fuzzy dice’, 42, 1.99)<br>   (‘’, 42, NULL)</p>\n<p>   \\3. 访问复合类型：<br>   访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：<br>  SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;<br>   如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：</p>\n<pre><code class=\"sql\">   SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;\n</code></pre>\n<p>   \\4. 修改复合类型：<br>   见如下几个示例：<br>   <em>–直接插入复合类型的数据，这里是通过ROW表达式来完成的。</em></p>\n<pre><code class=\"sql\">  INSERT INTO on_hand(item) VALUES(ROW(&quot;fuzzy dice&quot;,42,1.99));\n</code></pre>\n<p>   <em>–在更新操作中，也是可以通过ROW表达式来完成。</em></p>\n<p>   <em>–在更新操作中，也是可以通过ROW表达式来完成。</em></p>\n<pre><code class=\"sql\">UPDATE on_hand SET item = ROW(&quot;fuzzy dice&quot;,42,1.99) WHERE count = 0;\n</code></pre>\n<p>  <em>–在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，</em><br>   <em>–但是在等号右边的表达式里引用同一个字段时却需要圆括号。</em></p>\n<p>  <em>–在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，</em><br>   <em>–但是在等号右边的表达式里引用同一个字段时却需要圆括号。</em></p>\n<pre><code class=\"sql\">  UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;\n</code></pre>\n<p>   <em>–可以在插入中，直接插入复合类型中字段。</em></p>\n<p>   <em>–可以在插入中，直接插入复合类型中字段。</em></p>\n<pre><code class=\"sql\"> INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2); \n</code></pre>\n<h2 id=\"域：\"><a href=\"#域：\" class=\"headerlink\" title=\"域：\"></a>域：</h2><h3 id=\"domain：\"><a href=\"#domain：\" class=\"headerlink\" title=\"domain：\"></a>domain：</h3><p>pg中的CREATE DOMAIN表示创建一个新的域，这一功能在oracle中是不支持的。域本质上是一种带有可选约束(在允许的值集合上的 限制)的数据类型。 定义一个域的用户将成为它的拥有者。<br>如果给定一个模式名(例如CREATE DOMAIN myschema.mydomain …)，那么域将被创建在 该指定的模式中。 否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间 必 须保持唯一。<br>要创建一个域，你必须在其底层类型上拥有USAGE特权。</p>\n<p><strong>语法：</strong></p>\n<pre><code class=\"sql\">Command:     CREATE DOMAIN\nDescription: define a new domain\nSyntax:\nCREATE DOMAIN name [ AS ] data_type\n    [ COLLATE collation ]\n    [ DEFAULT expression ]\n    [ constraint [ ... ] ]\n\nwhere constraint is:\n\n[ CONSTRAINT constraint_name ]\n&#123; NOT NULL | NULL | CHECK (expression) &#125;\n123456789101112\n</code></pre>\n<p><strong>例子：</strong><br>–创建domain<br>创建一个domain表示用来存放小于0的整数</p>\n<pre><code class=\"sql\">bill=# create domain d1 as int check(value &lt; 0);\nCREATE DOMAIN\n12\n</code></pre>\n<p>–使用domain建表</p>\n<pre><code class=\"sql\">bill=# create table t_domain(id d1);\nCREATE TABLE\n12\n</code></pre>\n<p>–插入数据测试<br>插入大于0的数便会报错</p>\n<pre><code class=\"sql\">bill=# insert into t_domain values(1);\nERROR:  value for domain d1 violates check constraint &quot;d1_check&quot;\nbill=# insert into t_domain values(-1);\nINSERT 0 1\n</code></pre>\n<h2 id=\"网络地址类型\"><a href=\"#网络地址类型\" class=\"headerlink\" title=\"网络地址类型\"></a>网络地址类型</h2><h3 id=\"cidr-inet\"><a href=\"#cidr-inet\" class=\"headerlink\" title=\"cidr / inet:\"></a>cidr / inet:</h3><p> IPv4 或 IPv6 网络地址 。</p>\n<p> <code>inet</code>和<code>cidr</code>类型之间的本质区别是<code>inet</code>接受右边有非零位的网络掩码， 而<code>cidr</code>不接受。例如，<code>192.168.0.1/24</code>对<code>inet</code>是有效的，但对<code>cidr</code>是无效的。 </p>\n<h3 id=\"macaddr：\"><a href=\"#macaddr：\" class=\"headerlink\" title=\"macaddr：\"></a>macaddr：</h3><p><code>macaddr</code>类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：</p>\n<p>‘08:00:2b:01:02:03’<br>‘08-00-2b-01-02-03’<br>‘08002b:010203’<br>‘08002b-010203’<br>‘0800.2b01.0203’<br>‘0800-2b01-0203’<br>‘08002b010203’</p>\n<h3 id=\"macaddr8：\"><a href=\"#macaddr8：\" class=\"headerlink\" title=\"macaddr8：\"></a>macaddr8：</h3><p> <code>macaddr8</code>类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。 </p>\n<h2 id=\"货币类型：\"><a href=\"#货币类型：\" class=\"headerlink\" title=\"货币类型：\"></a>货币类型：</h2><h3 id=\"money\"><a href=\"#money\" class=\"headerlink\" title=\"money:\"></a>money:</h3><table>\n<thead>\n<tr>\n<th>名字</th>\n<th>存储尺寸</th>\n<th>描述</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>money</code></td>\n<td>8 bytes</td>\n<td>货币额</td>\n<td>-92233720368547758.08到+92233720368547758.07</td>\n</tr>\n</tbody></table>\n<h2 id=\"文本搜索类型：\"><a href=\"#文本搜索类型：\" class=\"headerlink\" title=\"文本搜索类型：\"></a>文本搜索类型：</h2><h3 id=\"tsquery\"><a href=\"#tsquery\" class=\"headerlink\" title=\"tsquery:\"></a>tsquery:</h3><p>一个<code>tsquery</code>值存储要用于搜索的词位，并且使用布尔操作符<code>&amp;</code>（AND）、<code>|</code>（OR）和<code>!</code>（NOT）来组合它们，还有短语搜索操作符<code>&lt;-&gt;</code>（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体<code>&lt;*</code>N<code>*&gt;</code>，其中*<code>N</code>*是一个整数常量，它指定要搜索的两个词位之间的距离。<code>&lt;-&gt;</code>等效于<code>&lt;1&gt;</code>。</p>\n<p>圆括号可以被用来强制对操作符分组。如果没有圆括号，<code>!</code>（NOT）的优先级最高，其次是<code>&lt;-&gt;</code>（FOLLOWED BY），然后是<code>&amp;</code>（AND），最后是<code>|</code>（OR）。</p>\n<h3 id=\"tsvector\"><a href=\"#tsvector\" class=\"headerlink\" title=\"tsvector:\"></a>tsvector:</h3><p> 一个<code>tsvector</code>值是一个排序的可区分词位的列表，<em>词位</em>是被<em>正规化</em>合并了同一个词的不同变种的词 </p>\n<h2 id=\"UUID类型：\"><a href=\"#UUID类型：\" class=\"headerlink\" title=\"UUID类型：\"></a>UUID类型：</h2><p>数据类型<code>uuid</code>存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。</p>\n<p>一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：</p>\n<pre><code>a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n</code></pre>\n<p>PostgreSQL也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：</p>\n<pre><code>A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n&#123;a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11&#125;\na0eebc999c0b4ef8bb6d6bb9bd380a11\na0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n&#123;a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11&#125;\n</code></pre>\n<p>输出总是采用标准形式。</p>\n<h3 id=\"XML类型\"><a href=\"#XML类型\" class=\"headerlink\" title=\"XML类型:\"></a>XML类型:</h3><p> <code>xml</code>数据类型可以被用来存储XML数据。它比直接在一个<code>text</code>域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作 </p>\n<h2 id=\"事务快照：\"><a href=\"#事务快照：\" class=\"headerlink\" title=\"事务快照：\"></a>事务快照：</h2><h3 id=\"txid-snapshot\"><a href=\"#txid-snapshot\" class=\"headerlink\" title=\"txid_snapshot\"></a>txid_snapshot</h3><p>没看到~</p>"},{"title":"稀疏数组","date":"2021-04-01T08:28:28.000Z","_content":"\n\n\n==\n\n<!-- more -->\n\n\n\n1. 当一个数组中大部分元素为0时，或者为同一数值时，可以使用稀疏数组来保存该数组；\n   稀疏数组处理方式：\n\n- 记录数一共有几行几列，有几种不同值；\n- 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模；\n\n2. 原始数组\n\n```\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n```\n\n\n\n3. 稀疏数组\n\n```\n| 行  | 列  | 值  |\n---------------------\n| 11  | 11  | 2  |\n| 1   | 2   | 1  |\n| 2   | 3   | 1  |\n```\n\n\n\n4. 代码处理：\n\n```java\npublic class ArrayDemo03 {\n    //稀疏数组\n    public static void main(String[] args) {\n        int[][] arr1 = new int[11][11];\n        arr1[1][2] = 1;\n        arr1[2][3] = 1;\n\n        System.out.println(\"输出原始数组：\");\n\n        for (int[] ints : arr1) {\n            for (int anInt : ints) {\n                System.out.print(anInt + \"\\t\");\n            }\n            System.out.print(\"\\n\");\n        }\n\n        System.out.println(\"====================================\");\n\n        //转换为稀疏数组保存\n        //获取有效值保存\n        int sum = 0;\n        for (int i = 0; i < 11; i++) {\n            for (int j = 0; j < 11; j++) {\n                if (arr1[i][j]!=0)\n                    sum++;\n            }\n        }\n        System.out.println(\"有效值得个数为：\" + sum);\n\n\n        System.out.println(\"===============遍历数组，将非0的值存储在稀疏数组中=====================\");\n        int[][] arr2 = new int[sum+1][3];\n\n        arr2[0][0] = 11;\n        arr2[0][1] = 11;\n        arr2[0][2] = sum;\n\n        //遍历数组，将非0的值存储在稀疏数组中\n        int count = 0;\n        for (int i = 0; i < arr1.length; i++) {\n            for (int j = 0; j < arr1[i].length; j++) {\n                if (arr1[i][j]!=0){\n                    count++;\n                    arr2[count][0] = i;\n                    arr2[count][1] = j;\n                    arr2[count][2] = arr1[i][j];\n                }\n            }\n        }\n        System.out.println(\"=============================================\");\n        System.out.println(\"输出稀疏数组：\");\n\n        for (int i = 0; i < arr2.length; i++) {\n            System.out.print(arr2[i][0] + \"\\t\"\n                +arr2[i][1]+\"\\t\"\n                +arr2[i][2]+\"\\n\");\n        }\n\n        System.out.println(\"===============================================\");\n        System.out.println(\"还原\");\n        int[][] arr3 = new int[arr2[0][0]][arr2[0][1]];\n\n        //给其他元素0\n        for (int i = 1; i < arr2.length; i++) {\n            arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2];\n        }\n\n        //打印arr3\n        System.out.println(\"输出还原的数组：\");\n        for (int[] ints : arr3) {\n            for (int anInt : ints) {\n                System.out.print(anInt + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n\n\n5. 输出结果：\n\n```\n输出原始数组：\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n====================================\n有效值得个数为：2\n===============遍历数组，将非0的值存储在稀疏数组中=====================\n=============================================\n输出稀疏数组：\n11\t11\t2\n1\t2\t1\n2\t3\t1\n===============================================\n还原\n输出还原的数组：\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n\nProcess finished with exit code 0\n\n```\n\n可以用来做棋盘","source":"_posts/稀疏数组-20210401.md","raw":"---\ntitle: 稀疏数组\ndate: 2021-04-01 16:28:28\ntags:\n- java\ncategories:\n- java\n---\n\n\n\n==\n\n<!-- more -->\n\n\n\n1. 当一个数组中大部分元素为0时，或者为同一数值时，可以使用稀疏数组来保存该数组；\n   稀疏数组处理方式：\n\n- 记录数一共有几行几列，有几种不同值；\n- 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模；\n\n2. 原始数组\n\n```\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n```\n\n\n\n3. 稀疏数组\n\n```\n| 行  | 列  | 值  |\n---------------------\n| 11  | 11  | 2  |\n| 1   | 2   | 1  |\n| 2   | 3   | 1  |\n```\n\n\n\n4. 代码处理：\n\n```java\npublic class ArrayDemo03 {\n    //稀疏数组\n    public static void main(String[] args) {\n        int[][] arr1 = new int[11][11];\n        arr1[1][2] = 1;\n        arr1[2][3] = 1;\n\n        System.out.println(\"输出原始数组：\");\n\n        for (int[] ints : arr1) {\n            for (int anInt : ints) {\n                System.out.print(anInt + \"\\t\");\n            }\n            System.out.print(\"\\n\");\n        }\n\n        System.out.println(\"====================================\");\n\n        //转换为稀疏数组保存\n        //获取有效值保存\n        int sum = 0;\n        for (int i = 0; i < 11; i++) {\n            for (int j = 0; j < 11; j++) {\n                if (arr1[i][j]!=0)\n                    sum++;\n            }\n        }\n        System.out.println(\"有效值得个数为：\" + sum);\n\n\n        System.out.println(\"===============遍历数组，将非0的值存储在稀疏数组中=====================\");\n        int[][] arr2 = new int[sum+1][3];\n\n        arr2[0][0] = 11;\n        arr2[0][1] = 11;\n        arr2[0][2] = sum;\n\n        //遍历数组，将非0的值存储在稀疏数组中\n        int count = 0;\n        for (int i = 0; i < arr1.length; i++) {\n            for (int j = 0; j < arr1[i].length; j++) {\n                if (arr1[i][j]!=0){\n                    count++;\n                    arr2[count][0] = i;\n                    arr2[count][1] = j;\n                    arr2[count][2] = arr1[i][j];\n                }\n            }\n        }\n        System.out.println(\"=============================================\");\n        System.out.println(\"输出稀疏数组：\");\n\n        for (int i = 0; i < arr2.length; i++) {\n            System.out.print(arr2[i][0] + \"\\t\"\n                +arr2[i][1]+\"\\t\"\n                +arr2[i][2]+\"\\n\");\n        }\n\n        System.out.println(\"===============================================\");\n        System.out.println(\"还原\");\n        int[][] arr3 = new int[arr2[0][0]][arr2[0][1]];\n\n        //给其他元素0\n        for (int i = 1; i < arr2.length; i++) {\n            arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2];\n        }\n\n        //打印arr3\n        System.out.println(\"输出还原的数组：\");\n        for (int[] ints : arr3) {\n            for (int anInt : ints) {\n                System.out.print(anInt + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n\n\n5. 输出结果：\n\n```\n输出原始数组：\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n====================================\n有效值得个数为：2\n===============遍历数组，将非0的值存储在稀疏数组中=====================\n=============================================\n输出稀疏数组：\n11\t11\t2\n1\t2\t1\n2\t3\t1\n===============================================\n还原\n输出还原的数组：\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n\nProcess finished with exit code 0\n\n```\n\n可以用来做棋盘","slug":"稀疏数组-20210401","published":1,"updated":"2022-04-07T17:25:27.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x2a003vy4w1bu3i7mxm","content":"<p>==</p>\n<span id=\"more\"></span>\n\n\n\n<ol>\n<li>当一个数组中大部分元素为0时，或者为同一数值时，可以使用稀疏数组来保存该数组；<br>稀疏数组处理方式：</li>\n</ol>\n<ul>\n<li>记录数一共有几行几列，有几种不同值；</li>\n<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模；</li>\n</ul>\n<ol start=\"2\">\n<li>原始数组</li>\n</ol>\n<pre><code>0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n</code></pre>\n<ol start=\"3\">\n<li>稀疏数组</li>\n</ol>\n<pre><code>| 行  | 列  | 值  |\n---------------------\n| 11  | 11  | 2  |\n| 1   | 2   | 1  |\n| 2   | 3   | 1  |\n</code></pre>\n<ol start=\"4\">\n<li>代码处理：</li>\n</ol>\n<pre><code class=\"java\">public class ArrayDemo03 &#123;\n    //稀疏数组\n    public static void main(String[] args) &#123;\n        int[][] arr1 = new int[11][11];\n        arr1[1][2] = 1;\n        arr1[2][3] = 1;\n\n        System.out.println(&quot;输出原始数组：&quot;);\n\n        for (int[] ints : arr1) &#123;\n            for (int anInt : ints) &#123;\n                System.out.print(anInt + &quot;\\t&quot;);\n            &#125;\n            System.out.print(&quot;\\n&quot;);\n        &#125;\n\n        System.out.println(&quot;====================================&quot;);\n\n        //转换为稀疏数组保存\n        //获取有效值保存\n        int sum = 0;\n        for (int i = 0; i &lt; 11; i++) &#123;\n            for (int j = 0; j &lt; 11; j++) &#123;\n                if (arr1[i][j]!=0)\n                    sum++;\n            &#125;\n        &#125;\n        System.out.println(&quot;有效值得个数为：&quot; + sum);\n\n\n        System.out.println(&quot;===============遍历数组，将非0的值存储在稀疏数组中=====================&quot;);\n        int[][] arr2 = new int[sum+1][3];\n\n        arr2[0][0] = 11;\n        arr2[0][1] = 11;\n        arr2[0][2] = sum;\n\n        //遍历数组，将非0的值存储在稀疏数组中\n        int count = 0;\n        for (int i = 0; i &lt; arr1.length; i++) &#123;\n            for (int j = 0; j &lt; arr1[i].length; j++) &#123;\n                if (arr1[i][j]!=0)&#123;\n                    count++;\n                    arr2[count][0] = i;\n                    arr2[count][1] = j;\n                    arr2[count][2] = arr1[i][j];\n                &#125;\n            &#125;\n        &#125;\n        System.out.println(&quot;=============================================&quot;);\n        System.out.println(&quot;输出稀疏数组：&quot;);\n\n        for (int i = 0; i &lt; arr2.length; i++) &#123;\n            System.out.print(arr2[i][0] + &quot;\\t&quot;\n                +arr2[i][1]+&quot;\\t&quot;\n                +arr2[i][2]+&quot;\\n&quot;);\n        &#125;\n\n        System.out.println(&quot;===============================================&quot;);\n        System.out.println(&quot;还原&quot;);\n        int[][] arr3 = new int[arr2[0][0]][arr2[0][1]];\n\n        //给其他元素0\n        for (int i = 1; i &lt; arr2.length; i++) &#123;\n            arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2];\n        &#125;\n\n        //打印arr3\n        System.out.println(&quot;输出还原的数组：&quot;);\n        for (int[] ints : arr3) &#123;\n            for (int anInt : ints) &#123;\n                System.out.print(anInt + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>输出结果：</li>\n</ol>\n<pre><code>输出原始数组：\n0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n====================================\n有效值得个数为：2\n===============遍历数组，将非0的值存储在稀疏数组中=====================\n=============================================\n输出稀疏数组：\n11    11    2\n1    2    1\n2    3    1\n===============================================\n还原\n输出还原的数组：\n0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n\nProcess finished with exit code 0\n</code></pre>\n<p>可以用来做棋盘</p>\n","site":{"data":{}},"excerpt":"<p>==</p>","more":"<ol>\n<li>当一个数组中大部分元素为0时，或者为同一数值时，可以使用稀疏数组来保存该数组；<br>稀疏数组处理方式：</li>\n</ol>\n<ul>\n<li>记录数一共有几行几列，有几种不同值；</li>\n<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模；</li>\n</ul>\n<ol start=\"2\">\n<li>原始数组</li>\n</ol>\n<pre><code>0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n</code></pre>\n<ol start=\"3\">\n<li>稀疏数组</li>\n</ol>\n<pre><code>| 行  | 列  | 值  |\n---------------------\n| 11  | 11  | 2  |\n| 1   | 2   | 1  |\n| 2   | 3   | 1  |\n</code></pre>\n<ol start=\"4\">\n<li>代码处理：</li>\n</ol>\n<pre><code class=\"java\">public class ArrayDemo03 &#123;\n    //稀疏数组\n    public static void main(String[] args) &#123;\n        int[][] arr1 = new int[11][11];\n        arr1[1][2] = 1;\n        arr1[2][3] = 1;\n\n        System.out.println(&quot;输出原始数组：&quot;);\n\n        for (int[] ints : arr1) &#123;\n            for (int anInt : ints) &#123;\n                System.out.print(anInt + &quot;\\t&quot;);\n            &#125;\n            System.out.print(&quot;\\n&quot;);\n        &#125;\n\n        System.out.println(&quot;====================================&quot;);\n\n        //转换为稀疏数组保存\n        //获取有效值保存\n        int sum = 0;\n        for (int i = 0; i &lt; 11; i++) &#123;\n            for (int j = 0; j &lt; 11; j++) &#123;\n                if (arr1[i][j]!=0)\n                    sum++;\n            &#125;\n        &#125;\n        System.out.println(&quot;有效值得个数为：&quot; + sum);\n\n\n        System.out.println(&quot;===============遍历数组，将非0的值存储在稀疏数组中=====================&quot;);\n        int[][] arr2 = new int[sum+1][3];\n\n        arr2[0][0] = 11;\n        arr2[0][1] = 11;\n        arr2[0][2] = sum;\n\n        //遍历数组，将非0的值存储在稀疏数组中\n        int count = 0;\n        for (int i = 0; i &lt; arr1.length; i++) &#123;\n            for (int j = 0; j &lt; arr1[i].length; j++) &#123;\n                if (arr1[i][j]!=0)&#123;\n                    count++;\n                    arr2[count][0] = i;\n                    arr2[count][1] = j;\n                    arr2[count][2] = arr1[i][j];\n                &#125;\n            &#125;\n        &#125;\n        System.out.println(&quot;=============================================&quot;);\n        System.out.println(&quot;输出稀疏数组：&quot;);\n\n        for (int i = 0; i &lt; arr2.length; i++) &#123;\n            System.out.print(arr2[i][0] + &quot;\\t&quot;\n                +arr2[i][1]+&quot;\\t&quot;\n                +arr2[i][2]+&quot;\\n&quot;);\n        &#125;\n\n        System.out.println(&quot;===============================================&quot;);\n        System.out.println(&quot;还原&quot;);\n        int[][] arr3 = new int[arr2[0][0]][arr2[0][1]];\n\n        //给其他元素0\n        for (int i = 1; i &lt; arr2.length; i++) &#123;\n            arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2];\n        &#125;\n\n        //打印arr3\n        System.out.println(&quot;输出还原的数组：&quot;);\n        for (int[] ints : arr3) &#123;\n            for (int anInt : ints) &#123;\n                System.out.print(anInt + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>输出结果：</li>\n</ol>\n<pre><code>输出原始数组：\n0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n====================================\n有效值得个数为：2\n===============遍历数组，将非0的值存储在稀疏数组中=====================\n=============================================\n输出稀疏数组：\n11    11    2\n1    2    1\n2    3    1\n===============================================\n还原\n输出还原的数组：\n0    0    0    0    0    0    0    0    0    0    0    \n0    0    1    0    0    0    0    0    0    0    0    \n0    0    0    1    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n0    0    0    0    0    0    0    0    0    0    0    \n\nProcess finished with exit code 0\n</code></pre>\n<p>可以用来做棋盘</p>"},{"title":"将博客搬至CSDN","date":"2021-08-08T07:09:39.000Z","_content":"","source":"_posts/将博客搬至CSDN-20210808.md","raw":"---\ntitle: 将博客搬至CSDN\ndate: 2021-08-08 15:09:39\ntags:\ncategories:\n---\n","slug":"将博客搬至CSDN-20210808","published":1,"updated":"2022-06-14T04:17:31.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x2b003wy4w1flwm5c6n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"博客搭建踩坑","date":"2021-04-01T17:20:13.000Z","cover":"https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/fw658.gif","_content":"\n\n\n# blog搭建遇到的问题\n\n<!-- more -->\n\nHexo 文档：https://hexo.io/zh-cn/docs/\n\nhexo-nexmoe 主题文档：https://docs.nexmoe.com/hexo-nexmoe/start\n\n大多数问题都可以通过看文档解决。\n\n# 折叠文章\n\n添加`<!-- more -->`，但不能放在头上，会被视为无效。\n\n\n\n# 新建文章\n\n```powershell\nhexo new title // 文章\n\nhexo new post  <title> // 文章\n\nhexo new draft <title> // 草稿  \n\nhexo publish <draft title> // 发布草稿\n\nhexo new page <title> // 页面\n```\n\n\n\n\n\n\n\n## hexo设置`new_post_name`的疑问\n\n\n\nHexo配置文件`hexo/_config.yml`中设定如下：\n\n```powershell\nnew_post_name: :title-：year:month:day.md\n```\n\n```powershell\n$ hexo new post 举个栗子  \n\n结果：举个栗子-20210414.md\n```\n\nfrom：https://segmentfault.com/q/1010000008833637\n\n\n\n# hexo 文章中图片引入问题\n\n官方文档中提供的方法如下:\n\n文章资源文件夹 - 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n\n```powershell\n_config.yml\npost_asset_folder: true\n```\n\n当资源文件管理功能打开后，Hexo将会在你每一次通过 `hexo new [layout] <title> `命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n\n\n\n但是这样的话，每创建一个文章就有一个对应的资源文件夹，有点乱，也不方便日后管理；\n\n所以这里选择将图片存入github仓库的方式，jsdelivr + github 实现cdn懒加载。\n\n\n\n首先创建一个GitHub仓库用来存图片；\n\n引用图片的链接为：`https://cdn.jsdelivr.net/gh/<仓库名>@<版本号，可以写@latest,表示最新版本>/<仓库内相对路径>/xxxx.png`\n\n例如：\n\n`https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/author.png`\n\n\n\n# `hexo` 关键字引起的渲染问题\n\n编写`markdown`文件时，`hexo` 关键字务必用反引号包裹，否则会引起页面渲染问题。","source":"_posts/博客搭建踩坑-20210418.md","raw":"---\ntitle: 博客搭建踩坑\ndate: 2021-04-02 01:20:13\ncover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/fw658.gif\ntags:\n- blog搭建\ncategories:\n- blog搭建\n---\n\n\n\n# blog搭建遇到的问题\n\n<!-- more -->\n\nHexo 文档：https://hexo.io/zh-cn/docs/\n\nhexo-nexmoe 主题文档：https://docs.nexmoe.com/hexo-nexmoe/start\n\n大多数问题都可以通过看文档解决。\n\n# 折叠文章\n\n添加`<!-- more -->`，但不能放在头上，会被视为无效。\n\n\n\n# 新建文章\n\n```powershell\nhexo new title // 文章\n\nhexo new post  <title> // 文章\n\nhexo new draft <title> // 草稿  \n\nhexo publish <draft title> // 发布草稿\n\nhexo new page <title> // 页面\n```\n\n\n\n\n\n\n\n## hexo设置`new_post_name`的疑问\n\n\n\nHexo配置文件`hexo/_config.yml`中设定如下：\n\n```powershell\nnew_post_name: :title-：year:month:day.md\n```\n\n```powershell\n$ hexo new post 举个栗子  \n\n结果：举个栗子-20210414.md\n```\n\nfrom：https://segmentfault.com/q/1010000008833637\n\n\n\n# hexo 文章中图片引入问题\n\n官方文档中提供的方法如下:\n\n文章资源文件夹 - 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n\n```powershell\n_config.yml\npost_asset_folder: true\n```\n\n当资源文件管理功能打开后，Hexo将会在你每一次通过 `hexo new [layout] <title> `命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n\n\n\n但是这样的话，每创建一个文章就有一个对应的资源文件夹，有点乱，也不方便日后管理；\n\n所以这里选择将图片存入github仓库的方式，jsdelivr + github 实现cdn懒加载。\n\n\n\n首先创建一个GitHub仓库用来存图片；\n\n引用图片的链接为：`https://cdn.jsdelivr.net/gh/<仓库名>@<版本号，可以写@latest,表示最新版本>/<仓库内相对路径>/xxxx.png`\n\n例如：\n\n`https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/author.png`\n\n\n\n# `hexo` 关键字引起的渲染问题\n\n编写`markdown`文件时，`hexo` 关键字务必用反引号包裹，否则会引起页面渲染问题。","slug":"博客搭建踩坑-20210418","published":1,"updated":"2022-04-07T17:25:27.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clana7x2c0040y4w172gp4mel","content":"<h1 id=\"blog搭建遇到的问题\"><a href=\"#blog搭建遇到的问题\" class=\"headerlink\" title=\"blog搭建遇到的问题\"></a>blog搭建遇到的问题</h1><span id=\"more\"></span>\n\n<p>Hexo 文档：<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a></p>\n<p>hexo-nexmoe 主题文档：<a href=\"https://docs.nexmoe.com/hexo-nexmoe/start\">https://docs.nexmoe.com/hexo-nexmoe/start</a></p>\n<p>大多数问题都可以通过看文档解决。</p>\n<h1 id=\"折叠文章\"><a href=\"#折叠文章\" class=\"headerlink\" title=\"折叠文章\"></a>折叠文章</h1><p>添加<code>&lt;!-- more --&gt;</code>，但不能放在头上，会被视为无效。</p>\n<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><pre><code class=\"powershell\">hexo new title // 文章\n\nhexo new post  &lt;title&gt; // 文章\n\nhexo new draft &lt;title&gt; // 草稿  \n\nhexo publish &lt;draft title&gt; // 发布草稿\n\nhexo new page &lt;title&gt; // 页面\n</code></pre>\n<h2 id=\"hexo设置new-post-name的疑问\"><a href=\"#hexo设置new-post-name的疑问\" class=\"headerlink\" title=\"hexo设置new_post_name的疑问\"></a>hexo设置<code>new_post_name</code>的疑问</h2><p>Hexo配置文件<code>hexo/_config.yml</code>中设定如下：</p>\n<pre><code class=\"powershell\">new_post_name: :title-：year:month:day.md\n</code></pre>\n<pre><code class=\"powershell\">$ hexo new post 举个栗子  \n\n结果：举个栗子-20210414.md\n</code></pre>\n<p>from：<a href=\"https://segmentfault.com/q/1010000008833637\">https://segmentfault.com/q/1010000008833637</a></p>\n<h1 id=\"hexo-文章中图片引入问题\"><a href=\"#hexo-文章中图片引入问题\" class=\"headerlink\" title=\"hexo 文章中图片引入问题\"></a>hexo 文章中图片引入问题</h1><p>官方文档中提供的方法如下:</p>\n<p>文章资源文件夹 - 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p>\n<pre><code class=\"powershell\">_config.yml\npost_asset_folder: true\n</code></pre>\n<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt; </code>命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>\n<p>但是这样的话，每创建一个文章就有一个对应的资源文件夹，有点乱，也不方便日后管理；</p>\n<p>所以这里选择将图片存入github仓库的方式，jsdelivr + github 实现cdn懒加载。</p>\n<p>首先创建一个GitHub仓库用来存图片；</p>\n<p>引用图片的链接为：<code>https://cdn.jsdelivr.net/gh/&lt;仓库名&gt;@&lt;版本号，可以写@latest,表示最新版本&gt;/&lt;仓库内相对路径&gt;/xxxx.png</code></p>\n<p>例如：</p>\n<p><code>https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/author.png</code></p>\n<h1 id=\"hexo-关键字引起的渲染问题\"><a href=\"#hexo-关键字引起的渲染问题\" class=\"headerlink\" title=\"hexo 关键字引起的渲染问题\"></a><code>hexo</code> 关键字引起的渲染问题</h1><p>编写<code>markdown</code>文件时，<code>hexo</code> 关键字务必用反引号包裹，否则会引起页面渲染问题。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"blog搭建遇到的问题\"><a href=\"#blog搭建遇到的问题\" class=\"headerlink\" title=\"blog搭建遇到的问题\"></a>blog搭建遇到的问题</h1>","more":"<p>Hexo 文档：<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a></p>\n<p>hexo-nexmoe 主题文档：<a href=\"https://docs.nexmoe.com/hexo-nexmoe/start\">https://docs.nexmoe.com/hexo-nexmoe/start</a></p>\n<p>大多数问题都可以通过看文档解决。</p>\n<h1 id=\"折叠文章\"><a href=\"#折叠文章\" class=\"headerlink\" title=\"折叠文章\"></a>折叠文章</h1><p>添加<code>&lt;!-- more --&gt;</code>，但不能放在头上，会被视为无效。</p>\n<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><pre><code class=\"powershell\">hexo new title // 文章\n\nhexo new post  &lt;title&gt; // 文章\n\nhexo new draft &lt;title&gt; // 草稿  \n\nhexo publish &lt;draft title&gt; // 发布草稿\n\nhexo new page &lt;title&gt; // 页面\n</code></pre>\n<h2 id=\"hexo设置new-post-name的疑问\"><a href=\"#hexo设置new-post-name的疑问\" class=\"headerlink\" title=\"hexo设置new_post_name的疑问\"></a>hexo设置<code>new_post_name</code>的疑问</h2><p>Hexo配置文件<code>hexo/_config.yml</code>中设定如下：</p>\n<pre><code class=\"powershell\">new_post_name: :title-：year:month:day.md\n</code></pre>\n<pre><code class=\"powershell\">$ hexo new post 举个栗子  \n\n结果：举个栗子-20210414.md\n</code></pre>\n<p>from：<a href=\"https://segmentfault.com/q/1010000008833637\">https://segmentfault.com/q/1010000008833637</a></p>\n<h1 id=\"hexo-文章中图片引入问题\"><a href=\"#hexo-文章中图片引入问题\" class=\"headerlink\" title=\"hexo 文章中图片引入问题\"></a>hexo 文章中图片引入问题</h1><p>官方文档中提供的方法如下:</p>\n<p>文章资源文件夹 - 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p>\n<pre><code class=\"powershell\">_config.yml\npost_asset_folder: true\n</code></pre>\n<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt; </code>命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>\n<p>但是这样的话，每创建一个文章就有一个对应的资源文件夹，有点乱，也不方便日后管理；</p>\n<p>所以这里选择将图片存入github仓库的方式，jsdelivr + github 实现cdn懒加载。</p>\n<p>首先创建一个GitHub仓库用来存图片；</p>\n<p>引用图片的链接为：<code>https://cdn.jsdelivr.net/gh/&lt;仓库名&gt;@&lt;版本号，可以写@latest,表示最新版本&gt;/&lt;仓库内相对路径&gt;/xxxx.png</code></p>\n<p>例如：</p>\n<p><code>https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/author.png</code></p>\n<h1 id=\"hexo-关键字引起的渲染问题\"><a href=\"#hexo-关键字引起的渲染问题\" class=\"headerlink\" title=\"hexo 关键字引起的渲染问题\"></a><code>hexo</code> 关键字引起的渲染问题</h1><p>编写<code>markdown</code>文件时，<code>hexo</code> 关键字务必用反引号包裹，否则会引起页面渲染问题。</p>"},{"title":"无人驾驶","reprint":false,"date":"2024-08-13T14:33:35.000Z","_content":"\n新的开始，无人驾驶\n\n# 新的开始，无人驾驶\n","source":"_posts/20240813-无人驾驶.md","raw":"---\ntitle: 无人驾驶\nreprint: false\ndate: 2024-08-13 22:33:35\ntags: 无人驾驶\ncategories: 无人驾驶\n---\n\n新的开始，无人驾驶\n\n# 新的开始，无人驾驶\n","slug":"无人驾驶","published":1,"updated":"2024-08-13T14:35:27.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clzsiyqll00005m7lehjm5qjy","content":"<p>新的开始，无人驾驶</p>\n<h1 id=\"新的开始，无人驾驶\"><a href=\"#新的开始，无人驾驶\" class=\"headerlink\" title=\"新的开始，无人驾驶\"></a>新的开始，无人驾驶</h1>","site":{"data":{}},"excerpt":"","more":"<p>新的开始，无人驾驶</p>\n<h1 id=\"新的开始，无人驾驶\"><a href=\"#新的开始，无人驾驶\" class=\"headerlink\" title=\"新的开始，无人驾驶\"></a>新的开始，无人驾驶</h1>"}],"PostAsset":[],"PostCategory":[{"post_id":"clana7x0t0003y4w1dr041qcp","category_id":"clana7x0x0006y4w11bqseu9d","_id":"clana7x14000hy4w1gsb4ck7x"},{"post_id":"clana7x0w0005y4w1d0ad5xya","category_id":"clana7x0x0006y4w11bqseu9d","_id":"clana7x16000ly4w1g1xshe9z"},{"post_id":"clana7x0x0007y4w171lph7ee","category_id":"clana7x14000gy4w1h2l5a24k","_id":"clana7x1a000ty4w10kdt90di"},{"post_id":"clana7x0y0008y4w1hpqz70qf","category_id":"clana7x14000gy4w1h2l5a24k","_id":"clana7x1c000yy4w1cxx5b6nk"},{"post_id":"clana7x12000dy4w11q2f1db0","category_id":"clana7x19000sy4w1aw9selod","_id":"clana7x1e0014y4w1h05i79tr"},{"post_id":"clana7x13000fy4w18irm0g5f","category_id":"clana7x14000gy4w1h2l5a24k","_id":"clana7x1h001ay4w1939bhlsn"},{"post_id":"clana7x1e0016y4w18gtidu9s","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1j001ey4w1el1r1c3b"},{"post_id":"clana7x14000iy4w1d7incwcj","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1m001jy4w18tc1gbbx"},{"post_id":"clana7x1f0018y4w1bqax3foy","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1o001my4w19ni6du8e"},{"post_id":"clana7x1h001cy4w17itvevnj","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1p001qy4w19ifb51f1"},{"post_id":"clana7x15000ky4w154y1d9wh","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1r001ty4w16mcnf92a"},{"post_id":"clana7x1i001dy4w19mzkei3j","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1s001wy4w19myj5x3i"},{"post_id":"clana7x17000oy4w1eynfbct4","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1s001yy4w14szfg15p"},{"post_id":"clana7x18000ry4w15o537x8m","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1s0021y4w15aat1s0w"},{"post_id":"clana7x1a000vy4w14xqh76ec","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1t0025y4w1a1c93k9a"},{"post_id":"clana7x1b000xy4w19a552abz","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1t0027y4w1cae143ln"},{"post_id":"clana7x1c0010y4w1cd7h7byk","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x1u002by4w1afsu0f37"},{"post_id":"clana7x1d0011y4w1ccg5glpy","category_id":"clana7x1t0026y4w16etm1gdp","_id":"clana7x1w002gy4w16fh0doza"},{"post_id":"clana7x1l001iy4w1d6wh0m0q","category_id":"clana7x1u002dy4w177aqdc3q","_id":"clana7x1w002ky4w1ddwjeplt"},{"post_id":"clana7x1m001ly4w11rgk32gm","category_id":"clana7x1u002dy4w177aqdc3q","_id":"clana7x1y002py4w13h9p442e"},{"post_id":"clana7x1p001py4w18tis8h5d","category_id":"clana7x1u002dy4w177aqdc3q","_id":"clana7x1y002ry4w1gscbel9z"},{"post_id":"clana7x1q001sy4w1dta39zwh","category_id":"clana7x1u002dy4w177aqdc3q","_id":"clana7x20002vy4w18c4t6wq7"},{"post_id":"clana7x2a003vy4w1bu3i7mxm","category_id":"clana7x1e0013y4w1a60abapq","_id":"clana7x2d0042y4w19fjpfrkc"},{"post_id":"clana7x28003qy4w1hsypeptb","category_id":"clana7x29003sy4w1bdmx8lu1","_id":"clana7x2e0045y4w1fbv584tq"},{"post_id":"clana7x2a003uy4w12aq6a87k","category_id":"clana7x29003sy4w1bdmx8lu1","_id":"clana7x2e0046y4w1ar22dq54"},{"post_id":"clana7x2c0040y4w172gp4mel","category_id":"clana7x2e0044y4w17ijz0zfj","_id":"clana7x2f004by4w18k3i0tlj"},{"post_id":"clzsiyqll00005m7lehjm5qjy","category_id":"clzsiyqlo00015m7l09opfjus","_id":"clzsiyqlv00045m7lacnj6yzq"}],"PostTag":[{"post_id":"clana7x0p0001y4w18koocdxv","tag_id":"clana7x0u0004y4w19u2n8zj8","_id":"clana7x10000ay4w1e9cb20gi"},{"post_id":"clana7x0t0003y4w1dr041qcp","tag_id":"clana7x0z0009y4w1djo30eqg","_id":"clana7x16000ny4w1alq11jrv"},{"post_id":"clana7x0t0003y4w1dr041qcp","tag_id":"clana7x13000ey4w1gywsasnj","_id":"clana7x17000py4w161l25eow"},{"post_id":"clana7x0w0005y4w1d0ad5xya","tag_id":"clana7x15000jy4w1denh86ad","_id":"clana7x1a000uy4w1czeuctpr"},{"post_id":"clana7x0x0007y4w171lph7ee","tag_id":"clana7x15000jy4w1denh86ad","_id":"clana7x1e0015y4w18xteao96"},{"post_id":"clana7x0x0007y4w171lph7ee","tag_id":"clana7x1b000wy4w1gejs0gly","_id":"clana7x1f0017y4w1297gebnb"},{"post_id":"clana7x0y0008y4w1hpqz70qf","tag_id":"clana7x15000jy4w1denh86ad","_id":"clana7x1l001hy4w1a9hu88yb"},{"post_id":"clana7x0y0008y4w1hpqz70qf","tag_id":"clana7x1b000wy4w1gejs0gly","_id":"clana7x1m001ky4w10vye86is"},{"post_id":"clana7x12000dy4w11q2f1db0","tag_id":"clana7x1j001fy4w15xzv25hr","_id":"clana7x1q001ry4w1hjc45bhw"},{"post_id":"clana7x13000fy4w18irm0g5f","tag_id":"clana7x1b000wy4w1gejs0gly","_id":"clana7x1s001xy4w19uuadt7b"},{"post_id":"clana7x14000iy4w1d7incwcj","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x1t0022y4w10zw18qtn"},{"post_id":"clana7x15000ky4w154y1d9wh","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x1u0029y4w11gg0b4uw"},{"post_id":"clana7x15000ky4w154y1d9wh","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x1u002ay4w1cmima2ho"},{"post_id":"clana7x17000oy4w1eynfbct4","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x1v002ey4w19f9x70v7"},{"post_id":"clana7x18000ry4w15o537x8m","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x1x002ly4w12pnp8t57"},{"post_id":"clana7x18000ry4w15o537x8m","tag_id":"clana7x1v002fy4w1djsb9rwi","_id":"clana7x1x002my4w1gqct1ouo"},{"post_id":"clana7x1a000vy4w14xqh76ec","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x1z002sy4w17ajlfn96"},{"post_id":"clana7x1a000vy4w14xqh76ec","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x1z002ty4w14iv2gw7y"},{"post_id":"clana7x1b000xy4w19a552abz","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x21002xy4w13b148erc"},{"post_id":"clana7x1b000xy4w19a552abz","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x21002yy4w126tvf50h"},{"post_id":"clana7x1c0010y4w1cd7h7byk","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x210030y4w160ure833"},{"post_id":"clana7x1d0011y4w1ccg5glpy","tag_id":"clana7x21002zy4w1aiwtfrik","_id":"clana7x220032y4w1haau4zhp"},{"post_id":"clana7x1e0016y4w18gtidu9s","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x220035y4w1fctger4w"},{"post_id":"clana7x1e0016y4w18gtidu9s","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x220036y4w1hh7bf8yn"},{"post_id":"clana7x1f0018y4w1bqax3foy","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x230039y4w1a5bu7irp"},{"post_id":"clana7x1f0018y4w1bqax3foy","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x23003ay4w1g49a90zv"},{"post_id":"clana7x1h001cy4w17itvevnj","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x23003dy4w1d6a9he9o"},{"post_id":"clana7x1h001cy4w17itvevnj","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x23003ey4w1h03g8ed5"},{"post_id":"clana7x1i001dy4w19mzkei3j","tag_id":"clana7x1r001uy4w1b3h15fqk","_id":"clana7x24003hy4w1198p8b0f"},{"post_id":"clana7x1i001dy4w19mzkei3j","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x24003iy4w11u3j1czy"},{"post_id":"clana7x1l001iy4w1d6wh0m0q","tag_id":"clana7x24003gy4w11uoy86k5","_id":"clana7x24003ky4w1euq90awj"},{"post_id":"clana7x1m001ly4w11rgk32gm","tag_id":"clana7x24003gy4w11uoy86k5","_id":"clana7x25003my4w13tbhf836"},{"post_id":"clana7x1p001py4w18tis8h5d","tag_id":"clana7x24003gy4w11uoy86k5","_id":"clana7x25003oy4w1huq88w7d"},{"post_id":"clana7x1q001sy4w1dta39zwh","tag_id":"clana7x24003gy4w11uoy86k5","_id":"clana7x25003py4w1gux6ag0y"},{"post_id":"clana7x28003qy4w1hsypeptb","tag_id":"clana7x29003ty4w1bo7q3cpg","_id":"clana7x2c003zy4w154ko1y1j"},{"post_id":"clana7x28003qy4w1hsypeptb","tag_id":"clana7x1t0023y4w17uex6e3p","_id":"clana7x2d0041y4w14c3vejtm"},{"post_id":"clana7x2a003uy4w12aq6a87k","tag_id":"clana7x2c003yy4w1dv69809l","_id":"clana7x2e0048y4w1dg5pehmv"},{"post_id":"clana7x2a003uy4w12aq6a87k","tag_id":"clana7x2d0043y4w1dwgbhtyf","_id":"clana7x2e0049y4w122d3d4nr"},{"post_id":"clana7x2a003vy4w1bu3i7mxm","tag_id":"clana7x2e0047y4w1h84nb530","_id":"clana7x2f004cy4w16h2v8fxz"},{"post_id":"clana7x2c0040y4w172gp4mel","tag_id":"clana7x2e004ay4w13zrb50g1","_id":"clana7x2f004dy4w1avd55pfw"},{"post_id":"clzsiyqll00005m7lehjm5qjy","tag_id":"clzsiyqlv00025m7lduzfg6b1","_id":"clzsiyqlv00035m7l0sec3302"}],"Tag":[{"name":"批处理工具","_id":"clana7x0u0004y4w19u2n8zj8"},{"name":"vue","_id":"clana7x0z0009y4w1djo30eqg"},{"name":"echart","_id":"clana7x13000ey4w1gywsasnj"},{"name":"Vue","_id":"clana7x15000jy4w1denh86ad"},{"name":"Cesium","_id":"clana7x1b000wy4w1gejs0gly"},{"name":"-DB","_id":"clana7x1j001fy4w15xzv25hr"},{"name":"java基础","_id":"clana7x1r001uy4w1b3h15fqk"},{"name":"狂神说","_id":"clana7x1t0023y4w17uex6e3p"},{"name":"spring","_id":"clana7x1v002fy4w1djsb9rwi"},{"name":"资源","_id":"clana7x21002zy4w1aiwtfrik"},{"name":"Leetcode","_id":"clana7x24003gy4w11uoy86k5"},{"name":"mysql","_id":"clana7x29003ty4w1bo7q3cpg"},{"name":"GIS","_id":"clana7x2c003yy4w1dv69809l"},{"name":"数据库","_id":"clana7x2d0043y4w1dwgbhtyf"},{"name":"java","_id":"clana7x2e0047y4w1h84nb530"},{"name":"blog搭建","_id":"clana7x2e004ay4w13zrb50g1"},{"name":"无人驾驶","_id":"clzsiyqlv00025m7lduzfg6b1"}]}}