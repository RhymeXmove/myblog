---
title: PostGis数据类型
date: 2021-08-08 16:38:55
tags:
- GIS
- 数据库
categories:
- DB
cover: https://cdn.jsdelivr.net/gh/RhymeXmove/blogimg@latest/cover/postgre.jpeg
---



整理自官方文档

<!--more-->



# PostGIS空间数据库，数据类型

## 几何类型：

### point(点)：

点是几何类型的基本二维构建块。point使用以下任一语法指定类型的值：

```
（x，y）   x，y
```

其中*x*和*y*是相应的坐标，作为浮点数。

使用第一种语法输出点。



### line(线):

线由线性方程`*A*`x + `*B*`y + `*C*`= 0表示，其中`*A*`和`*B*`不都为零。类型的值 `line`以下列形式输入和输出：

```
{ A，B，C}
```

或者，可以使用以下任何形式进行输入：

```
[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2
```

其中（x1，y1）和（x2，y2）是线上的两个不同点。

 

### lseg(线段):

线段由成对的点表示，这些点是段的端点。`lseg`类型的值使用下列语法中的任何一种来指定：

```
[ ( x1 , y1 ) , ( x2 , y2 ) ]( ( x1 , y1 ) , ( x2 , y2 ) )  ( x1 , y1 ) , ( x2 , y2 )    x1 , y1   ,   x2 , y2
```

其中（x1，y1）和（x2，y2）是线段的端点。

使用第一种语法输出线段。



### box (矩形):

矩形是由矩形的对角线的点对来表示的。box 使用下列语法中的任何一种来指定类型的值：

( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )
    x1 , y1   ,   x2 , y2

其中（x1，y1）和（x2，y2）是矩形的任意两个相对的角。

使用第二种语法输出矩形。

可以在输入时提供任意两个相对的角，但是值将根据需要重新排序，以便按顺序存储右上角和左下角。

所以建议在输入时提供右上角和左下角。



### path(路径)：

路径由连接点列表表示。路径可以是**开放**的（其中列表中的第一和最后一个点被认为是未连接的），或者是**闭合**的（其中第一和最后一个点被认为是连接的）。

`path`使用以下任何语法指定类型的值：

```
[ ( x1 , y1 ) , ... , ( xn , yn ) ]( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn
```

其中点是包括路径的线段的端点。方括号（`[]`）表示开放路径，而圆括号（`()`）表示闭合路径。当省略最外面的括号时，如在第三到第五语法中，假设闭合路径。

其中点是包括路径的线段的端点。方括号（[]）表示开放路径，而小括号（（））表示闭合路径。当最外括号被省略时，如在第三到第五语法中，表示默认为一条闭合路径。

根据需要，建议使用第一或第二语法输出路径。

 

### polygon(多边形)：

多边形由点列表（多边形的顶点）表示。多边形与闭合路径非常相似，但存储方式不同，并且具有自己的一组支持程序。

`polygon`使用以下任何一种语法指定类型的值：

```
( ( x1 , y1 ) , ... , ( xn , yn ) )  ( x1 , y1 ) , ... , ( xn , yn )  ( x1 , y1   , ... ,   xn , yn )    x1 , y1   , ... ,   xn , yn
```

其中点是包括多边形边界的线段的端点。

建议使用第一种语法输出多边形。

 

### circle(圆)：

圆由中心点和半径表示。`circle`使用以下任何一种语法指定类型的值：

```
< ( x , y ) , r >( ( x , y ) , r )  ( x , y ) , r    x , y   , r
```

其中（x，y）是中心点，r是圆的半径。

建议使用第一种语法输出圆。



##  数字类型 ：

### numeric:

 numeric [ (p , s ) ]等同于decimal [ (p , s ) ]	可选精度的准确数字，p代表整数位加小数位的总位数（不算小数点），s代表小数位的位数。 



### float4 / float8: 

 对于`float8`值，此值最多使用 17 个有效十进制数字，对于`float4`值，最多使用9个数字。 

 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用[extra_float_digits](http://www.postgres.cn/docs/12/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)参数选择四舍五入的十进制输出。 将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于`float4`）或15（对于`float8`）个有效的十进制数字。 设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。



### int2 / int4 / int8:

int2 = smallint；

 int4 = integer ；

int8 = bigint；

**`int2`**    2字节小范围整数-32768 to +32767；

**`int4`**    4字节整数的典型选择-2147483648 to +2147483647；

**`int8`**  8字节  大范围整数  -9223372036854775808 to +9223372036854775807



###  serial2  /   serial4  / serial8：

自增整数



## 字符型：

### char:

 定长字符串 , postgre 内 char类型数据不够填满长度时，会以空格的形式自动补长，取数据的时候，char类型的要用trim()去掉多余的空格，最大255个字符。



### varchar:

变长字符串，输入长度不够，变为输入字符长度，最大65535个字节 。



### text:

无限变长



## 布尔类型：

### bool:

布尔值， f/ t

输入true或1默认保存为't'

输入false或0默认保存为'f'

可为空(NULL)



## 二进制数据类型：

### bytea:

 bytea类型是PostgreSQL特有的存储二进制数据的字段类型，与SQL标准中的BLOB和BINARY LARGE OBJECT类型相同。

## 位串类型：

### bit:

BIT 是一种可以存储值 0 或 1 的整数类型。

缺省情况下，BIT 数据类型不允许 NULL。

一个 BIT 值需要 1 个存储字节。

在将字符串转换为 BIT 时，前导空格和尾随空格会被删除。如果前导字符是 +，则其将被忽略。如果前导字符是 -，则后面的位会被解释为负数。前导的 0 字符将跳过，其余字符将转换为整数值。如果值不为 0 或 1，则返回错误。



### varbit:

 `varbit(n)` 数据是最长*`n`*的变长类型，更长的串会被拒绝 。



## 日期类型：

### date:

 日历日期（年，月，日） 



### interval:

interval [ fields ] [ (p) ]	16字节	时间间隔	-178000000年	178000000年

| 例子                                               | 描述                                         |
| -------------------------------------------------- | -------------------------------------------- |
| 1-2                                                | SQL标准格式：1年2个月                        |
| 3 4:05:06                                          | SQL标准格式：3日4小时5分钟6秒                |
| 1 year 2 months 3 days 4 hours 5 minutes 6 seconds | 传统Postgres格式：1年2个月3日4小时5分钟6秒钟 |
| P1Y2M3DT4H5M6S                                     | “带标志符的”ISO 8601 格式：含义同上          |
| P0001-02-03T04:05:06                               | ISO 8601 的“替代格式”：含义同上              |



### time：

time [ (*p*) ] without time zone

一天中的时间



### timetz:

time [ (*p*) ] with time zone

一天里的时间，包括时区



### timestamp:

timestamp [ (*p*) ] without time zone

日期和时间



### timestamptz:

timestamp [ (*p*) ] with time zone

日期和时间，包括时区



## JSON 类型:

### json  /  jsonb:

json 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支 持索引，这也是一个令人瞩目的优势。

**JSON 基本类型和相应的PostgreSQL类型**

| JSON 基本类型 | PostgreSQL类型 | 注释                                                         |
| ------------- | -------------- | ------------------------------------------------------------ |
| `string`      | `text`         | 不允许`\u0000`，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样 |
| `number`      | `numeric`      | 不允许`NaN` 和 `infinity`值                                  |
| `boolean`     | `boolean`      | 只接受小写`true`和`false`拼写                                |
| `null`        | (无)           | SQL `NULL`是一个不同的概念                                   |



##  **复合类型** :

### （Type）:

 PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。
   \1. 声明复合类型:
   下面是两个简单的声明示例：

```sql
  **CREATE TYPE** complex **AS** (
     r double,
     i double
   ); 
   **CREATE TYPE** inventory_item **AS** (
     name      text,
     supplier_id  integer,
     price      numeric
   );
```

   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：

   和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：

```sql
 CREATE TABLE on_hand (
     item   **inventory_item**,
     count  integer
   );
```

   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。

   最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。

   \2. 复合类型值输入：
   我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：
   '("fuzzy dice",42,1.99)'
   如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，
   '("fuzzy dice",42,)'
   如果只是需要一个空字串，而非NULL，写一对双引号，如：
   '("",42,)'
   在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：
   **ROW**('fuzzy dice', 42, 1.99)
   **ROW**('', 42, NULL)
   注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：
   ('fuzzy dice', 42, 1.99)
   ('', 42, NULL)

   \3. 访问复合类型：
   访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：
  SELECT (item).name FROM on_hand WHERE (item).price > 9.99;
   如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：

```sql
   SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;
```

   \4. 修改复合类型：
   见如下几个示例：
   *--直接插入复合类型的数据，这里是通过ROW表达式来完成的。*

```sql
  INSERT INTO on_hand(item) VALUES(ROW("fuzzy dice",42,1.99));
```

   *--在更新操作中，也是可以通过ROW表达式来完成。*

   *--在更新操作中，也是可以通过ROW表达式来完成。*

```sql
UPDATE on_hand SET item = ROW("fuzzy dice",42,1.99) WHERE count = 0;
```

  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*
   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*

  *--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，*
   *--但是在等号右边的表达式里引用同一个字段时却需要圆括号。*

```sql
  UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;
```

   *--可以在插入中，直接插入复合类型中字段。*

   *--可以在插入中，直接插入复合类型中字段。*

```sql
 INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2); 
```



## 域：

### domain：

pg中的CREATE DOMAIN表示创建一个新的域，这一功能在oracle中是不支持的。域本质上是一种带有可选约束(在允许的值集合上的 限制)的数据类型。 定义一个域的用户将成为它的拥有者。
如果给定一个模式名(例如CREATE DOMAIN myschema.mydomain …)，那么域将被创建在 该指定的模式中。 否则它会被创建在当前模式中。域的名称在其模式中的类型和域之间 必 须保持唯一。
要创建一个域，你必须在其底层类型上拥有USAGE特权。

**语法：**

```sql
Command:     CREATE DOMAIN
Description: define a new domain
Syntax:
CREATE DOMAIN name [ AS ] data_type
    [ COLLATE collation ]
    [ DEFAULT expression ]
    [ constraint [ ... ] ]

where constraint is:

[ CONSTRAINT constraint_name ]
{ NOT NULL | NULL | CHECK (expression) }
123456789101112
```

**例子：**
–创建domain
创建一个domain表示用来存放小于0的整数

```sql
bill=# create domain d1 as int check(value < 0);
CREATE DOMAIN
12
```

–使用domain建表

```sql
bill=# create table t_domain(id d1);
CREATE TABLE
12
```

–插入数据测试
插入大于0的数便会报错

```sql
bill=# insert into t_domain values(1);
ERROR:  value for domain d1 violates check constraint "d1_check"
bill=# insert into t_domain values(-1);
INSERT 0 1
```



##  网络地址类型

### cidr / inet:

 IPv4 或 IPv6 网络地址 。

 `inet`和`cidr`类型之间的本质区别是`inet`接受右边有非零位的网络掩码， 而`cidr`不接受。例如，`192.168.0.1/24`对`inet`是有效的，但对`cidr`是无效的。 

### macaddr：

`macaddr`类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：

'08:00:2b:01:02:03'
'08-00-2b-01-02-03'
'08002b:010203'
'08002b-010203'
'0800.2b01.0203'
'0800-2b01-0203'
'08002b010203'



### macaddr8：

 `macaddr8`类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。 



## 货币类型：

### money:

| 名字    | 存储尺寸 | 描述   | 范围                                         |
| ------- | -------- | ------ | -------------------------------------------- |
| `money` | 8 bytes  | 货币额 | -92233720368547758.08到+92233720368547758.07 |



## 文本搜索类型：

### tsquery:

一个`tsquery`值存储要用于搜索的词位，并且使用布尔操作符`&`（AND）、`|`（OR）和`!`（NOT）来组合它们，还有短语搜索操作符`<->`（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体`<*`N`*>`，其中*`N`*是一个整数常量，它指定要搜索的两个词位之间的距离。`<->`等效于`<1>`。

圆括号可以被用来强制对操作符分组。如果没有圆括号，`!`（NOT）的优先级最高，其次是`<->`（FOLLOWED BY），然后是`&`（AND），最后是`|`（OR）。

### tsvector:

 一个`tsvector`值是一个排序的可区分词位的列表，*词位*是被*正规化*合并了同一个词的不同变种的词 



## UUID类型：

数据类型`uuid`存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。

一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：

```
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
```

PostgreSQL也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：

```
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
```

输出总是采用标准形式。



### XML类型:

 `xml`数据类型可以被用来存储XML数据。它比直接在一个`text`域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作 



## 事务快照：

### txid_snapshot
没看到~